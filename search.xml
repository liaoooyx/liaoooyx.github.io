<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Convolutional LSTM Network</title>
      <link href="/2020/06/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%85%B3%E4%BA%8ELSTM%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8F%98%E4%BD%93/"/>
      <url>/2020/06/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%85%B3%E4%BA%8ELSTM%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8F%98%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>关于LSTM以及相关变体，以及各个逻辑门对LSTM的影响——<a href="https://blog.csdn.net/micsf/article/details/80899302" target="_blank" rel="noopener">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>梯度消失和梯度爆炸问题解决方案</title>
      <link href="/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本质上是因为神经网络的更新方法，梯度消失是因为反向传播过程中对梯度的求解会产生sigmoid导数和参数的连乘，sigmoid导数的最大值为0.25，权重一般初始都在0，1之间，乘积小于1，多层的话就会有多个小于1的值连乘，导致靠近输入层的梯度几乎为0，得不到更新。梯度爆炸是也是同样的原因，只是如果初始权重大于1，或者更大一些，多个大于1的值连乘，将会很大或溢出，导致梯度更新过大，模型无法收敛。</p></blockquote><a id="more"></a><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><blockquote><ul><li>解决方案一（预训练加微调）</li><li>解决方案二（梯度剪切、正则）</li><li>解决方案三（改变激活函数）</li><li>解决方案四（batchnorm）</li><li>解决方案五（残差结构）</li><li>解决方案六（LSTM）</li></ul><p>——<a href="https://zhuanlan.zhihu.com/p/76772734" target="_blank" rel="noopener">从反向传播推导到梯度消失and爆炸的原因及解决方案（从DNN到RNN，内附详细反向传播公式推导</a>，第四节</p></blockquote><h4 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h4><blockquote><p>在深层神经网络或循环神经网络中，误差的梯度可在更新中累积相乘。如果网络层之间的梯度值大于 1.0，那么重复相乘会导致梯度呈指数级增长，梯度变的非常大，然后导致网络权重的大幅更新，并因此使网络变得不稳定。</p><p>信号：</p><ul><li><p>模型不稳定，导致更新过程中的损失出现显著变化；</p></li><li><p>训练过程中，在极端情况下，权重的值变得非常大，以至于溢出，导致模型损失变成 NaN等等。</p></li></ul><p>解决梯度爆炸的其他方法：</p><ol><li>减少学习率（个人理解梯度爆炸是模型训练发散的一种情况）；</li><li>使用ReLU函数，使得梯度稳定；</li><li>使用正则化，即检查网络中权重的大小，对较大的权重进行惩罚，限制了梯度爆炸造成的权重变得很大的情况。</li></ol><p>——[常见损失函数小结](</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摘录各参数对神经网络的影响</title>
      <link href="/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%B0%E5%BD%95%E5%90%84%E5%8F%82%E6%95%B0%E5%AF%B9%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%B0%E5%BD%95%E5%90%84%E5%8F%82%E6%95%B0%E5%AF%B9%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="神经网络中的常见问题"><a href="#神经网络中的常见问题" class="headerlink" title="神经网络中的常见问题"></a>神经网络中的常见问题</h3><h4 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h4><blockquote><p>在深层神经网络或循环神经网络中，误差的梯度可在更新中累积相乘。如果网络层之间的梯度值大于 1.0，那么重复相乘会导致梯度呈指数级增长，梯度变的非常大，然后导致网络权重的大幅更新，并因此使网络变得不稳定。</p><p>信号：</p><ul><li><p>模型不稳定，导致更新过程中的损失出现显著变化；</p></li><li><p>训练过程中，在极端情况下，权重的值变得非常大，以至于溢出，导致模型损失变成 NaN等等。</p></li></ul><p>解决梯度爆炸的其他方法：</p><ol><li>减少学习率（个人理解梯度爆炸是模型训练发散的一种情况）；</li><li>使用ReLU函数，使得梯度稳定；</li><li>使用正则化，即检查网络中权重的大小，对较大的权重进行惩罚，限制了梯度爆炸造成的权重变得很大的情况。</li></ol><p>——<a href="https://zhuanlan.zhihu.com/p/37217242" target="_blank" rel="noopener">常见损失函数小结</a></p></blockquote><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><blockquote><ol><li><strong>神经网络为什么需要激活函数：</strong>首先数据的分布绝大多数是非线性的，而一般神经网络的计算是线性的，引入激活函数，是在神经网络中引入非线性，强化网络的学习能力。所以激活函数的最大特点就是非线性。</li><li><strong>不同的激活函数，根据其特点，应用也不同。</strong>Sigmoid和tanh的特点是将输出限制在(0,1)和(-1,1)之间，说明Sigmoid和tanh适合做概率值的处理，例如LSTM中的各种门；而ReLU就不行，因为ReLU无最大值限制，可能会出现很大值。同样，根据ReLU的特征，Relu适合用于深层网络的训练，而Sigmoid和tanh则不行，因为它们会出现梯度消失。</li></ol><p>——<a href="https://zhuanlan.zhihu.com/p/73214810" target="_blank" rel="noopener">激活函数总结</a></p></blockquote><h4 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h4><blockquote><p>sigmoid函数作为激活函数本身就存在梯度消失的问题（见缺点3）</p><p>——<a href="https://zhuanlan.zhihu.com/p/37217242" target="_blank" rel="noopener">常见损失函数小结</a></p><p>优缺点：</p><ul><li>优点：平滑、易于求导。</li><li>缺点：<ol><li>激活函数计算量大（在正向传播和反向传播中都包含幂运算和除法）；</li><li>反向传播求误差梯度时，求导涉及除法；</li><li>Sigmoid导数取值范围是[0, 0.25]，由于神经网络反向传播时的“链式反应”，很容易就会出现梯度消失的情况。例如对于一个10层的网络， 根据<img src="https://www.zhihu.com/equation?tex=0.25^{10}\approx0.000000954" alt="[公式]">，第10层的误差相对第一层卷积的参数<img src="https://www.zhihu.com/equation?tex=W_1" alt="[公式]">的梯度将是一个非常小的值，这就是所谓的“梯度消失”。</li><li>Sigmoid的输出不是0均值（即zero-centered）；这会导致后一层的神经元将得到上一层输出的非0均值的信号作为输入，随着网络的加深，会改变数据的原始分布。</li></ol></li></ul><p>——<a href="https://zhuanlan.zhihu.com/p/73214810" target="_blank" rel="noopener">激活函数总结</a></p></blockquote><h4 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h4><blockquote><p>相比Sigmoid函数</p><ol><li>tanh的输出范围时(-1, 1)，解决了Sigmoid函数的不是zero-centered输出问题；</li><li>幂运算的问题仍然存在；</li><li>tanh导数范围在(0, 1)之间，相比sigmoid的(0, 0.25)，梯度消失（gradient vanishing）问题会得到缓解，但仍然还会存在。</li></ol><p>——<a href="https://zhuanlan.zhihu.com/p/73214810" target="_blank" rel="noopener">激活函数总结</a></p></blockquote><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><p><strong>特点</strong></p><blockquote><p>ReLU的有效导数是常数1，解决了深层网络中出现的梯度消失问题，也就使得深层网络可训练。<strong>同时ReLU又是非线性函数，所谓非线性，就是一阶导数不为常数；对ReLU求导，在输入值分别为正和为负的情况下，导数是不同的，即ReLU的导数不是常数，所以ReLU是非线性的（只是不同于Sigmoid和tanh，relu的非线性不是光滑的）。</strong></p><p>——<a href="https://zhuanlan.zhihu.com/p/73214810" target="_blank" rel="noopener">激活函数总结</a></p><p>relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。</p><p><strong>relu</strong>的主要贡献在于：</p><ul><li>解决了梯度消失、爆炸的问题</li><li>计算方便，计算速度快</li><li>加速了网络的训练</li></ul><p>同时也存在一些<strong>缺点</strong>：</p><ul><li>由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）</li><li>输出不是以0为中心的</li></ul><p>——<a href="https://zhuanlan.zhihu.com/p/76772734" target="_blank" rel="noopener">从反向传播推导到梯度消失and爆炸的原因及解决方案（从DNN到RNN，内附详细反向传播公式推导）</a></p></blockquote><p><strong>ReLU函数相对于tanh和sigmoid函数好在哪里：</strong></p><blockquote><p>采用sigmoid等函数，算激活函数是（指数运算），计算量大；反向传播求误差梯度时，求导涉及除法，计算量相对大。而采用Relu激活函数，整个过程的计算量节省很多。</p><p>对于深层网络，sigmoid函数反向传播时，很容易就会出现梯度消失的情况（在sigmoid接近饱和区时，变换太缓慢，导数趋于0），这种情况会造成信息丢失，梯度消失在网络层数多的时候尤其明显，从而无法完成深层网络的训练。</p><p>ReLU会使一部分神经元的输出为0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生。</p><p>——<a href="https://zhuanlan.zhihu.com/p/37217242" target="_blank" rel="noopener">常见损失函数小结</a></p><p>相比Sigmoid和tanh，ReLU摒弃了复杂的计算，提高了运算速度。</p><p>解决了梯度消失问题，收敛速度快于Sigmoid和tanh函数，但要<strong>防范ReLU的梯度爆炸</strong></p><p>容易得到更好的模型，但也要<strong>防止训练中出现模型【Dead】情况</strong>。</p><p>——<a href="https://zhuanlan.zhihu.com/p/73214810" target="_blank" rel="noopener">激活函数总结</a></p></blockquote><p><strong>在使用relu的网络中，是否还存在梯度消失的问题？</strong></p><blockquote><p>梯度衰减的原因包括：激活函数导数，此外，还有多个权重连乘也会影响。梯度消失只是表面说法，按照这样理解，底层使用非常大的学习率，或者人工添加梯度噪音，原则上也能回避，有不少论文这样试了，然而目前来看，有用，但没太大的用处。深层原因训练不好的本质难题可能不是衰减或者消失（残差网络论文也提到这一点），是啥目前数理派也搞不清楚，所以写了论文也顺势这样说开了。不然，贸贸然将开山鼻祖的观点否定了，是需要极大勇气和大量的实验，以及中二精神的。</p><p>—— <a href="https://www.zhihu.com/question/49230360/answer/114914080" target="_blank" rel="noopener">知乎问题</a>，回答 <a href="https://www.zhihu.com/people/lykquitphy" target="_blank" rel="noopener">纳米酱</a></p></blockquote><h4 id="Leaky-ReLU-PReLU（Parametric-Relu）-RReLU（Random-ReLU）"><a href="#Leaky-ReLU-PReLU（Parametric-Relu）-RReLU（Random-ReLU）" class="headerlink" title="Leaky ReLU, PReLU（Parametric Relu）, RReLU（Random ReLU）"></a>Leaky ReLU, PReLU（Parametric Relu）, RReLU（Random ReLU）</h4><blockquote><p>为了防止模型的【Dead】情况，后人将x&lt;0部分并没有直接置为0，而是给了一个很小的负数梯度值</p><p><strong>Leaky ReLU</strong>中的<img src="https://www.zhihu.com/equation?tex=\alpha" alt="[公式]">为常数，一般设置 0.01。这个函数通常比 Relu 激活函数效果要好，但是效果不是很稳定，所以在实际中 Leaky ReLu 使用的并不多。</p><p><strong>PRelu（参数化修正线性单元）</strong> 中的<img src="https://www.zhihu.com/equation?tex=\alpha+" alt="[公式]">作为一个可学习的参数，会在训练的过程中进行更新。</p><p><strong>RReLU（随机纠正线性单元）</strong>也是Leaky ReLU的一个变体。在RReLU中，负值的斜率在训练中是随机的，在之后的测试中就变成了固定的了。RReLU的亮点在于，在训练环节中，aji是从一个均匀的分布U(I,u)中随机抽取的数值。</p><p>——<a href="https://zhuanlan.zhihu.com/p/73214810" target="_blank" rel="noopener">激活函数总结</a></p></blockquote><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><blockquote><p>损失函数是网络学习的指挥棒，它引导着网络学习的方向——能让损失函数变小的参数就是好参数。所以，损失函数的选择和设计要能表达你希望模型具有的性质与倾向。——<a href="https://me.csdn.net/firelx" target="_blank" rel="noopener">shine-lee</a>（<a href="https://blog.csdn.net/blogshinelee/article/details/103518097" target="_blank" rel="noopener">原文</a>）</p></blockquote><h4 id="交叉熵损失"><a href="#交叉熵损失" class="headerlink" title="交叉熵损失"></a>交叉熵损失</h4><p>（Pytorch）CrossEntropyLoss本身已经包含了softmax，在神经网络中使用CrossEntropyLoss作为损失函数时，不需要再添加softmax。（以下文章有提及：<a href="https://blog.csdn.net/zhufenghao/article/details/52735750" target="_blank" rel="noopener">1</a>，<a href="https://blog.csdn.net/haiyuanboy/article/details/90377817" target="_blank" rel="noopener">2</a>）</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/95386061" target="_blank" rel="noopener">交叉熵损失</a>：扩大低概率高损失、高概率低损失的差距，同样使得损失函数对网络输出“更敏感”，更有利于分类。</p><p>——<a href="https://zhuanlan.zhihu.com/p/37217242" target="_blank" rel="noopener">常见损失函数小结</a></p></blockquote><h4 id="交叉熵与均方误差损失函数对比"><a href="#交叉熵与均方误差损失函数对比" class="headerlink" title="交叉熵与均方误差损失函数对比"></a>交叉熵与均方误差损失函数对比</h4><p>交叉熵只看重正确分类的结果，而均方差对每个输出结果都看重。</p><blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3bno6qd9j31hs0ju794.jpg" alt="截屏2020-05-24 上午3.17.13"></p><p>——<a href="https://blog.csdn.net/blogshinelee/article/details/103518097" target="_blank" rel="noopener">直观理解为什么分类问题用交叉熵损失而不用均方误差损失?</a></p><p><strong>交叉熵的损失函数只和分类正确的预测结果有关系，而MSE的损失函数还和错误的分类有关系，该分类函数除了让正确的分类尽量变大，还会让错误的分类变得平均，但实际在分类问题中这个调整是没有必要的。但是对于回归问题来说，这样的考虑就显得很重要了。所以，回归问题熵使用交叉上并不合适。</strong><br>——<a href="https://blog.csdn.net/weixin_41888969/article/details/89450163" target="_blank" rel="noopener">为什么均方差（MSE）不适合分类问题？交叉熵（cross-entropy）不适合回归问题？</a></p><ol><li>神经网络中如果预测值与实际值的误差越大，那么在反向传播训练的过程中，各种参数调整的幅度就要更大，从而使训练更快收敛，如果预测值与实际值的误差小，各种参数调整的幅度就要小，从而减少震荡。</li><li><strong>使用均方误差损失函数，误差增大参数的梯度会增大（梯度大，告诉权重要向这个方向更新），但是当误差很大时，参数的梯度就会又减小了（权重又不往这个方向更新了，这不合理）。</strong></li><li>使用交叉熵损失函数，误差越大参数的梯度也越大，能够快速收敛。</li></ol><p>——<a href="https://blog.csdn.net/liuweiyuxiang/article/details/90707375" target="_blank" rel="noopener">分类问题为什么要使用交叉熵损失函数而不是均方误差</a></p></blockquote><h3 id="激活函数-损失函数"><a href="#激活函数-损失函数" class="headerlink" title="激活函数+损失函数"></a>激活函数+损失函数</h3><blockquote><p>MSE均方误差+Sigmoid激活函数使得神经网络反向传播的起始位置——输出层神经元学习率缓慢。</p><p>交叉熵损失+Sigmoid激活函数可以解决输出层神经元学习率缓慢的问题，但是不能解决隐藏层神经元学习率缓慢的问题。</p><ul><li><p>改变激活函数或损失函数有可能解决该问题：</p><p>激活函数：将sigmoid函数，改为不会造成梯度消失的函数，例如：ReLU函数，不仅能解决输出层学习率缓慢，还能解决隐藏层学习率缓慢问题。</p><p>损失函数：将均方误差损失，改为交叉熵损失（<a href="https://blog.csdn.net/blogshinelee/article/details/103518097" target="_blank" rel="noopener">直观理解为什么分类问题用交叉熵损失而不用均方误差损失?</a>）</p></li></ul><p>——<a href="https://zhuanlan.zhihu.com/p/37217242" target="_blank" rel="noopener">常见损失函数小结</a></p><p>只要激活函数是sigmoid，tanh类似的曲线，不适合使用MSE，需要搭配交叉熵损失函数。</p><p>对于MSE，随着误差的增大，权值需要调整的幅度先变大后变小，这就导致当误差很大时，模型显得“自暴自弃”不肯学习</p><p>——<a href="https://zhuanlan.zhihu.com/p/63731947" target="_blank" rel="noopener">为什么使用交叉熵作为损失函数</a>，评论</p></blockquote><h3 id="优化器-Optimizer"><a href="#优化器-Optimizer" class="headerlink" title="优化器 Optimizer"></a>优化器 Optimizer</h3><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf43xiyod1g30h80dc4n1.gif" alt="img" style="zoom: 50%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf43xmkc6bg30h80dc1ca.gif" alt="img" style="zoom:50%;" /></p><p>——<a href="https://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Convolutional Neural Networks for Visual Recognition</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于VGG网络的文章链接</title>
      <link href="/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E4%BB%8B%E7%BB%8DVGG%E7%BD%91%E7%BB%9C%E7%9A%84%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5/"/>
      <url>/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E4%BB%8B%E7%BB%8DVGG%E7%BD%91%E7%BB%9C%E7%9A%84%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/41423739" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41423739</a></p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1409.1556">VGG</a>是Oxford的<strong>V</strong>isual <strong>G</strong>eometry <strong>G</strong>roup的组提出的（大家应该能看出VGG名字的由来了）。该网络是在ILSVRC 2014上的相关工作，主要工作是证明了增加网络的深度能够在一定程度上影响网络最终的性能。VGG有两种结构，分别是VGG16和VGG19，两者并没有本质上的区别，只是网络深度不一样。</p></blockquote><p>我的理解是，根据【感受野】的思想，将一些现有的神经网络改为更深层的神经网络</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VGG </tag>
            
            <tag> 感受野 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是否有能够自动调整神经网络参数的方法？</title>
      <link href="/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%98%AF%E5%90%A6%E6%9C%89%E8%83%BD%E5%A4%9F%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F/"/>
      <url>/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%98%AF%E5%90%A6%E6%9C%89%E8%83%BD%E5%A4%9F%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Is there any method or technique can help us to infer the parameters of a CNN model automatically in a reasonable way rather than tedious experiments? Such as the parameters 4096 and 512 in the screenshot.</p><a id="more"></a><h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><p>Unfortunately there’s no real way to know what the optimal architecture for a neural network is. Some researchers have suggested methods such as reinforcement learning (<a href="https://openreview.net/forum?id=r1Ue8Hcxg&amp;noteId=r1Ue8Hcxg" target="_blank" rel="noopener">https://openreview.net/forum?id=r1Ue8Hcxg&amp;noteId=r1Ue8Hcxg</a>) or genetic algorithms (<a href="https://ieeexplore.ieee.org/abstract/document/7731699?casa_token=M5491lfwA_AAAAAA:5pnyD5x1Bu8hbj3Tqj_Tu4AK3ruCDp4Q2DjBtRqVJAIPjDim38bY3KkAJQZYNK8gVlOnhUnJ" target="_blank" rel="noopener">https://ieeexplore.ieee.org/abstract/document/7731699?casa_token=M5491lfwA_AAAAAA:5pnyD5x1Bu8hbj3Tqj_Tu4AK3ruCDp4Q2DjBtRqVJAIPjDim38bY3KkAJQZYNK8gVlOnhUnJ</a>) to experimentally evolve the network architecture and find the best one. In CW1 we got a feel for how changing network configurations can affect the performance; but in reality, our experiments with each component isolated aren’t a route to finding the optimal architecture, because it’s difficult to tune each parameter in isolation. Varying one affects what is optimal for all the rest.</p><p>In practice, most people don’t spend too much time tuning. Rather, they first pick a few network architectures which have worked well on a similar dataset or on a similar task, and they train and compare. They might then choose to fine-tune the best-performing network with a few variations on things like dropout, activation function, etc. </p><h4 id="关于遗传算法"><a href="#关于遗传算法" class="headerlink" title="关于遗传算法"></a>关于遗传算法</h4><blockquote><p>作者：番茄鸡蛋炒饭被抢注啦<br>链接：<a href="https://www.jianshu.com/p/ae5157c26af9" target="_blank" rel="noopener">https://www.jianshu.com/p/ae5157c26af9</a></p><p>既然我们把函数曲线理解成一个一个山峰和山谷组成的山脉。那么我们可以设想所得到的每一个解就是一只袋鼠，我们希望它们不断的向着更高处跳去，直到跳到最高的山峰。<strong>所以求最大值的过程就转化成一个“袋鼠跳”的过程。</strong></p><p>下面介绍介绍“袋鼠跳”的几种方式。</p><ul><li>爬山算法：一只袋鼠朝着比现在高的地方跳去。它找到了不远处的最高的山峰。但是这座山不一定是最高峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。</li><li>模拟退火：袋鼠喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高峰跳去。这就是模拟退火算法。</li><li>遗传算法：有很多袋鼠，它们降落到喜玛拉雅山脉的任意地方。这些袋鼠并不知道它们的任务是寻找珠穆朗玛峰。但每过几年，就在一些海拔高度较低的地方射杀一些袋鼠。于是，不断有袋鼠死于海拔较低的地方，而越是在海拔高的袋鼠越是能活得更久，也越有机会生儿育女。就这样经过许多年，这些袋鼠们竟然都不自觉地聚拢到了一个个的山峰上，可是在所有的袋鼠中，只有聚拢到珠穆朗玛峰的袋鼠被带回了美丽的澳洲。</li></ul><p>遗传算法并不保证你能获得问题的最优解，但是使用遗传算法的最大优点在于你不必去了解和操心如何去“找”最优解。（你不必去指导袋鼠向那边跳，跳多远。）而只要简单的“否定”一些表现不好的个体就行了。（把那些总是爱走下坡路的袋鼠射杀，这就是遗传算法的精粹！）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遗传算法 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将人工智能用户数据分析 AIDI Artificial Intelligence for Data Analytics</title>
      <link href="/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%B2%E5%BA%A7%EF%BC%9A%E5%B0%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-AIDI-Artificial-Intelligence-for-Data-Analytics/"/>
      <url>/2020/05/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%AE%B2%E5%BA%A7%EF%BC%9A%E5%B0%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-AIDI-Artificial-Intelligence-for-Data-Analytics/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="CRISP-DM方法学"><a href="#CRISP-DM方法学" class="headerlink" title="CRISP-DM方法学"></a>CRISP-DM方法学</h4><h4 id="数据工程挑战"><a href="#数据工程挑战" class="headerlink" title="数据工程挑战"></a>数据工程挑战</h4><p>数据组织</p><ul><li>数据解析——cleverCSV</li><li>获取或推断数据字典——ptype，colnet</li><li>数据整合——datadiff</li><li>数据转换 </li></ul><p>数据质量</p><ul><li>Cannoicalization</li><li>缺失数据——HI-VAE</li><li>异常检测和诊断——RVAE</li><li>数据不稳定 non-stationarity——CP Evalution</li></ul><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>机器学习、语义技术、编程语言</p><h4 id="AI-Assistance"><a href="#AI-Assistance" class="headerlink" title="AI Assistance"></a>AI Assistance</h4><ul><li>基于AI的算法</li><li>确保可重复生产和透明性</li></ul><h4 id="数据工程相关的工作"><a href="#数据工程相关的工作" class="headerlink" title="数据工程相关的工作"></a>数据工程相关的工作</h4><ul><li>数据库</li><li>数据挖掘，比如 anomaly detection (Emmott et al, 2013)</li><li>编程语言</li><li>统计学</li></ul><h3 id="datadiff"><a href="#datadiff" class="headerlink" title="datadiff"></a>datadiff</h3><ul><li>数据的格式可能每年都在变化<ul><li>swap, delete, insert columns</li></ul></li><li>Hungarian 算法</li></ul><h3 id="异常检测——RVAE"><a href="#异常检测——RVAE" class="headerlink" title="异常检测——RVAE"></a>异常检测——RVAE</h3><p>真实数据通常伴随着异常数据outliers anomalies</p><h4 id="Variational-Autoencoder-VAE"><a href="#Variational-Autoencoder-VAE" class="headerlink" title="Variational Autoencoder, VAE"></a>Variational Autoencoder, VAE</h4><p>VAE被用于异常点检测 (An &amp; Cho, 2015; Wang et al, 2017)</p><p>可以拟合异常点，但也会对导致对异常点过度拟合，</p><h4 id="Robust-VAE-RVAE"><a href="#Robust-VAE-RVAE" class="headerlink" title="Robust VAE, RVAE"></a>Robust VAE, RVAE</h4><p>异常点注入 outlier injection process</p><h3 id="ptype"><a href="#ptype" class="headerlink" title="ptype"></a>ptype</h3><p>Ceritli, Williams and Geddes (2020)</p><p>评估方法：accuracy and jaccard index</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getd66infhj30kv08b0uw.jpg" alt="截屏2020-05-15 下午12.34.17"></p><h4 id="trifacta"><a href="#trifacta" class="headerlink" title="trifacta"></a>trifacta</h4><p>基于正则表达式和验证公式</p><h3 id="ColNet"><a href="#ColNet" class="headerlink" title="ColNet"></a>ColNet</h3><p>Chen, Jimenz-Ruiz, Horrocks, Sutton (2019)</p><p>预测数据列的语义类型</p><h3 id="CleverCSV"><a href="#CleverCSV" class="headerlink" title="CleverCSV"></a>CleverCSV</h3><p>van den Burg, Nazabal, Sutton (2019)</p><p>CleverCSV通过改进对杂乱CSV文件的方言检测功能，为Python csv软件包提供了直接替代。它还提供了一个方便的命令行工具，该工具可以标准化凌乱的文件或生成Python代码以将其导入。</p><h4 id="Wrattler"><a href="#Wrattler" class="headerlink" title="Wrattler"></a>Wrattler</h4><p>Petricek, Geddes andd Sutton (2018)</p><p>常见的notebook问题</p><ul><li>有限的可重用性</li><li>没有状态回滚</li><li>有限的交互</li><li>每个核用于单语言</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>Tundra Traits (Bjorkman et al, Nature 2018)</p><p>Household Electricity Survey</p><p>CleanEHR: Electronic Health Records</p><p>Ofcom Broadband</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 讲座 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搜索引擎的关键词匹配方案</title>
      <link href="/2020/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E4%B8%89%E7%A7%8D%E5%85%B3%E9%94%AE%E8%AF%8D%E5%8C%B9%E9%85%8D%E6%96%B9%E6%A1%88/"/>
      <url>/2020/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E4%B8%89%E7%A7%8D%E5%85%B3%E9%94%AE%E8%AF%8D%E5%8C%B9%E9%85%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h4 id="搜索引擎的关键词匹配方案"><a href="#搜索引擎的关键词匹配方案" class="headerlink" title="搜索引擎的关键词匹配方案"></a>搜索引擎的关键词匹配方案</h4><p>方法一：【词嵌入技术】</p><p>方法二：计算相似度</p><ul><li>【词袋】包含1000个基础单词</li><li>任何一个单词都匹配能用一个1000维的向量表示</li><li>任何一个文档，都能用每个单词所表示的向量相加</li><li>文档之间（或文档和查询词之间）的相似度可以通过计算两个向量的距离。</li></ul><p>方法三：【倒排索引】</p><ul><li>具体介绍请转至，博客标题：信息检索（谷歌搜索）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无服务器计算 FaaS</title>
      <link href="/2020/05/%E4%BA%91%E8%AE%A1%E7%AE%97/19%20%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94FaaS/"/>
      <url>/2020/05/%E4%BA%91%E8%AE%A1%E7%AE%97/19%20%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94FaaS/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="无服务计算"><a href="#无服务计算" class="headerlink" title="无服务计算"></a>无服务计算</h4><p>开发者不需要配置或者管理服务器或容器，如AWS Lambda，只需要将业务代码上传至平台即可。</p><p>在无服务计算的模型中，服务器的存在对开发者是隐藏的。</p><ul><li>无服务结构和功能即服务 Function-as-a-Service(FaaS) 平台的优点：简单、快速、灵活</li><li><strong>无服务</strong>指的是软件结构，<strong>功能即服务</strong>是其中的关键的机制，通过这种机制，开发者在该软件结构中实现业务逻辑</li></ul><h4 id="IaaS-PaaS-SaaS-FaaS的区别"><a href="#IaaS-PaaS-SaaS-FaaS的区别" class="headerlink" title="IaaS, PaaS, SaaS, FaaS的区别"></a>IaaS, PaaS, SaaS, FaaS的区别</h4><h4 id="无服务计算执行模型"><a href="#无服务计算执行模型" class="headerlink" title="无服务计算执行模型"></a>无服务计算执行模型</h4><p>如果该功能不存在于现有的服务器中，则平台从数据库中读取功能，并部署到服务器上，再返回功能的执行结果给用户</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>无需管理服务器，可连续扩展，动态分配资源，避免资源过度分配（管理资源分配，平衡资源分配），按使用付费</p><p>从生产角度From a productivity standpoint，可以不考虑代码存储和执行环境管理的细节</p><p>基于execution metrics，无服务计算十分划算priced，so there is a financial advantage as well.</p><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>详见<em>13.能源效率</em></p><p>用户总是高估自己的需求（以防万一，天真），从而浪费大量空闲资源，而使用无服务器计算，供应商和消费者双方都不需要面对这个问题</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf91tot5s1j30rg0es78k.jpg" alt="截屏2020-05-29 上午2.10.46" style="zoom:50%;" /></p><h4 id="无服务器函数-Serverless-Functions"><a href="#无服务器函数-Serverless-Functions" class="headerlink" title="无服务器函数 Serverless Functions"></a>无服务器函数 Serverless Functions</h4><p>从 monoliths 到 microservices 到 functions</p><p><strong>微服务</strong>的特点：Smaller-grained services 粒度小的服务，专属、具体的功能</p><p><strong>微服务</strong>的结构：事件处理器 Event handler，无服务后端，数据处理</p><p><strong>无服务器函数</strong>的特点：FaaS的指导原则，开发者无需关注被抽象化的服务器，按照功能的使用服务而不是服务器实例的大小，提供的服务是事件驱动的且能够立即扩展</p><h4 id="透明的应用部署"><a href="#透明的应用部署" class="headerlink" title="透明的应用部署"></a>透明的应用部署</h4><p>PaaS：用于基于用户需求和约束的服务发现</p><p><strong>无服务结构</strong>和<strong>微服务</strong>可以掩盖“运行过程中软件和数据的灵活组合/拆分和可交互性”</p><p>【容器】或其他技术用于桥接云和边缘计算之间的间隔：Unikernels 提供解决“软件定义的基础架构”的基础功能</p><h4 id="无服务计算——其他好处"><a href="#无服务计算——其他好处" class="headerlink" title="无服务计算——其他好处"></a>无服务计算——其他好处</h4><p>简化部署和打包，消除系统管理的要求</p><p>敏捷开发，使开发者集中于代码，并快速发布deliver</p><p>扩展的成本更低：扩展（用户访问量）不需要开发者通过代码实现，管理者也不用更新服务器或添加新的服务器</p><p>更小的开发成本和经营成本 operational costs</p><p>更快发布软件 software release，减少到市场的时间 Decreased time to market</p><h4 id="无服务架构的解决方案和结构细节"><a href="#无服务架构的解决方案和结构细节" class="headerlink" title="无服务架构的解决方案和结构细节"></a>无服务架构的解决方案和结构细节</h4><ul><li>Amazon Lambda</li><li>Apache Openwhisk</li><li>IBM Openwhisk</li><li>Google cloud functions</li><li>Microsoft Azure functions Other: Iron.io, Fission</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件度量 Metrics Used in Software Measurement</title>
      <link href="/2020/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F/"/>
      <url>/2020/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>注意，任何一种软件度量都是有缺陷的</p><blockquote><p>Every software metric is flawed if you blindly take it to its extreme.</p></blockquote><h4 id="软件度量的作用"><a href="#软件度量的作用" class="headerlink" title="软件度量的作用"></a>软件度量的作用</h4><ul><li>帮助开发者管理软件开发进度，比如预估开发时间、评估软件质量是否足以交付</li><li>通过定义和测量软件的属性，来更好的理解软件（软件工程）</li></ul><blockquote><p>Software Metrics: A Rigorous &amp; Practical Approach, Second Edition. Bieman, James M.IBM Systems Journal; Armonk Vol. 36, Iss. 4,  (1997): 594-595.</p></blockquote><h4 id="架构度量的作用"><a href="#架构度量的作用" class="headerlink" title="架构度量的作用"></a>架构度量的作用</h4><p>软件架构能在开始具体开发工作之前，帮助我们确定软件的骨架，就好像建房子一样。而<strong>架构度量</strong>则是帮助我们量化软件架构的一些基本属性，以检查好坏（但还需要发现属性与好坏直接的关系，这需要学者研究或者开发经验）。</p><blockquote><p>Coulin T, Detante M, Mouchère W, et al. Software Architecture Metrics: a literature review[J]. arXiv preprint arXiv:1901.09050, 2019.</p></blockquote><h4 id="2个问题"><a href="#2个问题" class="headerlink" title="2个问题"></a>2个问题</h4><ul><li>哪些架构度量可以帮助设计者评估软件架构</li><li>这些架构度量在什么程度上表示了架构的质量</li></ul><h4 id="架构质量的5个方面"><a href="#架构质量的5个方面" class="headerlink" title="架构质量的5个方面"></a>架构质量的5个方面</h4><ul><li>Maintainability 可维护性</li><li>Performance 性能</li><li>Extensibility 可扩展性</li><li>Simplicity and Understandability 简单性+可理解性</li><li>Re-usability 可重用性</li></ul><h4 id="架构度量的4个方面"><a href="#架构度量的4个方面" class="headerlink" title="架构度量的4个方面"></a>架构度量的4个方面</h4><ul><li>Coupling 耦合</li><li>Cohesion 内聚</li><li>Complexity 复杂性</li><li>Size 大小</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>至2011年为止，共20种度量方式：<a href="https://maisqual.squoring.com/wiki/index.php/Category:Metrics" target="_blank" rel="noopener">https://maisqual.squoring.com/wiki/index.php/Category:Metrics</a> (<a href="https://maisqual.squoring.com/wiki/index.php/Maisqual_Metrics" target="_blank" rel="noopener">Maisqual Metrics set</a>)</p><p>软件架构度量（文献综述）：Coulin T, Detante M, Mouchère W, et al. Software Architecture Metrics: a literature review[J]. arXiv preprint arXiv:1901.09050, 2019.</p><p>Eclipse度量插件中使用的度量方法：<a href="http://eclipse-metrics.sourceforge.net/example/index.html" target="_blank" rel="noopener">http://eclipse-metrics.sourceforge.net/example/index.html</a></p><h2 id="架构度量"><a href="#架构度量" class="headerlink" title="架构度量"></a>架构度量</h2><h3 id="S-R-Chidamber-and-C-F-Kemerer-“A-metrics-suite-for-object-oriented-design-”-in-IEEE-Transactions-on-Software-Engineering-vol-20-no-6-pp-476-493-June-1994"><a href="#S-R-Chidamber-and-C-F-Kemerer-“A-metrics-suite-for-object-oriented-design-”-in-IEEE-Transactions-on-Software-Engineering-vol-20-no-6-pp-476-493-June-1994" class="headerlink" title="S. R. Chidamber and C. F. Kemerer, “A metrics suite for object oriented design,” in IEEE Transactions on Software Engineering, vol. 20, no. 6, pp. 476-493, June 1994."></a>S. R. Chidamber and C. F. Kemerer, “A metrics suite for object oriented design,” in IEEE Transactions on Software Engineering, vol. 20, no. 6, pp. 476-493, June 1994.</h3><h4 id="Weighted-Methods-Per-Class-WMC"><a href="#Weighted-Methods-Per-Class-WMC" class="headerlink" title="Weighted Methods Per Class (WMC)"></a>Weighted Methods Per Class (WMC)</h4><p>计算方式：一个类中所有方法的复杂度之和，如果所有方法的复杂度相同，则为方法数量之和</p><p>Theoretical Basis: WMC relates directly to Bunge’s definition of complexity of a thing, since methods are properties of object classes and complexity is determined by the cardinality of its set of properties. The number of methods is, therefore, a measure of class definition as well as being attributes of a class, since attributes correspond to properties.</p><p>Viewpoints:</p><ul><li>1) The number of methods and the complexity of methods involved is a predictor of how much time and effort is required to develop and maintain the class.</li><li>2) The larger the number of methods in a class the greater the potential impact on children, since children will inherit all the methods defined in the class.</li><li>3) Classes with large numbers of methods are likely to be more application specific, limiting the possibility of reuse.</li></ul><h4 id="Depth-of-Inheritance-Tree-DIT"><a href="#Depth-of-Inheritance-Tree-DIT" class="headerlink" title="Depth of Inheritance Tree (DIT)"></a>Depth of Inheritance Tree (DIT)</h4><p>计算方式：继承树中的最大长度（深度）</p><p>Definition: Depth of inheritance of the class is the DIT metric for the class. In cases involving multiple inheritance, the DIT will be the maximum length from the node to the root of the tree.</p><p>Theoretical Basis: DIT relates to Bunge’s notion of the scope of properties. DIT is a measure of how many ancestor classes can potentially affect this class.</p><p>Viewpoints:</p><ul><li><p>The deeper a class is in the hierarchy, the greater the number of methods it is likely to inherit, making it more complex to predict its behavior.</p></li><li><p>Deeper trees constitute greater design complexity, since more methods and classes are involved.</p></li><li><p>The deeper a particular class is in the hierarchy, the greater the potential reuse of inherited methods.</p></li></ul><h4 id="Number-of-Children-NOC"><a href="#Number-of-Children-NOC" class="headerlink" title="Number of Children(NOC)"></a>Number of Children(NOC)</h4><p>计算方式：一个类的直接子类的数量</p><p>Definition: NOC = number of immediate subclasses subordinated to a class in the class hierarchy.</p><p>Theoretical Basis: NOC relates to the notion of scope of properties. It is a measure of how many subclasses are going to inherit the methods of the parent class.</p><p>Viewpoints:</p><ul><li>1) Greater the number of children, greater the reuse, since inheritance is a form of reuse.</li><li><strong><em>2)\</em></strong> Greater the number of children, the greater the likelihood of improper abstraction of the parent class. If a class has a large number of children, it may be a case of misuse of subclassing.</li><li>3) The number of children gives an idea of the potential influence a class has on the design. If a class has a large number of children, it may require more testing of the methods in that class.</li></ul><h4 id="Coupling-between-object-classes-CBO"><a href="#Coupling-between-object-classes-CBO" class="headerlink" title="Coupling between object classes (CBO)"></a>Coupling between object classes (CBO)</h4><p>计算方式：一个类与其他类耦合的数量。依赖和被依赖都属于耦合，但计算方式是按类计算的，即使两个类相互依赖也只是各计一次。</p><p>Definition: CBO for a class is a count of the number of other classes to which it is coupled.</p><p>Theoretical Basis: CBO relates to the notion that an object is coupled to another object if one of them acts on the other, i.e., methods of one use methods or instance variables of another. As stated earlier, since objects of the same class have the same properties, two classes are coupled when methods declared in one class use methods or instance variables defined by the other class.</p><p>Viewpoints:</p><ul><li>1) Excessive coupling between object classes is detrimental to modular design and prevents reuse. The more inde- pendent a class is, the easier it is to reuse it in another application.</li><li><em>2)</em> In order to improve modularity and promote encapsu- lation, inter-object class couples should be kept to a minimum. The larger the number of couples, the higherthe sensitivity to changes in other parts of the design, and therefore maintenance is more difficult.</li><li>3) A measure of coupling is useful to determine how complex the testing of various parts of a design are likely to be. The higher the inter-object class coupling, the more rigorous the testing needs to be.</li></ul><h4 id="Response-For-a-Class-UFC"><a href="#Response-For-a-Class-UFC" class="headerlink" title="Response For a Class (UFC)"></a>Response For a Class (UFC)</h4><p>计算方法：一个类中的方法调用其他方法的数量（包括该类的其他方法和其他类的方法）</p><p>Definition: RFC = |RS| where RS is the response set for the class.</p><p>Theoretical Basis: The response set of a class is a set of methods that can potentially be executed in response to a message received by an object of that class. The cardinality of this set is a measure of the attributes of objects in the class. Since it specifically includes methods called from outside the class, it is also a measure of the potential communication between the class and other classes.</p><p>Viewpoints:</p><ul><li>1) If a large number of methods can be invoked in response to a message, the testing and debugging of the class becomes more complicated since it requires a greater level of understanding required on the part of the tester.</li><li>2) The larger the number of methods that can be invoked from a class, the greater the complexity of the class.</li><li>3) <strong>A</strong> worst case value for possible responses will assist in appropriate allocation of testing time.</li></ul><h4 id="Lack-of-Cohesion-in-Methods-LCOM"><a href="#Lack-of-Cohesion-in-Methods-LCOM" class="headerlink" title="Lack of Cohesion in Methods (LCOM)"></a><a href="http://eclipse-metrics.sourceforge.net/descriptions/pages/cohesion/LackOfCohesionInMethods.html" target="_blank" rel="noopener">Lack of Cohesion in Methods (LCOM)</a></h4><p>计算方式：一个类中，没有公共字段的方法对的数量，减去，该类中至少一个公共字段的方法对的数量。如果此值为负，则度量标准值将设置为0。</p><p>Theoretical Basis: The LCOM is a count of the number of method pairs whose similarity is 0 minus the count of method pairs whose similarity is not zero. The larger the number of similar methods, the more cohesive the class, which is consistent with traditional notions of cohesion that measure the inter-relatedness between portions of a program. If none of the methods of a class display any instance behavior, i.e., do not use any instance variables, they have no similarity and the LCOM value for the class will be zero. The LCOM value provides a measure of the relative disparate nature of methods in the class. A smaller number of disjoint pairs (elements of set P ) implies greater similarity of methods. LCOM is intimately tied to the instance variables and methods of a class, and therefore is a measure of the attributes of an object class.</p><p>Viewpoints:</p><ul><li>1) Cohesiveness of methods within a class is desirable, since it promotes encapsulation.</li><li>2) Lack of cohesion implies classes should probably be split into two or more subclasses.</li><li><strong>3)</strong> Any measure of disparateness of methods helps identify flaws in the design of classes.</li><li>4) Low cohesion increases complexity, thereby increasing the likelihood of errors during the development process.</li></ul><p><a href="https://stackoverflow.com/questions/6013032/why-does-lack-of-cohesion-of-methods-lcom-include-getters-and-setters" target="_blank" rel="noopener">缺陷</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件度量 </tag>
            
            <tag> software metrics </tag>
            
            <tag> architecutral metrics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微核模式的插件式架构设计：静态代码分析工具</title>
      <link href="/2020/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E6%A0%B8%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E6%A0%B8%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>下文中，<u>基于微核模式设计的静态代码分析工具</u>将简称为<u>工具</u></p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol><li>用户可以实现自己的软件度量方法，并作为插件集成到工具中<ol><li>以代码的方式实现</li><li>以配置的方式实现</li></ol></li><li>工具对项目代码分析完毕后，提供一个对象来获取计算软件度量所需的元数据<ol><li>需要分析究竟需要提供多少元数据才能满足用户插件的需求</li><li>如果工具提供的元数据不足，如何让用户生成新的元数据<ol><li>代码特征的最小集</li></ol></li></ol></li></ol><h4 id="基本设计思想"><a href="#基本设计思想" class="headerlink" title="基本设计思想"></a>基本设计思想</h4><ul><li>通过接口声明插件应该具备的功能。在本例中则是定义用户自定义的插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Interface Plugin &#123;</span><br><span class="line">    void doSth();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PrintSth implements Plugin &#123;</span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    public void doSth() &#123;</span><br><span class="line">        PrintHelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">    private void PrintHelloWorld() &#123;</span><br><span class="line">        System.out.println(&quot;HelloWorld!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>至于检测插件是否实现了接口，可以使用isAssignableFrom()</li></ul><h4 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h4><p>OSGI（开放服务网关协议，Open Service Gateway Initiative）技术是Java动态化<a href="https://baike.baidu.com/item/模块化/3295536" target="_blank" rel="noopener">模块化</a>系统的一系列规范。应用对象：Java动态模型系统。</p><p><a href="https://zhuanlan.zhihu.com/p/28909673" target="_blank" rel="noopener">SPI</a> （Service Provider Interface）</p><ul><li><p>在平台中使用ServiceLoader，在运行时动态加载插件（热部署+非Classpath路径加载）</p></li><li><p>优点</p><ul><li>使用 <a href="https://zhoukaibo.com/tags/java/" target="_blank" rel="noopener">Java</a> SPI 机制的优势是实现解耦，使得接口的定义与具体业务实现分离，而不是耦合在一起。应用程序可以根据实际业务情况启用或替换具体组件。</li></ul></li><li>缺点<ul><li>不能按需加载。虽然 ServiceLoader 做了延迟载入，但是基本只能通过遍历全部获取，也就是接口的实现类得全部载入并实例化一遍。如果你并不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li><li>加载不到实现类时抛出并不是真正原因的异常，错误很难定位。</li></ul></li><li>鉴于 SPI 的诸多缺点，很多系统都是自己实现了一套类加载机制，例如 dubbo。用户也可以自定义classloader+反射机制来加载，实现并不复杂。此外开源的类加载解决方案有 <a href="https://github.com/pf4j/pf4j" target="_blank" rel="noopener">Plugin Framework for Java (PF4J)</a> 等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件设计 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 软件架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>去中心化的众包数据分析（众包：市民产生-&gt;市民使用）</title>
      <link href="/2020/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%97%E5%8C%85%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%88%E5%B8%82%E6%B0%91%E4%BA%A7%E7%94%9F-%E5%B8%82%E6%B0%91%E4%BD%BF%E7%94%A8%EF%BC%89/"/>
      <url>/2020/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%97%E5%8C%85%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%88%E5%B8%82%E6%B0%91%E4%BA%A7%E7%94%9F-%E5%B8%82%E6%B0%91%E4%BD%BF%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>去中心化的系统</strong>不等于<strong>分布式系统</strong></p><p>去中心化：没有中心节点</p><p>分布式系统：可能有中心节点</p><a id="more"></a><h3 id="去中心化的，隐私保护的，实时的数据分析"><a href="#去中心化的，隐私保护的，实时的数据分析" class="headerlink" title="去中心化的，隐私保护的，实时的数据分析"></a>去中心化的，隐私保护的，实时的数据分析</h3><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><ul><li>数据是数字化经济中的新石油</li><li>无处不在的大数据和分析</li><li>大数据的危害</li><li>为什么应将大数据传播者进行再教育</li></ul><h4 id="威胁和挑战"><a href="#威胁和挑战" class="headerlink" title="威胁和挑战"></a>威胁和挑战</h4><p>在中心管理的计算基础设施中，存储和处理的大数据。（注意：分布式系统distributed system 不等于 去中心化的系统decentralized system）</p><p>大数据业务模型鼓励大规模的采集<u>侵犯隐私的个人数据</u></p><p>大数据的AI算法的透明程度和如何问责</p><p>区别对待的/歧视性的数据分析和使用，如市民概况profilling</p><p>危害自治、公平、民主</p><h4 id="大数据分析的另一种选择"><a href="#大数据分析的另一种选择" class="headerlink" title="大数据分析的另一种选择"></a>大数据分析的另一种选择</h4><p>去中心化Decentralized：不需要依赖（可信的）第三方</p><p>隐私保护Privacy-preserving：在不暴露个人数据的情况下，提供高质量的服务</p><p>众包和群众参与Crowd-sourced &amp; participatory：使用个人设备，最大化的使数据和计算的本地化</p><p>边缘计算Edge computing：使数据更本地化，减少延迟</p><p>分布式账本Distributed ledgers：不需要依赖（可信的）第三方</p><p>模糊处理Obsfucation，差分隐私differential privacy，同态加密技术homomorphic encryption techniques：用于隐私保护</p><blockquote><p><a href="https://blog.csdn.net/weixin_41564401/article/details/82777335" target="_blank" rel="noopener">同态加密</a>：数据持有者传输数据前先将数据加密，云服务器在接收到数据后照例计算，只不过这次是在密文上进行的，云服务器啥都看不到。待得到结果后再将结果的密文返还给数据持有者，数据持有者解开后即得最终结果。</p><p><a href="https://www.zhihu.com/question/47492648" target="_blank" rel="noopener">差分隐私</a>：对数据集做一个满足差分隐私的加密，并公布出去，给大众做数据分析。扰动后的数据集和源数据集的整体统计学信息（如方差、均值）几乎一致，但个体信息不一致，防止大众通过数据库对比导致隐私泄露。核心是保证数据保密性的情况下最大化数据可用性。</p></blockquote><h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><ol><li>自主的选择</li><li>自我监管的信息共享</li><li>去中心化的数据分析</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geawoy3qe0j30yu0j40xy.jpg" alt="截屏2020-04-29 下午1.23.58"></p><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ul><li>延迟：在网络中对<u>短暂的transient大数据</u>进行<u>传播dissemination、分布distribution、同步synchronization</u></li><li><p>如何通过去中心化网络上连续更新的数据流，提供及时的、精确的实时数据分析</p></li><li><p>如何根据网络动态调整数据分析：比如关联join&amp;叶子leaves节点、故障等</p></li><li>如何优化用于多程序的复杂网络的运营：比如资源向上/下扩展，去中心化系统的虚拟化</li><li>解决上述挑战的方法如何用于新的通用数据分析模型：比如MapReduce</li></ul><h4 id="挑战之一"><a href="#挑战之一" class="headerlink" title="挑战之一"></a>挑战之一</h4><p>如何以高性价比和弹性的方式，将去中心化的、动态的、隐私保护的数据分析，应用在物联网上</p><ul><li>高性价比cost-effective：通信和内存 VS 准确度</li><li>弹性resilient：面向高精度的自我更正操作</li><li>去中心化：集体的P2P计算+众包</li><li>动态的：对计算进行实时的、连续的调整</li><li>隐私保护：数据摘要summarization</li><li>分析：聚合函数Aggregation function，如SUM、AVG等</li></ul><h4 id="数据分析的焦点：聚合函数-Aggregation-Functions"><a href="#数据分析的焦点：聚合函数-Aggregation-Functions" class="headerlink" title="数据分析的焦点：聚合函数 Aggregation Functions"></a>数据分析的焦点：聚合函数 <strong>Aggregation Functions</strong></h4><p>用于大规模实时数据分析的常用轻量级计算</p><p>聚合函数：SUM, AVG, MAX, MIN, STDEV, COUNT, etc.</p><p>MapReduce模型中的关键操作（reduce）</p><p>适用于隐私敏感的应用：</p><ul><li>交通监控（车速）</li><li>能源需求响应（电量需求）</li><li>流行病爆发监控（受感染人群）</li><li>投票</li></ul><h4 id="聚合问题——中心化的方法"><a href="#聚合问题——中心化的方法" class="headerlink" title="聚合问题——中心化的方法"></a>聚合问题——中心化的方法</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geb6549mbnj30wq0je0ub.jpg" alt="截屏2020-04-29 下午6.50.38" style="zoom:50%;" /></p><h4 id="聚合问题——去中心化的方法"><a href="#聚合问题——去中心化的方法" class="headerlink" title="聚合问题——去中心化的方法"></a>聚合问题——去中心化的方法</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geb6795wa1j30jc09g0tg.jpg" alt="截屏2020-04-29 下午6.53.00" style="zoom:50%;" /></p><p>需要考虑：在不同的情况下以性价比高的更新方式聚合数据：</p><ul><li>不同的聚合函数</li><li>新的输入值</li><li>被移除的输入数据</li><li>关联和叶子节点</li><li>故障节点</li></ul><p>特点：</p><ul><li>自治的实体（设备/代理）有：电脑、传感器、智能手机</li><li>P2P交互</li><li>持续的通信</li><li>全局目标：聚合传感器的输出值</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>Evangelos Pournaras and Jovan Nikolic, On-demand Self-adaptive Data Analytics in Large-scale Decentralized Networks, in the Proceedings of the 16th IEEE International Symposium on Network Computing and Applications-NCA-2017, Cambridge, USA, November 2017 © IEEE</p><p>Evangelos Pournaras, Jovan Nikolic, Self-corrective Dynamic Networks via Decentralized Reverse Computations, in the Proceedings of the 14th International Conference on Autonomic Computing-ICAC-2017, Columbus, Ohio, July 2017 © IEEE</p><p>Evangelos Pournaras, Jovan Nikolic, Alex Omerzel, Dirk Helbing, Engineering Democratization in Internet of Things Data Analytics, in the proceedings of the 31st IEEE International Conference on Advanced Information Networking andApplications-AINA-2017, Taiwan, March 2017 © IEEE</p><p>Thomas Asikis, Evangelos Pournaras, Optimization of privacy-utility trade-offs under informational self-determination, Future Generation Computer Systems, 2018,ISSN 0167-739X</p><h4 id="动态去中心化聚合"><a href="#动态去中心化聚合" class="headerlink" title="动态去中心化聚合"></a>动态去中心化聚合</h4><p><strong>Gossip-based Aggregation</strong></p><p>Jelasity, M., Montresor, A. and Babaoglu, O., 2005. Gossip-based aggregation in large dynamic networks. ACM Transactions on Computer Systems (TOCS), 23(3), pp.219-252</p><p> <strong>Tree-based Aggregation</strong></p><p>Ding, M., Cheng, X. and Xue, G., 2003, October. Aggregation tree construction in sensor networks. In <em>2003 IEEE 58th Vehicular Technology Conference. VTC 2003-Fall (IEEE Cat. No. 03CH37484)</em> (Vol. 4, pp. 2168-2172). IEEE.</p><p><strong>Synopsis Diffusion</strong></p><p>Nath, S., Gibbons, P.B., Seshan, S. and Anderson, Z., 2008. Synopsis diffusion for robust aggregation in sensor networks. ACM Transactions on Sensor Networks (TOSN), 4(2), pp.1- 40. Vancouver</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智慧城市：去中心化的普适智能</title>
      <link href="/2020/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/20%20%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%EF%BC%9A%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E6%99%AE%E9%80%82%E6%99%BA%E8%83%BD/"/>
      <url>/2020/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/20%20%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%EF%BC%9A%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E6%99%AE%E9%80%82%E6%99%BA%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>数字化时代会给<u>科技-社会-经济系统</u>的<u>自我管理能力</u>带来机会和挑战</p><a id="more"></a><h4 id="数字化时代的机遇"><a href="#数字化时代的机遇" class="headerlink" title="数字化时代的机遇"></a>数字化时代的机遇</h4><p>高度自动化、更低的成本、更高的效率、更简单的通讯、在线适应 online adaptation</p><p>发生革命性概念的社会-科学行业：能源、移动、监控、食物供应链</p><blockquote><p>profiling：记录和分析一个人的心理和行为特征，以便评估或预测他们在特定领域的能力或帮助识别特定人群</p></blockquote><h4 id="威胁和挑战"><a href="#威胁和挑战" class="headerlink" title="威胁和挑战"></a>威胁和挑战</h4><p>关于隐私入侵、监控、剖析：中心化的系统；底下的公民隐私意识，和高的推理机会。</p><p>自动化：操纵性不透明算法，收割注意力，虚假新闻等。</p><h3 id="共享经济中的自我管理挑战——from-local-to-global-objectives"><a href="#共享经济中的自我管理挑战——from-local-to-global-objectives" class="headerlink" title="共享经济中的自我管理挑战——from local to global objectives"></a>共享经济中的自我管理挑战——from local to global objectives</h3><h4 id="智慧网格-Smart-Grids"><a href="#智慧网格-Smart-Grids" class="headerlink" title="智慧网格 Smart Grids"></a>智慧网格 Smart Grids</h4><p>本地：日常生活（洗衣、做饭、洗澡、充电）</p><p>全局：预防/减轻断电，最小化成产成本，最大化可再生资源的使用</p><h4 id="智慧城市"><a href="#智慧城市" class="headerlink" title="智慧城市"></a>智慧城市</h4><p>本地：共享单车——从某地存取单车</p><p>全局：预防/减缓共享单车站台过载，最小化以人工重新放置单车，最小化运营成本，最小化投资成本；</p><p>本地：选择一条导航路径</p><p>全局：预防/减轻交通拥挤，减少城市空气污染，发生交通事故或城市建造时高效的重新规划交通，最大化基础设施的生命周期</p><h4 id="集体学习"><a href="#集体学习" class="headerlink" title="集体学习"></a>集体学习</h4><p>是一种新的范例，针对去中心化得到普适智能：设计社科、分布式系统、AI</p><h5 id="自治的代理，能够自主决定一系列资源调度和分配的计划。"><a href="#自治的代理，能够自主决定一系列资源调度和分配的计划。" class="headerlink" title="自治的代理，能够自主决定一系列资源调度和分配的计划。"></a>自治的代理，能够自主决定一系列资源调度和分配的计划。</h5><p>核心思想：众包的运营灵活性。</p><p>关键点：普适的自治性，隐私，没有推诿 no nudding，增强信任</p><h5 id="平衡个人（本地）和集体（全球）目标的代理"><a href="#平衡个人（本地）和集体（全球）目标的代理" class="headerlink" title="平衡个人（本地）和集体（全球）目标的代理"></a>平衡个人（本地）和集体（全球）目标的代理</h5><p>核心思想：经过设计的对社会负责的决策</p><p>关键点：内在利益与外在动机之间的相互作用</p><h5 id="代理商协调和合作选择他们的计划"><a href="#代理商协调和合作选择他们的计划" class="headerlink" title="代理商协调和合作选择他们的计划"></a>代理商协调和合作选择他们的计划</h5><p>核心思想：利用群众的计算资源进对众包进行自我管理</p><p>关键点：通过设计使用专有的汇总信息来保护隐私</p><h3 id="区域自治计划——参与模型"><a href="#区域自治计划——参与模型" class="headerlink" title="区域自治计划——参与模型"></a>区域自治计划——参与模型</h3><p>由代理自我决定的，（可替换的）运营计划</p><ul><li>自我决定：自治</li><li>可替换的：灵活性</li><li>运营：取决于应用</li><li>计划：资源调度和分配</li></ul><h4 id="计划的灵活性"><a href="#计划的灵活性" class="headerlink" title="计划的灵活性"></a>计划的灵活性</h4><ul><li>住宅供电需求<ul><li>提前打开或关闭热水器，来控制温度变化</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea1ru9sp4j30s40i4n1g.jpg" alt="截屏2020-04-28 下午7.34.08" style="zoom: 33%;" /></p><ul><li>共享单车<ul><li>根据位置选择站台，来权衡价格或距离</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea1sgcschj311q0midqm.jpg" alt="截屏2020-04-28 下午7.34.46" style="zoom: 25%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea1w1wau9j31200h0wls.jpg" alt="截屏2020-04-28 下午7.38.13" style="zoom:33%;" /></p><ul><li>交通</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea1xeya1fj31180jigrh.jpg" alt="截屏2020-04-28 下午7.39.34" style="zoom:33%;" /></p><h3 id="全局优化"><a href="#全局优化" class="headerlink" title="全局优化"></a>全局优化</h3><h4 id="系统范围的集体目标-System-wide-Collective-Objectives"><a href="#系统范围的集体目标-System-wide-Collective-Objectives" class="headerlink" title="系统范围的集体目标 System-wide Collective Objectives"></a>系统范围的集体目标 System-wide Collective Objectives</h4><ul><li>成本函数</li><li><ul><li>线性<ul><li>可被局部优化——不需要协作</li></ul></li><li>二元 quadratic：<ul><li>需要协作和集体决策</li><li>如最小化方差或均方根误差</li></ul></li></ul></li><li>通用稳定性，和指标匹配</li><li>复杂度 = <script type="math/tex">可能的计划数量^{设备数量}</script></li><li>组合优化问题——NP难</li></ul><h4 id="EPOS-解决方案"><a href="#EPOS-解决方案" class="headerlink" title="EPOS 解决方案"></a><a href="epos-net.org">EPOS</a> 解决方案</h4><p><strong>EPOS: Economic Planning &amp; Optimized Selections</strong></p><p><strong>I-EPOS I</strong>terative</p><h4 id="协作结构——自我管理树状拓扑"><a href="#协作结构——自我管理树状拓扑" class="headerlink" title="协作结构——自我管理树状拓扑"></a>协作结构——自我管理树状拓扑</h4><p>基于流言的交互与信息交换</p><p>E.Pournaras,M.Warnier,and F.M.Brazier,“<em>Adaptive</em> <em>self-organization in distributed tree topologies</em>,” <em>International Journal of Distributed Systems and Technologies (IJDST)</em>, vol. 5, no. 3, pp. 24–57, 2014</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea4v5l33uj30cg0dcgqr.jpg" alt="截屏2020-04-28 下午9.21.11" style="zoom: 50%;" /></p><h4 id="区域计划选择——区域-amp-全局成本"><a href="#区域计划选择——区域-amp-全局成本" class="headerlink" title="区域计划选择——区域&amp;全局成本"></a>区域计划选择——区域&amp;全局成本</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea566mtnsj312o0m2go7.jpg" alt="截屏2020-04-28 下午9.31.47"></p><h4 id="协作——分布式集体决策"><a href="#协作——分布式集体决策" class="headerlink" title="协作——分布式集体决策"></a>协作——分布式集体决策</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea584zgpqj30xo0mc0z4.jpg" alt="截屏2020-04-28 下午9.33.40"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea5bj7kuxj310o0nudmx.jpg" alt="截屏2020-04-28 下午9.36.56"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea5bqkujej310o0nkn3q.jpg" alt="截屏2020-04-28 下午9.37.07"></p><h3 id="社科权衡-Socio-technical-Trade-offs"><a href="#社科权衡-Socio-technical-Trade-offs" class="headerlink" title="社科权衡  Socio-technical Trade-offs"></a>社科权衡  <strong>Socio-technical Trade-offs</strong></h3><h4 id="社会衡量"><a href="#社会衡量" class="headerlink" title="社会衡量"></a>社会衡量</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea5ft0aadj310y0lq77f.jpg" alt="截屏2020-04-28 下午9.40.39"></p><h4 id="监管能力与权衡"><a href="#监管能力与权衡" class="headerlink" title="监管能力与权衡"></a>监管能力与权衡</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea5gocy55j311u0lu7cm.jpg" alt="截屏2020-04-28 下午9.41.53"></p><h4 id="对计划选择的影响"><a href="#对计划选择的影响" class="headerlink" title="对计划选择的影响"></a>对计划选择的影响</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea5h3qkylj312a0es79j.jpg" alt="截屏2020-04-28 下午9.42.18"></p><h3 id="最新技术的比较：COHDA-Greedy-EPOS"><a href="#最新技术的比较：COHDA-Greedy-EPOS" class="headerlink" title="最新技术的比较：COHDA, Greedy, EPOS"></a>最新技术的比较：COHDA, Greedy, EPOS</h3><p>C. Hinrichs, S. Lehnhoff, and M. Sonnenschein, “COHDA: A combinatorial optimization heuristic for distributed agents,” in <em>International Conference on Agents and Artificial Intelligence</em>. Springer, 2013, pp. 23–39.</p><p>E. Pournaras, M. Warnier, and F. M. Brazier, “Local agent-based self-stabilisation in global resource utilisation,” <em>International Journal of Autonomic Computing</em>, vol. 1, no. 4, pp. 350–373, 2010.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gea5j94jlcj311y0negya.jpg" alt="截屏2020-04-28 下午9.44.21"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智慧城市示例 </tag>
            
            <tag> 去中心化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache Storm</title>
      <link href="/2020/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/19%20Apache-Storm/"/>
      <url>/2020/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/19%20Apache-Storm/</url>
      
        <content type="html"><![CDATA[<p>Storm是一个分布式的实时计算系统，针对于大数据中高速率Velocity、大体积Volumn的特点。Storm中每个节点的处理速度能超过每秒百万条记录。Storm还旨在简化对无界的流数据的可靠处理</p><p><a href="https://blog.csdn.net/u011082453/article/details/82417259" target="_blank" rel="noopener">补充参考文章</a></p><a id="more"></a><h4 id="Storm流"><a href="#Storm流" class="headerlink" title="Storm流"></a>Storm流</h4><p>Storm中的核心抽象是流Stream。流是一种数据格式，是一个不间断的无界的连续多元组序列。Storm在建模事件流时，把流中的事件抽象为tuple即多元组。流通过schema定义，其中的字段以多元组形式出现，每个流都有一个ID。</p><p>Storm提供原语，以可靠的方式，将流转化为新的分布式流（比如将推文流转化为趋势话题流）。</p><p>Spouts和Bolts是两个基本的Storm原语</p><blockquote><p>流是一个没有边界的tuple序列，而这些tuples会被以一种分布式的方式并行创建和处理。 每个tuple可以包含多列，字段类型可以是： integer, long, short, byte, string, double, float, boolean和byte array。 还可以自定义类型 — 只要你实现对应的序列化器。</p></blockquote><h4 id="Spouts：消息生产者"><a href="#Spouts：消息生产者" class="headerlink" title="Spouts：消息生产者"></a>Spouts：消息生产者</h4><blockquote><p>Spouts是topology消息的生产者。Spout从一个外部源（如消息队列，Twitter API）读取多元组，并发送到topology中。 消息源Spouts可以是可靠的也可以是不可靠的。一个可靠的消息源可以重新发送一个处理失败的tuple， 一个不可靠的消息源Spouts不会。</p><p>Spout类的方法nextTuple不断发送把多元组发送到topology中，storm在检测到一个元祖被整个topology成功处理的时候调用ack, 否则调用fail。</p><p>Storm只对可靠的spout调用ack和fail。</p></blockquote><h4 id="Bolts：消息消费者"><a href="#Bolts：消息消费者" class="headerlink" title="Bolts：消息消费者"></a>Bolts：消息消费者</h4><p>一个Bolt可以消费任意数量的输入流，比如处理输入流、输出新的流等。复杂的转化可能需要多个Bolt。Bolt可以执行任何操作，包括执行函数、过滤多元组、聚合流、关联流、数据库通信等</p><blockquote><p>消息处理逻辑被封装在bolts里面，Bolts可以做很多事情： 过滤， 聚合， 查询数据库等。</p><p>Bolts可以简单的做消息流的传递。复杂的消息流处理往往需要很多步骤， 从而也就需要经过很多Bolts。第一级Bolt的输出可以作为下一级Bolt的输入。而Spout不能有下一级。</p><p>Bolts的主要方法是execute（死循环）连续处理传入的tuple，成功处理完每一个tuple调用OutputCollector的ack方法，以通知storm这个tuple被处理完成了。当处理失败时，可以调fail方法通知Spout端可以重新发送该tuple。</p></blockquote><h4 id="Storm-Topologies"><a href="#Storm-Topologies" class="headerlink" title="Storm Topologies"></a>Storm Topologies</h4><p>Storm topology网的节点由Spout和Bolt组成。它是流转化的图，topology中的边指示了bolt用于处理那些流。当spout或bolt将多元组发送到流上，它会下发到下一级指向的所有bolt。</p><p>下图是Storm集群的topology的顶级抽象。</p><p>topology中的每个节点都能并行执行，可以中心化配置并行数量（parallelism）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8l82hgsvj30e80a4t9q.jpg" alt="截屏2020-04-27 下午1.15.59" style="zoom: 50%;" /></p><p>Strom中运行的Topologies，相当于在MapReduce模型中运行的jobs。而Strom topology可以无限的处理数据。</p><blockquote><p>Storm将流中元素抽象为tuple，一个tuple就是一个值列表value list，list中的每个value可以是任意可序列化的类型。topology的每个节点都要说明它所发送出的多元组的字段的name，其他节点只需要订阅该name就可以接收处理。</p></blockquote><p>在Storm集群中用于运行topology的实体有3个：Worker processes、Executors（Threads）、Tasks</p><div class="table-container"><table><thead><tr><th>实体</th><th>描述</th></tr></thead><tbody><tr><td>Worker processes 工作进程</td><td>一个工作进程负责执行一个topology。Storm上的一台机器可以运行一个或多个工作进程。</td></tr><tr><td>Executors（Threads）处理器线程</td><td>处理器将作为线程运行。一个工作进程可以运行多个这样的处理器线程。每个处理器线程运行一个或多个相同组件的任务（spouts、bolts）</td></tr><tr><td>Tasks 任务</td><td>负责真正的数据处理工作</td></tr></tbody></table></div><p>在Storm集群中有2种类型的节点：主节点和工作节点</p><div class="table-container"><table><thead><tr><th>节点</th><th>描述</th></tr></thead><tbody><tr><td>主节点 Master</td><td>运行后台进程“Nimbus”，类似于Hadoop中的Job Tracker；Nimbus负责在集群上分发代码，而分配任务到机器上，以及监控故障</td></tr><tr><td>工作节点 Worker</td><td>每个工作节点运行一个后台进程“Supervisor”；Supervisor负责监听分配到自身机器上的任务，开启或关闭必要工作进程</td></tr></tbody></table></div><h4 id="Storm的结构"><a href="#Storm的结构" class="headerlink" title="Storm的结构"></a>Storm的结构</h4><p>Nimbus和Supervisor之间的协调通过 <strong>Apache Zookeeper cluster</strong>完成</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8mch3w61j30y20j60wy.jpg" alt="截屏2020-04-27 下午1.54.40"></p><h4 id="Apache-ZooKeeper"><a href="#Apache-ZooKeeper" class="headerlink" title="Apache ZooKeeper"></a>Apache ZooKeeper</h4><p>原本是一个Hadoop子项目。它是一个中心化的服务，针对分布式系统中的：分布式配置、服务同步、命名注册表。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8nehiv6bj30rk09amz9.jpg" alt="截屏2020-04-27 下午2.31.25" style="zoom: 50%;" /></p><p>ZooKeeper允许分布式的进程之间进行协作，通过共享的数据寄存器的分层命名空间（Znodes）实现。</p><p>ZooKeeper服务被复制到集群上的所有机器中。每个机器都维护，在内存上in-memory的<u>数据树</u>镜像，以及，持久化存储的事务日志和快照。</p><h4 id="Storm上的ZooKeeper"><a href="#Storm上的ZooKeeper" class="headerlink" title="Storm上的ZooKeeper"></a>Storm上的ZooKeeper</h4><p>Strom通过ZooKeeper集群实现Nimbus和Supervisors之间的协调。</p><p>ZooKeeper管理集群的状态（e.g. 消息acks，处理状态），使得Strom重启后也能恢复状态（关系到容错、可靠性）。</p><p>Nimbus和Surpervisors是<strong>快速衰退fail-fast</strong>和<strong>无状态stateless</strong>的，所有的状态都保存在ZooKeeper或本地磁盘上。</p><p>由于数据是在内存中处理的，因此ZooKeeper可以实现高吞吐和低延迟。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8nsz9aa4j30k60k0dia.jpg" alt="截屏2020-04-27 下午2.45.21" style="zoom:67%;" /></p><h4 id="Storm的数据模型（数据结构）"><a href="#Storm的数据模型（数据结构）" class="headerlink" title="Storm的数据模型（数据结构）"></a>Storm的数据模型（数据结构）</h4><p>Storm使用多元组作为数据模型（数据结构）。一个多元组是一个值列表。Storm支持<u>原始类型（基本数据类型）、字符串和二进制数组</u>作为多元组的字段类型。也可以通过序列化器实现自定义类型。topology中的节点还需要声明它发送的多元组的<strong>输出字段（output fields）</strong>。</p><blockquote><p>字段类型可以是： integer, long, short, byte, string, double, float, boolean和byte array。 还可以自定义类型 — 只要你实现对应的序列化器。</p><p>topology的每个节点都要说明它所发射出的多元组的字段的name，其他节点只需要订阅该name就可以接收处理。</p></blockquote><h4 id="Strom-Groupings-分组"><a href="#Strom-Groupings-分组" class="headerlink" title="Strom Groupings 分组"></a>Strom Groupings 分组</h4><p>它告诉topology应该如何将多元组发送到下一个任务</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8p73szlqj30g80dk77m.jpg" alt="截屏2020-04-27 下午3.33.32" style="zoom:50%;" /></p><div class="table-container"><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Shuffle groupings</td><td>发送多元组到随机任务上</td></tr><tr><td>Fields groupings</td><td>按照流的输出字段分组，相同输出字段的流会被发送到同一个任务上</td></tr><tr><td>Partial Key groupings</td><td>同样是按照字段分组，但会平衡两个bolts之间的负载</td></tr><tr><td>All groupings</td><td>将流复制到bolts的所有任务上</td></tr><tr><td>Global groupings</td><td>将整个流发送到最小ID值的一个bolt上</td></tr><tr><td>Direct groupings</td><td>允许多元组的生产者指定接收多元组的任务</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8pku8sbrj311o0d2dio.jpg" alt="截屏2020-04-27 下午3.46.43"></p><h4 id="Hadoop中的Storm"><a href="#Hadoop中的Storm" class="headerlink" title="Hadoop中的Storm"></a>Hadoop中的Storm</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8pllch4jj312o0oc77z.jpg" alt="截屏2020-04-27 下午3.47.28"></p><h4 id="流的可靠性"><a href="#流的可靠性" class="headerlink" title="流的可靠性"></a>流的可靠性</h4><p>Storm保证每个spout多元组都会被topology完全处理。Storm会追踪每个spout触发的元组树，并确认它什么时候能完全被处理完。每个拓扑都会有提供关联的<strong>消息超时message timeout</strong>（可配置）。如果一个spout元组没有在超时时间内完成处理，则storm会终止它，并在之后重新执行。</p><p>在bolt中，使用emit方法表示产生了一个新的多元组，使用ack方法声明该元组已经完成处理</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8prfy4gjj30i00dk0vj.jpg" alt="截屏2020-04-27 下午3.53.03" style="zoom:50%;" /></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge8q4zds44j312y0p6wjj.jpg" alt="截屏2020-04-27 下午4.06.02"></p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>unbounded sequence of tuples —— 无界的多元组序列<br>primitives —— 原语<br>hierarchical namespace of data registers —— 数据寄存器的分层命名空间<br>in-memory —— 内存上的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云经济</title>
      <link href="/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/15%20%E4%BA%91%E7%BB%8F%E6%B5%8E/"/>
      <url>/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/15%20%E4%BA%91%E7%BB%8F%E6%B5%8E/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="云计算的好处"><a href="#云计算的好处" class="headerlink" title="云计算的好处"></a>云计算的好处</h4><p>效率、可访问性、机遇、创新、灵活性、节省</p><h4 id="云计算的经济效益"><a href="#云计算的经济效益" class="headerlink" title="云计算的经济效益"></a>云计算的经济效益</h4><p>云计算最明显的经济利益是直接成本节省，这是由于IT基础架构所在的组织和数据中心内部的变化而产生的。</p><ul><li>供应方：大型数据中心由于具有强大的购买力而降低了成本</li><li>需求方：允许跨不同行业区域和时区的多个用户使用服务器</li><li>多用户效率：增加用户数量可降低每个租户的服务器成本</li><li>数据中心效率：先进的数据中心设计可减少功耗并改善散热</li></ul><h4 id="质量和价格的关系"><a href="#质量和价格的关系" class="headerlink" title="质量和价格的关系"></a>质量和价格的关系</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9zauphe6j30my0bwt9l.jpg" alt="截屏2020-05-29 下午9.28.21" style="zoom: 33%;" /></p><h4 id="云计算经济"><a href="#云计算经济" class="headerlink" title="云计算经济"></a>云计算经济</h4><p>云计算提供了强大的计算机功能，无限的存储，以及多样性的服务和程序</p><p>但我们需要考虑：谁可以使用它？费用是多少？有什么保证？</p><h4 id="商用云"><a href="#商用云" class="headerlink" title="商用云"></a>商用云</h4><p>所提供服务的特点：可靠，按需使用</p><p>用户必须期望以某种方式购买这些服务</p><p>云提供商将需要具有用于提供这些服务的支付机制</p><p>整合收费服务：</p><ul><li>服务供应的新模型，例如已启用的【实用计算utility computing】</li><li>开发基础架构以实现云服务交易</li><li>为交易资源实现的经济模型（例如拍卖，商品市场）</li></ul><h4 id="实现“计算机实用程序”的愿景：消费者和提供者想要什么？"><a href="#实现“计算机实用程序”的愿景：消费者和提供者想要什么？" class="headerlink" title="实现“计算机实用程序”的愿景：消费者和提供者想要什么？"></a>实现“计算机实用程序”的愿景：消费者和提供者想要什么？</h4><p>云服务消费者希望：最小化支出，满足QoS。考虑：</p><ul><li>我该如何表达QoS需求，以满足我的目标？</li><li>我该如何发现服务并映射应用程序，以满足QoS需求？</li><li>我该如何管理多个提供商并完成工作？</li></ul><p>云提供商希望：最大化收益，吸引客户</p><ul><li>我该如何分配和执行资源分配？</li><li>我该如何做广告和吸引消费者？</li><li>我该如何确定服务定价模式？</li><li>我该如何指定价格？</li><li>我该如何将价格转换成资源分配？</li><li>我该如何执行会计核算？</li></ul><h4 id="支付云服务"><a href="#支付云服务" class="headerlink" title="支付云服务"></a>支付云服务</h4><ul><li>应用领域</li><li>软件库</li><li>计算资源</li><li>磁盘存储</li><li>网络链接</li><li>可视化</li><li>电源</li></ul><h4 id="商业模型"><a href="#商业模型" class="headerlink" title="商业模型"></a>商业模型</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9zlyaft7j30za0liand.jpg" alt="截屏2020-05-29 下午9.39.38" style="zoom:67%;" /></p><h4 id="计费模型"><a href="#计费模型" class="headerlink" title="计费模型"></a>计费模型</h4><p>按需 On-demand</p><ul><li>使最终用户可以按小时支付服务费</li><li>价格根据实例类型设置。</li><li>这些类型的实例没有长期承诺</li></ul><p>预付 Prepaid</p><ul><li>客户在特定时间内预先支付固定价格</li><li>客户可以为长期承诺支付较低的价格</li></ul><p>拍卖 Auctioned</p><ul><li>模型基于供求关系</li><li>使客户能够竞标云服务</li><li>云提供商有权接受或拒绝该提议</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9zrjwms4j31360pkag0.jpg" alt="截屏2020-05-29 下午9.45.04"></p><h4 id="Amazon-EC2-Spot-实例"><a href="#Amazon-EC2-Spot-实例" class="headerlink" title="Amazon EC2 Spot 实例"></a>Amazon EC2 Spot 实例</h4><p><a href="http://aws.amazon.com/ec2/purchasing-options/spot-instances/" target="_blank" rel="noopener">链接</a></p><p>允许用户为Amazon EC2计算能力定制自己的价格</p><p>用户对备用Amazon EC2实例进行出价，并在出价超出当前现货价格时运行它们，该实时价格根据供需而实时变化。</p><p>在运行时间灵活，容忍中断的任务上，【Spot】实例可以显著的降低计算成本。</p><p>【Spot】实例是空闲的 Amazon EC2 实例</p><p>【Spot】的价格由Amazon EC2设置，Amazon EC2根据【Spot】实例的供求情况实时波动</p><p>当出价超过【Spot】的价格：</p><ul><li>启动Spot实例</li><li>该实例将一直运行，直到【Spot】价格超过出价（Spot中断）或用户选择终止它们为止</li></ul><p>用户要求指定：</p><ul><li>􏰀实例类型</li><li>所需的可用区 Availability Zone</li><li>所需的Spot实例数量</li><li>􏰀用户愿意为每个实例小时支付的最高价格（出价）</li></ul><p>要确定最高价格与过去的Spot价格的比较方式，可以通过Amazon EC2 API和AWS管理控制台获得过去90天的Spot价格历史记录。<em>**</em></p><h4 id="成本机制：能源消耗案例"><a href="#成本机制：能源消耗案例" class="headerlink" title="成本机制：能源消耗案例"></a>成本机制：能源消耗案例</h4><p><strong>问题定位</strong></p><p>能源消耗被云基础架构提供商视为最大的运营成本因素之一。</p><p>成本机制的局限性是，供应商会根据针对资源使用的预定费率及时向客户收取费用。 </p><p>考虑到可变的能源成本，这些预定义的电价仍然不够精确。</p><p><strong>动机</strong></p><p>需要对成本建模，模型考虑能耗，使得云提供商可以制定增强的成本决策并有效管理其资源。</p><ul><li>对<u>云服务成本</u>进行建模，可以帮助服务提供商提供满足其客户需求的合适服务。</li></ul><p><strong>目标</strong></p><p>提出一个新的【基于能源的成本模型】，该模型通过考虑<u><strong>异构虚拟机的资源使用和功耗</strong></u>来衡量其实际成本。</p><h4 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h4><p>分层􏰊：改编自参考架构</p><p>重点是<u>发生服务操作</u>的IaaS层</p><p>【Cost Modeller】是我们感兴趣的主要组件</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfa0etgcfjj30l20gmn05.jpg" alt="截屏2020-05-29 下午10.07.26" style="zoom: 67%;" /></p><h4 id="基于能源的成本模型"><a href="#基于能源的成本模型" class="headerlink" title="基于能源的成本模型"></a>基于能源的成本模型</h4><ol><li><p>第一步【实际资源使用量】：VM的工作量和PM的功耗通过监视系统进行测量。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfa0mqvjgsj30y40gk11c.jpg" alt="截屏2020-05-29 下午10.15.01"></p></li><li><p>【功耗估算】：将PM功耗归因于新请求的VM和PM上已在运行的VM。 使用以下公式：</p><ul><li><script type="math/tex; mode=display">当前虚拟机的空闲功率 = 当前物理机的空闲功率 * (\frac{当前虚拟机请求的虚拟CPU数量}{所有虚拟机请求的虚拟CPU数量之和})</script></li><li><script type="math/tex; mode=display">当前虚拟机的活动功率 = (当前物理机的功率-当前物理机的空闲功率) * (\frac{当前虚拟机请求的虚拟CPU数量*当前虚拟机的虚拟CPU使用量}{\sum 各个虚拟机请求的虚拟CPU数量*各个虚拟机的虚拟CPU使用量})</script></li><li><script type="math/tex; mode=display">当前虚拟机能耗=\frac{当前虚拟机功率}{1000}*\frac{时间}{3600}</script></li></ul></li><li><p>【成本估算】：根据步骤1的实际资源使用量和步骤2的功耗估算VM的总成本</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfa19kojw7j30rs0by76c.jpg" alt="截屏2020-05-29 下午10.37.00" style="zoom:50%;" /></p><p>（注：<script type="math/tex">VM_{xReqvCPUs}=当前虚拟机请求虚拟CPU数量</script>）</p></li></ol><h4 id="迁移成本模型——迁移成本问题"><a href="#迁移成本模型——迁移成本问题" class="headerlink" title="迁移成本模型——迁移成本问题"></a>迁移成本模型——迁移成本问题</h4><p>何时迁移：</p><ul><li>Host overload detection algorithms</li><li>Host underload detection algorithms</li></ul><p>迁移哪个：</p><ul><li>VM selection algorithms</li></ul><p>迁移到哪：</p><ul><li>VM placement algorithms</li></ul><h5 id="虚拟机迁移成本考虑：内存、网络、存储"><a href="#虚拟机迁移成本考虑：内存、网络、存储" class="headerlink" title="虚拟机迁移成本考虑：内存、网络、存储"></a>虚拟机迁移成本考虑：内存、网络、存储</h5><ul><li>􏰀VM的副本意味着应将原始VM的完整状态转移到副本，包括内存，磁盘和网络连接</li><li>􏰀内存状态迁移方法：将内存状态复制到目标，然后将其处理器状态传输到目标（反之亦然）</li><li>􏰀网络迁移方法：迁移后保持网络连通性，有必要保留开放连接</li><li>􏰀磁盘状态迁移：迁移磁盘状态通常代表整个迁移时间的最大组成部分</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云服务的软件质量挑战</title>
      <link href="/2020/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E6%8C%91%E6%88%98/"/>
      <url>/2020/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E6%8C%91%E6%88%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>关于软件质量的挑战，它关注的重点是改进服务（软件）的质量，提高用户对产品的可接受性。解决方案可以从以下几方面进行创新（大约28%的项目选择了前2个方案，33%的项目选择了第三个方案）：</p><ul><li>协作驱动的需求启发和分析 collaboration-driven requirements elicitation and analysis</li><li>软件验证方法 software validation and verification methods</li><li><p>为软件设计适合的工具和框架 —— 它涉及价值链上的所有参与者，从开发者到产品经理再到用户</p></li><li><p>当前正在研究一种新的标准，该标准旨在提高基于云的服务的可信性、透明性和互操作性，并引入一种能够<u>让输出进行进行自我/联合认证</u>的方法来实现该标准。</p></li></ul><ul><li>另外还需要新方法来指导软件质量发展，这些方法通过以下几个方法，帮助开发易用的、高质量的软件：<ol><li>推动应用程序开发的早期设计阶段，</li><li>提供适当的质量工程工具</li><li>学习优秀开源产品，遵循其中的最佳实践，包括开发，管理，许可，测试，标准</li></ol></li></ul><h4 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h4><p>在需求工程(requirement enginneering)中，通过利用大量在线用户反馈（e.g. 在论坛，应用市场，社交网络上的评分、评价），软件质量也可能得到显着提高。这能让用户参与到软件发展的过程中，帮助改进软件质量。但这需要专门的方法和工具来收集用户反馈，来帮助分析人员，系统架构师，开发人员和项目经理进行决策。方法和工具需要具有以下特点：</p><ol><li>可扩展性</li><li>自动分析用户反馈和上下文数据</li></ol><p>该方向的进一步挑战是，对匿名、隐私保护的用户活动数据进行采集，这不仅能涉及用户与软件的交互，还有助于开发商了解用户的使用环境，该采集功能需要集成到软件中（即软件开发过程）</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>G. Casale, C. Chesta, P. Deussen, E. Di Nitto, P. Gouvas, S. Koussouris, V. Stankovski, A. Symeonidis, V. Vlassiou, A. Zafeiropoulos, et al. Current and future challenges of software engineering for services and applications. Procedia Computer Science, 97:34–42, 2016.</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件质量 </tag>
            
            <tag> 云 </tag>
            
            <tag> 需求工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image Caption Generation 相关问题</title>
      <link href="/2020/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%AD%97%E5%B9%95%E7%94%9F%E6%88%90Image-Caption-Generation/"/>
      <url>/2020/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%AD%97%E5%B9%95%E7%94%9F%E6%88%90Image-Caption-Generation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://towardsdatascience.com/image-captioning-with-keras-teaching-computers-to-describe-pictures-c88a46a311b8" target="_blank" rel="noopener">参考文章</a></p><a id="more"></a><h3 id="Encoder-Decoder模型"><a href="#Encoder-Decoder模型" class="headerlink" title="Encoder-Decoder模型"></a>Encoder-Decoder模型</h3><p>图片字幕生成的细节：</p><ul><li><p>模型使用的词典不在乎单词的顺序问题</p></li><li><p>这是一个监督学习问题</p><ul><li><p>通过输入的Xi，预测输出的Yi</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdus9eyca0j311q0h8n0h.jpg" alt="截屏2020-04-15 下午2.33.57"></p></li><li><p>也即是给定图片向量，每次预测基于当前的部分字幕，生成下一个单词</p><ul><li>输入：图片向量和当前的部分字幕（以词典中的索引表示）<ul><li>将字幕转化为输入，涉及到词嵌入技术（the word embedding techniques），比如 GLOVE词嵌入模型，将每个单词都匹配为长度200（自定义）的向量</li><li>也可以单纯的只使用词典本身作为向量（在词典中存在为1，不存在为0）</li></ul></li><li>预测输出：下一个单词</li></ul></li></ul></li></ul><hr><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="Q1-What-the-advantages-disadvantages-might-be-of-using-lemmatized-vs-regular-tokens"><a href="#Q1-What-the-advantages-disadvantages-might-be-of-using-lemmatized-vs-regular-tokens" class="headerlink" title="Q1. What the advantages/disadvantages might be of using lemmatized vs regular tokens."></a><strong>Q1. What the advantages/disadvantages might be of using lemmatized vs regular tokens.</strong></h4><p>Tokenization is the process of splitting any string into words. It is an essential approach for data preparation relevant to field of language processing. In this process, there are lots of methods can be applied thus lead to different type of tokens such as lemmatized tokens and regular tokens. Lemmatization usually refers to transforming words from inflected, singular forms etc. to the base form, known as the lemma, which is an actual word in a dictionary. For example, <em>am</em>, <em>is</em>, <em>are</em> will be converted to <em>be</em>, and <em>runs</em>, <em>ran</em>, <em>running</em>, will be of <em>run</em>. During Lemmatization process, the transformation of a specific word relies on the current context, such as identifying whether the word <em>saw</em> is a noun or a verb.</p><p>The regular tokens are generated from simple process such as tokenization, removing punctuation, converting words into lowercase while lemmatized tokens have one more process which is Lemmatization. The mainly different is whether the token word is remaining same or converted to a base form.</p><p>There are many advantages of using lemmatized tokens. One of the most widely known advantages is it can give a better result by removing the inflectional endings only and therefore can properly represents a group of related words with same token. For example, in this Image Caption Generation task, where the data is not big enough, lemmatized tokens can represent the highly discrete words more aggregated. The inflected words with same meaning will be grouped and hence will not affect the weight differently in the network. From another perspective, it is equivalent to increasing the amount of data. As a result, the generated caption might be more accurate. However, it comes with the costs. Lemmatization uses a corpus to transform the words and takes the context of original text into account, which means more computing and storage consumption. On the other words, it will slow down the processing speed and use more memory.</p><p>On the other hand, the advantages and disadvantages of regular tokens are opposite to lemmatized tokens. As its simplicity, it is suitable for the tasks with constraints on time and memory. What’s more, English is not an inflection-rich language (comparing with Spanish and Arabic) thus not that much influence if using regular tokens. But the results may inevitably worse than using lemmatized tokens.</p><p>In conclusion, using lemmatized tokens is usually a better option, but still coms with its drawback. In some circumstances, the regular tokens might be more suitable. As a result, people should depend on the use case to choose a proper approach. </p><h4 id="Q2-Present-the-sample-images-and-generated-caption-for-each-epoch-of-training-for-both-the-RNN-and-LSTM-version-of-the-decoder-including-the-BLEU-scores"><a href="#Q2-Present-the-sample-images-and-generated-caption-for-each-epoch-of-training-for-both-the-RNN-and-LSTM-version-of-the-decoder-including-the-BLEU-scores" class="headerlink" title="Q2. Present the sample images and generated caption for each epoch of training for both the RNN and LSTM version of the decoder, including the BLEU scores."></a><strong>Q2. Present the sample images and generated caption for each epoch of training for both the RNN and LSTM version of the decoder, including the BLEU scores.</strong></h4><p>In this task, the report chooses the same two images for observing the generated caption for RNN and LSTM. Table 1 is listing the parameters which remain the same in the sampling process, including the image, the reference captions used for computing BLEU score, and the weights of BLEU for each gram. Table 2-6 are comparing the generated caption and the corresponding BLEU cumulative score between LSTM and RNN at each epoch. Noticed that the tokens <start> and <end> has been removed from generated caption.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdx7qbb7ghj30rs0k6gt9.jpg" alt="截屏2020-04-17 下午5.07.53"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdx7qm6t9xj30s408sacl.jpg" alt="截屏2020-04-17 下午5.08.08"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdx7rl8hmhj30p808e0xv.jpg" alt="截屏2020-04-17 下午5.09.09"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdx7rxx5xuj30rq0qkn56.jpg" alt="截屏2020-04-17 下午5.09.27"></p><h4 id="Q3-Compare-training-using-an-RNN-vs-LSTM-for-the-decoder-network"><a href="#Q3-Compare-training-using-an-RNN-vs-LSTM-for-the-decoder-network" class="headerlink" title="Q3. Compare training using an RNN vs LSTM for the decoder network."></a><strong>Q3. Compare training using an RNN vs LSTM for the decoder network.</strong></h4><p>In this coursework, we are the using encoder-decoder model for image caption generation. For both RNN decoder or LSTM decoder, they are all using the same encoder with CNN, which is responsible for extracting and compressing the contents of images into small feature vectors. And the variable that might affect the generated captions is controlled between RNN and LSTM in the decoder. The comparison will start by comparing the structure and then move to the results of the CW code, including the overall loss and BLEU score, the difference for training with long or short captions and quality of generated captions.</p><p>From the structural level, the recurrent neural network (RNN) is a feedforward neural network that has internal memory and is recurrent in nature. The traditional convolutional neural network (CNN) in which the data stream is flowing from layer to layer has no connections between neurons (or nodes) inside the layer, causing current neuron lacks memory for the previous neurons. While RNN, on the contrary, has connections between neurons inside the hidden layers. The inputs of a current neuron include the outputs of the last layer and the previous neuron in the current layer. As a result, RNN is suitable for sequence-related tasks such as speech recognition, natural language processing, etc. </p><p>Long short-term memory network (LSTM) is a variant of RNN, belonging to feedback neural network. It is aiming to deal with the problems of gradient vanish that traditional RNN encountered during training, which means losing information in a long-distance propagation. LSTM has a similar structure as RNN in general but more complex in details. Comparing with RNN, a common LSTM has an additional parameter to keep the memory of previous data over arbitrary time intervals, called cell state, which is the core of LSTM. To regulate the information over the cell, there are three gates named forget gate, input gate and output gate. The forget gate decides which information will be removed from the last cell state. The input gate is deciding what information should be added to the current cell state. Concatenate these two steps with the last cell state, it can update the current cell state. Then, the output gate determines which information will be outputted based on above, and finally get the output. This structure helps LSTM to address the vanishing gradient problem, and accordingly, have better performance than traditional RNN in terms of longer time series tasks</p><p>To evaluate and compare models, the first criteria is observing the loss value on both the straining step and test step. Figure 1 illustrates the trends of loss for LSTM and RNN, including the loss values for every batch and the average loss values at each epoch. But the difference between them is hard to find. From table 7, which is showing the average loss in number, it can still be noticed that the loss of LSTM is slightly bigger than that of RNN at the first epoch and becomes slightly smaller at the final epoch.</p><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye45gbrj30h00cw0tx.jpg" alt="地图的截图  描述已自动生成"></th><th style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye5z19zj30hb0crmyc.jpg" alt="手机屏幕截图  描述已自动生成"></th></tr></thead><tbody><tr><td style="text-align:center">(1)    LSTM</td><td style="text-align:center">(2)    RNN</td></tr></tbody></table></div><p> Figure 1: Loss per batch and  average loss per epoch during training for LSTM (1)  and RNN (2).  </p><p>Table 7: Average loss for LSTM and RNN on training set at each epoch.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduylad30jj310y0900ts.jpg" alt="截屏2020-04-15 下午6.20.37"> </p><p>After finish training the model, we can evaluate the model using the test set. Here we compare the loss of model on the test set between LSTM and RNN, as well as the differences of BLEU score. In Table 8, the loss of model with LSTM decoder is also lower than that with RNN decoder. Figure 2 is illustrating the cumulative BLEU scores from 1-gram to 4-gram, which can describe the overall performance of generated captions in the perspective of words. The areas under the line are representing the percentage of captions with different scores, where blue lines stand for LSTM and orange lines stand for RNN. From the distribution of the area under the lines, we might find that the area of RNN is prone to the left than the area of LSTM, indicating a lower score. The vertical dash lines in the figures that point out the average score over the whole test set (figure 2, where the actual values are shown in table 9) prove this again. On the other hand, we have to notice that LSTM are more likely to get scores very close to zero.</p><p>Table 8: Loss for LSTM and RNN on test set</p><div class="table-container"><table><thead><tr><th></th><th>LSTM</th><th>RNN</th></tr></thead><tbody><tr><td>Test set</td><td>2.603</td><td>2.725</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye539qzj30z80b341c.jpg" alt="图片包含 游戏机, 设备  描述已自动生成"></p><p>Figure 2: All of Cumulative BLEU scores and the average of scores on test set for LSTM and RNN, score from 0 to 1 separated into 30 bins.</p><p> Table 9: Average cumulative BLEU score for LSTM and RNN on test set.</p><div class="table-container"><table><thead><tr><th></th><th>LSTM</th><th>RNN</th></tr></thead><tbody><tr><td>1-gram</td><td>0.550</td><td>0.494</td></tr><tr><td>2-gram</td><td>0.461</td><td>0.416</td></tr><tr><td>3-gram</td><td>0.452</td><td>0.417</td></tr><tr><td>4-gram</td><td>0.467</td><td>0.442</td></tr></tbody></table></div><p>Table 10 is comparing the results between images with the longest reference captions and shortest captions on average in the test set. For the image with the longest reference captions, although the 1-gram BLEU score for LSTM is slightly lower than that for RNN, the other three type of cumulative BLEU scores, from 2-gram to 4-gram, are all higher. And for the image with the shortest one, all of the BLEU scores when using LSTM to train the decoder are higher than using RNN. However, if we compare the generated captions in a human perspective, it is obvious that all of them are misdescribing the corresponding images at the same point thus do not show much difference for people.  Table 11 is showing three randomly chosen samples, giving clues that the performance of LSTM and RNN are unstable and not always giving similar scores.</p><p>We compare the loss of LSTM decoder and RNN decoder, during the training epoch on the training set and after finish training on the test set, as well as the cumulative BLEU scores on the generated captions, on average and on both the longest and the shortest reference captions. In conclusion, the difference between Loss and BLEU score in overall may indicate that LSTM may have a better performance than RNN. But with human perception, it is hard to judge which is better. And the LSTM does not show its advantages in dealing with long captions. However, this insight may not obvious and convincing enough in this case as the training set, length of the captions and training epochs seem quite constrained.</p><p>Table 10: Comparing the images with long (left) or short (right) reference captions on average in test set.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduyncvc1mj30u00vu454.jpg" alt="截屏2020-04-15 下午6.21.38"> </p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdx7svcdz8j30ru13u4by.jpg" alt="截屏2020-04-17 下午5.10.09"></p><h4 id="Q4-Among-the-text-annotations-files-downloaded-with-the-Flickr8k-dataset-are-two-files-we-did-not-use-ExpertAnnotations-txt-and-CrowdFlowerAnnotations-txt-Read-the-readme-txt-to-understand-their-contents-then-consider-and-discuss-how-these-might-be-incorporated-into-evaluating-your-models"><a href="#Q4-Among-the-text-annotations-files-downloaded-with-the-Flickr8k-dataset-are-two-files-we-did-not-use-ExpertAnnotations-txt-and-CrowdFlowerAnnotations-txt-Read-the-readme-txt-to-understand-their-contents-then-consider-and-discuss-how-these-might-be-incorporated-into-evaluating-your-models" class="headerlink" title="Q4. Among the text annotations files downloaded with the Flickr8k dataset are two files we did not use: ExpertAnnotations.txt and CrowdFlowerAnnotations.txt. Read the readme.txt to understand their contents, then consider and discuss how these might be incorporated into evaluating your models."></a><strong>Q4. Among the text annotations files downloaded with the Flickr8k dataset are two files we did not use: ExpertAnnotations.txt and CrowdFlowerAnnotations.txt. Read the readme.txt to understand their contents, then consider and discuss how these might be incorporated into evaluating your models.</strong></h4><p>The file ExpertAnnotations.txt contains a set of image-captions pairs with a score that rated by experts from 1 (the caption does not describe the image at all) to 4 (the caption describes the image correctly). The file CrowdFlowerAnnotations.txt contains a collection of image-captions pairs with the judgement, by asking human whether the caption describes the image or not. Both of them giving additional non-correct captions for images compared with the file Flickr8k.token.txt, while the Crowd Flower Annotations use a binary judgement and the Expert Annotations provides a finer-grained score.</p><p>One of the limitations within the encoder-decoder model is that the only connection between the encoder and decoder is a fixed-length feature vector which represents the images with an uncertain number of objects. The feature vector may not represent all of the information of the input image so that the accuracy of the decoder will hence be affected.</p><p>On the other hand, the domain of image caption generation is related to the supervised learning using an algorithm to find out the optimal solution for generating appropriate caption of a specific image based on a collection of caption-image pairs. It is similar to image classification but far more complex as there are more objects. Hodosh et al. (2013) [1] shows that using multiple captions for an image gives better results than using a single caption. Extending from this, we suppose that if the model has additional data about not only what is correct but also what could be wrong, it might be possible to improve the model and achieve better results.</p><p>For example, when converting the words to the vector at the decoder step, we can introduce finer-grain weights with non-correct caption instead of binary values based on the two additional files. Or use it to improve the performance of the word embedding functions.</p><p>Reference:</p><p>[1] M. Hodosh, P. Young, and J. Hockenmaier. Framing image description as a ranking task: Data, models and evaluation metrics. J. Artif. Int. Res., 47(1):853–899, May 2013.</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Image Caption </tag>
            
            <tag> RNN </tag>
            
            <tag> encoder-decoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算中的安全性</title>
      <link href="/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/16%20%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/16%20%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><p>互联网最初的设计并没有太多的考虑安全问题。最初的观点是：“通过互联网联系在一起的相互信任的用户”，而互联网协议的设计者在其中充当佐料的角色。</p><p>网络安全领域包括黑客如何攻击电脑网络，我们如何对这些攻击进行防御，以及如何设计能够免疫攻击的结构。</p><p>在每一层中都应该考虑安全性问题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfan40et11j30xo0m6n32.jpg" alt="截屏2020-05-30 上午11.12.46" style="zoom:33%;" /></p><h4 id="什么是网络安全"><a href="#什么是网络安全" class="headerlink" title="什么是网络安全"></a>什么是网络安全</h4><p>机密性：只有发送方和接受方才能理解消息内容</p><ul><li>发送者加密消息</li><li>接受者解密消息</li></ul><p>身份验证：发送方，接收方要确认彼此的身份</p><p>消息完整性：发送者，接收者希望在无需检测的情况下，保证消息不被篡改（传输中或传输后）</p><p>访问和可用性：服务必须可访问并且对用户可用</p><h4 id="网络安全相关"><a href="#网络安全相关" class="headerlink" title="网络安全相关"></a>网络安全相关</h4><p>基本技术</p><ul><li>密码学</li><li>消息完整性</li><li>身份验证</li></ul><p>不同的安全场景</p><ul><li>保护电子邮件</li><li>保护TCP连接：安全套接字层（SSL）</li><li>网络层安全：IP安全协议（IPsec）</li><li>保护无线局域网</li></ul><p>操作安全性</p><ul><li>防火墙</li><li>入侵检测系统（IDS）</li></ul><p>（See Chapter 8 – Security in Computer Networks. Computer Networking: A Top-Down Approach, Jim Kurose and Keith Ross, 7th edition, Addison-Wesley, 2017）</p><h4 id="与云计算相关的问题的原因"><a href="#与云计算相关的问题的原因" class="headerlink" title="与云计算相关的问题的原因"></a>与云计算相关的问题的原因</h4><p>大多数安全问题源于：</p><ul><li>失去控制</li><li>缺乏信任（机制）</li><li>多重租赁</li></ul><p>上述问题主要存在于第三方管理模型中</p><p><a href="https://cloudsecurityalliance.org/" target="_blank" rel="noopener">云安全联盟</a>：促进最佳实践的使用，以在云计算中提供安全保证，并提供有关云计算使用的教育，以帮助保护所有其他形式的计算。</p><h4 id="在云端失去控制能力"><a href="#在云端失去控制能力" class="headerlink" title="在云端失去控制能力"></a>在云端失去控制能力</h4><p>消费者失去控制能力，例如：</p><ul><li>数据，应用程序，资源位于云供应商处</li><li>用户身份管理由云供应商处理</li><li><u>用户访问控制规则、安全策略和实施</u>由云供应商管理</li><li>消费者依靠云供应商来确保<ul><li>数据安全和隐私</li><li>资源可用性</li><li>服务/资源的监控和修复</li></ul></li></ul><h4 id="云端的信任缺乏"><a href="#云端的信任缺乏" class="headerlink" title="云端的信任缺乏"></a>云端的信任缺乏</h4><p>信任和风险</p><ul><li>信任第三方需要冒险</li><li>同一枚硬币的相反面</li><li>人们只有在付款时才会信任（经济学家的观点）</li><li>只有在危险的情况下才会产生信任的需要</li></ul><p>在云端：</p><ul><li>难以平衡信任和风险</li><li>信任主要是指缺乏问责制和可验证性</li></ul><h4 id="云端的多重租赁问题"><a href="#云端的多重租赁问题" class="headerlink" title="云端的多重租赁问题"></a>云端的多重租赁问题</h4><p>租客的相反目标之间的冲突</p><ul><li>租户们共享资源池，并有相反的目标</li></ul><p>【多重租赁】如何处理利益冲突？ </p><ul><li>租客可以在一起生活并“玩得开心”吗？ </li><li>如果不能，我们可以隔离它们吗？</li></ul><p>如何区分租客？</p><p>云计算带来新威胁</p><ul><li>多个独立用户共享同一物理基础设施</li><li>因此，攻击者可以合法地与目标位于同一台物理计算机中</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfao2x55ctj30e407m79e.jpg" alt="截屏2020-05-30 上午11.46.23" style="zoom: 50%;" /></p><h4 id="根据所担心的进行分类：C-onfidentiality-I-ntegrity-A-vailability"><a href="#根据所担心的进行分类：C-onfidentiality-I-ntegrity-A-vailability" class="headerlink" title="根据所担心的进行分类：C(onfidentiality) I(ntegrity) A(vailability)"></a>根据所担心的进行分类：C(onfidentiality) I(ntegrity) A(vailability)</h4><p>机密性：</p><ul><li>害怕失去对数据的控制<ul><li>存储在云中的敏感数据是否能保密？ </li><li>云是否会导致<u>机密客户数据</u>泄漏？</li></ul></li><li>云提供商本身是否诚实并且不会偷看数据？</li></ul><p>完整性</p><ul><li>我怎么知道云提供商在正确地进行计算？</li><li>如何确保云提供商确实存储了我的数据，而没有对其进行篡改？</li></ul><p>可用性：</p><ul><li>云规模是否足够好？</li><li>如果提供商遭到【拒绝服务攻击】，关键系统是否会在客户端崩溃？</li><li>如果云提供商倒闭会怎样？</li></ul><h5 id="续"><a href="#续" class="headerlink" title="续."></a>续.</h5><p>通过海量数据挖掘引发的隐私问题</p><ul><li>云现在存储来自许多客户端的数据，并且可以运行数据挖掘算法以获取有关客户端的大量信息</li></ul><p>暴露的攻击面增加：</p><ul><li>组织外部的实体（混合云）现在可以存储和计算数据</li><li>攻击者现在可以锁定云提供商与客户端之间的通信链接</li></ul><p>数据审计和取证（数据无法控制）</p><ul><li>难以审核<u>在组织外部</u>存储的云中的数据（储存在公有云中）</li><li>由于客户不在本地维护数据，取证也很困难</li></ul><p>法律和传递信任问题</p><ul><li>谁负责遵守规定？</li><li>如果云提供商将分包给第三方云，数据是否仍然安全？</li></ul><h4 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h4><p>威胁模型有助于分析安全问题，设计缓解策略并评估解决方案<br>步骤：</p><ul><li>识别攻击者，资产，威胁和其他组件</li><li>对威胁进行排名</li><li>选择缓解策略</li><li>根据策略构建解决方案</li></ul><h4 id="云计算中的安全和隐私问题"><a href="#云计算中的安全和隐私问题" class="headerlink" title="云计算中的安全和隐私问题"></a>云计算中的安全和隐私问题</h4><ul><li>基础设施安全：<ul><li>网络、主机、中间件层</li></ul></li><li>数据安全和存储：<ul><li>个人信息应作为组织使用的数据的一部分进行管理</li><li>个人信息保护应考虑云对每个阶段的影响</li></ul></li><li>身份识别和访问管理（IAM）<ul><li>组织的信任边界将变得动态，并将扩展到云提供商的领域。</li><li>对身份验证的需求增加<ul><li>个人，财务，医疗数据将托管在云中？ </li><li>托管在云中的S / W应用程序需要访问控制</li></ul></li><li>需要更高安全性的身份验证<ul><li>密码身份验证的限制</li></ul></li><li>其他，例如，需要来自移动设备的身份验证</li></ul></li><li>隐私<ul><li>隐私的概念在国家，文化和司法管辖区之间（有时在内部）差异很大。</li><li>隐私受到公众期望和法律解释的影响； 因此，即使有简洁的定义也难以表述</li><li>隐私或义务与个人数据（或个人身份信息，PII）的<u>收集，使用，披露，存储和破坏</u>有关。</li><li>隐私是关于组织对数据主体的责任，以及组织对个人信息的实践的透明度。</li></ul></li></ul><h5 id="数据安全和存储：数据生命周期"><a href="#数据安全和存储：数据生命周期" class="headerlink" title="数据安全和存储：数据生命周期"></a>数据安全和存储：数据生命周期</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfaom10i9vj30yw0kq488.jpg" alt="截屏2020-05-30 下午12.04.22" style="zoom: 33%;" /></p><p>数据沿袭：了解数据在云中的位置和时间对于审核/合规性很重要</p><p>存在许多用于保护云环境中的数据集和软件的解决方案，比如【加密Encryption】、【水印 Watermarking】、【着色Colouring】</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件度量工具的使用和比较：SonarQube、JDEPEND、</title>
      <link href="/2020/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AF%B9%E6%AF%94/"/>
      <url>/2020/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>软件度量是对程序本身进行数值化表示的一种方法，比如方法复杂度，代码行数，包数目等。目的是帮助开发者和管理者发现软件可能存在的缺陷、技术债务积累、代码气味等问题。</p><p><a href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis" target="_blank" rel="noopener">静态代码分析工具列表</a></p><a id="more"></a><h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><p>MacOS Catalina 10.15.4</p><p>Win10（虚拟机）</p><p>IntelliJ IDEA 2019.3</p><h3 id="SonarQube-8-2"><a href="#SonarQube-8-2" class="headerlink" title="SonarQube 8.2"></a>SonarQube 8.2</h3><p>提供多种安装方式，这里安装在本机：</p><p>下载压缩包并解压到对应目录后，使用命令行启动服务器，并访问<a href="http://localhost:9000/" target="_blank" rel="noopener">http://localhost:9000</a>即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../sonarqube/bin/[OS]/sonar.sh console</span><br></pre></td></tr></table></figure><p>SonarQube提供的度量方法，帮助用户了解自己是否满足代码质量的标准，好的代码质量能够减少许多代码问题和技术债务的积累。确保新写的代码是干净的，从不同的层面进行分析。</p><p>在GUI中，有相关的引导，能够轻易的将SonarQube引入项目中：基本原理是在GUI页面中为项目生成一个特定的Token，在Maven或Gradle项目的配置文件中添加SonarQube插件，最后执行提供的命令即可，命令中包含了之前生成的项目令牌。</p><p>在Measure栏，SonarQube中提供了许多实用的度量方法，包括：</p><ul><li>可靠性：Bugs、分级、补救措施</li><li>安全性：易损性、分级、补救措施</li><li>安全性审查：安全性热点、分级</li><li>可维护性（对会增加更新难度的代码进行标记）：代码气味、债务（时间）、债务比例、分级、达到A级的措施</li><li>覆盖率：覆盖率、需覆盖行、未覆盖行、已覆盖率<ul><li>单元测试数量、错误、故障、跳过、成功、执行时间</li></ul></li><li>重复率：密度、重复行、重复块、重复文件</li><li>大小（数量）：代码行、总行数、声明、函数、类、文件、注释行、注释行占比</li><li>复杂度：循环复杂度（全覆盖测试的最少测试用例）、感知复杂度（理解程序的困难程度）</li><li>问题：开放问题、重开问题、确认问题、False Positive问题，保留问题</li></ul><p>在Issues栏，SonarQube还能分析代码，检测出违反开发规范的代码，并给与提醒</p><p>在Activity栏，可以展示软件度量的变化趋势，主要包括：</p><ul><li>问题：Bugs、代码气味、易损性</li><li>覆盖率：需覆盖行和未覆盖行</li><li>重复率：代码行和重复行</li><li>定制：对任意的软件度量进行组合</li></ul><p>使用该功能，每执行一次命令行则记录一次数据日志</p><p>优点：全面</p><p>缺点：</p><ul><li>无法直接回顾以前的历史记录，需要对源码进行版本控制</li><li>不开源，研究人员/开发者无法使用自己的软件度量标准</li></ul><h3 id="JDepend"><a href="#JDepend" class="headerlink" title="JDepend"></a><a href="https://github.com/clarkware/jdepend" target="_blank" rel="noopener">JDepend</a></h3><p>说明文档在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$JDEPEND_HOME&#x2F;doc</span><br></pre></td></tr></table></figure><p>缺点：项目太老，需要修改源码重新编译，不支持可视化，没有历史记录，数据没有可视化，难以阅读，对新手来说难以理解</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdh8kjrwnij313t0u0qfg.jpg" alt="截屏2020-04-03 下午9.27.56"></p><h3 id="X-Ray"><a href="#X-Ray" class="headerlink" title="X-Ray"></a><a href="http://xray.inf.usi.ch/xray.php#download" target="_blank" rel="noopener">X-Ray</a></h3><p>2008年的工具</p><p>优点：多种可视化方式</p><p>缺点：只作为<a href="https://marketplace.eclipse.org/content/x-ray-software-visualization" target="_blank" rel="noopener">旧版Eclapse-Ganymede插件</a>使用，部分图片的内容让人感到混乱，扩展性差</p><h3 id="SourceMonitor"><a href="#SourceMonitor" class="headerlink" title="SourceMonitor"></a><a href="http://www.campwoodsw.com/sourcemonitor.html" target="_blank" rel="noopener">SourceMonitor</a></h3><p>优点：支持多语言，图形化设置，通过checkpoint可以保持和查看历史数据</p><p>缺点：只支持Windows，设置不合理，无历史记录，数据没有可视化，难以阅读，排版差</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdha02b0ilj30sg0no763.jpg" alt="截屏2020-04-03 下午10.17.29"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdha3u8dw5j31f20iwn8m.jpg" alt="截屏2020-04-03 下午10.17.29"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdha651nybj31f20hojup.jpg" alt="截屏2020-04-03 下午10.17.29"></p><h3 id="CodeCity"><a href="#CodeCity" class="headerlink" title="CodeCity"></a><a href="https://wettel.github.io/codecity.html" target="_blank" rel="noopener">CodeCity</a></h3><p>介绍，<a href="https://www.youtube.com/watch?v=HT3iw5l4l6U" target="_blank" rel="noopener">导入模型</a></p><p>优点：好看，功能多</p><p>缺点：复杂，旧，操作不易</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhb7tnianj31cv0u0qo0.jpg" alt="截屏2020-04-03 下午10.59.19"></p><h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a><a href="http://findbugs.sourceforge.net/publications.html" target="_blank" rel="noopener">FindBugs</a></h3><h3 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a><a href="https://pmd.github.io/" target="_blank" rel="noopener">PMD</a></h3><p>PMD is a source code analyzer. It finds common programming flaws like unused variables, empty catch blocks, unnecessary object creation, and so forth. It supports Java, JavaScript, Salesforce.com Apex and Visualforce, PLSQL, Apache Velocity, XML, XSL.</p><p>Additionally it includes CPD, the copy-paste-detector. CPD finds duplicated code in Java, C, C++, C#, Groovy, PHP, Ruby, Fortran, JavaScript, PLSQL, Apache Velocity, Scala, Objective C, Matlab, Python, Go, Swift and Salesforce.com Apex and Visualforce.</p><p>PMD的文档，它会对代码中的如下部分进行检查：<br>　　 未使用的本地变量<br>　　 空的catch块<br>　　 未使用参数<br>　　 空if语句<br>　　 重复的import语句<br>　　 未使用的私有方法<br>　　 可能是Singletons的类<br>　　 短/长变量及方法名字</p><p>PMD提供了一项叫作CPD的很有用的功能，它检查代码的拷贝粘贴部分。我使用PMD找到的最频繁的错误是未使用的import语句，未使用的私有变量以及意外重复拼写。</p><h3 id="CheckStyle"><a href="#CheckStyle" class="headerlink" title="CheckStyle"></a><a href="https://github.com/checkstyle/checkstyle" target="_blank" rel="noopener">CheckStyle</a></h3><p>Checkstyle is a tool for checking Java source code for adherence to a Code Standard or set of validation rules (best practices).</p><p>Checkstyle检查如下部分：<br>　　 Javadoc注释<br>　　 命名约定<br>　　 标题<br>　　 Import语句<br>　　 体积大小<br>　　 空白<br>　　 修饰符<br>　　 块<br>　　 混合检查（包活一些有用的比如非必须的System.out和printstackTrace）</p><p>不像PMD，Checkstyle能够检查Javadoc注释；Checkstyle可以发现更多的错误。包括漏掉的Javadoc注释，超过80个字符的行、不合约定的变量名、用tab来代替空格等等。两个工具都允许创建自定义的规则。</p><h3 id="Jalopy"><a href="#Jalopy" class="headerlink" title="Jalopy"></a><a href="http://jalopy.sourceforge.net/" target="_blank" rel="noopener">Jalopy</a></h3><p>商用版 <a href="https://www.triemax.com/" target="_blank" rel="noopener">TRIEMAX</a></p><p>　　Jalopy是一个易于配置的源代码格式程序，它能检测并修补Java代码中大量的习惯性缺陷。Jalopy更像一个代码整理器而不是检查器。Jalopy的插件现在已经支持大多数IDE，而且多数是无缝集成。我发现Jalopy特别强大，能够干许多很酷的事情。例如，它可以修改代码缩进、对齐括号、使行宽符合某个字符长度、插入相关的Javadoc注释以及对import语句排序。Jalopy最好的地方是超级自定义功能。一个简单的用户界面就可以让你选择Jalopy的所有功能的开关，不需要XML配置文件。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果想在你的组织中使用它们中的一个，Checkstyle似乎更好一些：它检查公司编码约定的大多数项目。如果增强代码质量是主要目标，那PMD是一个好的选择。但是如果你想要更多的功能并真正使用工具来修改代码，应该试试Jalopy。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
          <category> 实验笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件度量 </tag>
            
            <tag> SonarQube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《A Manifesto for Future Generation Cloud Computing&amp;#59 Research Directions for the Next Decade》 —— 读书笔记</title>
      <link href="/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8C%91%E6%88%98%E5%92%8C%E6%9C%AA%E6%9D%A5%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"/>
      <url>/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8C%91%E6%88%98%E5%92%8C%E6%9C%AA%E6%9D%A5%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>云计算和按需付费模型的出现，让用户可以随时随地获得基于订阅的服务。这带来的好处包括：更短的启动时间；创建可扩展的全球企业程序；给科学计算和高性能计算带来更好的成本价值关联；以及为无处不在的普适程序带来不同的调用/执行模型。</p><p>另一方面，无服务计算、软件定义网络、物联网、边缘计算等新技术为云计算带来了机遇，但也同时带来了新的挑战，对新方法和研究策略的需求。对于解决可扩展性、灵活性、可靠性、安全性、可持续性等问题的模型，也需要重新进行评估。</p><p>该文献将定义云计算中的主要的开放性挑战，调查最新的解决方案和它们的局限。接 着讨论新兴的趋势和影响范围，以及它们如何推动未来云计算的挑战。据此再进一步讨论云计算的未来，并指出下一个十年的研究方向。</p><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>云计算模型，提供了对基于订阅的IT资源的按需访问，按需扩展，按使用付费。当前的三种主要服务模型为SaaS、PaaS、IaaS。在软件即服务SaaS中，用户通过互联网访问在数据中心上运行和管理的程序或软件，从而避免如版权、维护IT基础设施等费用；平台即服务PaaS，适合对IT资源需要更多控制的用户，但也同时为用户提供了一些框架来支持云程序的创建和部署；基础设施即服务IaaS，则允许用户访问计算资源，通常是提供虚拟机和存储空间。它不仅是前两者的基础，也是云计算的支柱。</p><p>云计算中旧有的技术同样在不断发展，在虚拟化中，容器技术的出现和广泛使用，甚至导致新的服务模型出现：容器即服务CaaS。</p><p>其中一些特定云服务专注于简化配置，以此满足特定的商业要求，这些旨在帮助企业创造价值的云服务，在种类和数量方面正在快速的增长：比如新兴的、易于使用的、基于云的数据分析服务和无服务器结构。</p><p>云计算中的分布式计算是一个更明显的发展趋势，相关概念有雾计算、边缘计算、物联网、将服务分布在地理分布的数据中心等。边缘/雾计算的核心思想是将计算能力移动到更接近数据的地方，比如移动基站、网关、交换机、路由器等，从而降低延迟；</p><blockquote><p>cluster computing —— 网格计算<br>grid computing —— 集群计算</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfjn0ul31j311n0u04d1.jpg" alt="截屏2020-04-02 上午10.19.45"></p><h3 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h3><h4 id="可扩展性和可伸缩性（弹性）"><a href="#可扩展性和可伸缩性（弹性）" class="headerlink" title="可扩展性和可伸缩性（弹性）"></a>可扩展性和可伸缩性（弹性）</h4><ul><li>通过硬件的异质性来加速计算</li><li>资源虚拟化、性能、隔离、价值模型</li><li>用于可扩展弹性服务的软件</li><li>对性能进行监控和建模的中间件</li><li>适应性的程序编程模型</li></ul><p>网格计算和集群计算是早期的分布式计算模型，云计算与前两者不同，它的优点是可以保证按需提供几乎无限的计算资源。好处之一是<strong>云计算中预料之外的计算资源需求激增不会违反<a href="http://blog.sina.com.cn/s/blog_c3917d180101c8r6.html" target="_blank" rel="noopener">服务级别协议SLAs</a></strong>，因为用户购买的固定计算资源无法给用户提供预期之外的服务质量QoS。但<strong>前提</strong>是云服务提供商提供可扩展的服务，即用户可<strong>以按需增加计算资源</strong>，并且新的计算资源能够直接给当前程序带来性能和服务质量的提升；其二是<strong>客户不需要提前调查、规划、购买硬件设备，而是根据当前需求购买云计算资源，并灵活变动</strong>。</p><p>研究挑战在于可扩展的服务，它包括硬件级、中间件级和应用级。在硬件级中，要求云计算提供商有<strong>并行计算硬件</strong>，如多核、集群、加速器（GPUs），和非传统的架构（神经和量子），以及在<strong>IaaS服务</strong>中为用户提供<strong>异质硬件的抽象</strong>（如VMs、容器），同时提供隔离和性能保证。在<strong>中间件级别</strong>中，需要为用户提供<strong>编程模型和抽象</strong>，从而让使用PaaS服务的开发者可以专注于程序本身的功能（如Map、Reduce函数），而非功能性的问题（如可扩展性、容错）则交给中间件负责。在<strong>应用级</strong>中，需要开发新的算法，克服<strong>顺序确定性算法</strong>固有的可扩展性问题，包括非同步演化算法、近似算法、在线/增量算法（<a href="https://ieeexplore.ieee.org/document/5380857" target="_blank" rel="noopener">文献</a>）等，这些算法可能会通过<strong>牺牲精度或一致性来实现可扩展性和性能</strong>。</p><p>在弹性服务方面的挑战包括：如何<strong>精确预测</strong>计算资源需求和不同资源分配下的程序性能。这些工作负载和性能模型能够帮助中间件中的资源管理器进行决策，也使程序能够扩展和收缩，包括动态创建、迁移、回收虚拟机、容器和其他计算资源等。</p><p>成熟的<strong>虚拟机技术</strong>，使得CPU密集型应用中在虚拟机中的性能已经足以跟本机性能媲美，但依旧出现了<strong>容器技术</strong>，在快速启动的易于使用方面对虚拟机进行了改进。</p><p><strong>编程模型</strong>则使程序能够<strong>动态重新配置</strong>，让中间件在公有云和私有云之间迁移数据和计算，甚至是将计算移动到离数据源更近的地方，如IoT中的传感器网络。</p><p>云的可扩展性最终还是受各个<strong>组件</strong>（如计算、存储、相互联系）的扩展规模的限制。由Moore’s law 和 Dennard scaling可以推断，新的计算单元和用电量都将不再扩展，这直接影响了云的计算性能和成本。在这方面，需要研究CMOS（互补金属氧化物半导体）以外的新技术。类似的还有内存，DRAM（动态随机存取存储器）限制了成本和扩展，新的研究方向是非易失性技术，这些技术将在降低功耗的同时，进一步扩展负载存储操作内存。最后一个研究方向是<strong>光子互联</strong>，让所谓的硅光子通关光子连接传播到芯片中，改进性能、扩大规模、降低能耗。</p><h5 id="研究方向-——-硬件、中间件、应用级别"><a href="#研究方向-——-硬件、中间件、应用级别" class="headerlink" title="研究方向 —— 硬件、中间件、应用级别"></a>研究方向 —— 硬件、中间件、应用级别</h5><p>在硬件级别上，研究方向是<strong>特定功能的专用云</strong>（如Amazon提供GPUs，Google提供TPUs，Microsoft提供FPGAs），比如机器学习、数据流分析、图像视频模式识别。可应用的领域包括，机场控制点、社交网络挖掘、IoT传感器数据分析、智能运输等。云还需要适应于非传统结构，如神经形态、量子计算、纳米计算等。</p><p>研究还应包括开发合适的虚拟化抽象、即时编译的编程抽象、专用硬件的优化。还有FaaS云供应商的经济模型（比如可组合的视频、图像处理的微服务）</p><p>在中间件级别，研究应包括继续增加对现有基础设施的可重用性，加快部署速度，加快大规模部署时硬件和网络的供应。其中包括算法和软件堆栈来保证程序的可靠执行，具体方法是将故障转移到地理上远程的私有云或混合云。</p><p>研究应关于内部云，以支持同时在多个公有云供应商之间无缝的执行计算。对于高性能计算应用，需要保证多次运行下性能的一致性。还有匹配高性能计算应用的部署和调度算法来使用集群，即不会在并行执行时引入噪声。</p><p>对于通信密集型应用，需要研究高吞吐量和低延迟的网络。大数据程序对大规模数据的（近）实时处理、智能分析和关闭控制回路有很高要求。</p><blockquote><p>Service Level Agreement/SLA —— 服务协议级别<br>neuromorphic —— 神经形态<br>sequential deterministic algorithms —— 顺序确定性算法<br>asynchronous evolutionary algorithms ——非同步演化算法<br>approximation algorithms —— 近似算法<br>online/incremental algorithms —— 在线/增量算法<br>Complementary Metal-Oxide-Semiconductor —— CMOS —— 互补金属氧化物半导体<br>Dynamic Random-Access Memory —— DRAM —— 动态随机存取存储器<br>neuromorphic —— 神经形态<br>nanocomputing——纳米计算<br>Adiabatic quantum computation —— 绝热量子计算机<br>just-in-time compilation —— 即时编译</p></blockquote><h4 id="资源管理和调度"><a href="#资源管理和调度" class="headerlink" title="资源管理和调度"></a>资源管理和调度</h4><ul><li>大规模服务中的自动扩展和资源控制</li><li>多云操作和负载平衡</li><li>专门的多重控制回路设计</li><li>工作负载特征错误的敏感性</li><li>安全和资源管理的相互作用</li></ul><p>云数据中心有多达几十万的计算和存储设备，因此需要高效的资源管理和调度策略。当前的<strong>IaaS</strong>主要依赖两种<strong>虚拟机配置策略</strong>：<strong>静态</strong>和<strong>动态</strong>。静态策略使用<strong>装箱算法</strong>将固定数量的物理资源分配给虚拟机；动态则通过虚拟机<strong>实时迁移</strong>和其他负载平衡技术来处理负载的变化。这些策略可以是<strong>提前预测分配</strong>，也可以是<strong>监测后重新分配</strong>，但不管如何，都需要知道虚拟机资源的需求，可以是用户指定，也可以是通过监控数据进行预测</p><p>对于<strong>PaaS</strong>、<strong>SaaS</strong>供应商来说，资源管理方法可以帮助管理分配给分布式应用、容器、网络服务、微服务的资源的种类和数量。相关的策略有：1<strong>.自动扩展技术</strong>（基于当前和预测的负载动态扩展或收缩）2<strong>.资源节流技术</strong>（处理瞬时自动扩展中的工作负载突发、平滑和变化，和控制可抢占VM的使用）3.<strong>准入控制方法</strong>（处理高峰负载和高价值客户的负载优先级）4.<strong>服务编排和工作流调度</strong>（整理和编排工作负载，可能专门为特定领域设计，如科学领域中对成本和任务需求有限制的工作流，<a href="https://manuscript.elsevier.com/S0167739X15000059/pdf/S0167739X15000059.pdf" target="_blank" rel="noopener">参考文献</a>）5.<strong>多云的负载平衡</strong>（将应用的负载分布到多个云数据中心）。</p><p>其中的一个挑战是，当前的资源管理策略<strong>不适用</strong>于<strong>不精确的资管需求预测</strong>，因此需要新的权衡方法，在工作负载信息不精确的情况下，对策略<strong>最优性</strong>和<strong>稳健性</strong>之间进行权衡。当前的需求估计和工作负载预测方法在未来可能不适用，而机器学习和人工智能能否胜任有待研究。</p><p>另一个常见的问题是，资源管理策略<strong>专注于优化特定的度量指标和资源</strong>，缺少一个能在<strong>相同多重控制回路环境中共存</strong>的系统方法，使用户能公平的访问资源，以及对云堆栈各层在整体上实现最佳化（<a href="https://ieeexplore.ieee.org/abstract/document/6809354" target="_blank" rel="noopener">参考文献</a>）</p><p>当前的研究功能工作还缺少安全和资源管理之间的相互作用的风险问题</p><h5 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h5><p>雾计算增强了计算的去中心化，导致了资源和平台的异质性，以及工作负载的可变性。无服务计算和边缘计算则带来了将业务逻辑从系统核心中迁移出来的机会。软件定义计算和大数据则扩展了资管管理和调度的制定机制和推理技术。</p><p><strong>边缘分析</strong>的实时处理，需要边缘节点和云中心的合作资源管理，它需要感知<u>边缘设备的位置</u>和<u>资源的可用性</u>以优化资源分配，还需要在规模上考虑可移动性、高度动态的网络拓扑、隐私和安全保护约束。</p><p>在云中心和边缘上共存的<strong>多重控制回路</strong>的设计，分析、验证、实现和测试。</p><p>关于调度，在去中心化和异质的环境中，<strong>多资源公正性</strong>、<strong>非传统博弈论方法</strong>主要应用在中小规模计算集群，需要扩展应用至大规模的异质的云中心和边缘节点上。比如均场博弈可以帮助推理大量的资源、设备、用户类型的交互，从而解决固有的可伸缩性问题。</p><p>从终端用户的角度，无服务计算，即FaaS限制了函数执行的时间，从而提高了用户的期望值，而当前的性能不稳定，且响应时间还受到网络延迟的影响。此外，无服务计算按次数收费，因此需要新的资源管理策略来决定什么时候用FaaS，什么时候用在应用本地运行的微服务。</p><p>从FaaS供应商的角度，需要对资源分配进行最优化。如果要满足用户对函数执行的QoS的要求，则要权衡执行需求、网络延迟、隐私和安全问题。相关的研究包括执行时间的软约束、主动式的FaaS供应以避免资源启动时的高延迟。还有对于FaaS和其他云服务的供应商和消费者，它们有不同的目标和约束，因此需要新的<strong>博弈论方法</strong>和<strong>面向市场的模型</strong>对资源进行分配和对需求和供应的调节。</p><p>软件定义网络SDN扩展了可用于资源整体管理的控制机制的范围。在逻辑上使网络控制中心化，即单点管理，使资源管理更高效。研究之一是，软件定义网络还能促进虚拟机关联和流量的整合（传统数据中心的难点），从而优化能耗和满足SLA。</p><p>SDN中的服务功能链接SFC，是对虚拟网络功能链（如NAT、防火墙、IDS）的自动化设置。SDN和NFV组合让<u>服务链</u>能够高效、按需的安置。但最优化<strong>服务链安置</strong>还需要新的资源管理策略。VNF的虚拟化特性也简化了编排和合并，并且可以动态部署网络服务，因此需要新算法来利用这些特性。</p><p>机器学习算法也有助于VM配置、整合、负载平衡等资源管理问题，但也要注意，采用这些技术可能会导致潜在的控制失误，丧失确定性。相关的研究方法有<strong>可解释性AI</strong>。</p><p>随着处理的数据量的增加和超大规模工作流的出现，考虑诸如容错，性能建模，有效的数据管理和有效的资源使用等关键问题非常重要，而<strong>大数据分析</strong>则有助于此。例如，监视和分析资源消耗数据，可以使工作流管理系统能够检测性能异常并潜在地预测故障，从而利用诸如无服务器计算之类的技术来管理可重复使用并可在多个利益相关者之间共享的复杂工作流的执行。尽管如今存在定义此类解决方案的技术可能性，但仍缺乏将无服务器功能应用到HPC和科学计算用例的情况，因此需要对此领域进行进一步研究。</p><blockquote><p>provisioning policies —— 配置策略<br>bin-packing algorithms —— 装箱算法<br>resource throttling methods —— 资源节流技术<br>preemptible —— 抢占式的<br>service orchestration —— 服务编排<br>multiple control loops —— 多重控制回路<br>edge analytics ——边缘分析<br>multi-resource fairness —— 多资源公正性<br>game-theoretic approaches —— 博弈论方法<br>mean-field games —— 均场博弈<br>Service Function Chaining (SFC) —— 服务功能链接<br>network address translation (NAT) —— 网络地址翻译<br>intrusion detection systems (IDS) —— 入侵检测系统<br> virtual network functions (VNFs)—— 虚拟网络功能<br>NFV —— 网络功能虚拟化<br>service chain placement —— 服务链安置<br>explainable AI —— 可解释性AI</p></blockquote><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul><li>导致大规模服务中断的故障关联</li><li>缺少整体服务可靠性模型</li><li>缺少自动的可靠性感知的服务管理机制</li><li>缺少故障感知的配置策略</li></ul><p>云数据中心的系统是高度相互关联和相互依赖的。由于云计算系统的规模、复杂性和相互依赖性，它们需要面对可靠性相关挑战，比如硬件故障、资源缺失故障、溢出故障、网络故障、超时故障、和环境改变引发的软件缺陷。有些故障会影响系统操作，连锁故障甚至会应发大规模服务中断。企业组织通常会采用严格的可靠性保证和还原能力。需要新的云服务供应方式，来保障性能和<strong>从能各种故障中恢复的能力</strong>。另一个挑战是云系统的<strong>可靠性</strong>和<strong>能耗</strong>之间的相互影响的研究。</p><p><strong>云计算是面向服务的而不是面向资源的</strong>，所以分布式计算中保障可靠性的模型（如容错）不适和直接用于云计算系统。</p><p>云计算中相互关联的特征的范围，比如巨大的规模、服务共享模型、广域网络、软/硬件组件异质性，导致难以分析云计算系统的规模和可靠性的<strong>期望值</strong>。</p><p>现有许多研究对故障进行单独分析和解决，但都忽略了<strong>故障之间的相互影响</strong>。现存对的云计算环境中也缺少可靠性模型、自动的可靠性感知的服务管理机制，和故障感知配置策略</p><h5 id="研究方向-1"><a href="#研究方向-1" class="headerlink" title="研究方向"></a>研究方向</h5><p>当前的挑战是如何提供一种可兼容的服务，以满足用户的期待——对性能、可靠性和处理各种类型故障。</p><p>RaaS可靠性即服务，旨在提供创新的云服务，提高可靠性和恢复能力以确保服务性能。主要的挑战是开发一个层次的、面向服务的云服务可靠性模型。这要求现有云系统中包括新模块，例如故障模型和工作负载模型要适应资源供应策略，并为各种应用程序提供灵活的可靠性服务。</p><p>RaaS中的其中一个研究方向是使用机器学习进行<strong>故障预测</strong>，提高故障感知的资源供应策略。这也可以作为雾计算的另一个研究方向。但需要同时考虑系统的能源效率问题。</p><p>另一个研究方向是<strong>云存储系统</strong>的可靠性。挑战在于改进大数据应用的在云存储中的容错，比如复制和<a href="https://blog.csdn.net/BtB5e6Nsu1g511Eg5XEg/article/details/82321298?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">纠删码</a>。涉及的参数有耐用性、可用性、存储开销、网络带宽和流量、能耗、恢复性能。<strong>基于节点故障预测的纠错码动态复制</strong>能节省网络流量和存储空间。主要挑战在于解决<strong>多变量的优化问题</strong>，以满足不同的要求。</p><blockquote><p>Reliability as a Service (RaaS) —— 可靠性即服务<br>replication —— 复制/副本<br>Erasure coding —— 纠删码<br>network traffic —— 网络流量</p></blockquote><h4 id="可持续性"><a href="#可持续性" class="headerlink" title="可持续性"></a>可持续性</h4><ul><li>云数据中心的能源需求</li><li>虚拟机整合以最小化服务器的能耗</li><li>服务器之间数据流的最佳调度策略</li><li>基于机器学习的任务分配</li><li>能源与服务质量的权衡</li></ul><p>2017年世界上大约有850万云数据中心，它们每年的耗电量比大多数国家都多（除了美、中、俄、日）。ICT设施的耗电量接近世界总体耗电量的10%。但云和网络也有助于节能，比如智慧城市，或最大程度优化可再生和不可再生能源的混合使用。考<strong>虑能</strong>耗的同时还要考虑<strong>服务质量</strong>，比如在搜救领域就不能降低服务质量来减少能耗。</p><p>当前的主要工作是整合虚拟机（涉及资源管理）以减少能耗。但其他的基础设施，比如制冷系统（接近35%能耗）、网络等也需要适合的调度算法。</p><p>多核结构，新型的基于硬件的休眠启动控件、时钟速度管理技术，让服务器的能耗取决于瞬时工作负载。因此新的基于机器学习的方法能够动态<strong>分配</strong>任务到（云或雾的）多个服务器中，从而最少的违反SLA。整体技术也需要解决网络的服务质量，比如包延迟、远程访问云数据中心的网络能源效率问题。这些技术的目的都是为了提供一个能<strong>在线自动调整</strong>或自治的方法，使云系统的能耗和服务质量<strong>作为一个整体得到解决</strong>。</p><p>当前的实验研究表明，<strong>深度学习和神经网络</strong>能够按照规定的执行延迟、响应时间、系统吞吐量、和能耗对任务进行分配（<a href="https://spiral.imperial.ac.uk:8443/bitstream/10044/1/59726/2/ServerstateDetection.pdf" target="_blank" rel="noopener">参考文献</a>）。另一种方式涉及<strong>均衡能源供应</strong>，云数据中心可以调节自身能耗并以服务质量作为响应，根据供应的能源动态的修改处理器的可变时钟速率（<a href="https://ieeexplore.ieee.org/document/6903096" target="_blank" rel="noopener">参考文献</a>）。也有人建议使用混合使用可再生和不可再生能源</p><h5 id="研究方向-2"><a href="#研究方向-2" class="headerlink" title="研究方向"></a>研究方向</h5><p>云中心可以建立在北极圈这样的地方，通过自然冷却降低能耗。但这需要研究新的系统结构，支持在地理上分布数据中心和云计算。比如依赖分布数据的协调、资源供应、能源意识和碳足迹感知的算法；地理的负载平衡。还可以通过定价影响云服务提供商的选择。还有比如使用智能电网来管理ICT组件的能耗。以及，将<u>能量流</u>与<u>计算和通信资源</u>和<u>相关的组件</u>进行动态耦合，在满足作业的QoS和SLA的同时最小化能耗。</p><p>但要注意，云中心远离用户会<strong>增加网络的能耗</strong>，也会<strong>增大延迟</strong>。比如金融交易、股票等对响应时间的要求很严格。还要注意<strong>数据的专有性</strong>，比如数据是本地的，云中心也需要在该地。</p><p>高性能和更多数据处理通常意味着更高的能耗。因此需要同时考虑QoS、SLAs和能耗，并对其在线管理。但由于情况复杂，变化太快，难以提前预测或构建出完善的模型，因此需要一种自我感知的技术。相关的研究涉及机器学习。</p><p>由于雾计算带来的异质性问题，导致资源和能源的管理难度变大，进而增大能耗。但由于用户到雾节点的距离变短，因此网络能耗却降低了。研究应包括用户流量只经过最少的雾节点时网络QoS的改善情况。机器学习将有助于该研究。</p><p><strong>虚拟机整合</strong>是一个降低云中心能耗的有效措施。但降低网络能耗是一个复杂的问题，它会影响网络的可靠性、可扩展性和性能。已经提出了智能的能量感知和路由算法。但网络能耗的研究相比计算能耗的研究要少很多。随着SDN软件定义网络的出现，SDN提供的全球网络意识和中心化决策，为此领域带来了机会。</p><blockquote><p>Information and Communications Technology, ICT —— 信息通信技术<br>sleep-start controls —— 休眠启动控件<br>Holistic techniques —— 整体技术<br>rationing the energy supply —— 均衡能源供应</p></blockquote><h4 id="异质性"><a href="#异质性" class="headerlink" title="异质性"></a>异质性</h4><ul><li>虚拟机级别、供应商级别、硬件结构级别的异质性</li><li>虚拟机放置、供应配置和调度‘</li><li>采用供应商指定语言进行硬件加速</li></ul><p>因为云供应商需要不断更新硬件以满足用户需求，以及提高性能和效率，因此出现了云内在的异质性，反映在三个层面。</p><p><strong>虚拟机</strong>层面，原因是能够以<strong>多种方式和配置方法</strong>对同质的资源进行组织（或者接近同质的，比如相同的处理器族），比如N核的同质硬件处理器可以被组织为有任意核的虚拟机。<strong>供应商</strong>层面，原因是可以从<strong>多个云供应商</strong>中利用资源，不同的云供应商有不同的虚拟机监控程序和软件套件（通常出现在多重云环境中）。<strong>硬件结构</strong>层面，原因是<strong>同时利用</strong>CPUs和硬件加速器（如GPUs、FPGAs）。</p><p>第一重挑战是<strong>异质环境中的资源和工作负载管理</strong>。资源管理专注于以静态和动态的方式对虚拟机进行安置，综合考虑网络参数和能耗的本地调度或全局调度技术。工作负载管理则通过基准技术优化工作负载的安置的调度。基准技术的实践在虚拟机层面已经足够成熟，在供应商层面也正在发展（<a href="https://link.springer.com/article/10.1007/s10922-014-9307-7" target="_blank" rel="noopener">参考文献1</a> &amp; <a href="https://pureadmin.qub.ac.uk/ws/files/74475124/Varghese_IEEETCC.pdf" target="_blank" rel="noopener">参考文献2</a>），但在<strong>硬件结构层面对工作负载的性能预测</strong>还缺少研究。除此之外 ，当前对异质资源的资源管理和工作负载管理的研究也是分别进行的。当前还缺少对3个层面的异质性进行整合和管理的通用云平台。</p><p>第二重挑战关于<strong>应用软件的开发，使之兼容异质资源</strong>。当前大部分的加速器需要不同的编程语言（比如CUDA和OpenCL需要对GPU编程），导致云程序很难采用加速器。在IaaS中，开发者只能直接面对硬件环境进行编程，而SaaS、PaaS中，可以在中间件对硬件进行抽象。但在中间件提供对加速器硬件的抽象，则会减少优化性能的可能性。因此需要对性能和易用性进行权衡。在这方面的开放性挑战是开发与底层硬件无关的软件，并且可以基于可用硬件进行适应（<a href="https://ieeexplore.ieee.org/document/7495121" target="_blank" rel="noopener">参考文献</a>）</p><h5 id="研究方向-3"><a href="#研究方向-3" class="headerlink" title="研究方向"></a>研究方向</h5><p>目前有两个因素影响异质性在云计算中的应用。<strong>第一个是管理平台</strong>，由于当前对异质云环境中的资源和工作负载管理的研究是分散的，因此缺乏在异质环境下，整体的可用性。因此提出一个涵盖了异质性三个层次的平台，可以根据应用的需求选择最佳策略。因此需要异质的内存管理。当前的内存管理主要依靠虚拟机监控程序Hypervisor，这限制了异质性带来的好处。提出的解决方案是采用异质性感知的GuestOS。</p><p><strong>第二个是抽象</strong>，当前的硬件加速器的编程模型需要指定的语言，这限制了云程序对异质性的广泛采用。研究方向之一是开发一种开源的高级编程语言，满足抽象、弹性等核心云原则，以适用于异质环境中的云程序。这对迁移云程序到<u>云和雾的整合</u>中也有帮助。</p><p>当前编程语言具有局限性，比如OpenCL。CPU和硬件加速器的交互需要显式编程。编程语言TANGRAM，提供了在不同加速器之间的可迁移性，但还缺少在CPU和加速器之间寻找最优策略的性能模型和运行时自适应。</p><p>较早的技术或许能为解决异质性问题带来灵感，比如<u>多路复用信息和计算服务</u>提供了单级内存，这是异质系统的虚拟内存的基础。IBM的CP-67是虚拟化大型机操作系统以实现时间共享的首次尝试之一，后来被VMWare用于X86服务器的虚拟化。</p><p>最近还有讨论关于拆分数据中心。传统的数据中心通过服务器和机架构建，每个服务器提供完整的计算资源。而拆分的数据中心，则是将每种资源（如CPU、内存、存储）构建成独立的资源片“blade”，通过网络进行连接，因为每种类型资源的发展速度都不一样</p><blockquote><p>homogeneous —— 同质的，同类的<br>heterogeneous —— 异质的<br>vendor —— 供应商<br>Hypervisor —— 虚拟机监控程序<br>Software suits —— 软件套件<br>Field Programmable Gate Arrays (FPGAs) —— 现场可编程门阵列<br>benchmarking techniques —— 基准技术<br>GuestOS —— 即虚拟机上的操作系统<br>Multiplexed Information and Computing Service (Multics) ——多路复用信息和计算服务</p></blockquote><h4 id="相互关联的云"><a href="#相互关联的云" class="headerlink" title="相互关联的云"></a>相互关联的云</h4><ul><li>云的相互操作性</li><li>安全性和服务质量的常见规则和标准</li><li>跨站点的虚拟网络</li><li>服务的最小公分母背后的相互操作性</li></ul><p>云供应商都各自把工作局限于自己的服务。云的相互操作性是各种类型的云和系统（如公有云、私有云）彼此相互了解的一种能力，了解的信息包括：系统接口、配置、验证和授权格式、数据格式、程序的初始化和定制化。</p><p>从更宽泛的角度来说，互连云有许多用于方法，用于整合不同的云供应商和数据中心的服务和功能。这些技术取决于互连云的参与者、它的目标、和提供给用户的服务整合的透明度（<a href="Interconnected Cloud Computing Environments: Challenges, Taxonomy, and Survey">参考文献</a>）</p><p>现有的云供应商虽然有专门的互操作机制，但并<strong>没有统一的标准和开源</strong>，因此有很大的局限性。当前的标准化工作有：OGF的OCCI、SNIA的CDMI、DMTF的CIMI和OVF、IEEE的互连云、NIST的联合云。但<strong>现存云服务的接口并没有被标准化，且很多云服务的提供商都使用不同的接口、格式和上下文配置机制</strong>。</p><p>广义上，如果各种云之间的互连是由供应商发起和管理的，这些方式可以被归为联合的云计算。<strong>联合云计算</strong>可以被看做是云计算发展的下一步，也是<strong>雾计算和边缘计算</strong>结构的组成部分。联合云模型的好处有：资源优化、节约成本、敏捷资源交付、可扩展性、高可用性、商业连续性、地理分布</p><p>共享云之间的资源有2个原因，一是公司企业希望现有的内部基础设施能够<strong>最大程度的被使用</strong>，因此公司的私有云需要与公有云无缝集成；二是公司把的大部分的程序（没有隐私要求的）转移到公有云上，以此将程序的<strong>工作负载转移</strong>到云上，或放宽资源需求的限制。</p><p>最新的项目Aneka开发了中间件和库来整合不同的资源（如VM、数据库等），但也导致非最优的云程序或者只支持特定的服务模型</p><p>互操作性和便携性在不同的组件上有不同的考虑，包括接口规范、可移动的数据格式和应用、国际公认的服务质量和安全标准。如何高效，透明的供应，管理和配置，跨站点虚拟网络，以互连本地云和外部提供商资源，是普及该技术的重要挑战。</p><p>互连云服务的最小公分母是一个限制，如何突破这个限制，从而支持更丰富的云程序是其中的一个挑战。其他挑战还有：如何在多个供应商之间的授权、访问、账单方面进行协调；如何将互连云应用到雾计算等新兴趋势中。</p><h5 id="研究方向-4"><a href="#研究方向-4" class="headerlink" title="研究方向"></a>研究方向</h5><p>跨云系统的<strong>相互操作性</strong>和<strong>可移植性</strong>是一个复杂的领域，单纯的标准化不足以解决此问题。对于可移植性，<strong>可以使用应用容器和配置管理工具</strong>。对于云服务和产品的互操作性，<strong>则可以使用软件适配器和库</strong>。但由于问题的复杂性，目前还没有让人满意的解决方案。</p><p>采用软件适配器和库的挑战之一是如何在不强制采用服务之间最小的通用功能集的情况下促进云互连，即让用户仅通过一个供应商就能集成所需的复杂功能。其他研究方向还包括使用中间件进行，将多个提供商的简单服务，模拟成一个提供商提供的复杂服务。</p><p>上述挑战带来了一个研究方向，即用户级别（内部云或混合云）的中间件，在没有供应商的支持下，识别服务组合中的各方候选。因为供应商更希望服务组合中的服务全是自己提供的。然而，只有云供应商发现互连云能给它们带来收益，真正的互连云才会出现。这需要新的计费方式。</p><p>支持服务组合的中间件必须解决其两个接口中的难题：在与云用户的接口中，它需要无缝地交付服务，而交付功能的方式与用户无关：可以从单个提供商处获得所有服务（也许调用能够提供功能的SaaS），也可以通过组合来自不同提供商的不同服务来获得；在与供应商的接口中，不管如何与供应商合作，都能够获取复杂的功能：只要接口存在，中间件就应该提供该接口的使用方法，并自动检测是否满足使用要求。</p><p>最后，软件定义网络的出现，改变和优化了网络流量，这可能对云的互连产生影响。根据谷歌的报告，SDN最早的使用方式是优化连接数据中心的广域网流量。需要研究SDN和NFV对解决此领域问题的可行性。比如SDN和NFV可以提高<u>来自多个供应商的服务组合的</u>安全性和服务质量，通过对不同服务的流量分配不同的优先级，以及分别指定安全要求。</p><blockquote><p>InterCloud —— interconnected Cloud —— 互连云<br>minimum common denominator —— 最小公分母</p><ul><li>Open Grid Forum’s (OGF) Open Cloud Computing Interface (OCCI)</li><li>Storage Networking Industry Association’s (SNIA) Cloud Data Management Interface (CDMI)</li><li>Distributed Management Task Force’s (DMTF) Cloud Infrastructure Man- agement Interface (CIMI)</li><li>DMTF’s Open Virtualization Format (OVF)</li><li>IEEE’s InterCloud</li><li>National Institute of Standards and Technology’s (NIST) Federated Cloud</li></ul></blockquote><h4 id="强化资源受限设备的自主权"><a href="#强化资源受限设备的自主权" class="headerlink" title="强化资源受限设备的自主权"></a>强化资源受限设备的自主权</h4><ul><li>移动云绑定模型——任务委托和代码分流</li><li>移动云的适应性问题</li><li>云中心的物联网</li><li>雾计算</li></ul><p>智能手机等移动设备，它们的电池、CPU、内存、存储等跟台式设备比是受限的，但可以通过外部的云资源减少这些限制。因此出现了移动云的概念。</p><p>在移动云上的主要研究包括<strong>任务委托</strong>和<strong>可移动代码负担转移</strong>。任务委托是指，从多个云供应商中移动调用网络服务，因此涉及互操作性问题，解决方案是中间件。代码负担转移，则对应用程序进行配置和分区，并将资源密集型的方法函数转移到云实例的代理上（如Cloudlets/swarmlets）。相关的研究挑战有：如何开发理想的负担转移方式、如何识别资源密集型方法、如何学习合理的决策机制——兼顾设备上下文（如电池级别、网络连通性）和云上下文（如云代理的当前负载）</p><p>物联网演变为工业4.0和互联网4.0+，而云计算能够帮助存储和分布式处理物联网节点的数据。<strong>网络延迟</strong>是以云为中心的物联网模型的挑战之一。除此之外还有<strong>能耗</strong>问题，虽然可以通过可再生能源缓解，但却又引发了<strong>服务质量</strong>问题。</p><p><strong>雾计算</strong>是一个新兴的解决方案，它的优点包括边缘设备的安全、位置识别、敏捷开发、低延迟、成本和性能上的效率，但同时也是关键的挑战。</p><h5 id="研究方向-5"><a href="#研究方向-5" class="headerlink" title="研究方向"></a>研究方向</h5><p>在移动云领域，任务委托已经实现，但代码负担转移还存在适应性问题。并且由于移动设备的性能增强，代码负担转移的好处也变得有限。这意味着只有更大负担的程序需要转移，这意味着每次负担转移成本增加。该问题的研究方向应该是设计更好的针对移动云程序的多重租赁模型，在多个移动用户间分摊成本。而移动设备也云资源的异质性，增大了问题的复杂度。</p><p>研究方向之一是针对异构环境中负担转移的激励机制，鼓励移动用户参与并获得回报。另一个研究方向是新技术（无服务计算、CaaS、雾计算）对移动云领域的作用的详细探索。</p><p>激励机制还跟IoT和雾计算有关。比如由雾的提供者自己提供建立雾节点的基础设施，使雾节点更靠近数据源。这遵循消费者即提供者CaP模型，即利用消费者的台式机执行各种分布式计算任务。</p><p>另一方面轻量级的容器技术也更适合被雾节点采用。</p><p>对实时数据流分析之类的领域，<strong>边缘分析</strong>是另一个研究方向。原本的CIoT模型的数据处理在云中进行，雾节点只用于降低延迟。而边缘分析则是将数据处理分散在了整个雾计算拓扑层中，即边缘设备、雾节点和云。中间的处理包括过滤、整合、错误探测等。研究可以从QoS和QoE两方面对支持边缘分析的框架（如Apache Edgent）进行分析。目前已经有<u>在整个雾计算拓扑中对边缘分析任务和程序的调度和放置</u>的初步解决方案。</p><blockquote><p>task delegation —— 任务委托<br>mobile code offloading —— 可移动代码负担转移<br>Cloudlet —— 小云<br>swarmlets —— 小集群<br> consumer-as-provider (CaP) model —— 消费者即提供者模型<br>the Cloud-centric IoT (CIoT) model —— 以云为中心的物联网模型<br>QoE (Quality of Experience)  —— 体验质量</p></blockquote><h4 id="安全性和隐私"><a href="#安全性和隐私" class="headerlink" title="安全性和隐私"></a>安全性和隐私</h4><ul><li>基于编码的数据保护</li><li>选择性的信息共享</li><li>细粒度的访问</li><li>查询的机密性和完整性</li><li>基于安全性的云供应商原则</li></ul><p>涉及机密性、完整性、可用性。</p><p>在机密性方面，通常是在储存前在云供应商外部对数据进行编码，但这限制了云供应商的查询评估。解决方案之一是<strong>索引</strong>，使部分查询评估不需要对数据进行解码。索引是保存了部分数据属性的元数据，对索引的定义需要在精确性和隐私性方面取得平衡，<strong>精确的索引能提高查询性能，但会暴露数据信息</strong>。某些编码技术也支持直接对数据进行操作和评估，不需要解码。比如<strong>OPE</strong>和<strong>同态加密</strong>。一些加密的数据库系统支持<strong>对加密数据进行SQL查询</strong>。</p><p>一些基于云的程序（比如健康管理、社交服务等）会从多个数据源获得数据，而一些数据挖掘工具会因此挖掘到比预期更多的隐私数据，如何保护隐私性是一个挑战。对此的研究挑战是如何设计隐私保护的理论模型和实践机制。当前的研究趋势是<strong>采用机器学习分析大数据</strong>，包括威胁分析、攻击智能、病毒传播、数据关联等。</p><p>常用的保护措施是，隐私数据仅对通过加密登录的用户本身开放，但有时候需要选择性的公开一些数据给其他用户，常用的方法是：<strong>选择性加密</strong>和<strong>基于属性加密ABE</strong>。但选择性共享数据还要考虑到第三方合作共享和分布式计算的场景可能出现的问题。</p><p>有时候数据之间的关联比数据本身更加敏感，可以将数据拆分成不同部分并储存在不同的服务器中，但这会导致查询复杂度增加。</p><p>虽然<strong>选择性访问</strong>的问题已经被解决，但却会受到利用访问频率侵犯数据和用户隐私的攻击。解决方案是<strong>私有信息检索RIP技术</strong>，它涉及隐私保护索引技术：比如Oblivious RAM、B-tree结构、二分搜索树（<a href="https://ieeexplore.ieee.org/abstract/document/7830709" target="_blank" rel="noopener">参考文献</a>）。但该领域的实践性解决方案仍然是一个挑战。</p><p>关于完整性的技术有：数字签名、PDP、POR、将探测到的数据未授权修改存储在云供应商外部等。验证授权用户的数据的<strong>完整性</strong>只是其中一个方面。还有，由多用户共享数据的改变和查询引起的问题。相关的方法有确定性方法（使用认证的数据结构）和概率方法（完整性检查插入）（<a href="http://pdfs.semanticscholar.org/8cc0/0323e1907a0cf19561827fe4fa8047334e6f.pdf" target="_blank" rel="noopener">参考文献</a>），都可以代表有希望的方向，但所提供的适用性和完整性保证受到限制。</p><p>关于可用性，是如何让用户能够选择到满足其安全性需求的云供应商（云供应商的行为通常在SLAs中声明）。最近的研究有关于不同云服务特征的可能依赖的探索，但这只是第一步。</p><p>基于硬件的技术也可以保护云中的数据，最著名的是ARM TrustZone和 Intel SGX 技术。简单来说就是创建安全的执行环境。</p><p>高级持久性威胁APTs是一类新的网络攻击，特点是面向目标，高度针对性，组织合理，资金充裕，技术先进，隐秘且持久。目前缺乏足够的防御手段，以及减少损失的措施，如技术驱动或原则驱动的解决方案。</p><h5 id="研究方向-6"><a href="#研究方向-6" class="headerlink" title="研究方向"></a>研究方向</h5><p>主要研究方向是<strong>敏感数据管理</strong>。一，在简单的情况下，只需要保证数据存储的安全性，并保证对数据进行高效访问和操作。第二种情况是数据需要在多用户之间共享，并且可能存在多个提供者以提供更好的功能和安全性。</p><p>在简单的情况下，除了要保证数据的安全性，还需要<strong>可扩展性</strong>和良好的<strong>性能</strong>，且<strong>不能影响服务功能</strong>。具体来说，需要：1，能简单与当前的云技术集成；2，避免由于<u>选择性的获取数据</u>或<u>支持加密查询</u>而泄露数据；3，支持多种查询。</p><p>在第二种情况下，当有多个用户和多个云供应商时，第一个问题是设计用于选择性共享数据的解决方案，该方案支持：1，写入权限和多个写入者；2，当有多个供应商参与存储时，有效的执行策略更新；3，在参与分布式计算的各方中，选择性的共享信息，从而可以选择不安全但是更便宜的供应商。</p><p>分布式计算的执行还与<strong>隐私数据查询</strong>和<strong>数据完整性</strong>有关。相关的研究应针对开发的可扩展和高效的技术，以：1，支持不同用户并发访问；2，确保用户的活动不会造成数据库上下文泄露。</p><p>关于数据的完整性，挑战在于如何证明数据分布存储在多个云供应商时，数据的完整性。现有解决方案所提供的<u>完整性保证</u>以及<u>受支持的查询种类</u>受到限制。因此，需要设计一种通用框架来对<u>完整性的保证程度</u>进行评估，根据用户的付费来提供不同程度的保证和支持查询的类型。</p><p>雾计算和大数据对的副作用是数据的泄露的可能性变大。基于雾计算的方案中缺乏中央控制可能会引发隐私和信任问题。雾计算会假设存在可信节点和恶意节点。这需要从早期的P2P扩展到雾计算中，包括安全路由、冗余路由和信任拓扑。尽管可以把所有数据都传到数据湖中进行安全性分析，但并非所有设备都保持联网状态，并且把所有数据集中的经济成本很高。数据的种类（半/非 结构化）加剧了可扩展数据的保护问题，尤其是在大数据领域。</p><p>其他问题和<strong>大数据的来源和质量</strong>有关，数据的来源关系到数据是否可信，数据的质量对于特定领域十分重要（如医疗）。区块链可以保证数据不可变、可追溯、可验证，但由于数据不可变，也带来了新的隐私问题。</p><p>在基础设施级别，需要研究的安全性和隐私问题有：1，针对云中的多重租赁的虚拟化的正确管理；2、针对用户安全性需求的虚拟机资源的分配和取消；3，识别合法请求以处理<u>拒绝服务DoS攻击</u>和其他网络攻击，比如对云服务的协同攻击可能被错误地推断为合法流量，云会扩大资源来处理它们，导致额外的成本和能源浪费。</p><blockquote><p>Order Preserving Encryption —— OPE<br>fully (or partial) homomorphic encryption —— 全、半同态加密<br>selective encryption —— 选择性加密<br>attribute-based encryption (ABE) ——基于属性的加密<br>Private Information Retrieval (PIR) —— 私有信息检索<br>privacy-preserving indexing techniques —— 隐私保护索引技术<br>Oblivious RAM<br>Provable Data Possession —— PDP<br>Proof Of Retrievability —— POR<br>Software Guard Extensions —— SGX<br>Advanced Persistent Threats (APTs) —— 高级持久性威胁<br>selectively sharing data —— 选择性共享数据<br>Denial of Service (DoS) —— 拒绝服务</p></blockquote><h4 id="云计算的经济"><a href="#云计算的经济" class="headerlink" title="云计算的经济"></a>云计算的经济</h4><ul><li>服务级别协议和策略管理</li><li>将内部的基础设施迁移到公有云供应商</li><li>选择合适的云供应商</li><li>云的许可模型</li></ul><p>近年来，云经济学的研究主题集中在许多关键方面：1.云服务的定价；2.代理机制（搜索符合用户预算的资源）；3.监视以确定是否满足用户要求（涉及SLAs），比如WS-Agreement之类的规范的实现。</p><p>云经济学涉及SLA，而SLA管理又与<u>计算资源、实例和服务</u>的供应和需求有关，在这方面有许多关于<u>基于原则的方法</u>和相关的<u>最优化策略</u>的研究（因为缺少资源适用场景）</p><p>另一个相关的方面是如何迁移公司内部的基础设施和IT部门到云供应商。比如迁移服务需要考虑服务后续如何使用，对业务能力的影响；迁移系统需要考虑是否会影响保留在企业内部的系统功能。其中IT部门应该起到中介者的角色。</p><p>上述背景引起了新技术的出现，比如基于容器的部署（无服务器计算），使亚秒级计费成为可能，例如 Google “functions”，AWS Lambda。</p><p>使用许可是另一个问题，包括年度许可和永久许可。独立的软件供应商正在研究更适合云的许可模式，如<u>BYOL</u>，<u>完全按需</u>等。</p><p>选择合适的云供应商是另一个挑战。比较不同的云供应商十分耗时，并且难以比较。有人提出，专门平台对各个云平台进行比较，帮助用户进行选择；还有关于市场模型的研究</p><h5 id="研究方向-7"><a href="#研究方向-7" class="headerlink" title="研究方向"></a>研究方向</h5><p>容器的低开销的特性适合实时工作负载，这促进了无服务计算的普及。影响这种功能部署的经济因素，例如：（1）平均交易率与峰值交易率；（2）扩展系统上并发活动的数量，即随着用户数量的增加而运行多个并发功能；（3）基准测试不同后端硬件平台上无服务器功能的执行情况，以及该功能所需的总体执行时间。</p><p>雾计算和边缘计算为云市场带来了更多的供应商和业务模型。这类系统可称为微数据中心MDCs。业务模型包括：动态MDC发现，预先商定的MDC合约，MDC联盟，MDC—CDC交换（用户首选CDC，如果不能满足QoS目标，如延迟，则将计算外包给MDC）</p><p>使用雾计算和边缘计算资源会加剧云环境的不确定性。在不确定的情况下，设计师需要在服务质量和成本之间做出权衡。</p><p>企业内部的IT系统（比如邮件管理）迁移到云上，可能是公司获得更高专业水平的管理（比如网络安全，软件更新，可用性，维护等），但也存在信任相关的问题。从长远来看，这种迁移对风险承受能力和业务连续性意味着什么仍然不清楚。</p><p>边缘分析的相关研究。需要研究什么样的数据应该在边缘处理，什么样的数据在云数据中心处理。这也会影响收入模型。</p><p>18年已经有90多个云供应商（<a href="https://cloudharmony.com/directory" target="_blank" rel="noopener">详见</a>）。</p><blockquote><p>BYOL (bring your own license)<br>marketplace models —— 市场模型<br>Micro Data Centres (MDCs) —— 微数据中心<br>CDC —— 云数据中心</p></blockquote><h4 id="应用部署和交付"><a href="#应用部署和交付" class="headerlink" title="应用部署和交付"></a>应用部署和交付</h4><ul><li>资源的可编程性</li><li>持续传递</li><li>敏捷传递带来的技术债务积累</li></ul><p>资源的可编程性，是开发者能够对基础设施和平台进行编程控制，带来的好处比如让程序能够自动扩展，使程序能够在运行时自动修复、优化等。关键的好处是能够加速产品更新的交付。实现的关键是敏捷交付工具和基于模型的编排语言（比如 Terraform，OASIS TOSCA）。这些工具有助于自动化生命周期管理，包括持续交付和持续集成，应用程序和平台配置以及测试。</p><p>平台可编程性，开发云上的程序时，可以帮助减少软件开发的复杂度。比如用户专注于Map、Reduce任务，由中间件负责容错、任务分配的工作。当前正在研究的编程模型，关注如何处理<strong>云平台的异质性</strong>，比如将程序分布于边缘计算中的各个异质节点。当前缺乏交付框架和编程模型，将程序部署在CDC和边缘节点。因而无法在云应用中使用异构硬件，也无法使用互连云操作。</p><p>另一个挑战是应用程序的发展，加速产品更新交付会影响程序的质量。当前缺少云软件工程的研究，将传统开发和敏捷开发的优点结合。比如记录云程序的所有发行版本的性能和可靠性数据，以便更好地指导产品更新，以及自动识别违反设计模式的行为，并在测试新功能期间探索假设场景</p><h5 id="研究方向-8"><a href="#研究方向-8" class="headerlink" title="研究方向"></a>研究方向</h5><p>敏捷、连续的交付方式，通常是以降低设计质量（如遵循SLA、业务异质性、价值驱动设计）作为代价，比如，在早期设计时决定的架构有错误的风险。挑战之一是，如何在后续的开发中监控和修正云应用程序的设计和质量。目前的研究还局限于，如何定义能解决该挑战的支持方法、高级编程抽象、工具、组织过程。比如需要<u>可重用的抽象</u>来扩展现有的软件开发和交付方法。</p><p>通过<strong>基础设施即代码</strong>，使用连续交付工具自动创建，配置和管理云基础架构，这样的趋势预计将会增长。但任然缺乏专门为编写、调试、发展基础设施即代码而设计的<strong>软件工程方法</strong>。挑战在于，基础设施即代码通常是基于由不同的编程语言和脚本语言组合而成，因此需要更通用的软件质量工程工具。</p><p>专门为云定义新的架构和设计模式，使定义云产品更接近人的思维过程。该架构和模式需要考虑云的运行时的状态、容忍改变（上下文、情况、技术、SLAs）。新的架构和模式需要关注云程序的分解（即微服务），需要考虑这对安全性、性能、可靠性、和运营成本的影响。</p><p>随着无服务计算和FaaS的发展，还需要开发新的整合和控制模式，将传统的外部服务和无服务计算服务结合。比如需要新的模式辅助开发者构建 Cloudlets/swarmlets。这需要研究元控制器，实现在运行时对模型的动态无缝切换。元控制器依赖开发者设计的云软件模型。在这个方向的研究包括：模型驱动引擎，以方便推理、假设分析、监测反馈分析、以及决策。</p><p>还需要对用户的工作负载workload进行定义。关于性能、可靠性、安全性的需求需要本分解，不仅用于表达执行需求，还要能表征程序所处理的数据的属性。</p><p>集成服务的权衡因素有：1，安全性（FaaS，单个功能更易于保护和验证 VS 扩大了攻击面）；2，隐私（FaaS，基于模型的访问控制编排的好处 VS 增加了数据暴露）；3，性能（FaaS，函数级的自动扩展的好处 VS 增大网络流量和延迟）；4，成本（FaaS，单个函数调用更便宜，但提高网络花销）。</p><p>还需要设计编程模型，针对自适应、弹性、可移动、去中心化、分布式程序，提供给雾/边缘计算、互连云、物联网。<strong>功能性程序</strong>应该进行<strong>模块化</strong>的规范、编程、测试和验证。还需要对<u>不确定性程序</u>的正确性的验证和规范，比如在线机器学习算法。对于非功能性方面，可以交由中间件负责，比如容错可以是半透明的，或者有程序进行声明式控制，比如移动设备电量有限的情况下，将计算转移。</p><blockquote><p>CDC —— 云数据中心<br>infrastructure-as-code —— 基础设施即代码<br>meta-controllers —— 元控制器<br>Translucent programming models —— 半透明的编程模型</p></blockquote><h4 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h4><ul><li>服务在管理元数据上的局限性</li><li>数据管理策略和规范</li><li>管理对延迟敏感的数据流</li><li>整合流和批量数据</li></ul><p>大数据平台有多种类型，如用于互联网和企业工作负载，采用批处理+NoSQL，如Apache Hadoop；用于物联网，处理分布式数据流，如Apache Storm。</p><p><u>处理元数据（定位和使用数据）的服务</u>对<u>存储数据的服务</u>的支持不够。数据的隐私问题。广域网的延迟较高，从而影响物联网设备对低延迟处理的需求（出现边缘计算和雾计算）。数据中心里各个虚拟机之间的带宽和网络延迟，也会导致瓶颈和影响延迟敏感的数据流的处理。需要的解决方案包括，<strong>软件定义网络</strong>SDN，和<strong>网络功能虚拟化</strong>NFV。</p><p>还需要对Lambda结构的研究，以便在休息和运行时都能处理数据。Apache Flink和Spark Streaming 提供了一些早期方案。大数据系统对在弹性云上自动扩展和收缩的支持不够。</p><h5 id="研究方向-9"><a href="#研究方向-9" class="headerlink" title="研究方向"></a>研究方向</h5><p>缺乏对数据集的<strong>元数据</strong>的管理。与结构化数据仓库不同，“数据湖”的概念鼓励企业将其所有数据放入HDFS等云存储中，以便从中获取知识。但是，由于缺乏描述数据来源的<strong>元数据</strong>，因此很难挖掘数据。科学库对使用元数据有十多年的经验。</p><p>云数据中心对全球数据进行集中管理和计算，有助于安全性，也促了规模经济。但也带来了数据延迟、性能、网络带宽的挑战。而内容分发网络CDN是为变化缓慢的数据设计的（如视频、文件）。并且CDN是向附近对的CDN服务器读取内容，却缺少类似的，在边缘写入数据的机制。</p><p>如何最佳的放置数据处理程序，以及数据流的适配是难点。在此基础上，更大的挑战是如何分配带宽以满足延迟要求。</p><p>支持高级编程抽象的框架，如Apache Bean，简化了使用混合模型的大数据程序的开发和部署，但这是平台绑定的。经过如此，这也已经将常用的分析任务交给边缘资源，也促进了分布式查询。但需要找出放置任务的中间点，以同时最大程度地减少网络资源使用和延迟。另外还要研究管理资源灵活性的方法。</p><p>最后还要研究数据管理服务，以支持物联网、机器学习、区块链。物联网涉及处理流数据、高效存储、云和边缘的无缝合作。</p><p>机器学习（深度学习）的重点是高效管理以训练的模型，以及模型的快速加载和切换，以支持在线分布式分析。训练模型还需要访问大量数据集。</p><p>区块链和分布式帐本，可以改变我们管理和跟踪数据的方式。除了金融行业，它们也可以扩展为通过隐式审计线索以安全的方式存储其他企业数据。</p><blockquote><p>Software Defined Networking (SDN)<br>Network Functions Virtualization (NFV)<br>Scientific repositories —— 科学库<br>Content Distribution Networks (CDN) —— 内容分发网络<br> traffic engineering (TE) —— 流量工程</p></blockquote><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li>高能耗和缺少能源的对称性</li><li>缺少对服务质量的保证</li><li>多重租赁和可扩展性问题</li></ul><p>近年关于云网络的研究有：SDN和NFV，用于构建敏捷、灵活的可编程计算机网络，减少运营支出。还有关于扩展限制、平面空间地址、和服务的过度订阅等问题的研究，促进了一些网络结构的产生，比如VL2, PortLand, and BCube。</p><p>关于网络的挑战之一是如何使<strong>能耗与负载成比例</strong>。大多数网络组件，比如交换机、路由器等硬件本身不支持节能的功能，比如没有通信时休眠，低流量时段的链路速率调整等。</p><p>另一个挑战则关于服务质量的保证。因为没有实现<strong>性能隔离</strong>的机制，导致SLAs没有对比如带宽和延迟的保证。当前的研究有通过网络抽象层VDC<strong>对虚拟机带宽的保证</strong>（<a href="https://dl.acm.org/doi/abs/10.1145/1921168.1921188" target="_blank" rel="noopener">参考文献</a>），但没有<strong>对延迟的保证</strong>。</p><p>在<strong>混合云环境中</strong>部署虚拟集群时，虽然可以通过虚拟化技术解决资源的网络连接问题，但云提供商无法像在其自己的数据中心中那样获得对核心Internet设备的特权访问。因此，云提供商在路由和流量工程方面的灵活性在很大程度上受到限制，<strong>网络性能缺少保证</strong>。</p><p>此外，与专用的数据中心网络相比，诸如Internet之类的公用网络的性能更加不可预测和易变，这使得更难以提供有保证的性能要求。传统的WAN方法，例如用于此类网络中流量工程的多协议标签交换MPLS，由于缺乏<strong>网络全局视图</strong>，因此在带宽使用和处理对延迟敏感的流量方面也效率不高（<a href="https://dl.acm.org/doi/abs/10.1145/2486001.2486012" target="_blank" rel="noopener">参考文献</a>）。 </p><p>由于现代云数据中心的网络规模很大，因此它也同样面临着和互联网相似的问题，比如VLAN的限制，VXLAN在多播中的限制，IPV4的限制等。</p><h5 id="研究方向-10"><a href="#研究方向-10" class="headerlink" title="研究方向"></a>研究方向</h5><p>软件定义网络SDN的特征有：全局网络视野、可编程性、开放性，这些特征提供了一种研究方向，基于SDN的流量工程TE机制，应用于云数据中心网络内外。通过SDN，<strong>流量工程</strong>能更高效、智能的处理<u>动态流</u>的调度和管理。因此需要针对SDN的特性设计新的流量工程方法。</p><p>SDN可能影响云的安全性和隐私问题。虽然社区普遍认为SDN能改善网络层和应用层的安全性、可靠性，比如通过策略实施（防火墙、访问控制、中间盒），DoS攻击探测和缓解，细粒度的入侵监控，流量异常探测。但是，SDN会给范式带来改变，从而给<u>网络本身或部署在SDN网络上的服务和相关用户</u>带肋威胁。比如对SDN控制器进行单点攻击。现有的威胁也可能因此扩大，比如网络转发设备被劫持，导致影响范围扩大。</p><p>SDN技术的最新进展有望通过<u>使网络可编程</u>，并减少云提供商的资金和运营支，出来简化数据中心内部网络。但是需要进一步研究，当前用于互连云环境的方法的有效性，以及如何通过公共通信渠道使用SDN。</p><p>迄今为止，在满足应用程序的QoS要求的同时，几乎没有对虚拟网络功能（VNF）的放置和整合给予任何关注。服务链中的VNF的自动扩展也需要深入关注。VNFs提供的网络功能的性能变化受到多种因素影响，比如服务负载，底层主机过载。因此需要开发自动扩展机制，监视VNF实例的性能，并动态增减实例数量。流量工程、迁移技术、VNF放置，3种技术组合可以降低到网络通信成本。此外，自动扩展技术还应该根据服务链（而不是单个服务器）对VNF进行扩展，。</p><p>AI、ML、大数据分析在处理云计算的<u>网络</u>挑战和<u>自动化</u>方面有巨大潜力。</p><p>连接数十亿个均生成数据的设备的物联网的出现将对网络基础设施提出重大需求。随着移动设备数量的爆炸式增长，5G无线及其带宽的增加也将迫使网络容量显着扩展。尽管解决延迟和降低网络资源使用率的关键策略是边缘 / 雾计算，但是边缘/雾计算本身不足以满足所有网络需求。为了满足这种过渡的需求，需要新的产品和技术来扩展网络的带宽或承载能力，以及更快的宽带技术和光网络的进步。也需要进一步研究边缘计算和雾计算与5G的集成。</p><blockquote><p>Multi-Protocol Label Switching (MPLS) —— 多协议标签转换<br>middleboxes —— 中间盒<br>traffic anomaly detection —— 流量异常探测<br>paradigm —— 范式</p></blockquote><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><ul><li>HCI和分布式系统社区的差距</li><li>基础设施和服务的封装</li><li>生产力工具</li></ul><p>可用性是降低组织探索云服务和基础架构成本的关键因素，因为用户可以拥有更好的服务质量并提高生产力，从而减少人工支出。</p><p>云的可用性被NIST的可用性框架中突出为5个方面：能力、个人、可靠、安全、价值（<a href="https://link.springer.com/chapter/10.1007/978-3-319-20376-8_59" target="_blank" rel="noopener">参考文献</a>）。能力，与满足云消费者对云服务功能的期望有关。 个人，是允许用户和组织更改用户界面的外观和风格并自定义服务功能。 可靠，安全和价值，是与使系统在状态条件下安全、受保护地执行其功能，并分别将价值（结果）返回给用户。</p><p>对于可用性，当前的工作主要集中在将复杂的服务封装到API中，以方便用户使用，比如HPC云，研究者一直在创建服务来公开HPC应用程序，以简化其使用。</p><p>另一个方向是DevOps，它的目标是将开发（Dev）和操作（Ops）集成在一起，从而帮助更快地交付软件。在云环境中创建和部署解决方案时，DevOps提高了开发人员和运营商的生产力。 不仅要在云中构建新的解决方案，而且要简化从内部部署环境到多租户弹性云服务的旧软件迁移。</p><h5 id="研究方向-11"><a href="#研究方向-11" class="headerlink" title="研究方向"></a>研究方向</h5><p>有许多机会可以提高云环境中的可用性。例如，由于工作量/资源的波动或特性，用户仍然很难知道他们将花多少钱租用资源。具有更好估计的工具肯定会改善用户体验和满意度。由于大数据社区的最新需求，可以在云环境的不同层上进一步探索新的可视化技术，以更好地了解基础设施和应用程序行为，并向最终用户见解。</p><p>此外，用户仍然无法使用可用于运行其应用程序的资源和服务类型。资源和服务包括CPU，GPU，网络，存储，操作系统，以及PaaS中可用的所有服务。<strong>咨询系统</strong>将大大增强用户使用云资源和服务的体验，还可以建议用户应如何更有效地使用云。比如建议用户读数据进行远程传输或可视化，是否应该分配或删除资源，是否应将裸机替换为虚拟机等建议，以使Cloud易于使用且更具成本效益。</p><p>这方面的主要困难在于评估。在复杂庞大的云上，大规模设计和执行实验并非易事。</p><blockquote><p>capable, personal, reliable, secure, and valuable<br>High Performance Computing (HPC) —— 高性能计算</p></blockquote><h3 id="新兴的趋势和影响范围"><a href="#新兴的趋势和影响范围" class="headerlink" title="新兴的趋势和影响范围"></a>新兴的趋势和影响范围</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>Docker的诞生引起了各界对容器技术的关注。</p><p>容器依赖于现代Linux的内核设施，比如 cgroups, LXC (Linux containers) and libcontainer。Docker使用Linux核心的cgroups和命名空间来运行独立的容器。cgroups提供资源的隔离（如CPU、内存、网络、block I/O）。命名空间从程序的角度隔离操作环境（包括进程树、网络、用户ID、挂载文件系统）。libcontainer库作为<u>容器引用实现</u>。并将程序和相关依赖打包到容器镜像中。</p><p>容器技术在行业中的普及，促进了对容器即服务（CaaS）的需求，比如UberCloud。</p><p>容器的两大特点，一是启动速度快，甚至能低于1秒；二是容器对内存的占用量很小，消耗的资源很少。</p><p>容器的缺点是由于共享内核，因此隔离和安全比VM差（这是其中一个研究热点）。解决该问题的可能方案之一是<strong>硬件支持</strong>，比如Intel SGX的受信执行支持；二是使用Unikernel，是一种库操作系统。</p><p>容器技术的挑战是如何最优化容器性能，比如<strong>Slack技术</strong>对存储驱动最佳化，来加速容器启动。还有基于用户服务质量需求的容器集群管理，比如容器集群管理系统，Kubernetes，Mesos 和 Swarm。</p><blockquote><p>mounted file systems —— 挂载文件系统<br>container reference implementation —— 容器引用实现<br>trusted execution support of Intel SGX</p></blockquote><h4 id="雾计算"><a href="#雾计算" class="headerlink" title="雾计算"></a>雾计算</h4><p>雾计算是传统云计算模型的扩展。雾计算包括3个方面，一是使路由节点（如移动基站、网关、路由器等）执行通用目的计算；二是为路由节点添加计算能力，对传输数据进行处理；三是结合前2者。</p><p>好处之一是<strong>减少延迟</strong>，改进流式应用和实时应用的服务质量。二是<strong>位置感知</strong>。三是<strong>无缝支持可移动性</strong>，可以启用用户设备和计算服务器之间的无线访问，并可以组织可伸缩的控制系统。这些好处都适用于IoT应用。</p><p>雾计算和边缘计算的不同在于，<strong>边缘计算</strong>将计算能力提供给了IoT设备本身，而<strong>雾计算</strong>的计算节点（Dockers、VMs）则是靠近数据源。<strong>边缘计算需要IoT设备有执行代码和通信的能力，问题在于这样的接口并没有被所有的IoT设备采用</strong>。因此，雾计算似乎是迄今为止唯一可行/通用的解决方案。</p><p>雾计算尽管不能完全作为CDC，但也提供完整的IaaS，PaaS和SaaS资源堆栈。它的主要好处在于能减少延迟，预计每个城市只需要少数几个雾数据中心。从商业角度，还能使用私有云或独立的雾供应商的基础设施作为雾节点。对于<strong>移动边缘计算</strong>，它基于移动蜂窝网络，而不经过传统雾计算的路由节点</p><p>雾计算的优点包括，应用在不同计算层之间的<strong>垂直扩展性</strong>：它允许对<strong>传输数据进行提前处理</strong>，从而只有必要的流量会被发送到云数据中心。<strong>工作负载</strong>也可从云中分解下发到雾节点上，或者从边缘节点向上迁移到雾节点。在雾节点中可以使用更轻量的<strong>容器</strong>代替虚拟机。</p><p>云服务提供商已经开始建议客户使用它们提供的云接口来部署应用的存储和计算功能，以方便将来的雾节点迁移。云供应商已经开始使用边缘位置来提供<strong>更接近用户的安全服务</strong>（AWS Shield, Web Applica- tion Firewall Service）和<strong>网络流量修改</strong>（Lambda@Edge）</p><p>能够从雾计算中受益的还有智慧城市、物联网应用、多维数据（文字、音频、视频）采集、深度学习模型的在线训练和实时决策（交通信号）、无人汽车、无人机、计算和数据归档、沉浸式环境（MMORPG）、3D环境（HoloLens、Google Glass）、机器人手术。</p><p>挑战之一是<strong>与多方服务级别协议SLAs有关</strong>的复杂的管理问题，这关系到开发统一的可互操作的管理平台（<a href="https://www. edgexfoundry.org/">EdgeX Foundry项目</a>）。多个雾节点之间交互的可能性，涉及安全和隐私问题（<a href="https://www.openfogconsortium.org/" target="_blank" rel="noopener">Open Fog财团</a>）。</p><blockquote><p>MMORPG —— 大型多人在线角色扮演</p></blockquote><h4 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h4><p>大量的流数据（物联网传感器、CPS、社交网络）是人们对数据量Volume的关注转移到数据速度Velocity。比如in-memory处理数据的Spark Streaming、Flink、Kafka。</p><p>视频数据（城市监控、无人驾驶、无人机）在增长，但云计算中心的延迟和带宽有限。</p><p>与结构化数据仓库不同，“数据湖”鼓励企业将数据放到云中，但缺少对数据来源进行描述的元数据，导致数据难以被使用。</p><blockquote><p>streaming data —— 流数据<br>Cyber Physical Systems (CPS)</p></blockquote><h4 id="无服务器计算"><a href="#无服务器计算" class="headerlink" title="无服务器计算"></a>无服务器计算</h4><p>无服务器计算（功能即服务FaaS，后端即服务BaaS）是一种新兴的架构模型，极大的改变云计算应用的设计方式。与传统的三层模型（应用逻辑和数据库服务器都在云端）不同，无服务器程序的业务逻辑被迁移到了客户端，<strong>比如嵌入到app中，或者在临时分配的资源上</strong>。它的好处是不需要租用资源（如虚拟机）作为服务器运行程序。该模型隐式的处理了在VM上部署应用的挑战，如工作负载中平衡，可靠性、容错等，但也需要考虑平时不考虑的问题，如控制、灵活性、成本。</p><p>无服务器的意思是指，程序运行所需的资源由云供应商管理（而不再是由开发者租用服务器并自己管理）</p><p>无服务器计算减少了开发者的后端代码量、以及对云资源的管理。</p><p>相关的供应商有AWS Lambda，IBM OpenWhiskand，Google Cloud Functions。</p><p>在BaaS中，服务器端的逻辑由不同的云服务负责（如认证、数据库访问、消息传递）；而FaaS则使用短暂的计算资源，按访问次数计费。</p><p>FaaS中的挑战在于，云在执行功能（代码）前并不知道它所需的资源。为此，云供应商对函数的作用和执行时间有许多限制。这也在软件工程方面产生了新的挑战，需要重新设计应用程序结构以适用于该模型。尽管这会带来一些改变，比如要求程序无状态，但却能提高灵活性。与该模型相关的挑战还有<strong>基于事件的</strong>和<strong>超时感知的</strong>程序逻辑。前者是因为每个功能都能看做是对一个事件的独立响应，该事件还会触发其他事件来获取响应。后者是无服务器计算对函数的运行时间有限制，因此在设计函数时需要考虑超时问题，比如如何规避，和处理超时。</p><p>现在还没有一个成熟的<strong>通用目的</strong>的无服务器计算架构，尤其是在中间件层。</p><blockquote><p>serverless computing —— 无服务器计算</p></blockquote><h4 id="软件定义的云计算"><a href="#软件定义的云计算" class="headerlink" title="软件定义的云计算"></a>软件定义的云计算</h4><p>软件定义的云计算是一种方法，通过将虚拟化的概念扩展到数据中心的所有资源上（如计算、存储、网络），对<u>配置过程和物理资源抽象</u>的自动化和最佳化。<strong>虚拟化技术的目的是掩盖、抽象和透明地使用底层资源，而不需要程序和用户了解资源的属性</strong>。虚拟化技术在计算和存储方面已经有很大突破，当前的趋势是<strong>云的网络方面的虚拟化</strong>，即软件定义网络SDN和网络功能虚拟化NFV。</p><p><strong>软件定义网络SDN</strong>，动机是对敏捷的和高性价比的计算机网络需求，该网络还支持多重租赁。SDN主要目的是克服传统网络的限制，尤其是在多重租赁环境中，云数据中心需要提供资源，并保证资源之间相互独立、隔离。早期的CDN支持者认为网络设备的制造商不能满足他们的创新需求，还有一人则旨在通过利用商品硬件的低成本处理能力来运行其网络。</p><p>SDN将数据转发和网络控制解耦，使网络可被中心化管理和可编程。这样的拆分通过称为CDN控制器的软件，提高了<u>在逻辑上中心化网络的网络编排</u>的灵活性。SDN控制器提供了与供应商无关的开放标准（如OpenFlow），该标准为应用程序和网络服务抽象了基础结构。</p><p><strong>网络功能虚拟化NFV</strong>，是<u>网络连接</u>的另一个趋势，它将网络功能（如入侵检测、负载平衡、防火墙、网络地址翻译NAT、域名服务DNS等）从专用硬件转移到基于软件的应用上，能够在商业的架外（COTS）设备上执行。</p><p>网络服务链接，也称为<strong>服务功能链接（SFC）</strong>，是网络运营商用来建立互连的网络服务链的自动化过程。 SFC通过实例化在商品硬件上运行的纯软件服务，可以在NFV环境中组装虚拟网络功能（VNF）链。NFV环境的管理和编排是另一研究方向。</p><p>除了网络连接上的挑战，SDN和NFV还与可持续性、相互关联的云、安全性有关，比如通过OpenFlow交换机实现了可持续性，并提供了网络能耗比例（<a href="https://www.usenix.org/legacy/event/nsdi10/tech/full_papers/heller.pdf" target="_blank" rel="noopener">参考文献</a>）。</p><p>NFV的主要优点是能够让云供应商以更敏捷和灵活的方式提供网络功能服务。比如基于虚拟网络函数实例的迁移策略，减少能耗的整合算法（<a href="https://ieeexplore.ieee.org/abstract/document/7866881" target="_blank" rel="noopener">参考文献</a>）</p><blockquote><p>Software-defined networking (SDN)<br>Network functions virtualization (NFV).<br>multi-tenancy —— 多重租赁<br>data forwarding functions —— 数据转发功能<br>commercial off-the-shelf (COTS) equipment<br>network address translation (NAT)<br>domain name service (DNS)<br>service function chaining (SFC) —— 服务功能链接<br>virtual network functions (VNFs)</p></blockquote><h4 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h4><p>区块链有可追溯性、可靠性和可审计性的特点。区块链由不可改变的分布式账本ledger组成，账本分布在去中心化的网络上，账本的安全性依赖于密码学。链上的不同对象有账本的相同备份，且区块链上发生的事务需要得到所有对象的同意。</p><p>云计算对区块链的促进作用，不仅是可以持有区块链节点，还能创建服务来利用区块链。云可以将区块链服务封装到PaaS和SaaS上，来促进使用。但这也导致了可扩展性的问题。</p><p>除此之外，云在动态部署计算资源和管理存储上的特点，也是促进区块链被广泛采纳的重要因素。区块链的一个重要组件是作为平台对事务数据进行分析，而这可以和其他来源的数据混合，比如IoT、金融、天气等。</p><p>当前区块链的许多事务都是在云外发送的，如果将区块链转移到云上，那么会增大数据中心的负载，因此导致可持续性问题（主要是能耗）。负载不仅是事务本事，还包括相关的分析服务。因此，在云中处理区块链服务还需要高效的基础设施，以及满足动态的计算需求。</p><p>另一方面是区块链对云计算的促进作用。云是一个关于合作和数据交换的平台，而区块链可以构建一个更安全、可审计的事务平台。区块链和云计算可一起构建一个可信任的、可验证的数据市场，以高效的、可靠、可审核的方式交易数据。背后的原因是数据能够从AI/ML中产生价值。该领域涉及可扩展性、验证数据质量/有用性的机制、以及促进这类<u>区块链感知的数据交易机制</u>的可用性工具。</p><blockquote><p>cryptography —— 密码学</p></blockquote><h4 id="机器学习和深度学习"><a href="#机器学习和深度学习" class="headerlink" title="机器学习和深度学习"></a>机器学习和深度学习</h4><p>机器学习有助于云的资源管理的最优化，而云的计算资源（按需使用、易访问性）对机器学习服务也十分关键。</p><p><strong>自动化计算</strong>，旨在通过自动化提高计算系统的效率，它包括4个主要特征：自配置、自优化、自愈、自保护。AI的出现让这成为可能。对于云来说，这意味着以高效的方式管理工作负载、预测计算需求、估计SLA违反行为、更好的工作分配决策等。</p><p>业界已经开始为许多云服务提供<strong>自动调整技术</strong>，将运行应用程序堆栈委派给云平台，比如Azure SQL能够自动调整和清洗索引。该领域的其中一个研究方向是在机器学习的解决方案中，创建在不同环境下可重用的模型，而不是每次都从新创建模型。问题在于程序和服务本身的特点可能导致无法直接使用其他公司的资源优化方案。</p><p>云计算还能以灵活的方式为机器学习提供大规模计算资源，并且支持以大规模并行的方式训练模型。提供AI服务的平台有：IBM Watson，Microsoft Azure Machine Learning，AWS Deep Learning AMIs，Google Cloud Machine Learning Engine。</p><p>在未来，自动调整技术可能被大规模采纳（尤其是对SaaS）。此外还有，新的自动化工具的出现（半自动应用程序构建器——推荐成功案例的配置、自动化数据库分片、查询优化、智能负载平衡、服务的复制器）、基于机器学习的安全性云服务</p><blockquote><p>autonomic computing —— 自动化计算<br>auto-tuning —— 自动调整</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>跨云计算的所有服务模型（IaaS，PaaS和SaaS）将有重大发展。</p><p>在IaaS中，可以使用异构硬件（例如CPU和加速器（例如GPU和TPU））以及用于特定应用（例如HPC和深度学习）的专用云。下一代云还应该准备好接受非传统的体系结构，例如神经形态，量子计算，绝热，纳米计算等。此外，诸如容器化，SDN和Fog / Edge计算等新兴趋势将扩大研究范围。 IaaS突飞猛进。还讨论了通过利用可再生能源和基于IoT的冷却系统来解决CDC可持续性的解决方案。IaaS的新兴趋势也存在很大的余地，例如分解的数据中心，其中计算任务（例如CPU，内存和存储）所需的资源将被构建为独立的资源片，这将允许更快，更理想的资源供应来满足基于云的应用程序的不同QoS要求。为解决可伸缩性，资源管理和调度，异构性，互连云和网络挑战而提出的未来研究方向，应该能够实现由云提供的这种全面的IaaS。</p><p>同样，PaaS应该通过未来在资源管理和调度方面的研究方向取得重大进展。提出了对支持可伸缩的弹性计算和无缝使用异构资源的编程抽象，模型，语言和系统的需求，从而提高了能效，最小化了应用工程成本，提高了可移植性并确保了可靠性和性能水平。可以预见的是，对机器学习，深度学习和AI应用程序的持续热度将有助于处理通过PaaS开发的复杂性，异构性，规模和负载平衡应用程序。无服务器计算是PaaS的新兴趋势，这是一个有重大实际和经济影响的有希望探索的领域。提出了有趣的未来方向，例如功能级QoS管理和无服务器计算的经济性。此外，还将详细讨论数据管理和分析的未来研究方向以及安全性，从而为基于IoT和智能城市领域的实时流数据处理的边缘分析等具有平台支持的有趣应用提供支持。</p><p>SaaS应该主要从应用程序开发和交付以及云服务的可用性方面看到进步。需要透明的编程模型，语言和API，以解决应用程序开发的复杂性，同时允许控制将应用程序交付给下一代Cloud。在云应用程序开发期间，越来越多地采用了各种敏捷交付工具和云标准（例如，TOSCA）。未来的研究应集中在如何持续监视和迭代地发展云应用程序的设计和质量上。还建议扩展DevOps方法并定义新颖的编程抽象，以将其包括在现有软件开发和交付方法中，以支持IoT，边缘计算，大数据和无服务器计算。重点还应该放在开发有效的云设计模式和形式主义的开发上，以描述强烈鼓励应用程序处理的工作负载和工作流程，以及它们在性能，可靠性和安全性方面的要求。有趣的是，尽管技术已经成熟，但某些领域（例如移动云）仍然存在适应性问题。移动云的适应性以及设计Fog架构都需要新颖的激励机制。</p><p>因此，今后的研究应探讨云计算架构和市场模式，拥抱不确定性，并提供连续的“双赢”的决议，对于所有的参与者，包括供应商，用户和中介机构，无论是从收益上的投资回报率（ROI），并满足SLA的观点。</p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><p>&gt;</p><blockquote><p>non-volatile technologies —— 非易失性技术<br>Ad-hoc —— 特设的<br>offloading —— 分流<br>proportionality —— 对称性</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 读书笔记 </category>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算大纲</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/00%20%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%A7%E7%BA%B2/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/00%20%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li>分布式系统模型和支持技术</li><li>云计算–体系结构，服务，模型，用例</li><li>公共云、私有云、联合云</li><li>集群和数据中心的虚拟化，容器、独核</li><li>虚拟基础架构管理：OpenNebula和Openstack</li><li>资源管理和Kubernetes</li><li>云编程和软件环境</li><li>无服务器架构</li><li>云中间件和配置管理</li><li>大数据。 Mapreduce和Hadoop</li><li>服务水平协议</li><li>云经济</li><li>能源效率</li><li>安全与信任</li><li>无处不在的云和物联网</li><li>边缘计算</li></ol>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算的发展方向：物联网</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/17%20IoT%E7%89%A9%E8%81%94%E7%BD%91/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/17%20IoT%E7%89%A9%E8%81%94%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>云计算、物联网、社交网络影响着整个服务行业，也因此关系着未来互联网的演变和全球的经济。</p><p>云的生态系统需要普适性、高效性、安全性、用户接受性和值得信赖。</p><p>云是塑造未来互联网的关键：物联网和社交网络正参与着商业、政府、教育、娱乐等的各个方面</p><p><strong>《BIG SWITCH》描述了21世纪初出现的转变：</strong></p><p>更强大的电脑；无限的存储；高带宽的网络和普遍的连接（TB级的网络、宽带无线移动）；行业竞相建立大型数据中心（容量）；虚拟化有助于实现规模经济</p><p><strong>未来的网络开发存在以下技术挑战：</strong></p><p>可编程的网络结构；合并互联网、移动网络、和TV网络；基于TCP/IP的实名数据网络；智能路由和内容分布；加强安全和隐私保护</p><a id="more"></a><h4 id="云在未来互联网和社交网络中的角色"><a href="#云在未来互联网和社交网络中的角色" class="headerlink" title="云在未来互联网和社交网络中的角色"></a>云在未来互联网和社交网络中的角色</h4><p>在未来，云将会是提供网络服务的基础。未来的互联网不仅包含人和机器，还包括任何的对象或物体（物联网）</p><p>物联网的兴起：物理网应用程序必须最大化使用云，以便动态的处理和存储大规模的数据</p><p>云、物联网和社交网络正在重塑人类之间的关系，影响我们的日常生活，并且影响着全球的经济、政治系统</p><h4 id="物联网究竟意味着什么"><a href="#物联网究竟意味着什么" class="headerlink" title="物联网究竟意味着什么"></a>物联网究竟意味着什么</h4><p>Kevin Ashton将“物联网”描述为一个系统，它通过无处不在的传感器将物理世界和互联网联系在一起</p><blockquote><p>无处不在的传感器：手机、汽车、房间、门、床、椅子、建筑等任何物体</p></blockquote><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p>所有的传感器和控制端都在不断产生数据。通常这些数据是有用且私密的。因此需要一个系统来使这些设备相互沟通、管理数据，并加强适当的访问控制</p><p>而所有的通信、管理、访问控制技术，都是应用在大规模的设备网络上，因此必须是<u>可大规模扩展的</u></p><h4 id="开放协议"><a href="#开放协议" class="headerlink" title="开放协议"></a>开放协议</h4><p>当前的互联网和软件的解决方案有：</p><ul><li>接口 API：高度模块化</li><li>云：高度的分布式</li><li>面向服务的体系结构 SOA：高度解耦</li></ul><h4 id="物联网的维度"><a href="#物联网的维度" class="headerlink" title="物联网的维度"></a>物联网的维度</h4><p>任何时间相连：移动时、户内户外、白天晚上</p><p>任何地点相连：移动时、户外、户内（不在电脑上）、电脑上</p><p>任何物体相连：电脑之间、人与人（不使用电脑）、人与物（使用通用设备）、物与物</p><h4 id="无线传感器的角色"><a href="#无线传感器的角色" class="headerlink" title="无线传感器的角色"></a>无线传感器的角色</h4><p>无处不在的计算将促进各种各样的无线应用程序，包括监控宠物和家里的植物、控制程序、追踪书籍和单车等</p><h4 id="物联网的结构"><a href="#物联网的结构" class="headerlink" title="物联网的结构"></a>物联网的结构</h4><p>应用层：商品追踪、环境保护、智能搜索、远程医疗、智能交通、智能家居</p><p>网络层：云计算平台 —— 移动电信网、物联网、信息网</p><p>服务层：射频识别技术（射频标签）、传感器网络（节点）、GPS（公路地图）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd900m538xj311e0l80x3.jpg" alt="截屏2020-03-27 下午5.27.30" style="zoom:50%;" /></p><h4 id="概念图：基于云的物联网"><a href="#概念图：基于云的物联网" class="headerlink" title="概念图：基于云的物联网"></a>概念图：基于云的物联网</h4><p>无缝连接/无处不在的访问 —— 云计算 —— 基于云的物联网</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd9098ew80j30og0ie0vt.jpg" alt="截屏2020-03-27 下午5.35.49" style="zoom:50%;" /></p><h4 id="基于局部分布式云的IoT"><a href="#基于局部分布式云的IoT" class="headerlink" title="基于局部分布式云的IoT"></a>基于局部分布式云的IoT</h4><p>公有云：公开资源管理、服务质量管理、服务创新、准入控制</p><p>网络：地点管理、服务呈现、计费、身份管理、服务支持功能</p><p>本地云：本地资源管理、公有云交互</p><p>物体：资源请求、资源呈现</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd90e2iwt8j30kq0j8tds.jpg" alt="截屏2020-03-27 下午5.40.26" style="zoom:50%;" /></p><h4 id="射频识别技术-RFID"><a href="#射频识别技术-RFID" class="headerlink" title="射频识别技术 RFID"></a>射频识别技术 RFID</h4><blockquote><p><a href="https://baike.baidu.com/item/%E5%B0%84%E9%A2%91%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/9524139" target="_blank" rel="noopener">百度百科</a>：无线射频识别技术通过<a href="https://baike.baidu.com/item/无线电波/942435" target="_blank" rel="noopener">无线电波</a>不接触快速信息交换和存储技术，通过无线通信结合数据访问技术，然后连接数据库系统，加以实现非接触式的双向通信，从而达到了识别的目的，用于数据交换，串联起一个极其复杂的系统。在识别系统中，通过电磁波实现电子标签的读写与通信。根据通信距离，可分为近场和远场，为此读/写设备和电子标签之间的数据交换方式也对应地被分为负载<a href="https://baike.baidu.com/item/调制/4803375" target="_blank" rel="noopener">调制</a>和反向散射调制。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd90svv6dzj311y0j8dlx.jpg" alt="截屏2020-03-27 下午5.54.38" style="zoom: 50%;" /></p><h5 id="应用场景：物流分配中心"><a href="#应用场景：物流分配中心" class="headerlink" title="应用场景：物流分配中心"></a>应用场景：物流分配中心</h5><ol><li>通过RFID指示包裹的输送方向</li><li>通过RFID读取仓库中的库存或在运输中的包裹，同步到系统上，从而与供应链同步</li><li>通过RFID识别集装箱内的包裹，更新库存</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd914qqp3tj30zw0k8qp8.jpg" alt="截屏2020-03-27 下午6.06.03" style="zoom:50%;" /></p><h4 id="无线网络——支持普适计算"><a href="#无线网络——支持普适计算" class="headerlink" title="无线网络——支持普适计算"></a>无线网络——支持普适计算</h4><blockquote><p><a href="https://baike.baidu.com/item/%E6%99%AE%E9%80%82%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">百度百科</a>：<strong>普适计算</strong>（Ubiquitous computing（ubicomp）、pervasive computing），又称<strong>普存计算</strong>、<strong>普及计算</strong>、<strong>遍布式计算</strong>、<strong>泛在计算</strong>，是一个强调和环境融为一体的计算概念，而<a href="https://baike.baidu.com/item/计算机/140338" target="_blank" rel="noopener">计算机</a>本身则从人们的视线里消失。在普适计算的模式下，人们能够在任何时间、任何地点、以任何方式进行信息的获取与处理。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd91bg1jhpj310y0fw12e.jpg" alt="截屏2020-03-27 下午6.12.32"></p><h4 id="ZigBee-结构"><a href="#ZigBee-结构" class="headerlink" title="ZigBee 结构"></a>ZigBee 结构</h4><p>目的：监控和控制；电池：3个月-3年；网络数量：无限 ；带宽：20-150KB；范围：1-100+米；系统资源：4-32K</p><ul><li>全功能设备 FFD —— <ul><li>协调器 (ZigBee Coordinator, ZC)：<ul><li>一个ZB网络只需要1个协调器，发起网络</li><li>作为 802.15.4 2003 协议的协调器</li><li>当网络成型后，也能作为路由器</li></ul></li><li>路由器 (ZigBee Router, ZR)<ul><li>可选的组件，辅助ZC，对消息进行多跳路由</li></ul></li></ul></li><li>缩减功能设备 RFD<ul><li>终端设备 (ZigBee End Device, ZED)<ul><li>可选的网络组件</li><li>不参与路由</li></ul></li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd91m4qv31j30o60gwwjc.jpg" alt="截屏2020-03-27 下午6.22.47" style="zoom:50%;" /></p><h4 id="物联网中的云和大数据，5C-5ANY"><a href="#物联网中的云和大数据，5C-5ANY" class="headerlink" title="物联网中的云和大数据，5C+5ANY"></a>物联网中的云和大数据，5C+5ANY</h4><p>数据：存储在云中，跟随着用户和用户的设备，可随时随地访问，可被其他人共享</p><p>5C：Convergence、Contents、Computing、Communication、Connectivity</p><p>5Any：Any Time、Any Where、Any Service、Any Network、Any Object</p><h4 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h4><blockquote><p>Telecom —— 电信<br>RFID: Radio Frequency Identification Technology —— 射频识别技术<br>Antenna —— 天线</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算的发展方向：雾计算、边缘计算</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/18%20%E9%9B%BE%E8%AE%A1%E7%AE%97%E3%80%81%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E3%80%81%E5%B7%A5%E4%B8%9A4.0/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/18%20%E9%9B%BE%E8%AE%A1%E7%AE%97%E3%80%81%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E3%80%81%E5%B7%A5%E4%B8%9A4.0/</url>
      
        <content type="html"><![CDATA[<p>概述：</p><ol><li>回顾在物联网环境下，云计算的发展方向</li><li>为了阻止来自物联网的数据泛滥，在远程设备上采用智能本地数据处理成为关键：雾计算、边缘计算</li><li>本地数据处理中的虚拟化问题：以微服务和unikernels为例</li><li>工业4.0和智能工程</li></ol><a id="more"></a><h4 id="物联网家具：设备的发展前景"><a href="#物联网家具：设备的发展前景" class="headerlink" title="物联网家具：设备的发展前景"></a>物联网家具：设备的发展前景</h4><p>灯泡、冰箱、摄像头、手表、音响、显示器、扫地机器人等</p><h4 id="物联与智能产品：飞利浦照明"><a href="#物联与智能产品：飞利浦照明" class="headerlink" title="物联与智能产品：飞利浦照明"></a>物联与智能产品：飞利浦照明</h4><p>用户可以通过手机调节灯泡的亮度，调节开关；通过编程让它们：当发现进入者时闪烁，到晚上时变得昏暗</p><h3 id="雾计算"><a href="#雾计算" class="headerlink" title="雾计算"></a>雾计算</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>物联网应用和设备在持续激增，而旧的数据仓库模型：无法跟上物联网设备创建数据的速度和体积，也无法满足用户对低延迟响应时间的要求。但将数据发送到云上进行分析同样会带来风险：比如数据拥堵，安全问题等。网络数据传输的增长会导致数据拥堵的问题，而新的商业模型要求数据分析的时间少于1分钟（在某些情况下甚至要少与1秒）</p><h4 id="雾计算——思科架构"><a href="#雾计算——思科架构" class="headerlink" title="雾计算——思科架构"></a>雾计算——思科架构</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeq44w8ybj30tq0ca7cv.jpg" alt="截屏2020-04-01 下午5.18.16" style="zoom:50%;" /></p><p>雾平台：在网络边缘布置的密集型计算结构</p><p>特点：低延迟、位置感知、可通过无线访问使用</p><p>优点：实时分析、优化安全性</p><p>例子：</p><ol><li>智能交通信号灯系统，可基于当前的交通监控状况改变它的信号</li><li>数据可以发送到云端，用于长期分析</li></ol><p>在许多行业中，术语<u>边缘计算</u>和<u>雾计算</u>是可交互使用的，它们都涉及将<u>智能（计算处理数据的能力）</u>下发到离数据源更近的地方（泵、传感器、发动机、继电器），它们的根本区别在于<u>智能</u>到底安置在哪：</p><ul><li>雾：将<u>智能</u>发送到网络结构中的<u>局域网级别</u>，在雾节点或物联网网关中处理数据</li><li>边缘：将<u>智能、处理能力、通信能力</u>发送到边缘网关，或直接应用在设备本身（如可编程的自动化控制器 PACs）</li></ul><h3 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h3><p>在该结构中，数据可被处理，包括监控、分析、去重、缓存。</p><p>在该结构中，还需要考虑4个问题：1. 带宽，2. 网络能源，3.吞吐量，4. 数据存储；其他的开放新问题包括：</p><ol><li>便携性</li><li>能源效率</li><li>硬件结构的异构性</li><li>安全性</li><li>虚拟化</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeqp0e6pzj30no0ni7b8.jpg" alt="截屏2020-04-01 下午5.38.22" style="zoom:50%;" /></p><h4 id="1-可移动的边缘计算-Mobile-Edge-Computing-MEC"><a href="#1-可移动的边缘计算-Mobile-Edge-Computing-MEC" class="headerlink" title="1. 可移动的边缘计算 Mobile Edge Computing, MEC"></a>1. 可移动的边缘计算 Mobile Edge Computing, MEC</h4><p>在蜂窝网络或任何网络的边缘，启用云计算能力和通信技术服务环境的，一种网络结构。它的基本思想是与边缘计算和雾计算类似，即在接近蜂窝用户的地方运行程序和处理相关任务，从而缓解网络拥堵，提高性能。云不直接接收用户的数据，而是接收经过MEC节点处理后的少量数据。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gder2aip6dj30ts0l2dt4.jpg" alt="截屏2020-04-01 下午5.51.06" style="zoom:50%;" /></p><h4 id="2-低能耗计算案例"><a href="#2-低能耗计算案例" class="headerlink" title="2. 低能耗计算案例"></a>2. 低能耗计算案例</h4><p>该技术的关键在于如何使<u>本地处理数据的智能设备</u>使用最少的能源。目前，<u>低功耗和低能耗</u>仍然是物联网连接的智能对象的挑战。</p><p><u>性能</u>的表现由，除了速度之外的，非功能性部分组成，比如：能耗、可靠性、时间需求等</p><p>能源效率应该从三个方面考虑：</p><ol><li>系统级别：比如使用本地计算，而不是将数据传输到外部；通信是能源浪费的主要因素</li><li>设备级别：考虑到设备的异质性，使用在节能的结构</li><li>语言级别：避免数据通信，确保数据的本地性</li></ol><h4 id="3-硬件结构的异质性"><a href="#3-硬件结构的异质性" class="headerlink" title="3. 硬件结构的异质性"></a>3. 硬件结构的异质性</h4><p><u>异质的并行化结构</u>已经收到了相当大的关注，它的好处在于能够高效的运行程序和传递服务，并且在一个系统中组合了不同种类的处理器，从而优化了绝对性能和降低能耗</p><p>于是出现了新的平台，它们将多核CPUs、多核GPUs，和一系列的附加设备合并为一个单独的解决方案。它们的特点是高度的多样化，在混合的环境中操作，以及使用环境十分广泛（从超级计算机到个人智能手机）</p><h4 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4.安全问题"></a>4.安全问题</h4><p>将物理网设备中的敏感数据（医疗数据、个人跟踪数据、视频、财务数据等）从数据源（家庭、企业等）中发送出去，可能会导致隐私泄露、声誉受损、数据盗窃等问题。除此之外还需要考虑传输成本，如带宽消耗、处理成本、存储成本。</p><p>解决方案应该专注于保护设备、网络和使用时的安全：物理层的安全性、设备保护、密码保险、泄露预防、基础设备的安全性、数据传输时的安全性、平台安全性</p><h4 id="5-虚拟化：以微服务为例"><a href="#5-虚拟化：以微服务为例" class="headerlink" title="5. 虚拟化：以微服务为例"></a>5. 虚拟化：以微服务为例</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdes9a0hvfj30wq0g8acv.jpg" alt="截屏2020-04-01 下午6.32.26" style="zoom:50%;" /></p><p>微服务是一个结构模型，它以服务为粒度，将其拆分为多个分布的单元（小的服务），多个自治的服务相互合作，各个服务之间相互解耦，并且通过接口和协议（如HTTP）进行访问</p><h5 id="部署选项"><a href="#部署选项" class="headerlink" title="部署选项"></a>部署选项</h5><p>微服务可以是从<u>需要专用硬件</u>到<u>仅仅是软件包</u>。其中部署在容器上（如Docker）是在效率和管理方面都比较理想的选择（包含虚拟机的大部分优点，但比虚拟机的损耗更低）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdesj02pl5j30eg0m2di1.jpg" alt="截屏2020-04-01 下午6.41.48" style="zoom:33%;" /></p><h5 id="以-Unikernels-独立核心为例"><a href="#以-Unikernels-独立核心为例" class="headerlink" title="以 Unikernels 独立核心为例"></a>以 <a href="http://dockone.io/article/855" target="_blank" rel="noopener">Unikernels</a> 独立核心为例</h5><p>Unikernel简单来说就是<strong>删除应用与硬件中间多余的部分，只保留运行程序所需的最小依赖的库和栈模块的操作系统镜像</strong>。</p><p>由于Unikernel只实现了传统操作系统中的最低限度功能，因此极度轻量，允许在日常硬件上实现高密度部署。Unikernel还可以运行自己的<u>服务</u>，这些服务在需求出现时诞生，并在需求消失后立即消失，其中一些短暂的<u>微服务</u>的寿命可能以秒为单位，甚至是几分之一秒。Unikernel是<strong>即时计算服务</strong>，仅在有工作要做时存在，因此可以最大限度地利用计算基础架构。</p><p>但是当应用和配置需要更新，我们需要重新编译你的源码来生成新的Unikernel并部署新版本。如果是新的安全升级，也同样需要重新编译和部署。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdet1tpmvmj30tu0fggts.jpg" alt="截屏2020-04-01 下午6.59.54" style="zoom:50%;" /></p><h3 id="工业4-0"><a href="#工业4-0" class="headerlink" title="工业4.0"></a>工业4.0</h3><p>在工业4.0中，各个行业中的计算机和自动化将以全新的方式融合在一起，比如机器人远程连接到具备机器学习算法的计算机系统，而机器学习算法只需很少的人工操作即可学习和控制机器人。</p><p>工业4.0引入了<u>智能工厂</u>的概念，其中,<u>网络物理系统</u>监视工厂的物理上处理，并做出非中心化的决策</p><p>物理系统成为物联网，通过无线网络，实时地，在系统间相互通信，并与人类进行协作。</p><h4 id="工业4-0的六大设计原则"><a href="#工业4-0的六大设计原则" class="headerlink" title="工业4.0的六大设计原则"></a>工业4.0的六大设计原则</h4><ul><li><p>互操作性：<u>网络物理系统</u>（即工件载体，装配站和产品）、人类和智能工厂通过物联网相互连接和通信的能力</p></li><li><p>虚拟化：通过将传感器数据（来自监视物理上的处理过程）与虚拟工厂模型和仿真模型进行连接，以此创建的<u>智能工厂的虚拟副本</u></p></li><li><p>去中心化：智能工厂内的<u>网络物理系统</u>有自行决策的能力</p></li><li><p>实时功能：具有收集和分析数据并立即提供见解的能力</p></li><li><p>服务导向：通过<u>Internet of Services</u>提供（网络物理系统、人类和智能工厂的）服务</p></li><li><p>模块化：当对模块的需求发生改变时，智能工厂可以灵活地适应。</p></li></ul><h3 id="相关数据"><a href="#相关数据" class="headerlink" title="相关数据"></a>相关数据</h3><blockquote><p>pump——泵<br>motor——发动机<br>relay——继电器<br>energy efficient——节能<br>data-in-transit——传输中的数据<br>overhead——损耗<br>Cyber-Physical Systems —— 网络物理系统</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> 无处不在的云 </tag>
            
            <tag> 雾计算 </tag>
            
            <tag> MEC </tag>
            
            <tag> 微服务的虚拟化 unikernels </tag>
            
            <tag> 工业4.0 </tag>
            
            <tag> 边缘计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用embedding vector表达时间线上的诊断记录</title>
      <link href="/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/09%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E7%94%A8embedding%20vector%E8%A1%A8%E8%BE%BE%E6%97%B6%E9%97%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E8%AF%8A%E6%96%AD%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/09%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E7%94%A8embedding%20vector%E8%A1%A8%E8%BE%BE%E6%97%B6%E9%97%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E8%AF%8A%E6%96%AD%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>（E. Choi, et al., “Medical Concept Representation Learning from Electronic Health Records and its Application on Heart Failure Prediction,” arXiv, 2016.）</p><p>该论文展示了如何用embedding vector表达<u>时间线上的诊断记录</u></p><p>并比较了应用在4中机器学习方法中的效果：</p><ul><li>Logistic Regression</li><li>Multilayer Perceptron (MLP) - uses two fully connected layers</li><li>Support Vector Machine (SVM)</li><li>K-Nearest Neighbours (KNN)</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> embedding vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务级别协议</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/14%E6%9C%8D%E5%8A%A1%E7%BA%A7%E5%88%AB%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/14%E6%9C%8D%E5%8A%A1%E7%BA%A7%E5%88%AB%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="服务质量QoS-和-服务级别协议SLAs"><a href="#服务质量QoS-和-服务级别协议SLAs" class="headerlink" title="服务质量QoS 和 服务级别协议SLAs"></a>服务质量QoS 和 服务级别协议SLAs</h4><blockquote><p>QoS是描述服务质量的属性</p><p>SLA是保证服务质量的实施方法之一，他是供应商和使用方双方的协定</p></blockquote><p>服务质量：QoS：一个（系统）元素（如应用程序、作业、服务）具有<u>一定程度的保证</u>可以满足其<u>服务要求</u>的能力。</p><ul><li>比如使用Google搜索，我搜索的响应在1s内，那么谷歌搜索的QoS是有保障的，或者说我得到了服务质量</li></ul><p>云计算使用者所强调的核心缺陷，包括：</p><ul><li>默认提供“尽最大努力”的服务<ul><li>QoS使得服务提供商尽最大的努力提供服务，但不做任何保证。</li></ul></li><li>QoS =&gt; 随着时间的推移，保证资源使用</li><li>性能、安全、信任、成本</li></ul><p>所以引出了服务级别协议，来解决了缺陷：</p><ul><li>定义了商业关系</li><li>专注于<u>服务质量感知</u>中间件/系统的开发</li></ul><h4 id="服务提供商和SLAs"><a href="#服务提供商和SLAs" class="headerlink" title="服务提供商和SLAs"></a>服务提供商和SLAs</h4><p>服务提供商必须保证SLA，但对采用SLA持谨慎态度。因为服务提供商不得不面对一些商业风险，比如由于【故障】、【拒绝服务攻击】、【过载】等导致SLA违规和惩罚。</p><p>服务供应商是否应该提供SLA，考虑：</p><ul><li>要提供的QoS级别？</li><li>是否有足够的资源来执行服务？</li><li>是否有容错能力？</li><li>要采取的行动？</li></ul><h4 id="问题：（云）管理域"><a href="#问题：（云）管理域" class="headerlink" title="问题：（云）管理域"></a>问题：（云）管理域</h4><p>分布式系统中的【QoS预留】要求资源状态为：已设置、已存储、已维护</p><p>状态信息：是什么？在哪里？什么时候？有多少？</p><p>通用问题：</p><ul><li>缩放scaling</li><li>会计/收费</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9n5t7i71j30jq0cy0tw.jpg" alt="截屏2020-05-29 下午2.28.48" style="zoom:33%;" /></p><p>局部范围 A&lt;=&gt;B</p><p>非局部范围 A&lt;=&gt;C</p><h4 id="什么是服务级别协议SLA"><a href="#什么是服务级别协议SLA" class="headerlink" title="什么是服务级别协议SLA"></a>什么是服务级别协议SLA</h4><p>双方之间动态建立和管理的关系</p><p>目标是在协议的范围内由其中一方【交付服务】</p><ul><li>交付的内容包括：服务的功能和非功能属性。</li><li>交付内容的管理包括：协议双方的角色，权利和义务</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>在特定功能（服务）规定的上下文中，客户与提供者之间的关系如下：</p><ul><li>需要区分：【寻找合适的供应商】（P2P搜索、服务发现）和【建立SLA】（下图）</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9n7puw0hj30p80coabk.jpg" alt="截屏2020-05-29 下午2.30.49" style="zoom:50%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9na53zadj30ow0i4dht.jpg" alt="截屏2020-05-29 下午2.33.09" style="zoom:50%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9nansvd5j30vm0iawh4.jpg" alt="截屏2020-05-29 下午2.33.39" style="zoom:50%;" /></p><p>变体：</p><ul><li><p>多供应商SLA：单个SLA分布在多个提供商之间（例如，工作流程组成）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9nctgdonj30hu0a6wf8.jpg" alt="截屏2020-05-29 下午2.35.42" style="zoom:50%;" /></p></li><li><p>SLA依赖：为了使SLA有效，必须达成另一个SLA（例如，共同分配）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9nekzw2cj30du08y3z1.jpg" alt="截屏2020-05-29 下午2.37.23" style="zoom:50%;" /></p></li></ul><h4 id="例子：Amazon-EC2-SLAs"><a href="#例子：Amazon-EC2-SLAs" class="headerlink" title="例子：Amazon EC2 SLAs"></a>例子：Amazon EC2 SLAs</h4><p><a href="http://aws.amazon.com/ec2/sla/" target="_blank" rel="noopener">详细内容</a></p><p>此Amazon EC2服务级别协议（“ SLA”）是一项政策，用于管理Amazon Elastic Compute Cloud（“ Amazon EC2”）和Amazon Elastic Block Store（“ Amazon EBS”）的使用，服从Amazon Web Services客户协议（简称“ AWS协议”）的条款，条款双方为AWS公司和AWS服务用户。</p><p>Amazon EC2 SLAs 所包含的内容有：</p><ul><li>服务承诺和定义</li><li>服务积分的获得和使用范围</li><li>Amazon EC2 SLA排除项</li></ul><h4 id="服务级别协议-SLA"><a href="#服务级别协议-SLA" class="headerlink" title="服务级别协议 SLA"></a>服务级别协议 SLA</h4><p>【服务级别协议】是在两个组织（服务提供商和客户）之间的业务关系中存在的对期望和义务的明确声明。</p><ul><li>Purpose：描述协议的预期目标</li><li>Parties：参与协议或与协议有利益或目的的各方</li><li>Scope：协议涵盖的区域</li><li>SLObjectives：可以保证的度量指标以及要维持的指标水平</li><li>State：描述SLA的当前状态</li><li>Exclusions：什么不包括，例如，工作监控，保留或调整</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9o2gyfuuj30ey0akdh5.jpg" alt="截屏2020-05-29 下午3.00.24" style="zoom:67%;" /></p><div class="table-container"><table><thead><tr><th></th><th>描述</th></tr></thead><tbody><tr><td>Purpose</td><td>保证运行云计算密集型应用程序<br/>确保满足用户要求</td></tr><tr><td>Parties</td><td>用户，经纪人，资源</td></tr><tr><td>Scope</td><td>计算服务</td></tr><tr><td>Service Level Objectives (SLO)</td><td>资源可用性<br/>属性：CPU数量，CPU类型，CPU速度，RAM，存储，操作系统和版本</td></tr><tr><td>Service Level Indicators (SLI)</td><td>资源可用性和每个属性的值（详见WS-Agreement小节图）</td></tr><tr><td>Exclusions</td><td>指定所提供的服务等级，例如 服务监控/预订/适应</td></tr><tr><td>Administration</td><td>通过重新协商/适应资源来实现SLA的目标</td></tr></tbody></table></div><h4 id="SLA的内容"><a href="#SLA的内容" class="headerlink" title="SLA的内容"></a>SLA的内容</h4><p>在一定时间内必须达到指定数量和质量的资源才能达到预期的性能</p><ul><li>在从资源【所有者】到【请求者】的定义时间间隔内，委派特定资源功能</li></ul><p>比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9o60u019j30vs0dgtca.jpg" alt="截屏2020-05-29 下午3.03.48" style="zoom: 50%;" /></p><h4 id="服务级别协议的生命周期"><a href="#服务级别协议的生命周期" class="headerlink" title="服务级别协议的生命周期"></a>服务级别协议的生命周期</h4><ul><li>􏰀确定供应商：完成发现阶段􏰀</li><li>定义SLA：定义要求的内容</li><li>同意SLA条款：就服务水平目标达成协议</li><li>监控违反SLA的行为：􏰉确认【服务水平目标 SLO】是否被违反</li><li>销毁SLA：SLA过期</li><li>违反SLA的处罚</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9oi9jo0wj30w00l0wk2.jpg" alt="截屏2020-05-29 下午3.15.30" style="zoom:50%;" /></p><h4 id="SLA语言"><a href="#SLA语言" class="headerlink" title="SLA语言"></a>SLA语言</h4><ul><li>WSLA（IBM）：Web Service Level Agreements</li><li>WSML（HP）：Web Services Management Language</li><li>WSAS（Apache）：Web Services Application Server</li><li>WS-Agreement：the Open Grid Forum 提出的标准</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9oqe3j16j30je0d741l.jpg" alt="截屏2020-05-29 下午3.22.54" style="zoom: 67%;" /></p><p>（2012）</p><h4 id="WS-Agreement"><a href="#WS-Agreement" class="headerlink" title="WS-Agreement"></a>WS-Agreement</h4><p>Context：有关协议的信息</p><ul><li>发起方、响应者、到期时间</li></ul><p>Service Terms：关于服务的信息</p><ul><li>服务描述条款（通常每个域之间都是独立的）</li></ul><p>Guarantee Terms：关于服务级别信息</p><ul><li>服务水平目标，有效的协议资格条件，处罚条款等</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9oyrnd4vj30wa0dy77k.jpg" alt="截屏2020-05-29 下午3.30.59" style="zoom:50%;" /></p><p>WS-Agreement的实现有：</p><ul><li>wsag4j: Web Services Agreement for Java</li><li><a href="http://www.optimis-project.eu" target="_blank" rel="noopener">OPTIMIS project</a></li></ul><h4 id="动态SLAs"><a href="#动态SLAs" class="headerlink" title="动态SLAs"></a>动态SLAs</h4><p>静态协议</p><ul><li>确定服务【描述条款】、【保证条款】和【服务水平目标SLO】</li></ul><p>动态协议</p><ul><li>确定服务【描述条款】、【保证条款】、【服务水平目标SLO】以及【重新商讨】的可能性</li><li>【描述条款】、【服务水平目标】：定义为范围或功能</li></ul><h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9p9rnv6aj30s00hsacr.jpg" alt="截屏2020-05-29 下午3.41.58" style="zoom: 50%;" /></p><p>􏰀反馈控制机制和决策</p><ul><li>􏰓反馈报告资源的当前状态：CPU，内存，存储，网络</li><li>【QoS管理器】处理反馈</li><li>一些反馈可能需要采取措施<ul><li>SLA是否仍满足？</li><li>是否会违反SLA？</li></ul></li><li>􏰓反馈可能会导致应用程序执行的更改<ul><li>例如：工作迁移</li></ul></li></ul><h4 id="Monitor-Analyse-Plan-Execute-MAPE-方案"><a href="#Monitor-Analyse-Plan-Execute-MAPE-方案" class="headerlink" title="Monitor-Analyse-Plan-Execute (MAPE) 方案"></a>Monitor-Analyse-Plan-Execute (<strong>MAPE</strong>) 方案</h4><p>自动计算：分布式计算资源的自我管理特性，适应变化，同时向用户隐藏复杂性</p><p>Self-* system：系统不断检查并优化其状态，并自动适应不断变化的条件</p><p>根据控制回路可以对自主组件进行建模：</p><ul><li>􏰉传感器（用于自我监控）</li><li>效应器（用于自我调节）</li><li>基于<u>自我感知</u>和<u>环境感知</u>的<u>知识</u>和<u>规划器/适配器</u>，用于探索策略</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9pqapwbqj30dg0akafo.jpg" alt="截屏2020-05-29 下午3.57.52" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QoS </tag>
            
            <tag> SLA </tag>
            
            <tag> SLO </tag>
            
            <tag> SLI </tag>
            
            <tag> MAPE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>能源效率 Energy efficiency</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/13%20%E8%83%BD%E6%BA%90%E6%95%88%E7%8E%87/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/13%20%E8%83%BD%E6%BA%90%E6%95%88%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>【能源energy】：用于完成特定任务的物理货币。可以是各种形式，例如 电气，机械</p><p>【功率power】：瞬时能量使用率，或等效的概念</p><p>【能源】和【功率】关系：能量 = 平均功率 x 时间</p><p>【能源效率 EE】：单位能耗所完成工作的比例。在计算中，能源总是以电的形式传递</p><a id="more"></a><h4 id="环境影响"><a href="#环境影响" class="headerlink" title="环境影响"></a>环境影响</h4><ul><li>《时代》杂志报道说，从Youtube数据中心播放1分钟的视频需要花费0.0002kWh的能源。</li><li>通过Internet下载1MB，平均消耗0.01kWh的能量。</li><li>1分钟的视频流，互联网设备的平均能耗约为0.001kWh</li><li>2016年，数据中心，消耗了3%的全球电量供应，贡献了2%的全球碳排放</li><li>2017年，全球数据中心使用的电能为416.2兆瓦时，英国总耗电量大约300兆瓦时。<ul><li>数据中心使用的能源量可能每5年翻一番</li></ul></li><li>据估计，到2020年，IT部门将成为全球能耗最高的行业</li><li>苹果在北卡罗来纳州投资10亿美元新建的“ iDataCenter”，估计将需要多达25万套欧盟房屋（<a href="http://www.datacenterknowledge.com/the-apple-data-center-faq/" target="_blank" rel="noopener">链接</a>）</li><li>另一家云提供商在瑞典最北端（Lulea）建立了一个大型数据中心<ul><li>距北极圈70英里，84英亩的场地可容纳数万台计算机服务器</li><li>仍然需要500个巨大的风扇来冷却它们</li></ul></li></ul><h4 id="数据中心的能耗分布"><a href="#数据中心的能耗分布" class="headerlink" title="数据中心的能耗分布"></a>数据中心的能耗分布</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf8zudfqwlj31200k0h3x.jpg" alt="截屏2020-05-29 上午1.02.11" style="zoom:50%;" /></p><p>计算资源，尤其是服务器，是<u>复杂、不断发展的系统</u>的核心！</p><blockquote><p>Computer Rm. AC = Computer Room Air Conditioning</p></blockquote><h4 id="低效率链"><a href="#低效率链" class="headerlink" title="低效率链"></a>低效率链</h4><p>过去，通常会投入更多的财务资源来添加其他服务器，网络设备和存储，以确保正常运行时间和安全性。现由于缺乏物理空间，电源，冷却资源和资金而具有挑战性</p><p>计算效率低 =&gt; 需要更多服务器 =&gt; 服务器效率低 =&gt; 需要更多能源和冷却 =&gt; 能源和制冷效率低 =&gt; 更大的能耗</p><h4 id="功率、能源、和资源效率"><a href="#功率、能源、和资源效率" class="headerlink" title="功率、能源、和资源效率"></a>功率、能源、和资源效率</h4><p>【能源energy】：用于完成特定任务的物理货币</p><ul><li>可以是各种形式，例如 电气，机械</li></ul><p>【功率power】：瞬时能量使用率，或等效的概念</p><p>【能源】和【功率】关系：能量 = 平均功率 x 时间</p><p>【能源效率 EE】：单位能耗所完成工作的比例</p><ul><li>在计算中，能源总是以电的形式传递</li><li>单位：能源小时瓦数；功率瓦特</li></ul><blockquote><p>EE = Work Done / (Power x Time)</p><p>EE = Work Done / Energy</p><p>EE = Performance / Power</p></blockquote><h4 id="功率感知计算（节能方案）"><a href="#功率感知计算（节能方案）" class="headerlink" title="功率感知计算（节能方案）"></a>功率感知计算（节能方案）</h4><p>优化能耗，对应于云结构的不同层：</p><ul><li>硬件：DVFS（动态电压和频率缩放）冷却系统</li><li>操作系统：省电技术</li><li>节能软件设计</li><li>数据中心：关闭空闲的(idle)服务器；虚拟机整合；虚拟机调度</li><li>虚拟化：Xen Hypervisor</li><li>节能网络协议（Energy efficient network protocols）</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf90got2xej31100n8n4f.jpg" alt="截屏2020-05-29 上午1.23.38" style="zoom:50%;" /></p><h4 id="数据中心设计"><a href="#数据中心设计" class="headerlink" title="数据中心设计"></a>数据中心设计</h4><p>需要考虑：</p><ul><li>性价比</li><li><p>数据中心布局</p></li><li><p>冷却系统</p></li><li>服务器架构</li><li>通过冗余实现可靠性</li><li>网络I / O</li><li>交互式和批处理工作负载</li><li>服务器生命周期（约18个月）</li></ul><h4 id="衡量数据中心的效率：PUE"><a href="#衡量数据中心的效率：PUE" class="headerlink" title="衡量数据中心的效率：PUE"></a>衡量数据中心的效率：PUE</h4><p>【功率利用效率 Power Utilization Effectiveness (PUE)】：设施总功率/ IT设备功率</p><ul><li>2016年PUE中位数为1.69，2018年为1.1</li></ul><p>【性能 Performance】：延迟是重要的指标，因为它可以被用户看到</p><ul><li>服务水平目标（SLO）/ 服务水平协议（SLA）</li><li>比如99%的请求的响应时间必须低于100ms</li></ul><h3 id="节能方案"><a href="#节能方案" class="headerlink" title="节能方案"></a>节能方案</h3><h4 id="DVS-Dynamic-Voltage-Scaling-动态电压缩放"><a href="#DVS-Dynamic-Voltage-Scaling-动态电压缩放" class="headerlink" title="DVS (Dynamic Voltage Scaling) 动态电压缩放"></a>DVS (Dynamic Voltage Scaling) 动态电压缩放</h4><ul><li>通过降低电源电压来降低动态能耗，但会降低性能</li><li>最近的处理器已经支持这种技术，来<u>动态调节电源电压</u>。</li><li>动态能源损耗 = <script type="math/tex">\alpha</script> <em> Vdd<script type="math/tex">^2</script> </em> Ncycle<ul><li>Vdd：供应电压</li><li>Ncycle：时钟周期数</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf90zocoyoj30rq07y0th.jpg" alt="截屏2020-05-29 上午1.41.55" style="zoom:50%;" /></p><h5 id="基于DVFS的能源感知调度"><a href="#基于DVFS的能源感知调度" class="headerlink" title="基于DVFS的能源感知调度"></a>基于DVFS的能源感知调度</h5><p>【动态电压和频率缩放 Dynamic Voltage and Frequency scaling (DVFS)】：电源管理技术，通过降低处理器的时钟频率，使得电源电压也能够相应的降低。</p><p>动机是：</p><ul><li>开发【资源管理和调度算法】，目标是最小化能耗，并在工作截止日期之前完成</li><li>探索其中一个工业发展方向——实用程序模型/基于SLA的云计算资源分配</li></ul><h4 id="服务器整合"><a href="#服务器整合" class="headerlink" title="服务器整合"></a>服务器整合</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf91i9bw12j30ve066q3d.jpg" alt="截屏2020-05-29 上午1.59.47" style="zoom:50%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf918dto4kj30oc0n80w1.jpg" alt="截屏2020-05-29 上午1.50.16" style="zoom:50%;" /></p><ul><li>大多数服务器利用率低于5％</li><li>空闲服务器最多可消耗服务器最大能量输出的70％</li></ul><p>当关闭服务器时，我们需要考虑</p><ul><li><p>它会打破【冷热通道hot-cold aisle】</p><blockquote><p>热通道/冷通道配置的目标是通过管理气流来节省能源并降低冷却成本。 在最简单的形式中，热通道/冷通道数据中心设计涉及将服务器机架排成一行，其中冷气入口朝向一种方式，而热空气排放朝向另一种方式。</p></blockquote></li><li><p>当需要时，它们无法及时启动</p></li><li><p>系统管理员不确定如何有效使用</p></li></ul><h4 id="虚拟化和调度"><a href="#虚拟化和调度" class="headerlink" title="虚拟化和调度"></a>虚拟化和调度</h4><p>虚拟化：</p><ul><li>在单个服务器上允许许多应用程序。</li><li>更明智地规划和分配资源。</li></ul><p>调度和迁移：</p><ul><li><p>可以避免/最小化数据中心热点</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf91k84vl2j30ks0badwe.jpg" alt="截屏2020-05-29 上午2.01.35" style="zoom: 33%;" /></p></li><li><p>但迁移需要额外的成本和精力</p></li></ul><h3 id="调度问题和解决方案"><a href="#调度问题和解决方案" class="headerlink" title="调度问题和解决方案"></a>调度问题和解决方案</h3><p>何时迁移：</p><ul><li>Host overload detection algorithms</li><li>Host underload detection algorithms</li></ul><p>迁移哪个：</p><ul><li>VM selection algorithms</li></ul><p>迁移到哪：</p><ul><li>VM placement algorithms</li></ul><h4 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h4><p>使用大数据技术来识别低效点</p><ul><li>服务器体系结构类型表现出不同的资源效率低下。 <ul><li>CPU浪费4.33-14.22％，内存浪费1.29-7.61％</li></ul></li><li>使用大数据分析来识别，在特定的服务器和服务器类型中，资源利用率的潜在改进领域。</li><li>可以使用数据中心基础结构管理器（DCIM）进行监视。</li></ul><h5 id="用户资源估计"><a href="#用户资源估计" class="headerlink" title="用户资源估计"></a>用户资源估计</h5><p>用户总是高估自己的需求（以防万一，天真），从而浪费大量空闲资源</p><p>为此，供应商可以使用超额配置（类似于超额预订航班座位）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf91tot5s1j30rg0es78k.jpg" alt="截屏2020-05-29 上午2.10.46" style="zoom:50%;" /></p><h5 id="政策方针"><a href="#政策方针" class="headerlink" title="政策方针"></a>政策方针</h5><p>社会执行与政策</p><ul><li>许多公司希望被视为“绿色”</li><li>强制要求<u>限制数据中心能源成本</u>的压力越来越大</li></ul><p>当前，需求胜过储蓄</p><ul><li>Jevons悖论 = 效率高导致使用量增加</li><li>实际上，越容易消费产品，消费量就越大（效率低导致使用量大）</li></ul><h4 id="能源效率与软件设计"><a href="#能源效率与软件设计" class="headerlink" title="能源效率与软件设计"></a>能源效率与软件设计</h4><p>是否可以在考虑能源的情况下，构建现有基础架构，中间件和服务应用程序？</p><p>我们可以将软件设计与运营中的能源消耗联系起来吗？</p><ul><li>在需求/设计阶段，考虑节能的服务应用</li><li>与新颖的<u>软件、平台和基础架构组件</u>合作的服务应用</li></ul><h4 id="电源管理分类法"><a href="#电源管理分类法" class="headerlink" title="电源管理分类法"></a>电源管理分类法</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf92adr0k4j30z00bymyn.jpg" alt="截屏2020-05-29 上午2.26.48" style="zoom:50%;" /></p><h4 id="迈向绿色云计算：云提供商的措施"><a href="#迈向绿色云计算：云提供商的措施" class="headerlink" title="迈向绿色云计算：云提供商的措施"></a>迈向绿色云计算：云提供商的措施</h4><p>云服务提供商需要采取措施，以确保由于高昂的能源成本而不会大幅降低其利润率。</p><ul><li>亚马逊估计其数据中心与能源有关的成本占总预算的42％，其中包括直接用电和在15年内摊销的冷却基础设施。</li><li>Google，Microsoft和Apple在可以利用廉价水力发电的地方建造大型数据中心。</li></ul><p>世界各国政府也越来越强调要减少碳足迹，这对气候变化具有重大影响。</p><h4 id="绿色云：从【性能】转向【能源效率】"><a href="#绿色云：从【性能】转向【能源效率】" class="headerlink" title="绿色云：从【性能】转向【能源效率】"></a>绿色云：从【性能】转向【能源效率】</h4><p>随着能源成本的增加，需要将重点从仅针对纯性能的数据中心资源管理优化转移到针对能源效率的优化，同时保持较高的服务水平性能。</p><p>需要一种满足以下条件的【绿色云计算模型】：</p><ol><li>实现对计算基础架构的高效处理和利用</li><li>减少能源消耗</li></ol><h4 id="Google-Gmail服务的能源效率数据"><a href="#Google-Gmail服务的能源效率数据" class="headerlink" title="Google Gmail服务的能源效率数据"></a>Google Gmail服务的能源效率数据</h4><p><a href="https://static.googleusercontent.com/media/www.google.com/zh-CN//green/pdfs/google-green-computing.pdf" target="_blank" rel="noopener">链接</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf92ft04haj30ze0cc40j.jpg" alt="截屏2020-05-29 上午2.32.01" style="zoom:50%;" /></p><h4 id="冷却"><a href="#冷却" class="headerlink" title="冷却"></a>冷却</h4><p>云数据中心基础架构的关键方面：</p><ul><li>热服务器会导致许多问题（比如性能，损坏）。</li><li>湿度和压力也是要考虑的因素。</li></ul><p>不同类型的冷却：</p><ul><li><p>直接接触液冷</p></li><li><p>蒸发（对于一个8兆瓦的设施，每天蒸发70,000至200,000加仑）</p></li><li><p>浸没液体</p></li><li><p>空气，比如【hot-cold aisle】</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf92i8paccj30ry0cgtiu.jpg" alt="截屏2020-05-29 上午2.34.20" style="zoom:33%;" /></p></li></ul><h4 id="衡量软件能耗的度量：类型"><a href="#衡量软件能耗的度量：类型" class="headerlink" title="衡量软件能耗的度量：类型"></a>衡量软件能耗的度量：类型</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf92jn3c44j31080nyags.jpg" alt="截屏2020-05-29 上午2.35.42"></p><h4 id="衡量能源消耗的度量：上下文"><a href="#衡量能源消耗的度量：上下文" class="headerlink" title="衡量能源消耗的度量：上下文"></a>衡量能源消耗的度量：上下文</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf92jus7lzj30zy0o0468.jpg" alt="截屏2020-05-29 上午2.35.53"></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 功率感知计算 </tag>
            
            <tag> DVFS </tag>
            
            <tag> 服务器整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形数据库 Neo4J</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%9B%BE%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4J/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%9B%BE%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4J/</url>
      
        <content type="html"><![CDATA[<p>NoSQL可以被分成4类：键值对存储（MapReduce）、面向列的数据库（如Google Big Table）、文档数据库（MongoDB）、图形数据库（如Neo4J）</p><p>图形数据库主要用于存储具有更多关联的数据，而传统的RDBMS对大量数据的遍历性能不佳</p><p>图形数据库适合数据元素之间的关系与数据本身同样重要的项目</p><blockquote><p>由Neo4j，Inc.开发的图形数据库管理系统。它的开发人员将Neo4j描述为具有本机图形存储和处理的ACID兼容事务数据库，根据DB-Engines排名，Neo4j是最受欢迎的图形数据库，并且总体上是第22位最受欢迎的数据库。</p></blockquote><a id="more"></a><h4 id="NoSQL的种类"><a href="#NoSQL的种类" class="headerlink" title="NoSQL的种类"></a>NoSQL的种类</h4><p>NoSQL可以被分成4类：键值对存储（MySQL）、面向列的数据库（如Google Big Table）、文档数据库、图形数据库（如Neo4J）</p><h4 id="图-树结构的数据库"><a href="#图-树结构的数据库" class="headerlink" title="图/树结构的数据库"></a>图/树结构的数据库</h4><p>图包括2个元素：</p><ul><li><p>节点node：表示实体</p></li><li><p>关系relationship：表示2个节点之间是如何联系在一起的</p></li></ul><blockquote><p>2019年Twitter的每月活跃用户数量为3.21亿，通过图形数据库关联在一起</p></blockquote><h4 id="图形数据库-VS-传统的关系数据库管理系统RDBMS"><a href="#图形数据库-VS-传统的关系数据库管理系统RDBMS" class="headerlink" title="图形数据库 VS 传统的关系数据库管理系统RDBMS"></a>图形数据库 VS 传统的关系数据库管理系统RDBMS</h4><p>图形数据库主要用于存储更多连接的数据，而传统的RDBMS对大量数据的遍历(traverse)性能不佳</p><p>图形数据库适合：数据元素之间的关系与数据本身同样重要的项目</p><div class="table-container"><table><thead><tr><th>RDBMS</th><th>Graph DataBase</th></tr></thead><tbody><tr><td>表</td><td>图</td></tr><tr><td>行</td><td>节点</td></tr><tr><td>列和数据</td><td>属性和值</td></tr><tr><td>约束</td><td>关系</td></tr><tr><td>Joins</td><td>Traversal 遍历</td></tr></tbody></table></div><p>属性是用来表示数据的键值对</p><h3 id="Neo4J"><a href="#Neo4J" class="headerlink" title="Neo4J"></a>Neo4J</h3><p>是服从ACID的事务性数据库，提供自带的(native)图存储和处理</p><p>由Java编写，其他语言可以通过Cypher Query Language (CQL) 进行访问</p><blockquote><p>Cypher是一种声明性图形查询语言，它允许在属性图形中进行有表现力且有效的数据查询。</p></blockquote><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>以CQL作为查询语言，类似于SQL的查询语言</p><p>遵循属性图数据模型 Property Graph Data Model</p><p>包含可执行CQL命令的用户接口（Neo4J数据浏览器）</p><p>尽管是NoSQL，但其他大多数图像界面一样，服从ACID</p><p>提供REST和JavaScript接口</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>能够简单快速对<u>连接的数据</u>进行表示和获取</p><p>CQL的设计是人类可读的，并且易于学习</p><p>不需要复杂的Joins来获取连接的数据</p><h4 id="属性图数据模型"><a href="#属性图数据模型" class="headerlink" title="属性图数据模型"></a>属性图数据模型</h4><p>Neo4J使用属性图数据模型对数据进行存储和管理，Neo4J使用自带的图处理引擎GPE，对以这个格式存储的数据进行处理。该模型简单，只有少量的基本元素：</p><ul><li>数据由节点、关系和属性表示</li><li>节点和关系都包含属性</li><li>关系连接节点</li><li>属性是键值对</li><li><p>每个关系都包含“起始节点”和“结束节点”</p></li><li><p><strong>标签</strong>：将一系列的节点或关系用一个常用的名字管理起来。一个节点或关系可以有多个标签</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd12m5xkukj30qw0bk0vr.jpg" alt="截屏2020-03-20下午8.52.53"></p><h4 id="可视化——Neo4J-数据浏览器"><a href="#可视化——Neo4J-数据浏览器" class="headerlink" title="可视化——Neo4J 数据浏览器"></a>可视化——Neo4J 数据浏览器</h4><p>Neo4J 2.0版开始自带。能够快速简单的图形数据库进行可视化和编辑</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd12sg645oj312g0faafz.jpg" alt="截屏2020-03-20下午8.58.59"></p><h4 id="Cypher查询语言"><a href="#Cypher查询语言" class="headerlink" title="Cypher查询语言"></a>Cypher查询语言</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd12xhqnq2j311i0g2djr.jpg" alt="截屏2020-03-20下午9.03.50"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建emp节点，标签名为Employee</span><br><span class="line">CREATE (emp:Employee)</span><br><span class="line">&#x2F;&#x2F; 创建包含属性的节点</span><br><span class="line">CREATE (emp:Employee &#123;employeeNumber:10, name&#x3D;“Paul”, location&#x3D;“Leeds”&#125; ) ;</span><br><span class="line">&#x2F;&#x2F; 获取数据</span><br><span class="line">MATCH (myresults: Employee)</span><br><span class="line">RETURN myresults.name, myresults.location</span><br></pre></td></tr></table></figure><h4 id="与Java整合"><a href="#与Java整合" class="headerlink" title="与Java整合"></a>与Java整合</h4><p>Neo4J有自带接口和Cypher接口与Java整合，Cypher接口能让用户通过Java接口直接执行CQL命令</p><h3 id="Neo4J-VS-MySQL"><a href="#Neo4J-VS-MySQL" class="headerlink" title="Neo4J VS MySQL"></a>Neo4J VS MySQL</h3><p>对于MySQL来说，表中的每个元素都有一组提前定义好的属性（列）</p><p>在Neo4J中，每个节点node等价于MySQL中的一行记录</p><ul><li>Label能将相似的数据归为同一组，比如用户组。相当于MySQL中的表，但同一组数据并不会真正的存储在一起，只是语义上的划分</li></ul><h4 id="图形数据库-VS-传统的RDBMS——以用户-餐厅为例"><a href="#图形数据库-VS-传统的RDBMS——以用户-餐厅为例" class="headerlink" title="图形数据库 VS 传统的RDBMS——以用户/餐厅为例"></a>图形数据库 VS 传统的RDBMS——以用户/餐厅为例</h4><p>传统数据库需要3张表分别表示用户、餐厅和关系：</p><ul><li><p>存储：<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd167p6tmfj30em086q6v.jpg" alt="截屏2020-03-20下午10.57.26" style="zoom: 33%;" /></p></li><li><p>查询：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user.*, restaurant.* </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>, restaurant, joinTable </span><br><span class="line"><span class="keyword">WHERE</span> user.firstName = ‘Paul’ <span class="keyword">AND</span> user.id = joinTable.userId <span class="keyword">AND</span> restaurant.id = joinTable.restaurantId <span class="keyword">AND</span> joinTable.rating = ‘LOVED’</span><br></pre></td></tr></table></figure><p>图形数据库通过<u>节点</u>表示用户和餐厅，<u>关系</u>表示节点之间的关联信息，比如当用户写的评论可以直接储存在<u>关系</u>中</p><ul><li><p>存储：<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd16bcna2jj30gu0cgwf3.jpg" alt="截屏2020-03-20下午11.00.43" style="zoom:33%;" /></p></li><li><p>查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Neo4J会忽略不匹配该模式的所有值</span><br><span class="line">&#x2F;&#x2F; 通过提供的变量名，可以使用name.property与所有匹配的节点或关系进行交互</span><br><span class="line">MATCH (u:User &#123;firstName:‘Paul&#39;&#125;)-[rel:LOVED]-&gt;(res:Restaurant) RETURN res</span><br><span class="line">MATCH (u:User)-[rel]-&gt;(res:Restaurant &#123;name:&#39;French Laundry&#39;&#125;) RETURN u</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Neo4J </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云编程的前景</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/11%20%E4%BA%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E6%99%AF/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/11%20%E4%BA%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>云编程的前景</p><p>在云中的执行应用程序和服务的框架</p><p>云服务生命周期</p><p>常用的编程框架和模型：MPI、MapReduce / Hadoop 、亚马逊、微软 Azure</p><a id="more"></a><h4 id="云产品的现状"><a href="#云产品的现状" class="headerlink" title="云产品的现状"></a>云产品的现状</h4><p>云产品可应用于以下领域：科学/技术（无人驾驶汽车）、商务（电商、消费者关系管理CRM、会计、企业资源规划ERP）、消费者/社交（FB、Gmail、Twitter）</p><h3 id="产品和服务的编程"><a href="#产品和服务的编程" class="headerlink" title="产品和服务的编程"></a>产品和服务的编程</h3><p>现有的框架支持对应用程序和服务进行编程，并在云中执行：</p><ol><li>新的接口用以开发程序：比如Azure、Google App Engine</li><li>基于服务的工作流程的图形：比如业务过程执行语言WS-BPEL</li><li>高性能计算：MPI，OpenMP</li><li>非通用编程模型：MapReduce，Aneka（用于在云上开发分布式应用的平台和框架）</li></ol><h3 id="云服务的生命周期"><a href="#云服务的生命周期" class="headerlink" title="云服务的生命周期"></a>云服务的生命周期</h3><p>编程模型/构造服务：</p><ul><li>编程模型——用于开发产品</li><li>应用包装器——用于创建服务清单</li><li>虚拟机镜像构造器——用于产生镜像</li></ul><p>部署服务</p><ul><li>产品管理器——经服务部署到云基础设施上</li><li>虚拟机上下文工具contextualiser——将服务的软件依赖嵌入到虚拟机镜像中，并支持运行时配置</li><li>产品监控器——在操作是监控服务</li></ul><p>操作服务：</p><ul><li>虚拟机管理器——将虚拟机部署到物理节点</li><li>虚拟机基础设施管理器——管理虚拟机</li><li>基础设施监控器——监控云资源 </li></ul><h3 id="构造云服务"><a href="#构造云服务" class="headerlink" title="构造云服务"></a>构造云服务</h3><p>云服务是专门为了在云基础设施上部署而开发、策划和配置的</p><p>需执行的活动有：</p><ol><li>服务开发：开发应用程序，为用户提供功能服务<ul><li>使用编程模型简化服务开发：MapReduce、MPI、COMP Superscalar</li></ul></li><li>准备好虚拟机，等服务开发完成后，将服务部署在虚拟机上</li><li><p>指定和配置服务需求，描述参数（功能性和非功能性）</p><ul><li>容量需求、位置限制、能源效率限制</li></ul><p>针对云量身定制的编程语言：GO——针对云项目Docker的编程语言，提供并发操作</p></li></ol><h4 id="例1：消息传递接口MPI"><a href="#例1：消息传递接口MPI" class="headerlink" title="例1：消息传递接口MPI"></a>例1：消息传递接口MPI</h4><p>高性能多重计算机的出现；需要面向消息的<u>原语Primitives</u>以轻松编写高效的应用程序</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd04xhtyu7j30ys0i8tbv.jpg" alt="截屏2020-03-20上午1.27.08" style="zoom: 33%;" /></p><p>问题：大多数内部交互网络和高性能多重计算机都自带专有的通信库——需要硬件独立的通信库</p><p>解决方案：MPI</p><ul><li>为并行产品设计</li><li>使用底层网络</li><li>假设通信发生在已知的进程组</li></ul><h5 id="消息传递模型"><a href="#消息传递模型" class="headerlink" title="消息传递模型"></a>消息传递模型</h5><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd04om93dyj30ou0lw418.jpg" alt="截屏2020-03-20上午1.18.52" style="zoom:33%;" /></p><p>消息同步传输：</p><ul><li><p>需要发送者与接受者配合，但“配合”并不总是反映在代码上。</p></li><li><p>比较一对一通信和集体通信</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd04u6rjjuj30yg0aodgp.jpg" alt="截屏2020-03-20上午1.24.17"></p><h5 id="进程执行：裸机与虚拟环境的对比"><a href="#进程执行：裸机与虚拟环境的对比" class="headerlink" title="进程执行：裸机与虚拟环境的对比"></a>进程执行：裸机与虚拟环境的对比</h5><p>对消息传递的方式对进程来说没有区别，区别在于进程是位于裸机中还是虚拟机中</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd0503wa9hj30xu0nen3p.jpg" alt="截屏2020-03-20上午1.29.58" style="zoom:33%;" /></p><h4 id="例2：MapReduce——在大型集群上的可扩展数据处理"><a href="#例2：MapReduce——在大型集群上的可扩展数据处理" class="headerlink" title="例2：MapReduce——在大型集群上的可扩展数据处理"></a>例2：MapReduce——在大型集群上的可扩展数据处理</h4><ul><li>用于快速处理大规模数据集的编程模型</li><li>适用于网络规模的搜索和云计算产品</li><li>用户编写的<ul><li>map函数用于生成中间操作的键值对</li><li>reduce函数将键值对按键合并</li></ul></li></ul><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><p>由雅虎开发的软件平台，让用户编写和运行基于大规模分布式数据的产品</p><p>特点：</p><ul><li>可扩展：可以轻松的在网络空间上扩展，存储和处理PB级的数据</li><li>经济的：开源框架，能够最小化过量的任务滋生和大规模数据通信</li><li>高效的：通过大量的简单节点，进行高度并行的数据处理</li><li>可靠的：自动维护多个数据备份，当发送故障时能够重新部署计算任务</li></ul><h3 id="部署云服务"><a href="#部署云服务" class="headerlink" title="部署云服务"></a>部署云服务</h3><p>成果：服务能够在云基础设施资源上运行</p><p>执行的活动有：</p><ul><li>选择最合适的基础设施来部署服务</li><li>当服务被部署后，确保服务按照其约束进行<ul><li>约束指的是在性能、成本、能耗等方面达成一致</li></ul></li><li>上下文（配置）信息的交付，当服务被部署后，上下文信息用于初始化服务</li></ul><h3 id="操作云服务"><a href="#操作云服务" class="headerlink" title="操作云服务"></a>操作云服务</h3><p>服务运行在云基础设之上</p><p>执行的活动有：</p><ul><li>满足服务需求的管理操作（比如服务质量）</li><li>资源分配机制（包括数据放置）</li><li>（被虚拟机、容器使用的）基础设施用量的监控机制</li><li>根据基础设备用量、历史模式、预测未来用量的变化的报告机制</li></ul><h3 id="在AWS上的并行编程"><a href="#在AWS上的并行编程" class="headerlink" title="在AWS上的并行编程"></a>在AWS上的并行编程</h3><p>部分亚马逊平台上提供的服务</p><ul><li><p>EC2 亚马逊弹性云服务：提供可重新调整计算能力的Web服务，为开发者设计，简化网络规模的云计算</p></li><li><p>S3 简单存储服务：为用户提供安全、可容忍、可高度扩展的对象存储，通过简单的网络服务接口，从网络的任何地方，对任何数量的数据进行存储和获取</p></li><li><p>EBS 弹性块存储：基于EC2实例，支持<u>块级别</u>存储大小的持久化</p></li><li><p>SimpleDB：高度可用和灵活的非关系数据存储，减少开发者对数据库管理的工作。开发者只要通过网络服务请求对数据进行查询和存储，SimpleDB负责其余的工作</p></li></ul><h4 id="EC2——AMI-亚马逊虚拟机镜像"><a href="#EC2——AMI-亚马逊虚拟机镜像" class="headerlink" title="EC2——AMI 亚马逊虚拟机镜像"></a>EC2——AMI 亚马逊虚拟机镜像</h4><p>AMI是虚拟机实例的模板，AMI是预装了软件Linux系统，部署在EC2上。</p><p>AMI的类型包括私有（个人创建和使用），公开（由用户创建，并在AWS社区发布，任何人都能使用），付费（由个人创建，其他用户可以付费使用）</p><h4 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h4><p>特点：</p><ul><li><p>基于对象的存储服务，对象是最基础的数据单元，每个对象的大小为1Byte-5GB</p><ul><li>使用Bucket来存储对象，用Key来获取数据对象</li><li>对象包括：键、值、元数据、访问控制</li></ul></li><li><p>通过地理分散实现冗余，99.99%的可用性目标，共有或私有，每个对象都有专门的URL，支持比特流BitTorrent</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生成模型 Generative model</title>
      <link href="/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/10%20%E6%B3%9B%E5%8C%96%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/10%20%E6%B3%9B%E5%8C%96%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用encoder-decoder模型，能够构造出了一个能够对图像编码并还原图像的自编码模型。但是这并没有达到我们真正想要构造的生成模型的标准。因为，对于一个生成模型而言，解码器部分应该是单独能够提取出来的，并且对于在规定维度下任意采样的一个编码，都应该能通过解码器产生一张清晰且真实的图片。</p><p>——<a href="http://www.gwylab.com/note-vae.html" target="_blank" rel="noopener">生成模型——变分自编码器</a></p></blockquote><a id="more"></a><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote><p><a href="http://www.gwylab.com/note-vae.html" target="_blank" rel="noopener">生成模型——变分自编码器</a>：</p><p>我们的目的是，对于一个生成模型而言，解码器部分应该是单独能够提取出来的，并且对于<strong>在规定维度下任意采样的一个编码，都应该能通过解码器产生一张清晰且真实的图片。</strong></p><h4 id="现有模型无法做到这一点"><a href="#现有模型无法做到这一点" class="headerlink" title="现有模型无法做到这一点"></a>现有模型无法做到这一点</h4><p>假设有两张训练图片，一张是全月图，一张是半月图，经过训练我们的自编码器模型已经能无损地还原这两张图片。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf48jgv8dnj307r08yabd.jpg" alt="截屏2020-05-24 下午10.15.18" style="zoom: 67%;" /></p><p>接下来，我们在code空间上，<strong>两张图片的编码点中间处取一点</strong>，然后将这一点交给解码器，我们希望新的生成图片是一张清晰的图片（类似3/4全月的样子）。<strong>但是，实际的结果是，生成图片是模糊且无法辨认的乱码图。</strong></p><p><strong>一个比较合理的解释是，因为编码和解码的过程使用了深度神经网络，这是一个非线性的变换过程，所以在code空间上点与点之间的迁移是非常没有规律的。</strong></p><h4 id="改进：引入噪声"><a href="#改进：引入噪声" class="headerlink" title="改进：引入噪声"></a>改进：引入噪声</h4><p>我们可以引入噪声，使得图片的编码区域得到扩大，从而掩盖掉失真的空白编码点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf48nsm6wfj307p09876a.jpg" alt="截屏2020-05-24 下午10.19.26" style="zoom:67%;" /></p><p>在训练模型的时候，绿色箭头范围内的点都有可能被采样到，这样解码器在训练时会把绿色范围内的点都尽可能还原成和原图相似的图片。</p><p>然后我们可以关注之前那个失真点，现在它处于全月图和半月图编码的交界上，于是<strong>解码器希望它既要尽量相似于全月图，又要尽量相似于半月图，于是它的还原结果就是两种图的折中（3/4全月图）。</strong></p><p><strong>但是在绿色箭头范围之外的地方，它依然不会被覆盖到，仍是个失真点。</strong></p><h4 id="改进：正态分布曲线（高斯分布，均值为0，标准差为1）"><a href="#改进：正态分布曲线（高斯分布，均值为0，标准差为1）" class="headerlink" title="改进：正态分布曲线（高斯分布，均值为0，标准差为1）"></a>改进：正态分布曲线（高斯分布，均值为0，标准差为1）</h4><p>我们可以试图把噪音无限拉长，使得对于每一个样本，它的编码会覆盖整个编码空间。在这种情况下，图像的编码就由原先离散的编码点变成了一条连续的编码分布曲线</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf48tbqcv4j308k08kta1.jpg" alt="截屏2020-05-24 下午10.24.47" style="zoom:67%;" /></p><p><strong>不过我们得保证，在原编码附近编码的概率最高，离原编码点越远，编码概率越低。</strong></p><p>那么上述的这种将图像编码由离散变为连续的方法，就是变分自编码的核心思想。</p></blockquote><h4 id="输入向量"><a href="#输入向量" class="headerlink" title="输入向量"></a>输入向量</h4><p>输入向量是从分布空间<script type="math/tex">\mathbb{R}^n</script>中进行采样得到，其中n的取值范围通常为<script type="math/tex">n\in [100,512]</script></p><blockquote><p>分布空间<script type="math/tex">\mathbb{R}^n</script>可以看作是若干高斯分布的叠加。当拆分的数量达到512时，其叠加的分布相对于原始分布而言，误差是非常非常小的了。</p><p>详见<a href="http://www.gwylab.com/note-vae.html" target="_blank" rel="noopener">生成模型——变分自编码器</a>，第三节</p></blockquote><p>该向量并不是数据集中的数据，因此无法观测。我们称之为【latent 潜在的】</p><h4 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h4><blockquote><p>反卷积（Deconvolution）的概念第一次出现是Zeiler在2010年发表的论文<a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf" target="_blank" rel="noopener">Deconvolutional networks</a>中，但是并没有指定反卷积这个名字，反卷积这个术语正式的使用是在其之后的工作中(<a href="https://www.cs.nyu.edu/~gwtaylor/publications/zeilertaylorfergus_iccv2011.pdf" target="_blank" rel="noopener">Adaptive deconvolutional networks for mid and high level feature learning</a>)。</p><p>其他叫法：Transposed Convolution，Fractional Strided Convolution</p></blockquote><p>详细介绍：<a href="https://blog.csdn.net/sinat_29957455/article/details/85558870" target="_blank" rel="noopener">链接</a></p><blockquote><p>反卷积不能恢复数值，只能从大小上进行还原。而且，在当<script type="math/tex">stride>2</script>时，即便使用完全相同的参数进行转置卷积，输入的尺寸也不能恢复。</p><p>——<a href="https://www.zhihu.com/question/48279880" target="_blank" rel="noopener">知乎问题</a>，孙小野</p></blockquote><h4 id="例子：DCGAN"><a href="#例子：DCGAN" class="headerlink" title="例子：DCGAN"></a>例子：DCGAN</h4><p>（Radford et al., Unsupervised representation learning with deep convolutional generative adversarial networks. ICLR, 2016）</p><p>介绍及实现：<a href="https://www.tensorflow.org/tutorials/generative/dcgan" target="_blank" rel="noopener">https://www.tensorflow.org/tutorials/generative/dcgan</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4axpwqt5j30gy0kkdhu.jpg" alt="截屏2020-05-24 下午11.38.12" style="zoom: 67%;" /></p><h4 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4avssszdj30u60cct98.jpg" alt="截屏2020-05-24 下午11.36.22" style="zoom: 33%;" /></p><h4 id="构造损失函数"><a href="#构造损失函数" class="headerlink" title="构造损失函数"></a>构造损失函数</h4><p>使用【判别器】来判断【生成器】的效果。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4bcry4hjj30wa04y0t8.jpg" alt="截屏2020-05-24 下午11.52.40"></p><blockquote><p>生成器损失：</p><p>生成器损失量化其欺骗判别器的能力。直观来讲，如果生成器表现良好，判别器将会把伪造图片判断为真实图片（或 1）。<strong>这里我们将把判别器对生成图片的判断结果与一个值全为 1 的数组进行对比。</strong></p><p>判别器损失：</p><p>该方法量化判别器从判断真伪图片的能力。<strong>它将判别器对真实图片的预测值与值全为 1 的数组进行对比，将判别器对伪造（生成的）图片的预测值与值全为 0 的数组进行对比。</strong></p></blockquote><h4 id="判别器-Discriminator"><a href="#判别器-Discriminator" class="headerlink" title="判别器 Discriminator"></a>判别器 Discriminator</h4><blockquote><p>判别器是一个基于 CNN 的图片分类器。使用（尚未训练的）判别器来对图片的真伪进行判断。模型将被训练为：为真实图片输出正值，为伪造图片输出负值。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4b3lfmmyj30aq0gomy0.jpg" alt="截屏2020-05-24 下午11.43.50" style="zoom:50%;" /></p><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>生成器与判别器会同时进行训练和更新。</p><blockquote><p>训练循环在生成器接收到一个随机种子作为输入时开始。该种子用于生产一张图片。判别器随后被用于区分真实图片（选自训练集）和伪造图片（由生成器生成）。针对这里的每一个模型都计算损失函数，并且计算梯度用于更新【生成器】与【判别器】。</p></blockquote><p><strong>生成器和鉴别器可以视为相互竞争。 因此，该方法称为生成对抗网络（GAN）</strong></p><blockquote><p>但要注意生成器和判别器不能够互相压制对方。例如，可以让他们以相似的学习率训练）。</p></blockquote><p>在训练之初，生成的图片看起来像是随机噪声。随着训练过程的进行，生成的数字将越来越真实。在大概 50 个 epoch 之后，这些图片看起来像是 MNIST 数字。</p><h4 id="例子：BigGAN-deep"><a href="#例子：BigGAN-deep" class="headerlink" title="例子：BigGAN-deep"></a>例子：BigGAN-deep</h4><p>（Brock et al., Large Scale GAN Training for High Fidelity Natural Image Synthesis, ICLR 2019）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4bx8ff1dj310e0h0n1h.jpg" alt="截屏2020-05-25 上午12.12.19"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像分割</title>
      <link href="/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/08%20%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
      <url>/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/08%20%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p>任务：将图像划分为组成对象</p><p>方式：颜色分割 colour segmentation、行动分割 motion segmentation、语义分割semantic segmentation</p><a id="more"></a><h3 id="颜色分割-colour-segmentation"><a href="#颜色分割-colour-segmentation" class="headerlink" title="颜色分割 colour segmentation"></a>颜色分割 colour segmentation</h3><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><ul><li><p>将像像素值从[0,255]缩放到[0,1]</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf2tmoyv8qj30zy0hygu5.jpg" alt="截屏2020-05-23 下午4.53.43" style="zoom: 33%;" /></p></li><li><p>使用k-means对RGB向量进行聚类，被划分为一类的像素点，用同一种颜色代替</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf2tqkboiij30z40jgdic.jpg" alt="截屏2020-05-23 下午4.55.53" style="zoom: 33%;" /></p></li></ul><h3 id="行动分割-motion-segmentation"><a href="#行动分割-motion-segmentation" class="headerlink" title="行动分割 motion segmentation"></a>行动分割 motion segmentation</h3><p>向属于移动对象的像素分别归类到独立的对象中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf326ju9ngj30e60amjz9.jpg" alt="截屏2020-05-23 下午9.49.41" style="zoom:33%;" /><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf326243a2j30dw0ac748.jpg" alt="截屏2020-05-23 下午9.49.01" style="zoom:33%;" /><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf325y6dp2j30ds0ao10x.jpg" alt="截屏2020-05-23 下午9.49.09" style="zoom:33%;" /></p><h4 id="识别方式"><a href="#识别方式" class="headerlink" title="识别方式"></a>识别方式</h4><p>原理：固定的镜头下，对于视频中某个像素，如果有移动的物体经过，那么像素值会产生突变。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf32a8fvjej30os0mi409.jpg" alt="截屏2020-05-23 下午9.52.28" style="zoom:33%;" /></p><ol><li><p>对背景建模</p><p>当背景中没有任何移动物体的情况下，在一段时间中，在每一个像素的位置，计算各个像素的均值和标准差。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf32hvvvwfj30a807a74i.jpg" alt="截屏2020-05-23 下午10.00.35" style="zoom: 50%;" /></p><p>比如：</p><ul><li><p>均值图像：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf32vkfdrzj30dy0b8aeu.jpg" alt="截屏2020-05-23 下午10.13.45" style="zoom:33%;" /></p></li><li><p>标准差图像：注意左下方，由于原图中的亮度特别高，因此标准差很低；而地板上的不规则色块，则可能是由于MPEG压缩导致的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf32wqv08aj30yi0c67bw.jpg" alt="截屏2020-05-23 下午10.14.37" style="zoom: 33%;" /></p></li></ul></li></ol><ol><li><p>异常点 outliers</p><p>有了均值和标准差之后，我们可以设置异常点的判定阈值，比如<script type="math/tex">|l-\mu|>\lambda\sigma</script></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf330sslkqj30vc0c2afd.jpg" alt="截屏2020-05-23 下午10.18.46" style="zoom:50%;" /></p></li><li><p>检测光团blobs：【光团检测算法 Blob finding Algorithm】</p><ol><li><p>寻找连接的区域（四向或八向邻接 4-way or 8-way adjacency）</p><p>以3*3的格子的中间为中心，【四向】只认为上下左右与中心是邻接的，【八向】则还包括4个对角。比如图中左下的白块只在八向邻接中被认为是连接的<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3382q702j303e038dfp.jpg" alt="截屏2020-05-23 下午10.25.48" style="zoom: 50%;" /></p></li><li><p>忽略只包含少数像素的区域</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf33f4ctlzj30h20dewfc.jpg" alt="截屏2020-05-23 下午10.32.34" style="zoom:33%;" /></p></li><li><p>只展示最小的封闭矩形中的内容</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf33fa6ehej30dy0b83yr.jpg" alt="截屏2020-05-23 下午10.32.43" style="zoom:33%;" /></p></li></ol></li></ol><h4 id="更新背景"><a href="#更新背景" class="headerlink" title="更新背景"></a>更新背景</h4><p>背景可能因为以下原因而需要更新：</p><ul><li>背景中的固定物体发送了移动</li><li>光线的变化（云）</li><li>相机的自动光圈改变（auto-iris）</li><li>相机移动</li></ul><p><strong>更新模型的方法：</strong>下标记 <script type="math/tex">t</script> 表示当前时间点；<script type="math/tex">\rho</script> 是一个自定义的数值，比如<script type="math/tex">\rho=0.1</script>，那么背景将会随着时间一点点的更新。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf33kix3szj30ec03kwen.jpg" alt="截屏2020-05-23 下午10.37.45" style="zoom:50%;" /></p><p>该方法的问题在于，<u>移动物体</u>也可能因此被混合进背景中。</p><h4 id="使用中位数代替平均值"><a href="#使用中位数代替平均值" class="headerlink" title="使用中位数代替平均值"></a>使用中位数代替平均值</h4><p>我们需要一个【稳健robust】的估算器，通过忽略由移动物体引起的瞬时“异常值”，从而为我们提供所需的背景值。</p><p>中位数提供了【平均值的典型分布】的近似值</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf33w63wogj30tw04yq31.jpg" alt="截屏2020-05-23 下午10.48.56" style="zoom:50%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf33x7xq32j30pk0bgdnt.jpg" alt="截屏2020-05-23 下午10.49.56" style="zoom:50%;" /></p><h3 id="语义分割semantic-segmentation"><a href="#语义分割semantic-segmentation" class="headerlink" title="语义分割semantic segmentation"></a>语义分割semantic segmentation</h3><h4 id="逐像素分割语义"><a href="#逐像素分割语义" class="headerlink" title="逐像素分割语义"></a>逐像素分割语义</h4><p>生成像素级的语义：对每个像素进行分类，像素要么是目标对象，要么是背景，比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf38d2t9c9j30nc0iu14b.jpg" alt="截屏2020-05-24 上午1.23.35" style="zoom:33%;" /></p><h4 id="评估性能"><a href="#评估性能" class="headerlink" title="评估性能"></a>评估性能</h4><p>Area of Overlap (AO), or Intersection over Union (IU)：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf38gji41oj30cg04s3yo.jpg" alt="截屏2020-05-24 上午1.26.56" style="zoom:50%;" /><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf38hevpt9j30cw0ciq36.jpg" alt="截屏2020-05-24 上午1.27.47" style="zoom:33%;" /></p><h4 id="逐块分割语义"><a href="#逐块分割语义" class="headerlink" title="逐块分割语义"></a>逐块分割语义</h4><p>（Ning, F., D. Delhomme, Y. Lecun, F. Piano, L. Bottou, and P.E. Barbano. 2005. “Toward Automatic Phenotyping of Developing Embryos from Videos.” <em>IEEE Transactions on Image Processing</em> 14 (9) (September): 1360–71.）</p><p>显微镜图像分割。5种标签：核，核膜，细胞质，细胞壁，外部培养基。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf38stu0gij30jm0a40ut.jpg" alt="截屏2020-05-24 上午1.38.42" style="zoom: 50%;" /></p><h4 id="CNN结构"><a href="#CNN结构" class="headerlink" title="CNN结构"></a>CNN结构</h4><p>论文中将300*300的灰度图像分割成40*40的块，步长为4，卷积层没有padding，使用tanh作为激活函数（输出值在[-1,1]之间）</p><p>从50张原图中得到190,440个40*40的块，以及每个块中心像素对应的类别作为标签（原图中的每个像素已经划分好了，如上图）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3b1cw9djj30yk09w4e3.jpg" alt="截屏2020-05-24 上午2.55.59" style="zoom: 33%;" /></p><p>最终结构为：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf38sbsx7gj30cw0kw75v.jpg" alt="截屏2020-05-24 上午1.38.16" style="zoom: 50%;" /></p><p>论文中还使用了同样的结构，但是将最后的全连接层改为了<u>卷积核为1*1，输出5个特征图像的卷积层</u>，以原图作为输入。但最终的实验还是使用上述结构。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3cy5c1zwj30d60l440b.jpg" alt="截屏2020-05-24 上午4.02.15" style="zoom: 50%;" /></p><h4 id="MSE-均方误差损失函数"><a href="#MSE-均方误差损失函数" class="headerlink" title="MSE 均方误差损失函数"></a>MSE 均方误差损失函数</h4><p>在该结构中，采用MSE（均方误差）损失函数，且没有用softmax。</p><p>每个图像的ground-truth标签用【独热向量】表示，比如 (0,0,1,0,0)。</p><p>我们希望我们的预测的5个输出，最大程度的接近ground-truth标签，这与使用MSE作为损失函数，最小化该损失的想法一致。</p><p>公式如下：y为标签，x为预测值。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3bw68eghj30yk07smya.jpg" alt="截屏2020-05-24 上午3.25.43" style="zoom:50%;" /></p><h4 id="encoder-decoder结构"><a href="#encoder-decoder结构" class="headerlink" title="encoder-decoder结构"></a>encoder-decoder结构</h4><p>在【word2vec skip-gram】方案中，输入和输出的大小是一致的，但隐藏层却小得多。通过训练，网络学习如何将输入嵌入到更低维度的空间中。在嵌入空间中，相似的实例彼此更加接近。</p><p>我们的定义好输入与输出。训练模型对输入进行压缩，再还原。损失函数则比较输入与输出的差异，我们希望输出与输入一致。当训练完成后，我们将丢弃decoder的部分，只保留encoder来对数据进行压缩编码。</p><p>我们将这个想法扩展到深度神经网络中：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3dg6x6lqj30n40bs753.jpg" alt="截屏2020-05-24 上午4.19.36" style="zoom:33%;" /></p><h4 id="特殊例子：自动编码器"><a href="#特殊例子：自动编码器" class="headerlink" title="特殊例子：自动编码器"></a>特殊例子：自动编码器</h4><p>由于输入和输出是一致的，因此，自动编码器将学习如何压缩编码（编码code、嵌入embedding、表达representation）（对输入进行压缩）。这是非监督学习。该结构的简化表示如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3dk20o1pj30ho07yaae.jpg" alt="截屏2020-05-24 上午4.22.54" style="zoom:33%;" /></p><p>比如，自动编码器可以从图像集中学习图像的特征。在这里，encoder和decoder通常都是CNN。输出结果类似于CNN分类器的特征层，但属于非监督的。</p><h4 id="例子：语义分割"><a href="#例子：语义分割" class="headerlink" title="例子：语义分割"></a>例子：语义分割</h4><p>输入为原图像，输出为对像素，每个类别为1层。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3dxoktwqj30v007wwhi.jpg" alt="截屏2020-05-24 上午4.35.56" style="zoom:50%;" /></p><p>我们可以使用【maxpooling】来缩小，用【上卷积 up-convolution】来扩大。</p><h4 id="例子：U-Net：uses-encoder-decoder-architecture-with-cross-links"><a href="#例子：U-Net：uses-encoder-decoder-architecture-with-cross-links" class="headerlink" title="例子：U-Net：uses encoder-decoder architecture with cross links"></a>例子：U-Net：uses encoder-decoder architecture with cross links</h4><p>（Ronneberger, Olaf, Philipp Fischer, and Thomas Brox. 2015. “U-Net: Convolutional Networks for Biomedical Image Segmentation.” ArXiv:1505.04597 [Cs], May.）</p><p>输入为包含细胞的图像，输出为具有两个分类的分割图像，包括前景（细胞）和背景（非细胞）。注意这里显示的输出图像是渲染过后的图像，实际的输出图像只有2种颜色。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3e67hjjgj312u0mc46u.jpg" alt="截屏2020-05-24 上午4.44.35"></p><ul><li>输入是一个二维图像，输出是2个二维图像，分别是分割为前景的分布可能性，和分割为背景的分布可能性</li><li>encoder缩小图像的步骤包括：3*3卷积、池化<ul><li>图像大小的变化分别为：572，570，568，284。。。</li><li>特征图像的数量变化分别为：64。。128。。256。。1024</li><li>池化会缩小图像大小，但特征图像数量不变</li></ul></li><li>decoder扩大图像的步骤包括：3*3卷积、上卷积<ul><li>上卷积会扩大图像大小，同时缩小特性图像数量</li></ul></li><li><p><strong>注意，灰色的直线将encoder层的部分输出进行<u>中心裁剪</u>，并复制到了部分decoder层，附加到了上卷积操作的输出中，一起作为下一层的输入。</strong></p><ul><li>好处在于可以综合考虑encoder和decoder</li></ul></li><li><p>最后的2个64维1*1卷积核，将64个特征图像加权求和，得到2个分类，这相当普通CNN中的全连接层</p></li><li>前景和背景的分类使用独热编码</li><li>损失函数可以使用MSE或交叉熵损失。对每个像素点进行计算，并相加，目的是最小化该所有像素损失之和。</li></ul><h4 id="例子：视网膜疾病的诊断和转诊"><a href="#例子：视网膜疾病的诊断和转诊" class="headerlink" title="例子：视网膜疾病的诊断和转诊"></a>例子：视网膜疾病的诊断和转诊</h4><p>（De Faux et al., Clinically applicable deep learning for diagnosis and referral in retinal disease, <em>Nature Medicine,</em> volume 24, 2018）</p><p>原始图像为488*512*128(slices)的OCT扫描图像</p><p>处理包括2个阶段：图像分割，分类</p><p>10个诊断类型，和4个转诊类型</p><p>转诊建议可与临床专家媲美</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3xif967mj310q0l2qhy.jpg" alt="截屏2020-05-24 下午3.53.21"></p><p>图像分割模型：训练独立于分类器的语义分割U-net，可确保这个中间操作对临床医生有意义</p><ul><li>采用U-Net结构</li><li>输入是3D图像，输入为2D图像<ul><li>第一层输入为<script type="math/tex">488*512*9(slices)*1(channels)</script>（在原图上截取一个小窗口），输出为<script type="math/tex">488*512*9(slices)*32(channels)</script></li><li>3表示进行了3次卷积</li><li>注意右下角的立方体，长宽对应size，depth对应slices，log对应channels</li></ul></li><li>【3D卷积】，但卷积核为<script type="math/tex">3*3*1</script>，也就是说，虽然是3D卷积，但特征图像还是从单层slices中获取的<ul><li>在同一层的卷积中，都有padding，所以size保持一致</li></ul></li><li>使用【bilinear downsampling 双线性下采样】和【bilinear upsampling 双线性上采样】<ul><li>在不同层之间，上采样和下采样只<u>作用于size</u></li></ul></li><li>从第3层开始，使用<script type="math/tex">1*1*3</script>卷积核<ul><li><u>作用于slices</u>，因此slices的大小变化为9，7，5，3，1</li></ul></li><li>最终的输出为15个通道（15层，1层代表一个语义分割分类）<ul><li>更新权重：分别对这15个2D图像使用【softmax】，以及【cross-entropy loss交叉熵损失】，并将15个通道相加</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3xjoi3v8j310e0fuwmg.jpg" alt="截屏2020-05-24 下午3.54.54"></p><p>分类器模型：</p><ul><li>输入是语义分割后的图像，输出为诊断和转诊的可能性分布</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3xlcewcbj311a0c8abb.jpg" alt="截屏2020-05-24 下午3.55.52"  /></p><h4 id="上采样"><a href="#上采样" class="headerlink" title="上采样"></a>上采样</h4><p>线性上采样：</p><ul><li>假设实心点是图片中的像素（x轴表示像素，y轴表示值），我们想使图像放大一倍，我们只需要在相邻的2个原始像素之间插入一个点，然后在两个点之间插值。</li><li>实际的采用不一定要取中间值，只要是在直线上的任何一个位置都可以</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3z9fpi6xj30uc0byab7.jpg" alt="截屏2020-05-24 下午4.54.17" style="zoom:50%;" /></p><p>双线性上采用：</p><ul><li>同理。4个Q为原始值。P为最终采样点，</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3z9tqgzej30cy0bujsc.jpg" alt="截屏2020-05-24 下午4.54.39" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> 颜色分割 </tag>
            
            <tag> 行动分割 </tag>
            
            <tag> 语义分割 </tag>
            
            <tag> MSE损失函数 </tag>
            
            <tag> encoder-decoder模型 </tag>
            
            <tag> U-Net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache Spark</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/16%20APACHE%20SPARK/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/16%20APACHE%20SPARK/</url>
      
        <content type="html"><![CDATA[<p><strong>MapReduce的限制</strong></p><ol><li>MapReduce编程对许多人来说都是有难度的</li><li>性能通常会遇到瓶颈（因为批处理不适合所需的用例）</li></ol><p>这导致MapReduce不适用于大型应用程序。因此出现了多种专业系统的发展。</p><p> 因此Spark面世——将所有的专业系统整合到一起</p><a id="more"></a><h2 id="Apache-Spark"><a href="#Apache-Spark" class="headerlink" title="Apache Spark"></a>Apache Spark</h2><p>是一个通用目的数据处理引擎，为不同的需求设计，</p><ul><li>更快的批处理</li><li>应用需要交互式查询处理</li><li>处理流数据</li><li>系统需要迭代算法</li></ul><p>特征：</p><ul><li>是in-memory的计算引擎（充分利用内存）</li><li>用磁盘时比Hadoop快10倍，用内存时比Hadoop快100倍</li></ul><h4 id="Spark-结构"><a href="#Spark-结构" class="headerlink" title="Spark 结构"></a>Spark 结构</h4><p>Spark不提供任何类似HDFS的存储或者资源管理能力，它是一个以几乎实时的方式，处理大量数据的，统一的框架</p><p>三个主要的分层：</p><ol><li>生态层：基于核心层执行操作的库<ul><li>Spark SQL， Spark Streaming， BlinkDB， Spark ML， GraphX， Tachyon</li></ul></li><li>核心层：框架的通用层，它定义了所有的基础功能，其他功能和扩展都是基于这一层创建的<ul><li>Spark Core，Spark DataFrame API</li></ul></li><li>资源管理层：Spark以独立模式（单节点群集设置）管理自己的资源。 但是对于分布式集群模式，它可以与YARN之类的资源管理模块集成在一起。<ul><li>Standalone，YARN，Mesos</li></ul></li></ol><p>结构：</p><ul><li>Spark应用程序在集群上作为独立的进程集运行，由SparkContext对象（也称为驱动程序）协调。<ul><li>每个应用程序都有其自己的执行程序进程，这些进程在整个应用程序期间保持不变，并在多个线程中运行任务。</li><li>这具有将应用程序彼此<strong>隔离</strong>的好处——每个驱动程序调度自己的任务，并且来自不同应用程序的任务在不同的JVM中运行。</li><li>但是，这也意味着，如果不将数据写入外部存储系统，则无法在不同的Spark应用程序（SparkContext实例）之间共享数据。</li></ul></li><li>SparkContext负责将应用程序代码（JAR或Python文件）和任务发送给执行程序。</li><li>每个驱动程序都有一个Web UI，通常在端口4040上，该Web UI显示有关正在运行的任务，执行程序和存储使用情况的信息。</li></ul><h4 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h4><p>提供了Java、Scala、Python的high-level APIs</p><p>提供了优化引擎支持：产生执行图，结构化数据处理的高级工具</p><h3 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h3><p>处理：</p><ul><li>内存管理和容错</li><li><p>对集群上的任务jobs进行调度，分配，监控</p></li><li><p>与存储系统进行交互</p></li></ul><p>它也实现了弹性分布式数据库（RDDs）的关键概念。</p><ul><li>RDD是对象的不可变容错分布式集合，可以并行操作。</li><li>RDD可以包含任何类型的对象，并且可以通过加载外部数据集或从驱动程序分配集合来创建</li><li>RDD是分布在整个集群中的数据集的表示。</li></ul><h4 id="弹性分布式数据库-RESILIENT-DISTRIBUTED-DATABASES（RDDs）"><a href="#弹性分布式数据库-RESILIENT-DISTRIBUTED-DATABASES（RDDs）" class="headerlink" title="弹性分布式数据库 RESILIENT DISTRIBUTED DATABASES（RDDs）"></a>弹性分布式数据库 RESILIENT DISTRIBUTED DATABASES（RDDs）</h4><ul><li>RDDs可以被存储在内存或磁盘中，主要的性能来自于将数据存在内存中<ul><li>诸如MapReduce之类的当前框架提供了许多用于<u>访问集群的计算资源的接口</u>，但是缺乏<u>利用分布式内存的接口。</u></li></ul></li><li>Spark的优势：<ul><li>数据重用在许多迭代ML算法中很常见，例如K-means聚类。另一个示例是当用户对同一数据子集运行多个临时查询时。</li></ul></li><li>在Hadoop（和其他框架）中，在不同作业之间<u>重用数据的唯一方法</u>是将其写入外部存储系统（例如HDFS）。使用内存中的RDD，可以更快地处理数据。可以存储在分布式内存中的数据大小仅受群集大小限制。</li></ul><h4 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h4><ul><li>Transformations 转换：在RDD上执行并产生包含结果的新RDD的操作（例如，映射，过滤器，联接，联合等）</li><li>Actions 行动：在RDD上运行计算后返回值的操作（例如reduce，count，first等）。</li></ul><p>Spark上的转换操作是lazy的，并不会立即执行。只有当行动被调用时，转换才会执行。执行的结果将返回给驱动程序。该设计能提高Spark的运行效率</p><h4 id="Lazy-（Transformations）评估"><a href="#Lazy-（Transformations）评估" class="headerlink" title="Lazy （Transformations）评估"></a>Lazy （Transformations）评估</h4><p>转换是对数据的操纵。 它们从一个RDD转换到下一个。</p><p>比如：一个Action查询数据集中有多少数据，Spark在收到查询后，才会进行Transformations，再将结果返回给Action</p><h4 id="RDD用例"><a href="#RDD用例" class="headerlink" title="RDD用例"></a>RDD用例</h4><p>假设我们必须在大量的Web服务器访问日志中查找错误代码。</p><p>我们可以使用MapReduce，Storm或我们喜欢的任何框架来读取文件集，查找特定的错误代码，并将带有该代码的所有行放入存储设备（例如HDFS）</p><p>然后，当我们分析这些结果数据时，我们可能希望将错误与其他用户活动进行交叉引用cross-reference。 这将要求我们再次获取文件，处理并提供结果等。</p><p>对于传统方式需要重复对磁盘进行查询，而RDD是将数据存储在内存中，并提供了重新查询所用子集的功能。 </p><p>内存中数据存储非常适合许多迭代和交互式算法</p><h4 id="RDD容错"><a href="#RDD容错" class="headerlink" title="RDD容错"></a>RDD容错</h4><p>设计RDD的主要挑战是定义一个可提供有效容错能力的编程接口。</p><ul><li>故障是系统中的缺陷defect。</li><li>错误error是系统边界内观察到的行为与系统的指定行为之间的<strong>差异</strong></li><li>故障failure是系统当时<u>显示的行为</u>与<u>规范相反</u>的<strong>实例</strong></li></ul><p>现有解决方案提供基于<strong>细粒度更新</strong>的容错接口。</p><ul><li><p>使用这样的系统，获得容错的唯一方法，是<u>跨计算机复制数据</u>或<u>跨计算机记录更新</u>。</p></li><li><p>这些方法是数据密集型的——<strong>高带宽</strong>用于在群集网络上移动数据。</p></li></ul><p>RDD提供了基于粗粒度转换的接口（例如，映射，过滤器，联接）。 这些转换将相同的操作应用于许多数据项。</p><ul><li><p>这允许通过记录用于构建数据库的转换而不是实际数据本身来有效地应用容错。</p></li><li><p>如果RDD的分区丢失，则RDD具有有关如何从其他RDDS派生出来的足够信息，以便仅重新计算该分区。</p></li></ul><h4 id="RDD的限制"><a href="#RDD的限制" class="headerlink" title="RDD的限制"></a>RDD的限制</h4><p>不适合非迭代应用程序，因为Spark的主要性能提升是内存数据的迭代。</p><p>RDD也不太适合对共享状态进行异步细粒度更新的应用程序，例如Web应用程序的存储系统或增量Web爬虫。批量转换对于小的更新是浪费的。</p><h4 id="传统的流处理管道"><a href="#传统的流处理管道" class="headerlink" title="传统的流处理管道"></a>传统的流处理管道</h4><ol><li>从数据源接收流数据</li><li>在集群上并行处理流数据</li><li>将数据输出到下游的系统</li></ol><p>大多数传统的流处理器使用连续操作器（continuous operator）模型进行数据处理</p><ul><li>一组工作节点，每个工作节点运行一个或多个连续操作器</li><li>每个连续的操作器一次处理流数据一个记录，然后将记录转发给管道中的其他操作器。</li><li>有源操作器用于从采集系统接收数据，而下沉操作器则输出到下游系统。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcwbap19kxj30o80e4wii.jpg" alt="截屏2020-03-16下午6.05.24"></p><p>比如Apache Storm；这是一个非常优雅的解决方案，但是随着系统变得越来越大以及大数据分析的复杂性增加，使用此模型面临着越来越多的挑战。</p><h4 id="传统流数据处理系统的问题"><a href="#传统流数据处理系统的问题" class="headerlink" title="传统流数据处理系统的问题"></a>传统流数据处理系统的问题</h4><p><strong>故障和任务被卡主（straggling）：</strong></p><ul><li><p>随着规模扩大，集群节点故障或者无法预测的变慢（比如stragglers，掉队者）的可能性会增加</p></li><li><p>系统需要能自动从故障和卡住的任务（stragglers）中恢复，以实时提供结果</p></li><li>将<u>连续操作器</u>静态分配给工作节点，会使传统系统很难从故障和卡住的任务（stragglers）中快速恢复。</li></ul><p><strong>负载平衡：</strong></p><ul><li>Workers之间的处理负载分配不均，会导致连续操作器系统出现瓶颈。</li><li>这在大型集群和动态变化的工作负载中更可能发生。</li><li>系统需要能够根据工作负载动态调整资源分配。</li></ul><p><strong>流、批处理、交互式工作负载的统一：</strong></p><ul><li>在许多使用案例中，以交互方式查询流数据或将其与静态数据集（例如，预先计算的模型）结合起来很有吸引力。</li><li>在连续的操作器系统中，这很难做到，因为它们并非旨在动态地为临时查询引入新的运算器</li><li>这需要一个可以结合批处理，流式处理和交互式查询的引擎。</li></ul><p><strong>高级分析：</strong></p><ul><li><p>复杂的工作负载需要连续的学习和更新数据模型，甚至是用sql查询最新的流数据视图</p></li><li><p>使这些分析任务具有通用抽象（API），能让开发人员的工作更加轻松</p></li></ul><h4 id="离散流-Discretized-Streams-——-解决方案"><a href="#离散流-Discretized-Streams-——-解决方案" class="headerlink" title="离散流 Discretized Streams —— 解决方案"></a>离散流 Discretized Streams —— 解决方案</h4><p>为了解决这些问题，Spark Streaming组件使用称为离散化流的新架构，该架构直接利用了Spark引擎的库和容错能力。</p><ul><li>Spark Streaming接收器不会一次读取单个数据记录，而是将数据流离散化为亚秒级的微小批量（RDDs）。（即接收者并行接受数据并将其缓冲在Spark worker节点的内存中）。然后，Spark引擎运行简短的任务（数十毫秒）以处理批处理并将结果输出到其他系统。</li></ul><p>与连续操作器模型不同，Spark任务根据数据的位置和可用资源动态分配给工作人员。这是为了实现更好的负载平衡和更快的故障恢复。</p><ul><li>每个数据的batches都是一个RDD。这允许使用任何Spark代码或库来处理流数据。</li></ul><h4 id="DSP好处：动态负载平衡"><a href="#DSP好处：动态负载平衡" class="headerlink" title="DSP好处：动态负载平衡"></a>DSP好处：动态负载平衡</h4><p>将数据划分为多个微批，可以将计算能力以细粒度的方式分配给资源。</p><p>以字数统计为例：分区不均衡的流会导致某个节点过载，达到瓶颈；而将数据离散Discretized 后，可以根据节点的负载对任务进行分配和调度。</p><h4 id="DSP好处：从故障和卡住的任务中快速恢复"><a href="#DSP好处：从故障和卡住的任务中快速恢复" class="headerlink" title="DSP好处：从故障和卡住的任务中快速恢复"></a>DSP好处：从故障和卡住的任务中快速恢复</h4><p>传统流：</p><ul><li>万一发生节点故障，传统系统必须在另一个节点上重新启动发生故障的连续运算器，并重播数据流的某些部分以重新计算丢失的信息。（请注意，在重播后新节点赶上之前，管道无法继续进行。）</li></ul><p>Spark流（离散流）</p><ul><li><p>可以在集群中的所有其他节点上并行重新启动失败的任务，从而将所有重新计算均匀地分布在多个节点上，从而从故障中恢复。</p><p><u>计算已经离散化为可以在任何地方运行而不会影响正确性的任务。</u></p></li></ul><h4 id="DSP好处：流、批处理、交互的统一"><a href="#DSP好处：流、批处理、交互的统一" class="headerlink" title="DSP好处：流、批处理、交互的统一"></a>DSP好处：流、批处理、交互的统一</h4><p>Spark Streaming中的关键编程接口是DStream或分布式流。 每一批流数据都由RDD表示，因此DStream只是一系列RDD。</p><p>因此，我们可以使用任何Spark函数处理DStream。例如，我们可以将DStream与预先计算的静态数据集（已加载到另一个RDD中）结合在一起</p><p>数据批存储在workers的内存中，因此可以按需交互查询。<br>批处理，流和交互式工作负载的这种统一在Spark中非常简单，但是在没有<u>工作负载的通用接口</u>的系统中很难实现</p><h4 id="DSP好处：高级分析"><a href="#DSP好处：高级分析" class="headerlink" title="DSP好处：高级分析"></a>DSP好处：高级分析</h4><p>DStreams生成的RDD可以转换为DataFrames并使用SQL查询</p><p>例如，使用Spark的JDBC驱动程序，可以公开流的状态，并支持SQL语句进行查询。</p><p>然后，通过JDBC服务器，就能够以交互方式（比如SQL命令、GUI）查询持续更新的表。</p><h4 id="Spark流：性能"><a href="#Spark流：性能" class="headerlink" title="Spark流：性能"></a>Spark流：性能</h4><p>实际上，Spark Streaming具有批处理数据和利用Spark引擎的能力，可以使吞吐量与其他流系统相当或更高。</p><ul><li>Spark Streaming可以实现低至几百毫秒的延迟。</li></ul><p>开发人员有时会问微批处理是否会固有地增加过多的延迟。</p><ul><li>实际上，批处理延迟仅是端到端管道延迟的一小部分。</li></ul><ul><li>例如，许多应用程序在滑动窗口上计算结果，甚至在COS中，该窗口也仅定期更新（例如，每2秒滑动20秒的窗口）。</li></ul><ul><li>许多管道等待很短的时间来处理延迟或乱序的数据。</li></ul><ul><li>最后，任何自动触发算法都倾向于等待一段时间才能触发。</li></ul><p>同样，DStreams带来的吞吐量提高通常意味着您需要更少的计算机来处理相同的工作负载。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> RDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/12%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%91%E6%88%98/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/12%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%91%E6%88%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="数据的类型"><a href="#数据的类型" class="headerlink" title="数据的类型"></a>数据的类型</h4><p>关系型数据：表、事务、遗产</p><p>文本数据：Web</p><p>半结构化数据：XML</p><p>图形数据：社交网络、语义网络</p><p>流数据：只能被扫描一次</p><h4 id="大数据的5Vs"><a href="#大数据的5Vs" class="headerlink" title="大数据的5Vs"></a>大数据的5Vs</h4><p>Volume 体积</p><p>Velocity 速度</p><p>Variety 多样性</p><p>Veracity 真实性</p><p>Value 价值</p><h4 id="专用场景"><a href="#专用场景" class="headerlink" title="专用场景"></a>专用场景</h4><ul><li>索引，搜索，查询<ul><li>基于关键字的搜索</li><li>模式匹配（XML / RDF）</li><li>深度学习</li></ul></li><li>知识发现<ul><li>数据挖掘</li><li>统计建模</li></ul></li><li>聚合与统计</li><li>建模与预测</li></ul><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><ul><li>大量数据<ul><li>数据产生和类型的速度正在迅速提高</li></ul></li><li>数据描述<ul><li>用于描述内容的元数据和语义</li></ul></li><li>搜索<ul><li>启用语义的搜索引擎</li></ul></li><li>储存和保留<ul><li>重建比存储更容易</li><li>有用数据/噪音数据的比率</li><li>公司通常存储所有内容</li></ul></li><li>监管数据收集<ul><li>信息和知识</li><li>质量控制</li></ul></li></ul><h4 id="可能的解决方案：并行化"><a href="#可能的解决方案：并行化" class="headerlink" title="可能的解决方案：并行化"></a>可能的解决方案：并行化</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf834r6lk0j30tw0dqwfw.jpg" alt="截屏2020-05-28 上午6.10.17" style="zoom: 33%;" /></p><h4 id="并行化的挑战"><a href="#并行化的挑战" class="headerlink" title="并行化的挑战"></a>并行化的挑战</h4><ul><li><p>调度</p><ul><li>我们如何将工作分配给单个workers？</li></ul></li><li><p>可用性</p><ul><li>如果工作单位多于可用的workers该怎么办？</li></ul></li><li><p>依赖关系</p><ul><li>如果worker需要共享部分结果怎么办？</li><li>我们如何知道所有worker何时完成？</li></ul></li><li><p>容错</p><ul><li>如果worker在执行过程中故障怎么办？</li></ul></li><li><p>通信</p><ul><li>workers之间交换状态，访问共享资源（即数据）</li></ul></li></ul><h5 id="需要一种同步机制"><a href="#需要一种同步机制" class="headerlink" title="需要一种同步机制"></a>需要一种同步机制</h5><p>编程模型</p><ul><li>共享内存：pthreads</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf83aaj8w2j30ik08ojsq.jpg" alt="截屏2020-05-28 上午6.15.46" style="zoom: 50%;" /></p><ul><li><p>消息传递：MPI</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf83avmtd4j30d60640ts.jpg" alt="截屏2020-05-28 上午6.16.19" style="zoom: 50%;" /></p></li></ul><p>设计模式</p><ul><li><p>Master-slaves 主从</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf83bpz4rzj309u05sgm5.jpg" alt="截屏2020-05-28 上午6.17.08" style="zoom: 50%;" /></p></li><li><p>生产者消费者</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf83cw6piuj30e607mgmu.jpg" alt="截屏2020-05-28 上午6.18.13" style="zoom:50%;" /></p></li></ul><h4 id="并行化的挑战2"><a href="#并行化的挑战2" class="headerlink" title="并行化的挑战2"></a>并行化的挑战2</h4><p>以下情况会使【并发操作】变得困难</p><ul><li>数据中心扩展</li><li>故障和中断</li><li>多种交互服务</li><li>调试</li></ul><p>负担转移</p><ul><li>开发人员指定需要执行的计算</li><li>处理实际执行的执行框架（在运行时）</li></ul><h5 id="MapReduce、DFS"><a href="#MapReduce、DFS" class="headerlink" title="MapReduce、DFS"></a>MapReduce、DFS</h5><p>略</p><h4 id="案例学习：谷歌文件系统-GFS"><a href="#案例学习：谷歌文件系统-GFS" class="headerlink" title="案例学习：谷歌文件系统 GFS"></a>案例学习：谷歌文件系统 GFS</h4><p>总体结构</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf83xluvo7j30w40bmwl1.jpg" alt="截屏2020-05-28 上午6.38.08" style="zoom:50%;" /></p><p>GFS假设</p><ul><li>使用普通的商品硬件</li><li>高组件故障率<ul><li>廉价的商品组件会一直故障（使用心跳检测）</li></ul></li><li>数量不多的大型文件<ul><li>千兆字节的文件很常见</li></ul></li><li>文件是一次写入的，大部分附加到（同时）</li></ul><p>GFS设计</p><ul><li>文件作为【chunks】被储存<ul><li>固定大小（64MB）</li></ul></li><li>通过复制来保证可靠性<ul><li>每个【chunk】会被复制到超过3个【chunkserver】</li></ul></li><li>单个【master】来协调访问<ul><li>简单的中心化管理</li></ul></li><li>没有数据缓存<ul><li>因为巨大的数据集，因此缓存的作用很低</li></ul></li><li>简化接口</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 使用场景 </tag>
            
            <tag> 大数据挑战 </tag>
            
            <tag> 同步机制 </tag>
            
            <tag> GFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向列的数据库</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20NOSQL-%E8%B0%B7%E6%AD%8CBigTable/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20NOSQL-%E8%B0%B7%E6%AD%8CBigTable/</url>
      
        <content type="html"><![CDATA[<p>大数据系统的规模对数据库空间的要求有很大挑战</p><p>传统的关系数据库管理系统（Relational Database Management System：<em>RDBMS</em>）无法扩展为适应真正的massive级别数据：ACID原则不适合大规模的数据，CAP定理中描述的问题</p><a id="more"></a><h4 id="CAP定理："><a href="#CAP定理：" class="headerlink" title="CAP定理："></a>CAP定理：</h4><ul><li>一致性：所有客户都能看到最新的数据，不管执行过什么操作（比如更新或删除）</li><li>可用性：即使某些节点发送错误，系统也需要继续客户的操作</li><li>分区容错：即使网络或消息发送错误，系统也需要继续执行可续操作（比如一个节点向另一个节点发送的消息，允许发送错误并被丢弃）</li></ul><h4 id="ACID-和-BASE"><a href="#ACID-和-BASE" class="headerlink" title="ACID 和 BASE"></a>ACID 和 BASE</h4><p>ACID：</p><ul><li>Atomic 原子性：事务的所有操作都成功，不然就回滚</li><li>Consistent 一致性：事务不能使数据库的最终状态出现不一致</li><li>Isolated 隔离性：事务使独立的，不能影响其他事务</li><li>Durable 容忍性：即使服务器重新启动等，已完成的事务也会保留。</li></ul><p>BASE</p><ul><li><strong>B</strong>asic <strong>A</strong>vailability 基础可用性：系统在CAP定理方面，保证系统的可用性</li><li><strong>S</strong>oft-state 软状态：系统的状态会随时间改变，即使没有输入（因为要确保最终一致性）</li><li><strong>E</strong>ventual consistency 最终一致性：只要数据库最终变得一致，在每个事务之后就不需要一致性。</li></ul><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><p>可以被分成4类：Key-value stores、Column-oriented databases、Document databases、Graph databases</p><h3 id="Google-BigTable-HBASE"><a href="#Google-BigTable-HBASE" class="headerlink" title="Google BigTable (HBASE)"></a>Google BigTable (HBASE)</h3><p>BigTable是第一个（也是影响力最大的）面向列的NoSQL数据库之一。于2006年发布。它旨在可靠地扩展到数千台计算机上的PB级数据。</p><p>在60多种Google产品中使用，包括Google Earth，Google Analytics（分析）和Youtube。</p><p>BigTable具有极大的影响力，它催生了一个非常受欢迎的开源克隆：HBase。</p><p>设计为与MapReduce BigTable兼容并互补，可为MapReduce提供基于键的快速查找</p><h4 id="关键特征"><a href="#关键特征" class="headerlink" title="关键特征"></a>关键特征</h4><ul><li>BigTable是一个简单的概念 —- 映射两个任意字符串值（行键和列键）以及时间戳，并将其放入关联的任意字节数组中：（行：字符串，列：字符串，时间：int64）-&gt;字符串</li><li>在NoSQL分类中，BigTable是面向列的数据库。<br>它是高度分布式的，没有可用的连接，并且假定“一次写入多次读取”。</li><li>数据模型是“稀疏，分布式，持久的多维排序图”<br>a sparse, distributed, persistent multi-dimensional sorted map”</li><li>实际上，这意味着您可以通过提供行ID，列名和时间戳来访问BigTable中的任何单元（用于版本控制–您保留同一单元的过去版本）。<br>提供这些参数，BigTable会很快将结果返回给您。</li></ul><h4 id="Tablets"><a href="#Tablets" class="headerlink" title="Tablets"></a>Tablets</h4><ul><li>单元的每个新版本都会增加时间戳。 这允许您设置策略，例如“仅保留最新的n个版本”或“仅保留自时间t开始存储的版本”。</li><li>数据按行排序，以行的Key按字典顺序排序，并且表的行范围是动态分区的。 每行范围称为一个Tablets。</li><li>Tablets是分配和负载平衡的单位——如果发生不平衡，则Tablets可以在服务器之间移动。<br>Tablets的大小大约在200MB</li></ul><p>例如 ：如果关键范围是{January，February，March}，并且从March开始有很多数据进入，则它将拆分为多个Tablets，并在服务器之间移动以平衡系统。</p><p>因此，少量row范围的读取是高效的，并且通常仅需要与少量机器通信。</p><h4 id="Tablet-管理"><a href="#Tablet-管理" class="headerlink" title="Tablet 管理"></a>Tablet 管理</h4><p>BigTable使用3层模型对tablet进行管理</p><ol><li>第一层包含存储在Chubby（用于访问控制的分布式锁定服务）中的文件，该文件包含根Tablet的位置。</li><li>根tablet包含系统中所有tablets的位置。 它经过特殊处理，并且与其他tablet不同，它永远不会被分割——确保层次结构永远不会超过3个级别。</li><li>根tablet中的每一行都在内存中使用大约1k的数据。 假设每块tablet有128MB的限制，则3级层次结构可以处理$2^{34}$（〜170亿）个tablets。</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5s2zivqsj30o60b2whu.jpg" alt="截屏2020-03-24下午10.36.12" style="zoom:50%;" /></p><h4 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h4><p>Head node：分配tablets到tablet服务器上</p><p>Tablet server：管理对tablets的读写操作；客户端直接与tablet服务器通信；tablet服务器将太大的tablets拆分</p><p>SSTable：Sorted String Tables 包含真实数据</p><h4 id="读写组织"><a href="#读写组织" class="headerlink" title="读写组织"></a>读写组织</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcvbq1kcy8j30sg0e8dhf.jpg" alt="截屏2020-03-15下午9.34.38"></p><p>内存中有一个表（memTable）用于存储发生的一系列的更新</p><p>一个写操作会将记录添加到memTable中，并且同时会写入日志（为了容错）</p><p>通过读取SSTable文件以及通过动态应用memTable的更新来提供读操作。 换句话说：“这里是价值所在，以及需要应用到该价值以获得真正价值的更新流”</p><h4 id="次要压缩-Minor-Compactions"><a href="#次要压缩-Minor-Compactions" class="headerlink" title="次要压缩 Minor Compactions"></a>次要压缩 Minor Compactions</h4><p>随着写操作执行，memTable的大小也会增大。当memTable的大小达到阈值，该memTable会被冻结，并创建一个新的memTable。被冻结的memTable被转化为SSTable并被写成文件。</p><p> 这部分操作被认为次要压缩，该压缩的两个目标：</p><ol><li>减少tablet服务器的内存使用量</li><li>减少数据恢复时，必须从提交日志中读取的数据量。</li></ol><p>发生压缩时，传入的读/写操作可以继续。</p><h4 id="主要压缩-Major-Compactions"><a href="#主要压缩-Major-Compactions" class="headerlink" title="主要压缩 Major Compactions"></a>主要压缩 Major Compactions</h4><p>每个次要压缩都会产生一个新的SSTable，如果该操作不断进行，读操作需要从大量的SSTables中合并更新。</p><p>为了防止这种情况，我们会在后台定期执行合并压缩。这样的压缩读取了几个SSTables和memTable的内容，并写出了一个新的SSTable。 完成后，可以丢弃之前的SSTables和memTable。</p><p><strong>将所有SSTables重写为一个SSTable的合并压缩称为主要压缩</strong>。 请记住，单个SSTable本身可能会拆分为多个文件。</p><h4 id="关键特征-1"><a href="#关键特征-1" class="headerlink" title="关键特征"></a>关键特征</h4><p>调整压缩格式</p><ul><li><p>客户端可以控制是否压缩地区组的SSTable，以及如果压缩，则使用哪种压缩格式。</p><p>用户指定的压缩格式将应用于每个SSTable块（大小可通过特定于位置组的调整参数来控制）。</p><p>分别压缩每个块时，会损失一些空间，但是我们的好处是，可以读取SSTable的一小部分而无需解压缩整个文件。</p></li></ul><p>布隆过滤器</p><ul><li><p>读取操作必须从组成tablet状态的所有SSTable中读取。 如果这些SSTable不在内存中，我们可能最终会进行许多磁盘访问。</p><p>BigTable可以使用Bloom Filters减少此类访问的次数。 布隆过滤器允许我们询问SSTable是否可能包含指定行/列/对的任何数据。</p><p>对于某些应用程序，将少量tablet服务器内存分配给<u>布隆过滤器</u>，能够大大减少读取操作所需的磁盘搜索次数。</p></li></ul><p>使SSTables不可变</p><ul><li><p>使用BigTable改善性能的另一种方法是使SSTables不可变。</p><p>这意味着SSTables不会直接写入，因为唯一可写入的数据结构是memTable，这使得并发控制相对简单。</p><p>结果，由于具有不可变性，仅在发生重大压缩时才创建SSTables。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google BigTable </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP定理</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12_%20CAP%E5%AE%9A%E7%90%86/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12_%20CAP%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在<a href="https://zh.wikipedia.org/wiki/理论计算机科学" target="_blank" rel="noopener">理论计算机科学</a>中，<strong>CAP定理</strong>（CAP theorem），又被称作<strong>布鲁尔定理</strong>（Brewer’s theorem），它指出对于一个<a href="https://zh.wikipedia.org/wiki/分布式计算" target="_blank" rel="noopener">分布式计算系统</a>来说，不可能同时满足以下三点：<a href="https: //zh.wikipedia.org/wiki/CAP定理#cite_note-Lynch-1">[1]</a><a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-2" target="_blank" rel="noopener">[2]</a></p><ul><li>一致性（<strong>C</strong>onsistency） （等同于所有节点访问同一份最新的数据副本）</li><li><a href="https://zh.wikipedia.org/wiki/可用性" target="_blank" rel="noopener">可用性</a>（<strong>A</strong>vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li><li><a href="https://zh.wikipedia.org/w/index.php?title=网络分区&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">分区容错性</a>（<strong>P</strong>artition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择<a href="https: //zh.wikipedia.org/wiki/CAP定理#cite_note-3">[3]</a>。）</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-4" target="_blank" rel="noopener">[4]</a>。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p></blockquote><a id="more"></a><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>客户端将值写入任何服务器并获得响应后，它期望从其读取的任何服务器取回该值（或更新鲜的值）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcv3kjxahwj319q0lygnv.jpg" alt="截屏2020-03-15下午4.52.25"></p><p>为了保证该特性，客户端在向其中一个服务器写入后，该服务器需要与其他服务器同步，在同步完成后，才会通知客户端已成功写入。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcv3kxx6tij318w0lqwh7.jpg" alt="截屏2020-03-15下午4.52.58"></p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><blockquote><p>系统中非故障节点收到的每个请求都必须导致响应</p><p>every request received by a non-failing node in the system must result in a response</p></blockquote><p>在可用的系统中，如果我们的客户端向服务器发送请求并且服务器没有崩溃，则服务器最终必须响应客户端。不允许服务器忽略客户端的请求。</p><h3 id="分区容错"><a href="#分区容错" class="headerlink" title="分区容错"></a>分区容错</h3><blockquote><p>网络将被允许任意丢失从一个节点发送到另一节点的许多消息</p><p>the network will be allowed to lose arbitrarily many messages sent from one node to another</p></blockquote><p>即一个节点向另外一个节点发送的消息丢失是可接受的，下图展示当所有消息都丢失的情况：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcv3sa21zej30yo08k752.jpg" alt="截屏2020-03-15下午4.59.59"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异构硬件</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20%E5%BC%82%E6%9E%84%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20%E5%BC%82%E6%9E%84%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Cyber-Physical Systems (CPS)，the Internet of Things (IoT)， and the Smart Anything Everywhere Initiative</p><p>从长远来看，随着大规模采用，物联网转型影响预计将显着增加：千万级数量的物品互联，非常大的经济价值</p><p>关键驱动因素：物联网收集的数据，复杂的应用程序开发平台，应用于事物的分析以及<strong>异构硬件体系结构 heterogeneous hardware architectures</strong>，能够促进新业务模型</p><a id="more"></a><h4 id="云计算-大数据"><a href="#云计算-大数据" class="headerlink" title="云计算+大数据"></a>云计算+大数据</h4><p>实时流、实时处理</p><p>数据可视化</p><p>实时结构化数据库、交互式分析、批量处理</p><p>结构化和非结构化数据</p><p>云基础设施</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Cyber-Physical Systems (CPS)，the Internet of Things (IoT)， and the Smart Anything Everywhere Initiative</p><p>从长远来看，随着大规模采用，物联网转型影响预计将显着增加：千万级数量的物品互联，非常大的经济价值</p><p>关键驱动因素：物联网收集的数据，复杂的应用程序开发平台，应用于事物的分析以及<strong>异构硬件体系结构 heterogeneous hardware architectures</strong>，能够促进新业务模型</p><h3 id="异构硬件体系结构-Heterogeneous-hardware-architectures"><a href="#异构硬件体系结构-Heterogeneous-hardware-architectures" class="headerlink" title="异构硬件体系结构 Heterogeneous hardware architectures"></a>异构硬件体系结构 Heterogeneous hardware architectures</h3><p>是运行产品和提供服务的一种高效方法；将不同的处理器类型组合到一个系统中，以此提高绝对性能，最小化能耗和成本。</p><p>引入新的平台：合并多核CPUs，多核GPUs，和许多附加设备作为一个单独解决方案。出现在从超级计算机到个人智能手机的各种环境中.</p><p>因为产品的种类不断增长，因此需要设计<strong>更灵活的软件抽象software abstractions</strong>，以及改进系统结构，以探索异构平台的好处</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>数据巨大且复杂，传统处理方法效率不足：</p><ul><li>Too large to fit reasonably in fast RAM 数据太大无法合理的放入fast RAM中</li><li>Random access intensive, making prefetching and caching ineffective 随机访问密集，使预取和缓存无效</li></ul><p>数据经常被存在多机集群中的二号存储节点中</p><ul><li>存储系统和网络性能成为 first-order concerns</li></ul><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>大数据系统带来新的需求：新的编程模型和工具</p><p>大数据系统需要实现：高性能和高效率</p><h4 id="关于异质性方面"><a href="#关于异质性方面" class="headerlink" title="关于异质性方面"></a>关于异质性方面</h4><p>异质性是并行结构中最深奥和最有挑战的特征</p><p>宏观方面：分布式计算机（云）的网络，由不同的节点结构（单核，多核）组成，通过可能的异质网络进行内部交互；即网络的异质性和，网络上的机器的异质性</p><p>微观方面：底层的内存结构（main、cache、disk storage、tertiary storage）和不同的accelerator结构（固定的、可编程的，比如GPUs；可配置的：FPGAs）</p><h3 id="电脑结构"><a href="#电脑结构" class="headerlink" title="电脑结构"></a>电脑结构</h3><p>需要进行分类：根据目的进行分类</p><h4 id="通用处理器-General-Purpose-Processors（GPP）"><a href="#通用处理器-General-Purpose-Processors（GPP）" class="headerlink" title="通用处理器 General Purpose Processors（GPP）"></a>通用处理器 <strong>General Purpose Processors</strong>（GPP）</h4><ul><li>通用微处理器（通用电脑）：比如PCs，workstations，Laptops，notepads，用于执行多种应用和任务</li><li>微控制器：嵌入式系统<ul><li>专门为嵌入式系统中指定任务而设计</li><li>有面向控制的外围设备</li><li>具有片上CPU，固定数量的RAM，ROM，I / O端口</li><li>低成本、低能耗、低性能、比微处理器更小</li><li>适合对成本、空间、能耗要求严格的应用</li></ul></li></ul><h4 id="应用专用处理器"><a href="#应用专用处理器" class="headerlink" title="应用专用处理器"></a>应用专用处理器</h4><p>通用处理器对不同的软件都能表现出较好的性能，但专用处理器在特定任务上的表现更好</p><p>应用专用处理器出现的目的：更高的性能，更低的消耗，更低的成本</p><p>比如：TVs、mobile phone（不是智能手机）、GPSs</p><p>被分为：</p><ol><li>Digital Signal Processor (DSPs) 数字信号处理器</li><li>Application Specific Instruction Set Processors (ASIPs) 应用专用命令集处理器</li><li>Application Specific Integrated Circuit (ASICs) 应用专用集成电路<ul><li>指定市场、更少编程、难以构建</li></ul></li></ol><h4 id="Accelerators-Coprocessors-加速器-协处理器"><a href="#Accelerators-Coprocessors-加速器-协处理器" class="headerlink" title="Accelerators - Coprocessors 加速器-协处理器"></a><strong>Accelerators - Coprocessors</strong> 加速器-协处理器</h4><p>加速器-协处理器对某些功能的处理性能比CPU更高效more efficiently ：更快、更低能耗，但更难编程，比如：</p><ol><li>Graphics Processing Unit (GPU)<ul><li>Single Instruction Multiple Thread (SIMT) model 单指令多线程模型 – CUDA code</li><li>高效：数据并行应用；吞吐量密集型应用——算法需要处理大量数据元素</li></ul></li><li>FPGA (Field Programmable Gate Array) 现场可编程门阵列<ul><li>是逻辑门阵列，可以进行硬件编程以完成用户指定的任务</li><li>软件的一部分可以直接由硬件实现</li><li>比软件更有效率，但比ASIC更贵</li></ul></li></ol><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>Intel CPU -&gt; DSP -&gt; MultiCore -&gt; ManyCore -&gt; GPU -&gt; FPGA -&gt; ASIC</p><p>灵活性、可编程、 ——&gt; 性能、特定领域、能源使用率高 power efficiency</p><h4 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h4><p>Host memory 主存：CPU的内存</p><p>Device memory 显存：GPU的内存</p><p><strong>处理流程：</strong></p><ol><li>从CPU中将输入数据拷贝到GPU中</li><li>加载GPU程序并执行，将数据缓存到芯片chip上提高性能</li><li>将执行结果从GPU内存中拷贝回CPU内存</li></ol><h4 id="GPU——数据处理"><a href="#GPU——数据处理" class="headerlink" title="GPU——数据处理"></a>GPU——数据处理</h4><p>擅长处理并行 data-parallel processing</p><ul><li>在多个数据元素上并行执行相同的计算——低控制流开销和高SP浮点运算强度 high SP floating point arithmetic intensity</li><li>每个内存访问有许多计算</li></ul><p>高浮点运算强度和许多数据元素意味着可以通过计算而不是大数据缓存来隐藏内存访问延迟</p><ul><li>需要避免带宽饱和</li></ul><h4 id="FPGA-现场可编程门阵列"><a href="#FPGA-现场可编程门阵列" class="headerlink" title="FPGA 现场可编程门阵列"></a>FPGA 现场可编程门阵列</h4><p>可配置逻辑块，内部通信网络，I/O信号</p><h4 id="FPGA——数据处理"><a href="#FPGA——数据处理" class="headerlink" title="FPGA——数据处理"></a>FPGA——数据处理</h4><ul><li>用于数据采集和原始数据预处理以进行事件过滤</li><li>需要掌握基于FPGA的硬件描述语言（HDL）的编程模型。<ul><li>– VHDL和Verilog是设计FPGA系统的传统方法</li><li>–描述执行计算的基础设计的基础硬件</li><li>–这与诸如C和C ++的编程语言形成对比，后者描述了在固定不变体系结构上执行的指令</li><li>–这使得FPGA既可以在其上实现的方面极为灵活，又在不充分了解其编程模型的情况下也很难设计。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异构硬件 </tag>
            
            <tag> GPU </tag>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据仓库、数据去重</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/14%20%E5%8E%BB%E9%87%8D%E5%92%8C%E4%BB%93%E5%BA%93/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/14%20%E5%8E%BB%E9%87%8D%E5%92%8C%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>数据去重是一个逐渐流行起来的方法</p><p>重复数据删除有许多用途，但其主要用途是减少系统所需存储空间的潜力。</p><p>去重可以是文件file级别，块block级别，字节byte级别</p><a id="more"></a><h4 id="数据仓库-data-warehouse"><a href="#数据仓库-data-warehouse" class="headerlink" title="数据仓库 data warehouse"></a>数据仓库 data warehouse</h4><p>假设一个大公司：有许多数据库database、许多站点sites，和不同的schemas。</p><p>求是：•支持决策<br>•在全公司范围内查看高质量信息的集成视图（来自不同的数据库）<br>•分离运营系统和信息系统</p><p>运营系统和信息系统的比较</p><div class="table-container"><table><thead><tr><th>特征</th><th>运营系统</th><th>信息系统</th></tr></thead><tbody><tr><td>主要目的</td><td>在当前基础上用于商业运营</td><td>帮助制定决策</td></tr><tr><td>数据类型</td><td>当前商业运营状况的展示</td><td>历史数据和预测数据</td></tr><tr><td>主要用户</td><td>柜员、销售、管理员</td><td>管理者、商业分析师、客户</td></tr><tr><td>使用范围</td><td>狭窄的、有计划的和简单的<u>更新和查找</u></td><td>宽泛的、复杂的<u>查询和分析</u></td></tr><tr><td>设计目标</td><td>性能：吞吐量、可用性</td><td>灵活访问和使用</td></tr><tr><td>大小</td><td>对一个和少数几个表的大量更新和查询</td><td>周期性的批量更新，对大量或所有行的查询</td></tr></tbody></table></div><p>数据仓库包括：元数据，原始数据-&gt;轻度总结数据-&gt;高度总结数据，数据库管理系统；其他还有：负载管理、查询管理、数据仓库管理</p><p>数据仓库的使用者：联机分析处理OLIP工具，报告、查询、应用开发、EIS工具，数据挖掘工具，和终端用户end-user访问工具</p><p>数据仓库的来源：<strong>运营数据源Operational data source</strong>，运营数据库Operational data store</p><h4 id="数据仓库的定义"><a href="#数据仓库的定义" class="headerlink" title="数据仓库的定义"></a>数据仓库的定义</h4><p>“数据仓库是面向主题的，集成的，随时间变化且非易失性的数据收集，以支持管理层的决策过程。”</p><p><strong>Subject-oriented</strong>：</p><ul><li>面向重要的主题，而不是交易transactions：比如销售、市场、金融、分销distribution；</li><li>简洁的视图，仅提供有用的数据以供决策</li></ul><p><strong>Integrated</strong>：</p><ul><li><p>来自于多个数据源的数据遵循一致的命名习惯Consistent naming conventions、格式、编码结构</p></li><li><p>对缺失数据，噪声数据，不一致数据进行清洗cleaning和预处理pre-processing</p></li></ul><p><strong>Time-varinat</strong>：</p><ul><li>只读，周期性刷新</li><li>提供历史historical值和可能的预测projected值</li></ul><p><strong>Non-volatile</strong>：</p><ul><li>在物理上分别存储</li><li>非在线更新</li><li>从不移除数据，因此没有并发问题</li></ul><h4 id="运营数据-Operational-data"><a href="#运营数据-Operational-data" class="headerlink" title="运营数据 Operational data"></a>运营数据 Operational data</h4><ul><li>transient 短暂的（not historical）</li><li>not normalised非标准化的（指的是数据库的范式）（可能为了性能而去规范化）</li><li>约束在一定范围内（非全面的 not comprehensive）</li><li>有时候质量不佳（出现不一致和错误）</li></ul><p><strong>经过提取/转换/加载 E(xtract)T(ransform)L(oad)后：</strong></p><ul><li>详细的Detailed（但还没被总结summarized）</li><li>历史的（周期性的periodic）</li><li>标准化（第三范式3rd  normal form或更高）</li><li>全面的：以公司为角度</li><li>时效的：数据足够支持目前的决策制定</li><li>质量受控的：数据精确且准确</li></ul><h4 id="删除重复数据-Data-Deduplication"><a href="#删除重复数据-Data-Deduplication" class="headerlink" title="删除重复数据 Data Deduplication"></a>删除重复数据 Data Deduplication</h4><p>数据去重是一个逐渐流行起来的方法</p><p>重复数据删除有许多用途，但其主要用途是减少系统所需存储空间的潜力。</p><p>去重可以是文件file级别，块block级别，字节byte级别</p><h4 id="文件级别去重"><a href="#文件级别去重" class="headerlink" title="文件级别去重"></a>文件级别去重</h4><p>对单文件去重，常被认为“单实例存储”，它的主要思想就是：不管有多少文件实例被使用，只保留一个文件备份</p><p>该技术被用于Amazon S3，并报告出能够减少存储和带宽的成本为1/10</p><h4 id="块级别去重"><a href="#块级别去重" class="headerlink" title="块级别去重"></a>块级别去重</h4><p>将文件拆分成块blocks（或chunks）：核心思想是，经过两个文件不同，但他们可能包括相同的元素（比如两个不同的ppt可能包含同一张图片）</p><h4 id="字节级别去重"><a href="#字节级别去重" class="headerlink" title="字节级别去重"></a>字节级别去重</h4><p>在许多方面，字节级去重是块级去重的一种特殊情况。它比较数据流中的每个单独字节，而不是块。</p><p>字节级别去重是通常是“内容感知”的——比如，卖方对数据流的组成有一定的了解，因此知道要处理的数据流的特定部分。</p><p>该方法通常是“后处理”的，即先存储所有的流，再进行处理</p><h4 id="去重处理"><a href="#去重处理" class="headerlink" title="去重处理"></a>去重处理</h4><p>我们需要一种方法来检查数据是否已经被存储在我们的系统中：对文件、块、字节进行哈希计算，然后在我们的去重数据库DDB中查询该哈希值。如果该值存在，则该数据存在，如果值不存在，则存储该数据和对应的哈希值。</p><h4 id="Source-based-和-Target-based"><a href="#Source-based-和-Target-based" class="headerlink" title="Source-based 和 Target-based"></a>Source-based 和 Target-based</h4><p><strong>Source-based</strong>：</p><ul><li>之间在文件系统（或靠近数据的地方）中进行去重</li><li>对用户和应用透明</li><li>可以由文件系统本身或主机的操作系统执行</li><li>通常一个文件系统会扫描新文件并和现存的文件比较哈希值</li><li>通常需要中心化的管理（文件系统和备份服务器要在一起）</li><li>需要更多的用户资源，而不是带宽</li></ul><p>Target-based</p><ul><li>发生在备份服务器（第二/归档archive数据库）</li><li>重复数据从创建数据的位置删除</li><li>不损耗数据源的资源</li><li>不需要中心化的管理</li><li>需要更多的带宽</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h4 id="去重的权衡"><a href="#去重的权衡" class="headerlink" title="去重的权衡"></a>去重的权衡</h4><p><strong>Granularity 粒度</strong>：影响存储的效率和性能（存储空间和处理效率的权衡）</p><p>将文件拆分得越小（比如chunck-block-byte），就能找到更多的重复数据，但同样的，去重的处理速度也就越慢</p><p>另一个考虑是是容错：只留一个去重数据的副本copy是否足够</p><p>多个副本的优缺点？容错；数据分散靠近用户的cluster中，有利于提高响应时间；占用存储空间，增加成本</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>Operational System —— 运营系统<br>ad hoc —— 常用来形容一些特殊的、不能用于其它方面的，为一个特定的问题、任务而专门设定的解决方案<br>throughput —— 吞吐量</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据去重 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>围棋：AlphaGo Zero</title>
      <link href="/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/07%20%E5%9B%B4%E6%A3%8B%EF%BC%9AAlphaGo-Zero/"/>
      <url>/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/07%20%E5%9B%B4%E6%A3%8B%EF%BC%9AAlphaGo-Zero/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="AlphaGo-Zero"><a href="#AlphaGo-Zero" class="headerlink" title="AlphaGo Zero"></a>AlphaGo Zero</h4><p>（D. Silver, et al., Mastering the game of Go without human knowledge, Nature vol. 550, 2017.）</p><p>通过自己跟自己下棋的强化学习方式，AlphaGo Zero能够自主学习，而不需要人类监督或使用人类数据。</p><ul><li>minibatch=2048</li><li>从最后50万次自我对战中进行数据采样</li><li>每一次迭代学习时，从最佳的模拟玩家中生成2万5千次对战</li><li>如果新的模拟玩家比旧的模拟玩家明显更优秀，则将新的模拟玩家认为是最佳玩家</li></ul><blockquote><p><a href="https://blog.csdn.net/qq_16137569/article/details/83543641" target="_blank" rel="noopener">蒙特卡洛搜索树</a></p></blockquote><h4 id="下棋"><a href="#下棋" class="headerlink" title="下棋"></a>下棋</h4><p><strong>注意：文中的【行动】、【动作】都表示【下棋动作】</strong></p><p>对于棋盘上的每个位置s：</p><ul><li>基于该位置s，估计当前玩家【获胜的可能性v】</li><li>根据游戏规则和【选择每个行动的概率P(a|s)】，定义【一组可能的行动A(s)】</li></ul><p>至此，游戏可以开始：从基于当前棋盘，估计每个位置的获胜可能性分布，计算【选择选择每个行动的概率】，并选择下一个行动，轮流扮演下棋双方，直到游戏结束。</p><p>AlphaGo Zero的核心是深度神经网络，用于根据棋盘的位置，计算<u>行动的可能性和评估</u>：</p><p>$f_\theta(s)=(p,v)$，其中p为所有<u>行动的可能性</u>组成的向量</p><h4 id="改进行动的选择"><a href="#改进行动的选择" class="headerlink" title="改进行动的选择"></a>改进行动的选择</h4><p>与直接使用p相比，更好的方法是<strong>生成一组更好的【行动可能性action probabilities】π（在实验中是1600个），从π中选择行动</strong>。该方法称为【Markov Chain Tree Search 马尔可夫链树搜索】</p><p>在游戏中的每个点，当前的玩家对下棋的步骤进行了很多模拟。这些步骤用树表达，树的【根节点】表示用【当前棋盘布局】。而树的【子节点】表示【延伸的棋盘布局】，【边】表示【行动】</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf1z6fti65j30zo0eqtcv.jpg" alt="截屏2020-05-22 下午11.20.15" style="zoom:50%;" /></p><p>树中的每个【边 edge(s,a)】储存3个数据：</p><ul><li>P(s,a)：给棋盘布局s，选择某动作的先验概率。由<script type="math/tex">f_\theta(s)=(p,v)</script>计算而来。</li><li>N(s,a)：在所有模拟中遍历此节点的次数</li><li>Q(s,a)：它是edge(s,a)下所有子节点的【获胜的可能性v】的平均值。</li></ul><h4 id="单次模拟simulation"><a href="#单次模拟simulation" class="headerlink" title="单次模拟simulation"></a>单次模拟simulation</h4><p>从跟节点开始（即当前的棋局），以迭代的方式，选择能够最大化<script type="math/tex">Q(s,a)+U(s,a)</script>的行动，直到抵达叶子节点（目前还没有被发现undiscovered，即没有继续向下探索的节点）。然后将<script type="math/tex">f_\theta(s)=(p,v)</script>应用到该叶子节点上（此时该叶子节点被发现，将继续往下探索）。</p><p>U(s,a)与右式成正比，该公式的含义是，减少重复访问，鼓励探索<strong>（可以理解为能够被探索的潜力）</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf208kyzrlj30lo04cgma.jpg" alt="截屏2020-05-22 下午11.56.56" style="zoom: 50%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf20dxsijyj310w0au0wh.jpg" alt="截屏2020-05-23 上午12.02.04"></p><ol><li>计算Q+U（Q、U的初始值都是0），选择更大的路径（如果值相等则随机选择）。这类似于启发式的方法，告诉我们应该往哪里进行探索。<ul><li><strong>Q总结了该路径下获胜的可能性的大小，U表示该路径可被探索的潜力</strong>。换句话说，我们倾向于探索，<strong>更可能获胜+更大探索空间的路径</strong>。</li></ul></li><li>当走到树的第三层时，需要探索的路径上缺少节点（论文中，将该节点称为unexpanded，等价于上文所描述的undiscovered），于是我们将该<u>棋盘位置</u>发送到【DNN深度神经网络】上进行计算。<ul><li>【模拟 simulation】的步骤到此结束。接下来是储存探索得到的棋盘，并更新树。</li></ul></li><li>根据该棋盘位置的【获胜的可能性v】，往上更新Q，直到当前的棋盘布局。</li></ol><h4 id="如何计算【行动可能性π】"><a href="#如何计算【行动可能性π】" class="headerlink" title="如何计算【行动可能性π】"></a>如何计算【行动可能性π】</h4><p>针对当前棋盘位置，改进的行动可能性：<script type="math/tex">{\mathrm\pi}_{\mathrm\alpha}\propto\mathrm N{(\mathrm s,\mathrm a)}^{1/\operatorname{𝜏}}</script>。</p><ul><li><p>N(s,a)直接反映了【行动a】引起的【棋盘布局s】的质量</p><ul><li>N值越高，代表对该行动a的子节点探索的次数越多，则意味着发现更多的棋盘布局</li></ul></li><li><p><script type="math/tex">\operatorname{𝜏}</script> 控制着N(s,a)峰值。当<script type="math/tex">\operatorname{𝜏}</script> 接近0时，分布的最大值占主导地位；当<script type="math/tex">\operatorname{𝜏}</script> 变大时，分布会变得平坦。因此<script type="math/tex">\operatorname{𝜏}</script> 决定了所选的行动的专注程度。如下图：</p><ul><li>当<script type="math/tex">\operatorname{𝜏}</script> 越接近0时，大的值越大，小的值越小</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf22sch9sdj30k00oq44z.jpg" alt="截屏2020-05-23 上午1.25.00" style="zoom:50%;" /></p></li><li><p>在前30步时，我们让<script type="math/tex">\operatorname{𝜏}</script> 等于1，于是可以探索更多的行动。当我们最终评估AlphaGo Zero的能力时，我们让<script type="math/tex">\operatorname{𝜏}</script> 接近0，从而保证选择可能性最大的行动。</p></li></ul><h4 id="深度神经网络f-theta"><a href="#深度神经网络f-theta" class="headerlink" title="深度神经网络f_\theta"></a>深度神经网络<script type="math/tex">f_\theta</script></h4><p>$f_\theta(s)=(p,v)$</p><ul><li>p是一个向量，代表所有行动的【行动可能性】；v是当前棋盘布局s获胜的可能性</li><li>s代表当前棋盘布局和前7个棋盘布局，共8层</li><li>红色和蓝色分别表示白子和黑子的位置，灰色表示轮到哪方玩家</li><li>19*19为棋盘大小</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf22xam91yj30zq0mutck.jpg" alt="截屏2020-05-23 上午1.29.52" style="zoom:50%;" /></p><h4 id="残差网络Residual-neural-network-ResNet"><a href="#残差网络Residual-neural-network-ResNet" class="headerlink" title="残差网络Residual neural network (ResNet)"></a>残差网络Residual neural network (ResNet)</h4><blockquote><p>精度会随着网络的层数增多而增多吗？在深度学习中，网络层数增多一般会伴着下面几个问题</p><ol><li>计算资源的消耗</li><li>模型容易过拟合</li><li>梯度消失/梯度爆炸问题的产生</li></ol><p>问题1可以通过GPU集群来解决，对于一个企业资源并不是很大的问题；问题2的过拟合通过采集海量数据，并配合Dropout正则化等方法也可以有效避免；问题3通过Batch Normalization也可以避免。貌似我们只要无脑的增加网络的层数，我们就能从此获益，但实验数据给了我们当头一棒。</p><p>随着网络层数的增加，网络发生了退化（degradation）的现象：随着网络层数的增多，训练集loss逐渐下降，然后趋于饱和，当你再增加网络深度的话，训练集loss反而会增大。注意这并不是过拟合，因为在过拟合中训练loss是一直减小的。</p><p>当网络退化时，浅层网络能够达到比深层网络更好的训练效果，这时如果我们把浅层的特征传到深层，那么效果应该至少不比浅层的网络效果差，或者说如果一个VGG-100网络在第98层使用的是和VGG-16第14层一模一样的特征，那么VGG-100的效果应该会和VGG-16的效果相同。所以，我们可以在VGG-100的98层和14层之间添加一条直接映射（Identity Mapping）来达到此效果。</p><p>从信息论的角度讲，由于DPI（数据处理不等式）的存在，在前向传输的过程中，随着层数的加深，Feature Map包含的图像信息会逐层减少，而ResNet的直接映射的加入，保证了L+1层的网络一定比 L 层包含更多的图像信息。</p><p>基于这种使用直接映射来连接网络不同层直接的思想，残差网络应运而生。</p><p><a href="https://zhuanlan.zhihu.com/p/42706477" target="_blank" rel="noopener">引用文章</a></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf24nybl6oj30z80r443d.jpg" alt="截屏2020-05-23 上午2.30.05" style="zoom:50%;" /></p><p>残差网络分为一系列残差块。</p><p>关键思想是将每个块的输入直接传递到输出。这意味着块内的各层仅需要计算与输入的偏差——所谓的残差。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf258mw9b5j30o40dmq46.jpg" alt="截屏2020-05-23 上午2.49.57" style="zoom: 50%;" /></p><blockquote><p>在统计学中，残差和误差是非常容易混淆的两个概念。误差是衡量观测值和真实值之间的差距，残差是指预测值和观测值之间的差距。对于残差网络的命名原因，作者给出的解释是，网络的一层通常可以看做 <img src="https://www.zhihu.com/equation?tex=y%3DH(x" alt="[公式]">) , 而残差网络的一个残差块可以表示为 <img src="https://www.zhihu.com/equation?tex=H(x" alt="[公式]">%3DF(x)%2Bx) ，也就是 <img src="https://www.zhihu.com/equation?tex=F(x" alt="[公式]">+%3D+H(x)-x) ，在单位映射中， <img src="https://www.zhihu.com/equation?tex=y%3Dx" alt="[公式]"> 便是观测值，而 <img src="https://www.zhihu.com/equation?tex=H(x" alt="[公式]">) 是预测值，所以 <img src="https://www.zhihu.com/equation?tex=F(x" alt="[公式]">) 便对应着残差，因此叫做残差网络。</p></blockquote><h4 id="训练网络"><a href="#训练网络" class="headerlink" title="训练网络"></a>训练网络</h4><p>从当前玩家在实际t的角度，根据胜利者将<script type="math/tex">z_t</script>设为1或-1，在游戏的每个时间点，生成一个数据点<script type="math/tex">(s_t,\pi_t,z_t)</script>。</p><p>然后根据损失函数<script type="math/tex">l</script>，优化<script type="math/tex">f_\theta</script></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf25kzjozij310c0r448p.jpg" alt="截屏2020-05-23 上午3.01.48" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AlphaGo </tag>
            
            <tag> 残差网络 </tag>
            
            <tag> ResNet </tag>
            
            <tag> 深度神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云中间件，配置管理，Contextualization</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/10%20%E4%BA%91%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%EF%BC%8CContextualization/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/10%20%E4%BA%91%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%EF%BC%8CContextualization/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="云计算的好处"><a href="#云计算的好处" class="headerlink" title="云计算的好处"></a>云计算的好处</h4><ul><li>弹性资源：自治的资源按需供应（使用【utility model】）</li><li><p>多重租赁：多个用户并发使用相同资源</p></li><li><p>工作负载整合：将利用不足的资源释放，把工作负载低的虚拟机整合到同一个物理机器上。</p></li></ul><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>定义：位于网络中分布式计算系统每一侧的<u>操作系统和应用程序之间的软件层</u></p><ul><li>连接不同的软件组件</li><li>是在系统和分布式软件之间的软件层</li><li><p>隐藏了分布式系统的复杂性和【异质性heterogeneity】</p></li><li><p>连接了低层次的OS通信（系统级别的通信实现）和编程语言抽象（通信的接口）的间隔</p></li><li><p>为分布式应用提供了常用的编程接口和基础设施</p></li><li>促进资源服务的使用</li><li>将应用与基础设施连接</li></ul><h4 id="Platform-as-a-Service-PaaS"><a href="#Platform-as-a-Service-PaaS" class="headerlink" title="Platform as a Service (PaaS)"></a>Platform as a Service (PaaS)</h4><p>定义：“向消费者提供的功能是将使用提供商提供的编程语言，库，服务和工具创建的，由消费者创建或获取的应用程序部署到云基础架构上。消费者不需要管理或控制包括网络，服务器，操作系统或存储在内的底层云基础架构，但可以控制已部署的应用程序以及应用程序托管环境的配置设置。</p><p>简单的定义：在基本虚拟资源（即虚拟机，块存储）管理之外提供的任何服务。</p><p>是什么：是一种云中间件；提供<u>软件解决方案堆栈</u>即服务；可以聚合其他PaaS和IaaS供应商服务；通常由工具和/或库(APIs)组成</p><p>用处：通过抽象简化应用开发；通过简化管理促进应用部署</p><h4 id="PaaS例子"><a href="#PaaS例子" class="headerlink" title="PaaS例子"></a>PaaS例子</h4><ul><li>Google App Engine</li><li>Amazon Web Services<ul><li>– Amazon RDS (Relational Database Service) </li><li>– Amazon Elastic Transcoder</li></ul></li><li>Hadoop Project<ul><li>– MapReduce</li><li>– Hbase: Bigtable-like capabilities on top of Hadoop and HDFS</li></ul></li></ul><blockquote><p>云服务器属于iaas。</p><p>所谓PaaS实际上是指将软件研发的平台作为一种服务，并提供给用户。用户或者企业基于PaaS平台可以快速开发自己所需要的应用和产品。同时，PaaS平台开发的应用能更好地搭建基于<a href="https://www.baidu.com/s?wd=SOA架构&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">SOA架构</a>的企业应用。</p><p>PaaS作为一个完整的开发服务，提供了从开发工具、中间件，到数据库软件等开发者构建应用程序所需的所有<a href="https://www.baidu.com/s?wd=开发平台&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">开发平台</a>的功能。</p></blockquote><h4 id="云服务的生命周期"><a href="#云服务的生命周期" class="headerlink" title="云服务的生命周期"></a>云服务的生命周期</h4><ol><li>construction：开发、组合、配置</li><li>deployment：选择供应商、部署、上下文化</li><li>operation：调度、优化、执行、重新上下文化</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7u6gnkn1j30zw06mn0u.jpg" alt="截屏2020-05-28 上午1.00.30" style="zoom:50%;" /></p><p>（J. Tordsson, K. Djemame, D. Espling, G. Katsaros, W. Ziegler, O. Wäldrich, K. Konstanteli, A. Sajjad, M. Rajarajan, G. Gallizo, and S. Nair. Towards Holistic Cloud Management, In D. Petcu and J.L. Vazquez-Poletti (eds), European research Activities in Cloud Computing, Cambridge Scholars Publishing, pp. 122-150, 2012.）</p><h4 id="配置管理-Configuration-Management-CM"><a href="#配置管理-Configuration-Management-CM" class="headerlink" title="配置管理 Configuration Management (CM)"></a>配置管理 Configuration Management (CM)</h4><p>用于：在构造阶段后（但不是在部署和操作阶段），在大规模机器上（10k）配置应用和中间件</p><p>例子：puppet、chef</p><h4 id="Puppet-自动化运维工具"><a href="#Puppet-自动化运维工具" class="headerlink" title="Puppet 自动化运维工具"></a>Puppet 自动化运维工具</h4><ul><li>提供基于图像的和模型驱动的方式；</li><li>通过人类可读的DSL（Domain Specific Language）实现；</li><li>资源是存储在“清单”中的配置单位；</li><li>可以将资源编译到定义依赖项的目录中（作为有向非循环图）；</li><li>目录已应用于系统以对其进行配置；</li><li>许多步骤中配置的更改是不确定的（并非是最终的应用）</li></ul><h4 id="Chef"><a href="#Chef" class="headerlink" title="Chef"></a>Chef</h4><p>是Puppet的一个受欢迎的分支；</p><p>主要区别：天生就是确定性的 Deterministic</p><p>强调启动一个新的服务（适合虚拟机和云）</p><p>按顺序应用配置，且用户可知</p><p>使用烹饪进行类比：</p><ul><li>创建配方（安装步骤或脚本的预算）</li><li>使用刀（用于管理的命令行工具）</li><li>存储在服务器内的食谱中</li></ul><h4 id="Chef的结构"><a href="#Chef的结构" class="headerlink" title="Chef的结构"></a>Chef的结构</h4><p>Client-Server架构</p><p>服务器推送配置变更</p><p>客户端在机器上实施配置变更</p><h4 id="配置管理在Cloud上的问题"><a href="#配置管理在Cloud上的问题" class="headerlink" title="配置管理在Cloud上的问题"></a>配置管理在Cloud上的问题</h4><ol><li>云环境天生就是动态的：CM工具并不是用于处理有弹性的资源集合（AWS Elastic Beanstalk 是Chef的云生命周期可感知版）；因为云的生命周期，导致云应用和普通应用不一样（Useful in Construction，What about: Deployment, Operation?）</li><li>遗留软件如何迁移到云：如何使遗留软件和他们的中间件适应云的动态特征（如何将云的dynamic nature提取走）</li><li>如何构建可内部交互的云应用</li></ol><h3 id="Contextualization-上下文化"><a href="#Contextualization-上下文化" class="headerlink" title="Contextualization 上下文化"></a>Contextualization 上下文化</h3><p>定义：上下文是在部署到特定环境期间自主配置应用程序的各个组件并支持软件堆栈的过程。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7v5jau4xj30hm0hgq4h.jpg" alt="截屏2020-05-28 上午1.34.19" style="zoom: 50%;" /></p><p>（Contextualization: <strong>Dynamic Configuration of Virtual Machines</strong>.D. Armstrong, D. Espling, J. Tordsson, K. Djemame and E. Elmroth. Journal of Cloud Computing: Advances, Systems and Applications, 2015）</p><ul><li>通过PaaS组件，通过在整个生命周期内配置SaaS和PaaS，来启用弹性云软件堆栈。</li><li>通过通用配置机制支持旧式中间件</li><li>通过recontextualization 实现IaaS供应商的互操作性</li></ul><p>上下文化机制的两个阶段：</p><ul><li>Deployment：从环境中（在PaaS层）采集动态生成的配置数据</li><li>Operation：由VM boot触发，使用上述数据的软件配置</li></ul><p>被OpenNebula和OpenStack采用，使软件能够应用于Iaas供应商的环境，例如：</p><ul><li>配置基础网络（静态和动态）</li><li>配置虚拟机秘钥识别（SSH VPN）</li><li>连接基于网络的存储</li></ul><h4 id="Operation阶段的上下文化"><a href="#Operation阶段的上下文化" class="headerlink" title="Operation阶段的上下文化"></a>Operation阶段的上下文化</h4><ul><li><p>配置数据是如何传递到虚拟机的（见图）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7ukpq3s8j30nu0d6dou.jpg" alt="截屏2020-05-28 上午1.14.21" style="zoom:50%;" /></p></li><li><p>在boot阶段安装ISO光盘镜像（ISO CD image）：上下文数据通过网络脚本传递到虚拟机内部的脚本上，由脚本创建软件专门的配置文件和域数据</p></li><li><p>配置文件和数据用于设置云环境中，软件依赖和中间件服务的上下文</p></li></ul><h4 id="中间件上下文化（配置中间件）"><a href="#中间件上下文化（配置中间件）" class="headerlink" title="中间件上下文化（配置中间件）"></a>中间件上下文化（配置中间件）</h4><p>例子</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7uk7m57gj30ra0lagx4.jpg" alt="截屏2020-05-28 上午1.13.53" style="zoom:67%;" /></p><h4 id="Recontextualization-重新上下文化"><a href="#Recontextualization-重新上下文化" class="headerlink" title="Recontextualization 重新上下文化"></a>Recontextualization 重新上下文化</h4><p>在Operation阶段（runtime）改变配置数据</p><blockquote><p>The recontextualizer is responsible for triggering the creation and association of new infrastructure class context data when applicable domains are migrated to the infrastructure.<br>当将适用的域迁移到基础结构时，recontextualizer负责触发新基础结构类上下文数据的创建和关联。</p></blockquote><p>触发：虚拟机实时迁移Live Migration，比如本地环境变量更改，但无需重启reboot，因此需要触发机制，而不是有规律的执行</p><p>在重新上下文化的过程中，虚拟机将会持续运行，自动的，且更改对应用是透明的</p><h4 id="Contextualizer-结构"><a href="#Contextualizer-结构" class="headerlink" title="Contextualizer 结构"></a>Contextualizer 结构</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcsnmpoczxj31c00g2dlv.jpg" alt="截屏2020-03-13下午2.09.51"></p><blockquote><p>Figure 3 also includes the order in which components are called. From the figure it can be seen that the Contextualizer component is invoked by the VM Manger during application deployment (step 1) to create ISO images (steps 2, 3), create VM images (steps 4, 5) and/or manip- ulate VM images (steps 6, 7). After images have been created and/or manipulated, they are stored in a local data repository (step 8) for deployment by the VM Manager. During operation, if an event from the underlying hypervisor indicates that a VM has been stopped, started or migrated (step 9), alterations to the existing ISO images are made (steps 10, 11) and reinserted into the VM’s virtual device (step 12).</p></blockquote><p>从图中可以看出，在应用程序部署期间，VM管理器调用了Contextuizer组件（步骤1）以创建ISO映像（步骤2、3），创建VM映像（步骤4、5）和/或操作 -确定VM映像（步骤6、7）。 创建和/或操作映像后，它们将存储在本地数据存储库中（步骤8），以供VM Manager进行部署。 在操作过程中，如果来自底层管理程序的事件指示VM已停止，启动或迁移（步骤9），则对现有ISO映像进行更改（步骤10、11），然后将其重新插入VM的虚拟设备中（ 第12步）。</p><h4 id="Recontextualization-例子"><a href="#Recontextualization-例子" class="headerlink" title="Recontextualization 例子"></a>Recontextualization 例子</h4><p>由于先前的设置，分布式文件系统的操作性能可能会在实时迁移后降低</p><p>客户端数据与远程服务节点交互，而不是附近的节点</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务的生命周期 </tag>
            
            <tag> PaaS </tag>
            
            <tag> Contextualization </tag>
            
            <tag> Recontextualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop和MapReduce的发展</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/11%20Hadoop%E5%92%8CMapReduce%E7%9A%84%E5%8F%91%E5%B1%95/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/11%20Hadoop%E5%92%8CMapReduce%E7%9A%84%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>Hadoop 1 的局限、Hadoop 2：HDFS Federation、YARN</p><a id="more"></a><h3 id="Hadoop-1"><a href="#Hadoop-1" class="headerlink" title="Hadoop 1"></a>Hadoop 1</h3><h4 id="Hadoop1中的MapReduce"><a href="#Hadoop1中的MapReduce" class="headerlink" title="Hadoop1中的MapReduce"></a>Hadoop1中的MapReduce</h4><ol><li>客户端提交MapReduce任务到<u>工作追踪器 Job Tracker</u>上</li><li>工作追踪器询问<u>主节点 NameNode</u>：哪些<u>数据节点 Data Node</u>有文件块</li><li>工作追踪器然后将<u>任务追踪器 Task Tracker</u>和<u>执行Map计算的Java代码</u>提供给那些节点。计算任务将在拥有本地数据的节点执行</li><li>任务追踪器将启动Map任务，并监控进程。它将返回心跳和任务状态给工作追踪器</li><li>每一个Map任务完成后，该节点将临时存储结果（中间数据），当所有Map任务都完成后，数据将通过网络发送给执行Reduce任务的节点</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd17f7ua3oj30kq0gkdje.jpg" alt="截屏2020-03-20下午11.39.15" style="zoom:50%;" /></p><h4 id="Hadoop-1-的局限"><a href="#Hadoop-1-的局限" class="headerlink" title="Hadoop 1 的局限"></a>Hadoop 1 的局限</h4><p>集群资源管理和MapReduce是紧密耦合的</p><ul><li>Hadoop 1中的工作追踪器只在一个机器上运行<ol><li>可扩展性有限，但实际中可能需要许多数据节点</li><li>可用性只存在于单点，如果工作追踪器发生故障，那么所有工作 Jobs 都要重启</li></ol></li></ul><blockquote><p>雅虎估计该设计的上限是5000个节点和40000个并发任务</p></blockquote><p>在资源使用上同样存在问题</p><ul><li>Hadoop 1对map和reduce的插槽(slots)数量是提前定义好的，因此可能出现map插槽满了而reduce插槽还是空的情况（反之亦然）</li><li>文件的数量也十分有限。主节点在内存中持有元数据，因此每个集群通常限制为5千万-1亿个文件</li></ul><p>在Hadoop1上运行非MapReduce应用也存在限制</p><ul><li>MapReduce工作基于<u>批处理驱动的分析</u>，但是，人们通常希望在Hadoop集群中运行其他计算范例</li><li>为什么要运行非MapReduce应用？<ul><li>实时分析存在困难。 MapReduce是批处理驱动的； 当需要实时结果时，Apache Storm之类的引擎可以更好地工作。</li><li>消息传递方法在MapReduce中是不可能的（没有相互依赖性）。</li></ul></li></ul><p><strong>这些问题都在Hadoop2中得到解决</strong></p><h4 id="长尾现象"><a href="#长尾现象" class="headerlink" title="长尾现象"></a>长尾现象</h4><p>谷歌与2013年将其识别为长尾现象：<u>个别拖后腿的任务task stragglers</u>大大减慢了应用程序的完成速度（执行阈值比作业平均值高50％），由操作系统抖动 OS jitter，数据偏斜 data skew,，守护进程，能源等引起</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd18i1hjspj311y0e677y.jpg" alt="截屏2020-03-21上午12.16.14"></p><h3 id="Hadoop-2"><a href="#Hadoop-2" class="headerlink" title="Hadoop 2"></a>Hadoop 2</h3><p>Hadoop 2从受限的<u>面向批处理的模型</u>转变为更具交互性和专用性的处理模型</p><p>主要变化有：HDFS联盟，YARN，高度可用的NameNode，容器的概念</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd18nu9h66j30tg0cctcc.jpg" alt="截屏2020-03-21上午12.22.08"></p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是一个抽象概念，但本质上是一种资源分配。</p><p>容器授予应用程序使用特定主机上特定数量资源（cpu，内存，磁盘）的权限。</p><p>容器类似于虚拟机，但是在现有操作系统之上运行，而不是在<u>虚拟机管理程序Hypervisor</u>上运行。换句话说，容器能在应用级别对用户进行隔离（虚拟机是操作系统级别的隔离）。容器之间是相互独立的，但公用操作系统、bins和库</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd18ujrh6zj30lu0ditbg.jpg" alt="截屏2020-03-21上午12.28.35" style="zoom:50%;" /></p><h4 id="高可用性主节点"><a href="#高可用性主节点" class="headerlink" title="高可用性主节点"></a>高可用性主节点</h4><p>解决Hadoop1中主节点的单点问题：它提供在同一群集中运行两个冗余NameNode的选项，可以主动或被动配置，使备用节点<u>热待命 hot standby</u></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1955bwhfj30uq08owgr.jpg" alt="截屏2020-03-21上午12.38.46"></p><h4 id="HDFS水平可扩展性"><a href="#HDFS水平可扩展性" class="headerlink" title="HDFS水平可扩展性"></a>HDFS水平可扩展性</h4><p>由上图可以看出，即使通过备份让主节点获得高可用性，但2个单独的主节点并不能提供水平可扩展性</p><ul><li>垂直可扩展性：更多的RAM，更高效的内存使用，将部分命名空间放到内存中，主类归档（tar/zip）</li><li>水平可扩展性的好处：规模、隔离性、稳定性、可用性、灵活性、实现其他主节点或非HDFS 命名空间</li></ul><h4 id="解决方案：HDFS-Federation"><a href="#解决方案：HDFS-Federation" class="headerlink" title="解决方案：HDFS Federation"></a>解决方案：HDFS Federation</h4><p>解决方式是联合多个独立的主节点</p><ul><li>联合的主节点是独立的，不需要协调。</li><li>数据节点被所有主节点共用，作为块的存储。</li><li>每个数据节点向群集中的所有主节点注册。</li><li>DataNode发送心跳给所有主节点，并接受块报告和处理命令。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd19lu5mjej30jk0bstbq.jpg" alt="截屏2020-03-21上午12.54.48" style="zoom:50%;" /></p><p>主要概念：</p><ul><li><u>块池 Block Pool</u>是一个<u>命名空间 namespace</u>中的一系列块</li><li><p>数据节点存储集群中的所有块</p></li><li><p>块池是独立管理的。因此每个命名空间都可以生成块ID，而不需要与其他命名空间进行达成一致</p></li><li>一个主节点故障不会影响数据节点对其他主节点的服务</li><li>一个命名空间和它对应的块池统称为<u>命名空间卷 Namespace Volumes</u>，如果一个命名空间被删除，它对于的块池也会被删除</li></ul><h4 id="HDFS-Federation的好处"><a href="#HDFS-Federation的好处" class="headerlink" title="HDFS Federation的好处"></a>HDFS Federation的好处</h4><p>命名空间的可扩展性：HDFS群集存储（数据节点）可以水平扩展，但命名空间不能。 当使用大量文件部署时，可通过向群集添加更多主节点的而达成水平扩展的目的</p><p>性能：文件系统操作吞吐量不再局限于单个主节点的</p><p>隔离：单个主节点的在多用户环境中不提供隔离。 现在，我们可以将不同类别的应用程序放入不同的主节点中（例如，实验性应用程序减慢主节点的运行速度不会影响其余集群）</p><h4 id="Yet-Another-Resource-Negotiation-YARN"><a href="#Yet-Another-Resource-Negotiation-YARN" class="headerlink" title="Yet Another Resource Negotiation (YARN)"></a>Yet Another Resource Negotiation (YARN)</h4><p>YARN的基础思想是：将Hadoop资源管理和工作调度拆分为不同的进程（后台进程）</p><p>不同种类的应用程序都能被提交给YARN（比如MapReduce，Giraph等），应用程序可以是单个作业，也可以是作业的<u>有向无环图Directed Acyclic Graph（DAG）</u>。</p><p>这样可以并行运行更多作业，并且可扩展性得到显着提高</p><ul><li><u>资源管理器ResourceManager</u>代替<u>工作追踪器JobTracker</u>，负责在所有应用程序之间仲裁资源的使用权限。<ul><li>持续追踪：维护在集群上运行的所有程序，以及所有在线的节点管理器的可用资源</li><li>分配资源：决定下一个使用集群资源的程序（即下个一程序应该分配到哪个数据节点上）</li><li>监控<u>程序主节点</u></li></ul></li><li><p><u>节点管理器NodeManager</u>是一个基于机器的框架，负责管理容器、监视资源使用情况并向资源管理器报告。 集群中的每台计算机都是一个节点管理器和一个数据节点。 </p><ul><li>以容器的形式提供计算资源</li><li>管理容器内运行的进程</li><li>负责监视资源（容器）。 它没有固定数量的Map和Reduce插槽，但是可以动态创建和管理<u>资源容器</u>。 它就像Hadoop 1中JobTracker的通用版本。</li></ul></li><li><p><u>ApplicationMaster的任务是与资源管理器协商资源，并与各个节点管理器一起执行和监视任务。</p><ul><li>协调执行程序的内所有任务</li><li>请求合适的资源容器来执行任务</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1cz80dvaj30zk0hq118.jpg" alt="截屏2020-03-21上午2.51.28"></p><blockquote><p>ApplicationMaster负责单个应用程序的执行。它从资源调度程序（资源管理器）中请求容器，并在获得的容器上执行特定的程序（例如，Java类的主程序）。 Application Master知道程序逻辑，因此每个框架都需要自己编写ApplicationMaster。 MapReduce框架提供了自己的应用ApplicationMaster。</p><p>应用程序管理器ApplicationManager负责维护已提交的应用程序列表。在客户端提交应用程序后，应用程序管理器首先验证是否满足其ApplicationMaster的资源需求。如果有足够的资源，则将程序转发给调度器，否则将拒绝。还要确保没有其他具有相同应用程序ID的应用程序提交。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5f0alzhqj30ni0b2dgh.jpg" alt="image"></p><h4 id="提交应用到YARN中"><a href="#提交应用到YARN中" class="headerlink" title="提交应用到YARN中"></a>提交应用到YARN中</h4><ol><li>客户端将需要执行的程序发送给<u>资源管理器ResourceManager</u>（如MapReduce）</li><li>资源管理器，在容器内启动一个<u>程序管理器ApplicationMaster</u>，并将要执行的程序发送过去</li><li><u>程序管理器</u>与<u>资源管理器</u>协商资源。<ul><li>它负责应用程序的整个生命周期。</li><li>资源请求只是请求分配多个容器，表示为magabytes和CPU份额（当前）。</li></ul></li><li>然后，<u>ApplicationMaster</u>与<u>节点管理器</u>联系，以在容器中启动任务<ul><li>它监视这些任务的进度，重启失败的任务，推测性地运行速度较慢的任务，并计算应用程序计数器的总值。</li><li>它的整个生命周期用于与容器协商，来启动完成程序所需的所有任务</li></ul></li><li><u>资源管理器</u>不会监视程序中的任务——但它会检查<u>ApplicationMaster</u>的运行状况<ul><li>如果<u>ApplicationMaster</u>失败，则<u>资源管理器</u>可以在新容器中重新启动它。</li><li><u>资源管理器</u>负责<u>ApplicationMaster</u>，而<u>ApplicationMaster</u>负责<u>任务</u></li></ul></li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5fujv1klj317o0r6arg.jpg" alt="截屏2020-03-24下午3.31.42" style="zoom:50%;" /></p><h4 id="YARN可以运行任何分布式程序"><a href="#YARN可以运行任何分布式程序" class="headerlink" title="YARN可以运行任何分布式程序"></a>YARN可以运行任何分布式程序</h4><p>ResourceManager，NodeManager和Container不关心它们要运行的任务或应用程序的类型。只要实现了适当的ApplicationMaster，任何应用程序都可以运行。</p><p>好处：</p><ul><li>更高的集群利用率（一个框架不使用的资源可以被另一个框架使用）</li><li>更低的运营成本（仅需要管理和调整一种类型的集群）</li><li>数据移动减少（无需在YARN和其他系统之间移动数据）</li></ul><p>管理单个群集，还能够减少数据中心空间的使用，从而降低的运营成本，功耗，发热等。</p><h4 id="YARN的其他特征"><a href="#YARN的其他特征" class="headerlink" title="YARN的其他特征"></a>YARN的其他特征</h4><ul><li>如果作业足够小，则可以直接在ApplicationMaster的容器中运行MapReduce作业的所有任务。 这避免了从ResourceManager请求容器并要求NodeManager启动（据说很小）任务的开销。（见上图）</li><li>YARN提供简化的用户日志管理和访问。 与旧的Hadoop 1 MapReduce不同，日志不会保留在单个从节点上，而是移至中央存储（例如HDFS）。 后续可用于调试，性能分析等。</li><li>在重启资源管理器后恢复程序(YARN-128)——使资源管理器可以重建应用程序的状态，并仅重新运行未完成的任务。</li><li>高可用性的资源管理器体系结构（YARN-149）——发送故障后，支持资源管理器从一个实例到另一个实例（可能在另一台计算机上）。 它涉及领导者竞选，权限转移，客户端重定向。</li></ul><h4 id="Hadoop-2总结"><a href="#Hadoop-2总结" class="headerlink" title="Hadoop 2总结"></a>Hadoop 2总结</h4><p>HDFS2——高可用性和用于水平扩展的联合主节点</p><p>YARN——超越了Hadoop 1的批处理，并提高了效率</p><p>工具和程序的完整生态系统</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1dm0m0pfj30wy0be0wi.jpg" alt="截屏2020-03-21上午3.13.22"></p><h4 id="Hadoop不平衡集群"><a href="#Hadoop不平衡集群" class="headerlink" title="Hadoop不平衡集群"></a>Hadoop不平衡集群</h4><p>问题：</p><ul><li>将新服务器和机架添加到Hadoop群集可能会导致其变得不平衡。 现有数据保留在原处，新服务器处于空闲状态。</li><li>如果现有节点繁忙，则<u>工作追踪器JobTracker</u>可能不得不将Map任务分配给新服务器。</li><li>如果发生这种情况，新服务器将需要通过网络复制对应的数据块。 这导致更多的网络流量和较慢的作业完成时间。</li></ul><p>解决：为了解决不平衡的情况，Hadoop包含一个称为平衡器的实用程序。</p><ul><li>它检查节点之间的可用空间的差异，并尝试平衡到阈值。</li><li>当检测到具有大量磁盘空间的节点时，数据块将从空间较小的节点复制过去。 </li><li>平衡器是手动运行的，并在管理员关闭其终端时停止。 </li><li>平衡器的默认设置为1MB / s网络流量，可更改。</li></ul><p>理想情况下，平衡器应在所有群集上定期运行以进行良好管理。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop1 </tag>
            
            <tag> Hadoop2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从电视节目中恢复角色</title>
      <link href="/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/05next%20%E4%BB%8E%E7%94%B5%E8%A7%86%E4%B8%AD%E6%8D%95%E8%8E%B7%E4%BA%BA%E7%89%A9/"/>
      <url>/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/05next%20%E4%BB%8E%E7%94%B5%E8%A7%86%E4%B8%AD%E6%8D%95%E8%8E%B7%E4%BA%BA%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<p>J. Charles et al., Virtual Immortality: Reanimating Characters from TV Shows, VARVAI workshop at ECCV, 2016.</p><a id="more"></a><h4 id="移除视频中的背景声音"><a href="#移除视频中的背景声音" class="headerlink" title="移除视频中的背景声音"></a>移除视频中的背景声音</h4><p>比如音乐、笑声等</p><h4 id="自动音素标记"><a href="#自动音素标记" class="headerlink" title="自动音素标记"></a>自动音素标记</h4><p>使用【动态编程】和【美式英语声学模型】将【transcript】与音频对齐</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf1cjbvhh9j31180e0tpn.jpg" alt="截屏2020-05-22 上午10.16.44" style="zoom:50%;" /></p><blockquote><p>If you already have 【transcripts】 for your videos, 【transcript alignment】 is the fastest and least expensive way to create captions and use interactive video plugins.</p></blockquote><h4 id="面部识别与追踪"><a href="#面部识别与追踪" class="headerlink" title="面部识别与追踪"></a>面部识别与追踪</h4><p>正面面部识别(Viola and Jones, CVPR 2001)——Frontal face</p><p>使用关键点进行侧面追踪(Shi and Tomasi, CVPR 1994)——Profile</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf1cly0prwj30vu0bo173.jpg" alt="截屏2020-05-22 上午10.19.21" style="zoom:50%;" /></p><h4 id="自动人物标记"><a href="#自动人物标记" class="headerlink" title="自动人物标记"></a>自动人物标记</h4><ol><li>从对齐的【transcript】中，用<u>人名</u>标记<u>单独的人脸轨迹</u></li><li>使用【深度人脸特征 deep face features】训练分类器 （Parkhi et al., BMVC 2015）</li><li>对所有的【人脸轨迹】进行分类，并将分类器识别程度最高的<u>人脸轨迹标签加入到训练集中</li><li>重复2、3步骤：从对齐的【transcript】中，使用<u>未分配的人名</u>，对<u>还未标记的单独的人脸轨迹</u>进行重新训练（标记）</li><li>深度人脸识别</li></ol><h4 id="深度人脸识别"><a href="#深度人脸识别" class="headerlink" title="深度人脸识别"></a>深度人脸识别</h4><p>（Parkhi et al., Deep Face Recognition, BMVC 2015）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf1gk2466fj30yk0dg119.jpg" alt="截屏2020-05-22 下午12.35.59" style="zoom:50%;" /></p><h4 id="提取动态视位"><a href="#提取动态视位" class="headerlink" title="提取动态视位"></a>提取动态视位</h4><p>从检测到嘴部区域中，给每个音位（发音）提取视位（嘴型），捕捉共同发音（co-articulation）</p><blockquote><p>co-articulation：the articulation of two or more speech sounds together, so that one influences the other.<br>共同发音：两个或两个以上语音的表达一起发出声音，从而使一个影响另一个。</p></blockquote><p><img src="../../../../../Library/Application Support/typora-user-images/截屏2020-05-22 下午12.43.54.png" alt="截屏2020-05-22 下午12.43.54" style="zoom:50%;" /></p><h4 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h4><p>针对每个人的说法方式，建立对应的语言模型——LSTM，deep RNN，基于字符（因为说话的方式可能是非标准的单词或句子结构）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf1h0dq95yj30l40g8wi4.jpg" alt="截屏2020-05-22 下午12.51.39" style="zoom:33%;" /></p><h4 id="生成对话"><a href="#生成对话" class="headerlink" title="生成对话"></a>生成对话</h4><p>对训练好的网络进行采样，来生成对话。</p><p>通过还使用【Levenshtein/edit distance】显示训练集中的最佳匹配句子，可以显示每个生成句子的<u>唯一性</u>。</p><blockquote><p>Levenshtein/edit distance 原理：从一个句子变化成另一个句子，需要改变多少个字符</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf1hgebu64j310e0j47wh.jpg" alt="截屏2020-05-22 下午1.06.57" style="zoom: 50%;" /></p><h4 id="文本到语言"><a href="#文本到语言" class="headerlink" title="文本到语言"></a>文本到语言</h4><ol><li>为某个人生成人物对话</li><li>合成人物语音（通过软件）</li><li>基于1、2步骤，合成嘴型（将嘴部动作与音位（发音）对齐）</li><li>与背景视频融合</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf1hbh7p21j310y0oun5s.jpg" alt="截屏2020-05-22 下午1.01.58" style="zoom: 33%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bloom filters 布隆过滤器</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20Bloom%20filters%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20Bloom%20filters%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>布隆过滤器</strong>（英語：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><a id="more"></a><p><a href="https://zhuanlan.zhihu.com/p/72378274" target="_blank" rel="noopener">计算介绍</a></p><p>will trigger: false positive —- 认为存在，实际上不存在</p><p>will no trigger: false negative —- 认为不存在，但实际存储（真实情况是：只要布隆过滤器认为元素不存在，那么就肯定不存在）</p><h4 id="demo-amp-介绍"><a href="#demo-amp-介绍" class="headerlink" title="demo &amp; 介绍"></a>demo &amp; 介绍</h4><p><a href="https://llimllib.github.io/bloomfilter-tutorial/" target="_blank" rel="noopener">demo</a></p><p><a href="https://zhuanlan.zhihu.com/p/72378274" target="_blank" rel="noopener">计算方式</a></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>布隆过滤器</strong>（英語：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。<a href="https://zh.wikipedia.org/wiki/链表" target="_blank" rel="noopener">链表</a>、<a href="https://zh.wikipedia.org/wiki/树_(数据结构" target="_blank" rel="noopener">树</a>)、<a href="https://zh.wikipedia.org/wiki/散列表" target="_blank" rel="noopener">散列表</a>（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/db50673c67c6e72b7342ca1383def18cdead21b6" alt="{\displaystyle O(https://wikimedia.org/api/rest_v1/media/math/render/svg/db50673c67c6e72b7342ca1383def18cdead21b6),O(\log n),O(1)}">。</p><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个<a href="https://zh.wikipedia.org/wiki/散列函数" target="_blank" rel="noopener">散列函数</a>将这个元素映射成一个位<a href="https://zh.wikipedia.org/wiki/数组" target="_blank" rel="noopener">数组</a>中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ec39041121b14e8c2b1a986c9b04547b223e3c" alt="O(https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ec39041121b14e8c2b1a986c9b04547b223e3c)">。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p><p>布隆过滤器可以表示全集，其它任何数据结构都不能；</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" alt="k">和<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0a07d98bb302f3856cbabc47b2b9016692e3f7bc" alt="m">相同，使用同一组散列函数的两个布隆过滤器的交并<a href="https://zh.wikipedia.org/wiki/Wikipedia:列明来源" target="_blank" rel="noopener">[來源請求]</a>运算可以使用位操作进行。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率false positive随之增加。但是如果元素数量太少，则使用散列表足矣。</p><p>另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><p>在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p><p>optimal number of hash functions $k=\frac{m}{n}ln2,k=-\frac{lnp}{ln2}$</p><p>估计要添加的元素数量</p><p>bollm过滤器的大小</p><p>计算最佳的哈希函数数量</p><p>计算false positive的可能性</p><p>trade-off</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布隆过滤器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN图像分类</title>
      <link href="/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%BB%83%E4%B9%A0%EF%BC%9ACNN%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
      <url>/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%BB%83%E4%B9%A0%EF%BC%9ACNN%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>实验步骤和分析</p><a id="more"></a><h3 id="Clarification"><a href="#Clarification" class="headerlink" title="Clarification"></a>Clarification</h3><ul><li><p>This coursework is running and testing on Google Colab. </p></li><li><p>Because the test set is extracted randomly from the dataset, the accuracy on the test set cannot precisely represent the performance of model. But it is still a reasonable approach for evaluating the performance of model.</p></li><li><p>The evaluation on the test set is using the model at final epoch in task 1-3 using the model with lowest loss on validation set in task 4.</p></li></ul><h3 id="Task-1-Experiments"><a href="#Task-1-Experiments" class="headerlink" title="Task 1: Experiments"></a><strong>Task 1: Experiments</strong></h3><h4 id="Subtask-1-1-How-does-the-number-of-layers-affect-the-training-process-and-test-performance-Try-between-2-and-5-layers"><a href="#Subtask-1-1-How-does-the-number-of-layers-affect-the-training-process-and-test-performance-Try-between-2-and-5-layers" class="headerlink" title="Subtask 1-1: How does the number of layers affect the training process and test performance? Try between 2 and 5 layers."></a><strong>Subtask 1-1: How does the number of layers affect the training process and test performance? Try between 2 and 5 layers.</strong></h4><p>Firstly, to clarify the architecture of 4 CNNs for the experiments, I assume the layer 4 and 5 are following the pattern of given layer 1-3 —— the output channels of each layer are added by 8 from its input channels. The parameters of each layer are listed in table 1. Each convolutional layer is followed by the same ReLU, max-pooling and dropout (see table 2). After the last convolutional layer, there are 2 fully connected layers (see table 3). Other relevant parameters are shown in table 4.</p><p>In short, the control variable is only the number of layers and its parameters, everything else, even the increasing pattern of the layer’s parameters, keep the same as possible.</p><p>Table 1: Parameters of each convolutional layer.</p><div class="table-container"><table><thead><tr><th>Layer 1</th><th>Input channels = 3, output channels = 16,  kernel size = 3</th></tr></thead><tbody><tr><td>Layer 2</td><td>Input channels = 16, output channels = 24,  kernel size = 4</td></tr><tr><td>Layer 3</td><td>Input channels = 24, output channels = 32,  kernel size = 4</td></tr><tr><td>Layer 4</td><td>Input channels = 32, output channels = 40,  kernel size = 4</td></tr><tr><td>Layer 5</td><td>Input channels = 40, output channels = 48, kernel  size = 4</td></tr></tbody></table></div><p>Table 2: Functional layers followed by each layer, and relevant parameters.</p><div class="table-container"><table><thead><tr><th>ReLU</th><th></th></tr></thead><tbody><tr><td>Max-pooling</td><td>Kernel size = 2</td></tr><tr><td>Dropout</td><td>Rate = 0.3</td></tr></tbody></table></div><p>Table 3: Fully connected layer, and relevant parameters.</p><div class="table-container"><table><thead><tr><th>Fully connected layer 1</th><th>Input = (flattened output of last  convolutional layer), output = 512</th></tr></thead><tbody><tr><td>Fully connected layer 2</td><td>Input = 512, output = 10</td></tr></tbody></table></div><p>Table 4: Other relevant parameters and methods.</p><div class="table-container"><table><thead><tr><th>Other relevant parameters and methods.</th></tr></thead><tbody><tr><td>Learning  rate = 0.001, Batch size = 16, momentum=0.9  Optimizer = SGD, Loss function = CrossEntropyLoss</td></tr></tbody></table></div><p>In the subtask 1-1, table 5 compares the accuracy of CNNs with a different number of maximal layers, visualizing their confusion matrixes and Loss curves. For each CNNs, the training will stop when the model converges (pre-train the model to find out the most suitable training epochs —— the point when loss curve start increasing, which means overfitting and losing generalization on unseen data). For example, 2-layer CNN will converge at 4th epoch and achieve 49.89% accuracy on the test set, and 5-layer CNN can achieve 63.17% of accuracy on the test set, and this 5-layer CNN will converge at 40th epoch.</p><p>Table 5. Range of accuracy on the test set, after 3 times execution for each architectures (different number of maximal layers).</p><div class="table-container"><table><thead><tr><th>Maximal  layer</th><th>The highest  accuracy (%)</th><th>The lowest  accuracy (%)</th><th>Number of  Epochs when converge</th></tr></thead><tbody><tr><td>Layer 2</td><td>49.89</td><td>45.06</td><td>4</td></tr><tr><td>Layer 3</td><td>53.22</td><td>53.11</td><td>10</td></tr><tr><td>Layer 4</td><td>57.17</td><td>55.94</td><td>15</td></tr><tr><td>Layer 5</td><td>63.17</td><td>59.00</td><td>40</td></tr></tbody></table></div><p>Convolution layer is used to abstract feature and simplify the complexity of the network. A different number of filters and layers can have different performance. The results shown in table 5 indicate that with the increment of layers mentioned above, the accuracy of the model on the test set also increased. It is reasonable in this case because more layer will output more feature map to represent the original image and for classifying</p><p>In figure 1, we can have a clearer understanding of how the models with different layer perform when predicting the class on the test set. On confusion matrix (a) (b) (c) (d), the percentages of a misclassified image are decreasing when the CNN go deeper (seeing the light cells excluding diagonal getting dark from (a) to (b)). The loss curves (e) (f) (g) (h) in which the lines tend to be flat are used to detect converge.</p><p>The best performance is given by 5-layer CNN, achieving 63.17% accuracy on the test set at 40th epochs. The parameters are listed in Table 1-5. This 5-layer CNN will be used in task 2 &amp; 3, called CNN-5L.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduxi6uxvsj31320ioe5h.jpg" alt="截屏2020-04-15 下午5.43.01"></p><p>Figure 1. Confusion matrix and loss curves of CNNs at 1st execution —— (a) (e) 2-layer, (b) (f) 3-layer, (c) (g) 4-layer, (d) (h) 5-layer</p><h4 id="Subtask-2-Choose-one-more-architectural-element-to-test"><a href="#Subtask-2-Choose-one-more-architectural-element-to-test" class="headerlink" title="Subtask 2: Choose one more architectural element to test"></a><strong>Subtask 2: Choose one more architectural element to test</strong></h4><p>In subtask2, the report will test with 3 different elements. The first experiment is to test the performance of different batch size in 3-layer CNN. The second experiment is to increase the number of fully connected layers in 5-layer CNN. The third experiment is to increase the parameters for each convolutional layer.</p><ol><li><p>The first experiment is based on 3-layer convolutional neural, keeping other parameters same as mentioned above, and train the model with different batch size (see table 6). The model will be pre-trained to find out the number of epoch to converge before the evaluation of accuracy on the test set.</p><p>Intuitively, a larger batch size means the number of iterations required to run an epoch is reduced and therefore speed up the processing. If the batch size is within an ideal range, a larger the batch size will take more points into account, and therefore can make the gradient direction more accurate with less fluctuation. However, based on the result, to achieve similar accuracy, it needs more epochs to run.</p></li></ol><p>Table 6 Comparison of accuracy and converge epochs for different batch size</p><div class="table-container"><table><thead><tr><th>Batch size</th><th>Converge epochs</th><th>Accuracy</th></tr></thead><tbody><tr><td>8</td><td>7</td><td>49.44</td></tr><tr><td>16</td><td>10</td><td>53.22</td></tr><tr><td>32</td><td>13</td><td>51.28</td></tr></tbody></table></div><p>Figure 2: Confusion matrixes of 8 batches CNN (a), 16 batches CNN (b) and 32 batches CNN (c).</p><ol><li>The result of 5-layer architecture seems good. In this experiment, based on the previous 5-layer network, a new CNN with one more fully connected layer with the same 512 input and output channels is tested (see table 7.).  The accuracy of this model on the test set is 59.22% for the first time and 59.59% for the second time. It seems that the performance does not have much difference comparing with CNN-5L (the original 5-layer CNN).</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduxixih8lj311m0d6qoo.jpg" alt="截屏2020-04-15 下午5.43.29"></p><p>Table 7. Parameters of 3 fully connected layers</p><div class="table-container"><table><thead><tr><th>Fully connected layer 1</th><th>Input = (flattened output of last  convolutional layer), output = 512</th></tr></thead><tbody><tr><td>Fully connected layer 2</td><td>Input = 512, output = 512</td></tr><tr><td>Fully connected layer 3</td><td>Input = 512, output = 10</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy0gqk30j30um0ec49z.jpg" alt="截屏2020-04-15 下午6.00.33"></p><p>Figure 3. Confusion matrix (a) and loss curve (b) in experiment 2 (with 59.22% ACC on the test set).</p><ol><li>The third experiment is to increase the parameters for each convolutional layer —— multiply by 4 (see table 8). Larger channels values normally mean that the model can extract more features from an image. After pre-trained the CNN, the loss curve shows the model will converge at around 23rd epoch. Running 23rd epoch again, the model got 61.22% accuracy on the test set. It seems slightly better than the model in experiment 2 but still stays in the potential accuracy range of CNN-5L.</li></ol><p>Table 8. Parameters of each layer in the 5-layer CNN</p><div class="table-container"><table><thead><tr><th>Layer 1</th><th>Input channels = 3, output channels = 64,  kernel size = 3</th></tr></thead><tbody><tr><td>Layer 2</td><td>Input channels = 64, output channels = 96,  kernel size = 4</td></tr><tr><td>Layer 3</td><td>Input channels = 96, output channels = 128,  kernel size = 4</td></tr><tr><td>Layer 4</td><td>Input channels = 128, output channels = 160,  kernel size = 4</td></tr><tr><td>Layer 5</td><td>Input channels = 160, output channels = 196,  kernel size = 4</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy110xrwj30uw0e0n8i.jpg" alt="截屏2020-04-15 下午6.01.09"></p><p>Figure 4: Confusion matrix (a) and loss curve (b) in experiment 3.</p><h3 id="Task-2-Filter-visualization"><a href="#Task-2-Filter-visualization" class="headerlink" title="Task 2: Filter visualization"></a><strong>Task 2: Filter visualization</strong></h3><p>The filters before training are initialized randomly (see figure 5-a). During the training process, the filters will be updated by gradient descent and backpropagation. In figure 5, there are significant differences between the filters before training (5-a) and halfway training (5-b), which means the model change a lot during the process. However, comparing with the filters in halfway training and after training, there only slight differences, which means that the filters of the first layer of this specific model are close to the optimal values (but possibility local optimum instead of global optimum). This phenomenon can also be observed on loss and accuracy curve (see figure 6). It is clear that the differences between 0 and 20th epochs are significant but much smaller between 20th and 40th epochs (e.g. compare the gaps between 3 lines in figure 6-a).</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy1ia24zj311s0dw7jy.jpg" alt="截屏2020-04-15 下午6.01.39"></p><p>Figure 5: Filters before training (a), halfway training (b) and after training (c), outputting from Conv2d without ReLU.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy2hyckcj311y0euakn.jpg" alt="截屏2020-04-15 下午6.02.35"></p><p>Figure 6: Loss (a) and accuracy (b) curve in CNN-5L.</p><h3 id="Task-3-Feature-map-visualization"><a href="#Task-3-Feature-map-visualization" class="headerlink" title="Task 3: Feature map visualization"></a><strong>Task 3: Feature map visualization</strong></h3><p>The number of feature maps equals to that of output channels, each filter will extract a type of feature map. With the network goes deeper, feature maps will become smaller and blurrier, but also means being more representative than the previous layer. For example, figure 7 (a) is showing the image of a banana. It is obvious that the feature maps at 6th row are smaller and more abstractive than the 2nd row. Loot at the graffiti on the banana peel in the original image. The information of these graffiti which is unrelated for identifying and classifying is gradually removed from the feature maps as the network goes deeper.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy3hpsi1j30u00u6b29.jpg" alt="截屏2020-04-15 下午6.03.21"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy3qjgaoj313e0eejuh.jpg" alt="截屏2020-04-15 下午6.03.40"></p><p>Figure 7: Original and normalized image (1), feature maps after each CONV layer without ReLU (2-6), and feature map before fully connected layer (7), banana (a) and mug (b)</p><h3 id="Task-4-Improving-network-performance"><a href="#Task-4-Improving-network-performance" class="headerlink" title="Task 4: Improving network performance"></a><strong>Task 4: Improving network performance</strong></h3><p>In this task, inspired by AlexNet, this improved model (call CNN-task4) can achieve 69.11% accuracy on the test set. The relevant structure and parameters are listed below (see table 9). Noticed that the accuracy on the test set is evaluated by the model achieving the lowest loss on validation set during training (save the model at that epoch and reload it in evaluation).</p><p>Table 9: Structure and parameters of CNN-task4</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy4h8ikej31240pgaej.jpg" alt="截屏2020-04-15 下午6.04.27"></p><p>One of the adjustments is using another optimizer Adam, which support adaptive learning rate, updating the learning rate during learning. The reason behind is that adaptive learning rate will slow down the stride of gradient descent during the training. Giving a small stride can help reduce the possibility of missing and fluctuating around the (local or global) optimal solution. From figure 8, we can notice that CNN-task4 with 0.0001 initial learning rate can give a better loss curve than the others.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy4s62maj310c09swh3.jpg" alt="截屏2020-04-15 下午6.04.48"></p><p>Figure 8: Loss curve of original 5-layer CNN with 0.01 LR (a)，CNN-task4 with 0.001 initial LR (b)，CNN-task4 with 0.0001 initial LR (c)</p><p>Another adjustment is to move the dropout layer from convolution layers to fully connected layers. One reason is that the parameters in the convolution layer are quite few but highly relative. The pixels within a certain area of an image in convolutional layers are sharing the same information, which means that the discarded information may still be retained by nearby pixels. Using dropout layer in convolution layer may only help control the noise of the input images but not improving the generalization on unseen data (see figure 9 (d)). On the other hand, if the feature maps between 2 layers are highly abstracted when passing forward such as convolution operation with large kernel size or stride, or max-pooling operation, using dropout will, on the contrary, cause the feature maps to lose important information for classifying. And therefore, the performance of the model will decline, especially causing a significant decrease of accuracy on the test set and fluctuation of loss curve on the validation set (see figure 9 (c)).</p><p>Table 10 is comparing the accuracy on the test set of 4 different dropout layer placing strategies. The 2nd and 4th row are showing that adding dropout after convolution layer 3 &amp; 4, which have small kernel and stride, having similar performance. However, once the dropout layers are placed after max-pooling layer (see 3rd row). The accuracy of the model on the test set will decline from around 65% to 50%.</p><p>Table 10, Position of dropout layer (based on the CNN-task4 in table 9) and the highest accuracy on the test set after 30 epochs training</p><div class="table-container"><table><thead><tr><th>Dropout(0.5)  Before FC1&amp;2</th><th>69.11%</th><th>Figure 9 (a)</th></tr></thead><tbody><tr><td>No dropout</td><td>66.17%</td><td>Figure 9 (b)</td></tr><tr><td>Dropout(0.3)  after max-pooling layer 1&amp;2&amp;3</td><td>50.22%</td><td>Figure 9 (c)</td></tr><tr><td>Dropout(0.3)  after CONV 3&amp;4</td><td>64.94%</td><td>Figure 9 (d)</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy5ahtb9j311608o76i.jpg" alt="截屏2020-04-15 下午6.05.16"></p><p>Figure 9: Loss curve of CNN-task4, with dropout before FC1&amp;2 (original) (a), without dropout (b)，with 0.3 dropout after max-pooling (c)，with 0.3 dropout after CONV 3&amp;4 (d).</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像分类 </tag>
            
            <tag> CNN </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernets</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/09%20Kubernets/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/09%20Kubernets/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Kubernetes</strong>（常简称为<strong>K8s</strong>）是用于自动部署、扩展和管理「<a href="https://zh.wikipedia.org/wiki/作業系統層虛擬化" target="_blank" rel="noopener">容器化</a>（containerized）应用程序」的<a href="https://zh.wikipedia.org/wiki/开源软件" target="_blank" rel="noopener">开源</a>系统。<a href="https://zh.wikipedia.org/wiki/Kubernetes#cite_note-3" target="_blank" rel="noopener">[3]</a>該系統由<a href="https://zh.wikipedia.org/wiki/Google" target="_blank" rel="noopener">Google</a>设计并捐赠给Cloud Native Computing Foundation（今属<a href="https://zh.wikipedia.org/wiki/Linux基金会" target="_blank" rel="noopener">Linux基金会</a>）来使用。</p><p>它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。<a href="https://zh.wikipedia.org/wiki/Kubernetes#cite_note-4" target="_blank" rel="noopener">[4]</a> 它支持一系列容器工具, 包括<a href="https://zh.wikipedia.org/wiki/Docker_(軟體" target="_blank" rel="noopener">Docker</a>)等。CNCF於2017年宣布首批Kubernetes認證服務提供商（KCSPs），包含<a href="https://zh.wikipedia.org/wiki/IBM" target="_blank" rel="noopener">IBM</a>、<a href="https://zh.wikipedia.org/wiki/華為" target="_blank" rel="noopener">華為</a>、MIRANTIS等服務商。</p></blockquote><a id="more"></a><h4 id="Kubernets"><a href="#Kubernets" class="headerlink" title="Kubernets"></a>Kubernets</h4><p>kubernetes，简称K8s，是用8代替8个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><ul><li>Docker应用程序编排</li><li>Google Cloud、Rackspace、Azure providers</li><li>可简单的部署在操作系统上</li><li>支持容器复制</li></ul><p>将海量的用户容器进度包装和调度，动态的安置到节点上</p><h4 id="Kubernets的角色"><a href="#Kubernets的角色" class="headerlink" title="Kubernets的角色"></a>Kubernets的角色</h4><p>改进可靠性</p><ul><li>持续的监控和管理容器</li><li>将扩展您的应用程序以处理负载变化</li></ul><p>更好地利用基础设施资源</p><ul><li>通过适当地扩展和缩减整个平台，来帮助降低基础架构需求</li></ul><p>协调哪些容器在系统中的何时何地运行</p><ul><li>系统中所有不同类型的容器如何相互通信？（需要满足那些网络需求）</li></ul><p>轻松协调系统的部署</p><ul><li><p>需要部署哪些容器</p></li><li><p>容器应放在哪里</p></li></ul><h4 id="Kubernets的定义"><a href="#Kubernets的定义" class="headerlink" title="Kubernets的定义"></a>Kubernets的定义</h4><p>【集群】：Kubernetes将高可用性计算机集群协调连接在一起，是它们被视为一个独立的单元进行一起工作。包括</p><ul><li>Master，协调集群</li><li>Nodes，作为workers运行应用程序</li></ul><p>【Pod】：</p><ul><li>可部署的最小计算单元</li><li>由一个或多个容器组成，这些容器始终位于同一位置，共同调度，并在共享的上下文中运行</li></ul><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>高层架构：</p><ul><li>CNI (Container Network Interface) </li><li>CRI (Container Runtime Interface) </li><li>OCI (Open Container Initiative)</li><li>etcd：来自CoreO的开源分布式键值数据库。 充当所有组件的单一真值来源Single Source of Truth (SSOT)</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7ss15k8fj310y0kmdmt.jpg" alt="截屏2020-05-28 上午12.12.08"></p><ul><li>API 服务器：提供REST接口</li><li>调度器：分配【pod】到节点上</li><li>控制器管理者：运行控制循环</li><li>etcd：键值存储</li><li>kubelet：运行【pod】</li><li>kube-proxy：TCP/UDP 转发 forwarding</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7sw5hv2yj30vy0dqmyd.jpg" alt="截屏2020-05-28 上午12.16.11"></p><h4 id="更多概念"><a href="#更多概念" class="headerlink" title="更多概念"></a>更多概念</h4><p>部署：包括【Pod】模板，和副本字段</p><ul><li>Kubernetes将确保实际状态（副本数量，【Pod】模板）始终与所需状态匹配</li><li>更新部署后，将执行“滚动更新”</li></ul><p>服务：通过匹配的标签选择器选择【Pods】，并提供与应用程序进行通讯的稳定方式，该方式通过使用内部IP或DNS名称实现。</p><p>命名空间：一种逻辑隔离方法，大多数资源是命名空间范围的。 然后，您可以将逻辑上相似的工作负载分组并实施各种策略。</p><ul><li>将Pod匹配到实际所在的资源</li></ul><h4 id="【Pod】和容器"><a href="#【Pod】和容器" class="headerlink" title="【Pod】和容器"></a>【Pod】和容器</h4><p>一个【节点node】可以有一个或多个【pod】</p><p>一个【pod】可以有一个或多个【容器】</p><p>【容器】之间是紧密耦合的，比如</p><ul><li><p>一个【容器】，作为Web服务器，展示共享volume中的文件</p></li><li><p>还有一个另外的“sidecar”【容器】，将外源文件更新到volume中</p><p><img src="../../../../../Desktop/截屏2020-05-28 上午12.31.03.png" alt="截屏2020-05-28 上午12.31.03" style="zoom: 50%;" /></p></li></ul><p>【pod】为它们的【组成容器】提供两种共享资源：网络和存储。</p><p>【Pod】中的每个【容器】都共享网络名称空间，包括IP地址和网络端口。</p><p>【Pod】中的【容器】可以使用localhost相互通信</p><p>【Pod】可以指定一组共享存储卷</p><ul><li>【Pod】中的所有【容器】都可以访问共享卷</li></ul><p>【Volume】还允许Pod中的持久数据保留下来，以防其中的【容器】之一需要重新启动。</p><p>当发生迁移时，虚拟机需要整体复制（也有只迁移数据的实时迁移方案），容器则直接创建一个新的容器。</p><h4 id="【Pods】：扩展和部署"><a href="#【Pods】：扩展和部署" class="headerlink" title="【Pods】：扩展和部署"></a>【Pods】：扩展和部署</h4><p>通过【心跳】确保【nodes】的状态</p><p>系统性能：</p><ul><li>根据CPU负载或其他条件扩展/缩小Pod的数量</li></ul><p>系统监控：</p><ul><li>用于检查每个【pob】健康状况的【探针probe】</li><li>任何不健康的【pob】都会被终止，新的【pob】将投入使用</li></ul><p>部署：</p><ul><li>部署新版本的【容器】</li><li>控制到新【Pod】的流量以测试新版本</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信息检索（谷歌搜索）</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/16%20%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%EF%BC%88%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%EF%BC%89/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/16%20%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%EF%BC%88%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>对于搜索引擎来说，响应速度是至关重要的，因此遍历整个文档来搜索关键字是不能接受的。</p><p>其中一种解决方案是，将完整的文档进行【归纳】，将文档转为化【词袋 bag of words】（词列表、词向量），在词袋中搜索关键词，并返回查询结果所指向的源文件</p><p>更好的方式是【字典】+【倒排文件】</p><a id="more"></a><h4 id="数据库查询问题"><a href="#数据库查询问题" class="headerlink" title="数据库查询问题"></a>数据库查询问题</h4><ol><li><p>所有内容放在同一张表中</p><p>使用通配符 leading (and trailing) wildcards + 蛮力扫描 brute force scan</p></li><li><p>改进方法：将关键词提取出来，并放到另一张索引表中</p><p>使用关联查找 join + or/and</p></li></ol><h4 id="倒排索引（反向索引）-Inverted-index"><a href="#倒排索引（反向索引）-Inverted-index" class="headerlink" title="倒排索引（反向索引） Inverted index"></a><a href="https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">倒排索引</a>（反向索引） Inverted index</h4><p>【倒排】指的是，原本的索引是，一条文档记录中，记录着单词的索引（位置）；倒排后，就是一个单词的记录中，记录着应用过该单词的文档的索引（位置）</p><p>维基百科中的例子：</p><ol><li><p>第一种：只储存引用它的文档索引</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekkqrbwkqj30j9091mxo.jpg" alt="截屏2020-05-07 下午10.03.46"></p></li><li><p>储存引用它的文档索引，以及在该文档中出现的位置</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekkqwpyixj30l10663z6.jpg" alt="截屏2020-05-07 下午10.05.07"></p></li></ol><h4 id="倒排文档——【字典】【倒排-位置文件】【源文件】"><a href="#倒排文档——【字典】【倒排-位置文件】【源文件】" class="headerlink" title="倒排文档——【字典】【倒排/位置文件】【源文件】"></a>倒排文档——【字典】【倒排/位置文件】【源文件】</h4><p>倒排文档的思想是：除了储存文档和文档的索引词列表，还存储用于所有文档的词列表，该列表中的每一个词都指向引用过它的所有文档。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekkxodn0wj30x40iy0vw.jpg" alt="截屏2020-05-07 下午10.12.50"></p><h4 id="关联查询：关键词A、B、C查询"><a href="#关联查询：关键词A、B、C查询" class="headerlink" title="关联查询：关键词A、B、C查询"></a>关联查询：关键词A、B、C查询</h4><p>是用关键词A、B、C的倒排索引，如下图</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geklvp3xk1j30he0a6t9f.jpg" alt="截屏2020-05-07 下午10.45.34" style="zoom:50%;" /></p><p>建立文档的正排索引，如下图。</p><p>查询 (A or B) and C 可以表示为(1, 0, 1)或(0, 1, 1) 或 (1, 1, 1)，如下图红色。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geklwf5i95j30860emgmx.jpg" alt="截屏2020-05-07 下午10.46.15" style="zoom: 50%;" /></p><h4 id="进阶应用：权重"><a href="#进阶应用：权重" class="headerlink" title="进阶应用：权重"></a>进阶应用：权重</h4><p>可以为每个倒排索引增加权重，并且为查询也增加权重 <script type="math/tex">A_{0.5}, B_{0.7}, C_{1.0}</script></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekm52viocj30dq062aaw.jpg" alt="截屏2020-05-07 下午10.54.34" style="zoom:50%;" /></p><p>于是得到加权后的排名，比如：doc1: ((0.5, 0.7, 1.0), (0.2, 0.0, 0.4)) = 0.85，doc2 = ((0.5, 0.7, 1.0), (0.0, 0.6, 0.4)) = 0.86</p><h4 id="再次进阶：相似度"><a href="#再次进阶：相似度" class="headerlink" title="再次进阶：相似度"></a>再次进阶：相似度</h4><p>通过余弦可以表示两个向量的相似程度（向量b在向量a上的投影，投影长度为[0,1]）</p><p>余弦的特性：<script type="math/tex">cos(90°)=0，cos(0°)=1</script></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geksm2bbjmj30u60mm774.jpg" alt="截屏2020-05-08 上午2.38.15" style="zoom:33%;" /></p><h4 id="倒排文档的使用"><a href="#倒排文档的使用" class="headerlink" title="倒排文档的使用"></a>倒排文档的使用</h4><p>根据相似系数对查询进行排序，获取前N个结果，并将结果提交给用户，支持分页（查询下N个结果）。</p><p>对于【临近查询 proximity queries】，上文开始介绍倒排索引时，有介绍到它还能储存<u>单词在文档中出现的位置</u>。换句话说，它对查询词的顺序和位置是敏感的，于是查询【A B】与【B A】与【A X X B】的结果是不一样的。比如查询【A B】时，可以添加一条规则【pos(A) = pos(B) -1】。理论上，这能够在不影响recall的情况下提高precision。</p><h4 id="倒排文档的优缺点"><a href="#倒排文档的优缺点" class="headerlink" title="倒排文档的优缺点"></a>倒排文档的优缺点</h4><p>优点</p><ul><li>可以用于Boolean、权重、位置查询</li><li>可以在不访问具体文件的情况下完成查询</li><li>单个词的匹配数可从之间从【字典】中获得</li></ul><p>缺点</p><ul><li>如果源文件的内容发送改变，更新倒排文档的成本很高</li><li>额外的存储需求（【字典】+【倒排文件】的大小与原始数据大致相同）</li></ul><h4 id="优点2：效率"><a href="#优点2：效率" class="headerlink" title="优点2：效率"></a>优点2：效率</h4><p>提供查询和排序功能【不需要真正的从页面中进行查询】，比如搜索引擎，我们只需要返回页面对应的URL即可。</p><h4 id="关键点总结：倒排文件索引"><a href="#关键点总结：倒排文件索引" class="headerlink" title="关键点总结：倒排文件索引"></a>关键点总结：倒排文件索引</h4><p>标准的关系型数据库不提供适当的索引，来对一组索引词进行搜索。标准的SQL查询语句不适用于【搜索引擎】类型的查询。</p><p>倒排文件结构则专为这种查询而设计；将频率/权重储存在【字典】中，加上【倒排文件】，能够支持【向量模型的查询】。而存储位置信息则支持【临近查询 proximity queries】</p><h4 id="信息检索-VS-数据库管理系统"><a href="#信息检索-VS-数据库管理系统" class="headerlink" title="信息检索 VS 数据库管理系统"></a>信息检索 VS 数据库管理系统</h4><div class="table-container"><table><thead><tr><th></th><th>数据库</th><th>信息检索</th></tr></thead><tbody><tr><td>匹配</td><td>精确</td><td>部分或最佳匹配</td></tr><tr><td>推断方式</td><td>排除</td><td>引入</td></tr><tr><td>模型</td><td>确定性的</td><td>可能性的</td></tr><tr><td>数据</td><td>记录/字段</td><td>文本文档</td></tr><tr><td>查询语言</td><td>人造的</td><td>天然的？</td></tr><tr><td>查询规范</td><td>完整的</td><td>不完整的</td></tr><tr><td>查询目标</td><td>匹配</td><td>相关</td></tr><tr><td>查询错误</td><td>敏感的</td><td>不敏感的</td></tr></tbody></table></div><h4 id="文档检索"><a href="#文档检索" class="headerlink" title="文档检索"></a>文档检索</h4><p>信息检索最开始是为书目系统开发的，但这项技术后来扩展到了文本项目之外</p><p>信息检索的中心是由一组”描述符“或”索引词“表示的文档，搜索主要在索引词的域中进行的</p><p>需要一种语言来进行查询，以及一种用于将查询与文档描述符匹配的方法。</p><p>文档检索系统的结构如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekp5wu5maj30sa0feq55.jpg" alt="截屏2020-05-08 上午12.39.10" style="zoom:50%;" /></p><h4 id="讨论：集合理论-Set-theoretic-模型"><a href="#讨论：集合理论-Set-theoretic-模型" class="headerlink" title="讨论：集合理论 Set theoretic 模型"></a>讨论：集合理论 Set theoretic 模型</h4><h5 id="Boolean模型"><a href="#Boolean模型" class="headerlink" title="Boolean模型"></a>Boolean模型</h5><ul><li>简单，查询具有精确的语义，但只能精确查找，不能对结果排序</li><li>常用于书目系统</li><li>布尔查寻难以制定，需要多次迭代调整才能得到结果</li><li>基于集合理论模型的部分匹配系统：模糊集合模型Fuzzy set model、扩展的布尔模型</li></ul><h5 id="向量模型"><a href="#向量模型" class="headerlink" title="向量模型"></a>向量模型</h5><ul><li>简单，快速</li><li>部分匹配带来排序输出</li><li>常用语搜索引擎</li><li>该模型假设单词之间的独立的（不考虑短语、词组、语法）<ul><li>广义向量空间模型放宽了该假设，即同时考虑了词组</li><li>但这会增加复杂度，所以大部分的搜索引擎还是仅考虑独立的单词</li></ul></li></ul><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><ul><li>索引词的来源（比如源文档的所有单词）</li><li>如何确定权重<ul><li>对于在所有文档中出现频率都很高的词，权重应该更低，比如the，is</li></ul></li><li>对于不同地区，返回不同的结果（比如中文地区 VS 英文地区、澳洲地区 VS 美洲地区）</li><li>如何改进（用户试用然后获取反馈）</li><li>如何将信息检索与传统数据库整合<ul><li>比如谷歌引擎，除了信息检索响应之外，在侧边还有额外的数据库响应</li></ul></li><li><p>同义词 Synonyms</p><ul><li>比如football和soccer，是</li></ul></li><li><p>一词多义 homonyms</p><ul><li>比如lead（金属或迁引）</li></ul></li><li>全局语境还是局部语境<ul><li>比如，关于足球的文章里不会提到足球，而是提到更具体的，比如俱乐部、球员、比赛</li></ul></li><li>【临近查询】问题<ul><li>比如”Venetian blind”百叶窗 vs “blind Venetian”一种视力问题</li></ul></li></ul><h4 id="评估方式"><a href="#评估方式" class="headerlink" title="评估方式"></a>评估方式</h4><ul><li>易用性：用户需要迭代多少次查询才能得到想要的结果</li><li>时间：结果响应时间</li><li>展示：结果展示</li><li>覆盖度：结果集合覆盖的范围</li><li>recall：相关的结果，有多少被获取到了</li><li>precision：获取到的结果中，有多少是相关的</li><li>用户满意度：对获取的结果的满意程度</li></ul><h4 id="查询扩展Query-Broadening"><a href="#查询扩展Query-Broadening" class="headerlink" title="查询扩展Query Broadening"></a>查询扩展Query Broadening</h4><p>先用一个简单的查询，然后根据结果调整查询的关键字或者权重</p><p>方法之一是从用户中获得反馈信息，即【关联反馈 Relevance Feedback】</p><ul><li>比如用户选择结果中的某几条记录，希望获得与这些记录相似度更高的结果</li></ul><p>方法之二是使用同义词</p><ul><li>比如【预测用户可能想要查的单词，然后返回给用户作为可交互项】</li></ul><h4 id="关联反馈"><a href="#关联反馈" class="headerlink" title="关联反馈"></a>关联反馈</h4><p>我们认为在含义（或用途）上彼此相似的文档具有相似的索引词。</p><p>对于原本的查询词向量q，经过关联反馈后，产生了以下变化，记为q’</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekvpw3fv5j30r40du75t.jpg" alt="截屏2020-05-08 上午4.25.36" style="zoom:50%;" /></p><ol><li>添加了一些新的查询词：这些新添加的查询词是被标记为关联文档中的索引词</li><li>增加权重：在原查询词向量q中，如果某词同样出现在被标记为关联文档中，则增加它的权重</li><li>减少权重：如果某词出现在被标记为非关联的文档中，则降低它的权重</li></ol><h4 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h4><p>更新前：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gel4sco8wtj311k0okgt8.jpg" alt="截屏2020-05-08 上午9.39.39"></p><p>重新计算：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gel4srkx7sj30yg0kmaby.jpg" alt="截屏2020-05-08 上午9.39.39"></p><p>更新后：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gel4t1jh2oj310o0nutcz.jpg" alt="截屏2020-05-08 上午9.40.20"></p><h4 id="解决问题：同义词、一词多义"><a href="#解决问题：同义词、一词多义" class="headerlink" title="解决问题：同义词、一词多义"></a>解决问题：同义词、一词多义</h4><p>关联反馈有助于解决由于【同义词】问题而遗漏的文档。比如有一些文章用jelly代替jam，当通过jam查找到jelly的文章，且标记为相关后，后续的查找也会包括jelly</p><p>这也有助于解决【一词多义】问题。比如查询lead（金属）返回的结果中包括dog-walking，当标记该文章为非相关文章后，dog-walking的权重会降低，进而后续的查询中，这类文章更可能被排除</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点是随着查询不断的迭代，查询结果会越来越精确，适用于一些使用率高的查询系统。还能使<script type="math/tex">γ=0</script>，忽略非关联匹配，适用于正向反馈系统。</p><p>缺点是并非完全自动化</p><h4 id="同义词库-Thesaurus"><a href="#同义词库-Thesaurus" class="headerlink" title="同义词库 Thesaurus"></a>同义词库 Thesaurus</h4><p>同义词库或本体可能包括：</p><ul><li>描述特定的主题的受控制的词汇</li><li>同义词类别</li><li>广义和狭义的同义词，即hypernyms和hyponyms<ul><li>使用广义的同义词提高recall</li><li>使用狭义的同义词提高precision</li></ul></li><li>相关的术语的类别</li></ul><p>同义词库可以是通用的（比如Roget’s thesaurus或WordNet），也可以是领域专用的，比如医学领域</p><h4 id="语言标准化"><a href="#语言标准化" class="headerlink" title="语言标准化"></a>语言标准化</h4><p>用同义词替换查询词和文档中的词，以此改进precision和recall</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gel592yv41j30ze0bgjss.jpg" alt="截屏2020-05-08 上午9.55.48" style="zoom:50%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gel5aygtv0j310w0b00ug.jpg" alt="截屏2020-05-08 上午9.57.36" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倒排索引 </tag>
            
            <tag> 集合理论模型 </tag>
            
            <tag> 布尔模型 </tag>
            
            <tag> 向量模型 </tag>
            
            <tag> 关联反馈 </tag>
            
            <tag> 同义词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器翻译</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/19%20%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/19%20%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="多语言的挑战"><a href="#多语言的挑战" class="headerlink" title="多语言的挑战"></a>多语言的挑战</h2><h4 id="对于单词"><a href="#对于单词" class="headerlink" title="对于单词"></a>对于单词</h4><ul><li>复杂的拼写系统，比如：<ul><li>阿拉伯语中，词拼写比较模糊（元音会被省略）；</li><li>中文，词之间没有间隔</li></ul></li><li><p>词汇的歧义：比如eat，在法语中只对应1个词，但在日语中则分别对应2个词</p></li><li><p>单词形态复杂性和多样性，比如</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen0rwa76xj30wk0h20vt.jpg" alt="截屏2020-05-10 上午12.52.01" style="zoom:33%;" /></p></li></ul><h4 id="对于句子"><a href="#对于句子" class="headerlink" title="对于句子"></a>对于句子</h4><ul><li><p>结构上不匹配。</p><p>（下图可以看到，翻译成不同语言后，句子的结构和词的数量是不匹配的）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen11wphaqj30zc0e2din.jpg" alt="截屏2020-05-10 上午1.01.38" style="zoom:33%;" /></p></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen15s3icyj30ye0guq6n.jpg" alt="截屏2020-05-10 上午1.05.21" style="zoom:33%;" /></p><h4 id="语料库"><a href="#语料库" class="headerlink" title="语料库"></a>语料库</h4><p>需要语料库、字典或其他的NLP资源</p><p>尤其需要平行的语料库，其中原文与译文句子对齐</p><h2 id="机器翻译的方法"><a href="#机器翻译的方法" class="headerlink" title="机器翻译的方法"></a>机器翻译的方法</h2><h3 id="基于规则的机器翻译"><a href="#基于规则的机器翻译" class="headerlink" title="基于规则的机器翻译"></a>基于规则的机器翻译</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen29j06c9j30zk0gy76c.jpg" alt="截屏2020-05-10 上午1.43.34" style="zoom: 33%;" /></p><h4 id="Gisting：单词层面"><a href="#Gisting：单词层面" class="headerlink" title="Gisting：单词层面"></a>Gisting：单词层面</h4><p>【gist = 要旨】</p><p>使用字典，逐字的转换：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen2f7uzsdj30w007kabm.jpg" alt="截屏2020-05-10 上午1.49.01" style="zoom: 50%;" /></p><p>需要【平行语料库】</p><h4 id="Transfer：语法层面"><a href="#Transfer：语法层面" class="headerlink" title="Transfer：语法层面"></a>Transfer：语法层面</h4><p>分析源文本的语法结构，以及目标文本的语法结构，并将两者进行匹配</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen2jse7k3j30um0co40d.jpg" alt="截屏2020-05-10 上午1.53.24" style="zoom:50%;" /></p><p>需要【原文的语法结构与译文的语法结构的映射表】</p><h4 id="Interlingua：含义层面"><a href="#Interlingua：含义层面" class="headerlink" title="Interlingua：含义层面"></a>Interlingua：含义层面</h4><p>【Interlingua = 国际语】</p><p>最理想的翻译方式是理解原文的意思，并用译文语法和单词进行表达。</p><p>有人提出可以先将原文翻译成国际语，然后再将国际语翻译成译文。比如，将英文作为国际语，可以先将西班牙语翻译成英文，英文翻译成中文。比如：</p><p>从原文【John broke into the room】转换为图结构后（左上-右），可以在该结构的基础上，转化为更通用的国际语结构（左上-左）。然后再根据该国际语转化为译文（左下，右）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen2ywundoj30wa0jedja.jpg" alt="截屏2020-05-10 上午2.07.57"></p><p>但这效果并没有很好，因为从原文翻译成国际语时，如果产生错误，那么这个错误同样会在从国际语翻译成译文中出现。并且英语并不是一个非常正式的知识表示方法，需要一个更契合【图结构】的语言。</p><p>需要复杂的【语义结构的映射表】</p><h4 id="每一层都需要建立字典"><a href="#每一层都需要建立字典" class="headerlink" title="每一层都需要建立字典"></a>每一层都需要建立字典</h4><p>每一层都需要类似于【字典/映射表】的存在。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen3ek29ajj31040iaacd.jpg" alt="截屏2020-05-10 上午2.22.58" style="zoom:33%;" /></p><ol><li>Interlingua：需要复杂的【语义结构的映射表】</li><li>Transfer：需要【原文的语法结构与译文的语法结构的映射表】</li><li>Gisting：需要【并行语料库】</li></ol><p>这需要语言学家大量的工作，并且结果经常难以达成一致。</p><h3 id="基于统计的机器翻译-Statistical-Machine-Translate"><a href="#基于统计的机器翻译-Statistical-Machine-Translate" class="headerlink" title="基于统计的机器翻译 Statistical Machine Translate"></a>基于统计的机器翻译 Statistical Machine Translate</h3><p>绿色箭头</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen56kynjpj30z40lejud.jpg" alt="截屏2020-05-10 上午3.24.32" style="zoom:33%;" /></p><h4 id="噪声信道模型-Noisy-Channel-Model"><a href="#噪声信道模型-Noisy-Channel-Model" class="headerlink" title="噪声信道模型 Noisy Channel Model"></a>噪声信道模型 Noisy Channel Model</h4><p>该模型主要用于拼写纠正，但也可以用于机器翻译：</p><p>对一个英语句子，随机对句子进行扭曲（不同的权重），总有概率使其成为一个意思相同的法语句子。这个扭曲即是噪声。我们要做的就是找出特定的那个能翻译的权重。</p><blockquote><p>Noisy Channel Model示意图如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen43huxjqj30hp08pwfa.jpg" alt="img"></p><p>原来的一个正确的单词：经过 noisy channel ，结果变成了一个 noisy word。而这个noisy channel，其实就是前面讲的“两个词发音相近，容易拼错它们”，或者”两个字符在键盘上相邻，输入时就会错误地将一个词 输入成了(type) 另一个词。(其实niosy channel就是对现实世界存在的问题的一个建模)</p><p>而要想得出错误单词(noisy word) 对应的 正确单词，就需要用到贝叶斯推断。</p><p><a href="https://www.cnblogs.com/hapjin/p/8012069.html" target="_blank" rel="noopener">原文出处</a></p></blockquote><h4 id="自动的字对齐-Automatic-Word-Alignment"><a href="#自动的字对齐-Automatic-Word-Alignment" class="headerlink" title="自动的字对齐 Automatic Word Alignment"></a>自动的字对齐 Automatic Word Alignment</h4><p>【GIZA++】是一个<u>基于统计的机器翻译</u>工具套件，用于训练<u>字对齐</u>。通过带有各种约束的<u>最大化表达</u>来引导对齐。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen4kz8lukj30qa0dy75b.jpg" alt="截屏2020-05-10 上午3.03.46" style="zoom:33%;" /></p><h4 id="基于单词的模型-Word-based-Model（IBM模型）"><a href="#基于单词的模型-Word-based-Model（IBM模型）" class="headerlink" title="基于单词的模型 Word-based Model（IBM模型）"></a>基于单词的模型 Word-based Model（IBM模型）</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen4onovnoj30vg0fa0uv.jpg" alt="截屏2020-05-10 上午3.07.02" style="zoom: 33%;" /></p><p>（该模型有4个阶段：fertility，null-insertion，transaction，distortion）</p><p>逐字翻译对于结构相似的语言是比较有效的，但如果结构区别较大，比如中英互译，那么该模型的效果则会变差。但可以考虑将单词扩展为基于短语的翻译</p><h4 id="扩展为基于短语的翻译"><a href="#扩展为基于短语的翻译" class="headerlink" title="扩展为基于短语的翻译"></a>扩展为基于短语的翻译</h4><p>例1：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen4wch2pej30vm06uq3q.jpg" alt="截屏2020-05-10 上午3.14.41" style="zoom: 50%;" /></p><p>例2：通过【GIZA++】可视化后，下图展示了如何逐渐从单词扩展为短语。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen4ysljgdj30zi0m8acx.jpg" alt="截屏2020-05-10 上午3.17.01"></p><h4 id="基于短语的好处"><a href="#基于短语的好处" class="headerlink" title="基于短语的好处"></a>基于短语的好处</h4><ul><li><p>多对多映射可以处理不是固定搭配的短语</p></li><li><p>局部语境对消除歧义非常有用：比如【Interest rate】和【Interest in】</p></li><li><p>数据越多，模型记忆的句子越长（能直接对长句子映射翻译）<br>（如下图，框越大表示匹配的短语越长）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen5czob6mj30y60non13.jpg" alt="截屏2020-05-10 上午3.30.39" style="zoom:33%;" /></p></li></ul><h3 id="混合两种机器翻译方法"><a href="#混合两种机器翻译方法" class="headerlink" title="混合两种机器翻译方法"></a>混合两种机器翻译方法</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen5icljfrj310c0m4ae5.jpg" alt="截屏2020-05-10 上午3.35.49"></p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><h3 id="基于人类的评估"><a href="#基于人类的评估" class="headerlink" title="基于人类的评估"></a>基于人类的评估</h3><h4 id="准确度评估"><a href="#准确度评估" class="headerlink" title="准确度评估"></a>准确度评估</h4><ol><li>没有表达原始句子的内容，缺少动词、主语、宾语、短语或从句</li><li>没有充分表达原始句子的内容，原始句子的部分翻译不正确，缺少修饰语</li><li>表达出了原始句子的内容，但在短语，时态，单数/复数等之间的关系中存在错误</li><li>表达出了原始句子的内容，但顺序有误</li><li>表达出了原始句子的内容（可能需要稍作更正）</li></ol><h4 id="流畅度评估"><a href="#流畅度评估" class="headerlink" title="流畅度评估"></a>流畅度评估</h4><ol><li>含义完全不清晰</li><li>含义不清晰，但可以推断出</li><li>含义可以理解，但有歧义，原因可能是语法错误、术语错误、或句子结构错误</li><li>含义清晰，但存在语法错误、术语错误、或句子结构错误</li><li>含义清晰，语法、术语、句子结构都良好</li></ol><h3 id="自动化评估"><a href="#自动化评估" class="headerlink" title="自动化评估"></a>自动化评估</h3><h4 id="BLEU-Metric"><a href="#BLEU-Metric" class="headerlink" title="BLEU Metric"></a><a href="https://machinelearningmastery.com/calculate-bleu-score-for-text-python/" target="_blank" rel="noopener">BLEU Metric</a></h4><p>全称：BiLingual Evaluation Understudy，具有以下特点</p><ul><li>可以将评估窗口扩大为n-gram，但有长度限制</li><li>快速、成本低、且语言独立</li><li>与人类的评价高度相关</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>对于1-gram：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen65v6m6gj30w20aw403.jpg" alt="截屏2020-05-10 上午3.58.27" style="zoom:33%;" /></p><p>对于2-gram：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen66vui6lj30w00fy415.jpg" alt="截屏2020-05-10 上午3.59.25"></p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字对齐 </tag>
            
            <tag> GIZA++ </tag>
            
            <tag> Word Alignment噪声信道模型 </tag>
            
            <tag> 基于单词的翻译 </tag>
            
            <tag> IBM模型 </tag>
            
            <tag> 基于短语的翻译 </tag>
            
            <tag> Noisy Channel Model </tag>
            
            <tag> 评估标准 </tag>
            
            <tag> BLEU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对话系统、聊天机器人</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/20%20%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/20%20%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h4><p>建立对话系统的第一步是需要准确描述<u>人与人对话的过程</u></p><p>在说话者的角度：交流是建立在双方理解能够对话的基础上</p><ol><li>为什么要交流：双方假设一个共同的目标</li><li>说什么：双方都能理解陈述、请求、问题等</li><li>怎么说：语调的变化、礼貌习惯等</li></ol><p>从听者的角度：听者需要根据已观察到的证据，推断说话者的意图：</p><ol><li>准确的知道说话者说的是什么。这包括【听】，以及将声音信号【转化】为词或短语</li><li>找出说话者所说的内容的【字面含义】</li><li>找出说话者这样说的【原因】</li></ol><p>在双方的角度：交流是一个合作的事件，说话者与听者<u>实时管理</u>以下过程：</p><ol><li>说与听需要按顺序进行</li><li>需要确认另一方确实理解了</li><li>如果对方不理解，那么说话方就要解释清楚</li></ol><h4 id="为什么会发生对话"><a href="#为什么会发生对话" class="headerlink" title="为什么会发生对话"></a>为什么会发生对话</h4><p>使用语言的一个主要原因是为了与他人合作，来完成某件事情。如果人们可以独立完成他们需要的任何事情，不需要任何人帮助，那么他们完全可以不需要说话。更常见的情况是，人和计算机需要相互合作来完成他们的目标。</p><p>对话充满了规则和习惯，这些规则和习惯随着时间不断的演化，使得交流更加顺畅。比如</p><ul><li>一个【问题】后面通常跟着一个【答案】</li><li>【请求】经常是比较间接的，因为直接的要求显得很粗鲁</li><li>【拒绝】通常是对方不想要的，不受欢迎的回答，因此会通过重重的修饰来减轻影响</li></ul><h3 id="对话或谈话是如何工作的"><a href="#对话或谈话是如何工作的" class="headerlink" title="对话或谈话是如何工作的"></a>对话或谈话是如何工作的</h3><p>人与人的交互有以下几个方面：</p><ul><li>对话的基本事实</li><li>组织交流：对话如何继续进行</li><li>话语 Utterances</li><li>交谈的规则：Gricean Maxims</li></ul><h4 id="对话的基本事实"><a href="#对话的基本事实" class="headerlink" title="对话的基本事实"></a>对话的基本事实</h4><h5 id="话语-Utterances：对话的基本单位，a-spoken-word-statement-or-vocal-sound"><a href="#话语-Utterances：对话的基本单位，a-spoken-word-statement-or-vocal-sound" class="headerlink" title="话语 Utterances：对话的基本单位，a spoken word, statement, or vocal sound."></a>话语 Utterances：对话的基本单位，a spoken word, statement, or vocal sound.</h5><p>人们的对话并非一定要是句子。一个【话语】可以出现在多轮对话中，一轮对话也可以有多个【话语】。比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1genynhl5cnj30pu0eu76e.jpg" alt="截屏2020-05-10 下午8.24.06" style="zoom:33%;" /></p><h5 id="轮流对话-Taking-turns"><a href="#轮流对话-Taking-turns" class="headerlink" title="轮流对话 Taking turns"></a>轮流对话 Taking turns</h5><p>人们的对话是相对系统的。</p><p>【轮流对话 Turn-taking】：需要知道什么时候轮到你说话，这似乎是人类的本能，重叠和长时间停顿实际上很少见。</p><p>【邻近对Adjacency pairs】：由两部分组成的交流结构对于轮流对话来说是很清晰的，比如：</p><ul><li>提问/回答：向对方提出问题，希望得到答案。</li><li>问候/问候</li><li>请求/授予</li><li>等</li></ul><h5 id="常识-Common-ground"><a href="#常识-Common-ground" class="headerlink" title="常识 Common ground"></a>常识 Common ground</h5><p>【Common ground】是对话中双方都一致认可的事情的集合，比如：</p><ul><li>关于本文发生的对话的一部分【Common ground】是，这是这篇笔记的原文是来自于利兹大学的课程课件。不属于该【Common ground】的比如，笔者当时的午饭是什么。</li><li>人们在进行读对话之前会评估对方知道什么。</li></ul><h4 id="建立常识-Grounding"><a href="#建立常识-Grounding" class="headerlink" title="建立常识 Grounding"></a>建立常识 Grounding</h4><p>为了建立上述的【common ground】，交谈双方需要做一些事情：</p><ul><li><p>【Backchannels】：简短的【话语】，表示了解，对方可以继续，比如：<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1genzk3e1j4j30cs038jrh.jpg" alt="截屏2020-05-10 下午8.55.29" style="zoom:33%;" /></p></li><li><p>【话语的确认】Acknowledgement Of Utterance：表示持续关注等</p></li><li>提出问题，以进行确认</li></ul><h4 id="对话动作-Dialog-moves"><a href="#对话动作-Dialog-moves" class="headerlink" title="对话动作 Dialog moves"></a>对话动作 Dialog moves</h4><p>就好像游戏一样，我们可以看到对话一步一步进行的【动作】</p><ol><li><p>由于交流必须从某处开始，因此我们可以将一组【初始动作】组合在一起，比如</p><ul><li>提出假设： “you have a friendly face”</li><li>提出建议或请求：“let’s go and have a bite to eat”</li><li>提出问题：“are you doing anything tonight?”</li></ul></li><li><p>一部分对话是作为上一个对话的响应，比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo3638yxfj30qu0jmadg.jpg" alt="截屏2020-05-10 下午11.00.24" style="zoom: 33%;" /></p></li><li><p>但有一些响应，或多或少的会改变对话进行的方向——【对话管理动作】，比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo380ack0j30qc0aktak.jpg" alt="截屏2020-05-10 下午11.02.16" style="zoom:33%;" /></p></li></ol><h5 id="交谈结构"><a href="#交谈结构" class="headerlink" title="交谈结构"></a>交谈结构</h5><p>交谈/对话是有结构的，而不仅仅是一堆随机的、松耦合的陈述</p><ul><li>每一段交谈都有一个交谈的目的，即说话的理由（Grosz and Sidner 1986）</li><li>在基于任务的对话中，目的是清晰的，即交谈双方尝试一起达成一些目标，比如修车。</li></ul><p><strong>如果我们能够自动的找出交谈的结构，那么计算机就可以跟踪接下来会发生的事情</strong></p><ul><li>需要知道合适的话题</li><li>最好知道代词 pronouns 和名词短语 definite noun phrases 指的是什么</li></ul><h4 id="讲话的行为-Speech-acts"><a href="#讲话的行为-Speech-acts" class="headerlink" title="讲话的行为 Speech acts"></a>讲话的行为 Speech acts</h4><p>每个【话语 utterance】的功能是什么？</p><ul><li>【话语】经常等同于【动作actions】（Austin1962）</li></ul><p>比如：表演动词 performative verbs，当说出他们时，表示正在说的这句话就是当前正在做的事：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo3pd1xzej30r80aign8.jpg" alt="截屏2020-05-10 下午11.18.55" style="zoom:33%;" /></p><p>【讲话行为】能帮助我们理解当人们说话时，真正在做的事情。比如：“could you pass the salt?”：</p><ul><li>提出问题的句法形式</li><li>在许多语境中，【讲话行为】表达的是一个<u>礼貌的命令</u></li></ul><h5 id="前提和影响"><a href="#前提和影响" class="headerlink" title="前提和影响"></a>前提和影响</h5><p>【讲话行为】可以拆分为前提和影响：比如告知某人音乐会是周五举办的</p><ul><li>前提：<ul><li>确实知道音乐会是周五举办；</li><li>另一个人不知道音乐会什么时候举行</li></ul></li><li>影响：<ul><li>另一个人知道音乐会是周五举行</li></ul></li></ul><p>自动化的系统，通常能根据前提和影响清楚的表示【讲话行为】</p><h5 id="间接的讲话行为"><a href="#间接的讲话行为" class="headerlink" title="间接的讲话行为"></a>间接的讲话行为</h5><p>【讲话行为】可以是直接的或间接的：</p><p><strong>直接的</strong>：内容匹配含义，比如：</p><ul><li>Please take out the garbage.<ul><li>命令式imperative 的结构 &lt;==&gt; 命令式的含义</li></ul></li></ul><p><strong>间接的</strong>：内容不匹配含义，</p><ul><li><p>The garbage isn’t out yet.</p><ul><li>描述式的declarative结构 &lt;=/=&gt; 命令式的含义</li></ul></li><li><p>Could you take out the garbage?</p><ul><li>询问式interrogative的结构 &lt;=/=&gt; 命令式的含义</li></ul></li></ul><h4 id="如何使计算机识别一句话的内容与含义：DAMSL"><a href="#如何使计算机识别一句话的内容与含义：DAMSL" class="headerlink" title="如何使计算机识别一句话的内容与含义：DAMSL"></a>如何使计算机识别一句话的内容与含义：DAMSL</h4><p>人为的用<u>标签</u>标记不同的【讲话行为】——Dialogue Act Markup in Several Layers (DAMSL) 多层对话行为标记：是一种人们用来注释文本的【讲话行为】的模式schema</p><ul><li>前查功能forward-looking functions：寻找请求，如问题等</li><li>后查功能backward-looking functions：寻找响应，如回答、同意等</li></ul><p>它和【邻近对adjacency pairs】有一定的相似之处</p><h5 id="如何在计算机中使用"><a href="#如何在计算机中使用" class="headerlink" title="如何在计算机中使用"></a>如何在计算机中使用</h5><p>通过使用【DAMSL schema】</p><ul><li>人们可以给一个文本或者一个语料库添加注释；</li><li>人们可以在系统上训练模型，并尝试用这些标签对新的文本进行分类；</li><li>人们可以使用这些功能来告诉对话系统，下一步要做什么<ul><li>系统追踪之前的【后查功能】，来了解如何响应当前对话</li><li>如果对话系统需要一个回答，它也知道该用哪种【前查功能】来提出问题，让人们进行回答</li></ul></li></ul><p><strong>如果对话系统想要知道下一步该做什么，它还需要除了前查和后查功能之外的东西</strong></p><h4 id="交谈的规则：Gricean-maxims格言-规则"><a href="#交谈的规则：Gricean-maxims格言-规则" class="headerlink" title="交谈的规则：Gricean maxims格言/规则"></a>交谈的规则：Gricean maxims格言/规则</h4><p>Grice (1975)提出了4条格言/规则。</p><p>它基于合作原则，即对话对的双方的目的都是对谈话的最终目标作出贡献。</p><p>我们可以用这4条规则来推断说话者真正想要表达的意思：</p><h5 id="Gricean-maxim-1-Quantity-数量"><a href="#Gricean-maxim-1-Quantity-数量" class="headerlink" title="Gricean maxim 1: Quantity 数量"></a>Gricean maxim 1: Quantity 数量</h5><p>只需要准确回答对方所需的信息，不需要提供更多的信息：</p><p>正例：<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo5kl2iwrj30jo032q35.jpg" alt="截屏2020-05-11 上午12.23.32" style="zoom:33%;" /></p><p>反例：<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo5kvtf8uj30o804mmxs.jpg" alt="截屏2020-05-11 上午12.23.49" style="zoom:33%;" /></p><h5 id="Gricean-maxim-2-Quality-质量"><a href="#Gricean-maxim-2-Quality-质量" class="headerlink" title="Gricean maxim 2: Quality 质量"></a>Gricean maxim 2: Quality 质量</h5><p>尽量让你自己贡献出正确的信息，不要将你认为是错误的信息说出来，也不要说出缺乏充分证据的信息。</p><p>反例：<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo5ndnw9jj30pk030q3c.jpg" alt="截屏2020-05-11 上午12.26.14" style="zoom:33%;" /></p><h5 id="Gricean-maxim-3-Relevance-相关性"><a href="#Gricean-maxim-3-Relevance-相关性" class="headerlink" title="Gricean maxim 3: Relevance 相关性"></a>Gricean maxim 3: Relevance 相关性</h5><p>让回答的内容与对方的交谈相关</p><p>比如：<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo5ozwo3aj30qu03a3yz.jpg" alt="截屏2020-05-11 上午12.27.47" style="zoom:33%;" /></p><p>从段交谈中，我们推断Gail与某人在Indianapolis约会，否则这句话没太大意义</p><h5 id="Gricean-maxim-4-Manner-行为"><a href="#Gricean-maxim-4-Manner-行为" class="headerlink" title="Gricean maxim 4: Manner 行为"></a>Gricean maxim 4: Manner 行为</h5><p>让你的回答易于理解：</p><ul><li>避免表达模糊obscurity（比如避免使用非【common ground】的行话jargon）</li><li>避免歧义ambiguity</li><li>简短brief（类似于maxim1，但这里主要比较表达相同内容时交谈时间的长短）</li><li>有序orderly</li></ul><h3 id="早期的对话系统"><a href="#早期的对话系统" class="headerlink" title="早期的对话系统"></a>早期的对话系统</h3><h4 id="ELIZA"><a href="#ELIZA" class="headerlink" title="ELIZA"></a>ELIZA</h4><p>作者是Joseph Weizenbaum（mid-1960s）。</p><p>ELIZA系统模仿精神治疗师(Rogerian)的行为，即问问题，然后提供【backchannels】，而不是建议。</p><blockquote><p>如何测试一个对话系统，是看它有多像人——图灵测试Turing Test——如果一个人能够察觉它是在跟机器交互，那么表示这个系统则没有通过图灵测试</p></blockquote><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>ELIZA有许多不同的实现，但工作原理都类似：</p><ol><li><p>转换输入以改变观点（I &lt;=&gt; you）：<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geo6k1fihyj30ru044aaj.jpg" alt="截屏2020-05-11 上午12.57.37" style="zoom:33%;" /></p></li><li><p>模式识别</p></li><li><p>将关键字替换为固定短语canned phrases，或通用短语</p><blockquote><p>the “canned phrase 像罐头一样批量生产的短语” likes a synonym for “set phrase固定短语”, such as “make yourself at home”.</p></blockquote></li></ol><h5 id="如何发现ELIZA不是人类"><a href="#如何发现ELIZA不是人类" class="headerlink" title="如何发现ELIZA不是人类"></a>如何发现ELIZA不是人类</h5><ul><li>缺乏主动 initiative</li><li>缺少知识 knowledge，不知道真实世界</li><li>缺少常识 common sense</li><li>缺少真正的语法/句法，即句子结构</li><li>缺少（大部分）记忆</li></ul><h4 id="PARRY"><a href="#PARRY" class="headerlink" title="PARRY"></a>PARRY</h4><p>Colby et al 1971。</p><p>比ELIZA能聊得更长时间。它追踪全局对的情绪状态，并根据情绪状态选择不同标签的词。</p><blockquote><p>“With Parry, Dr. Colby established that a computer chip could be programmed to imitate a paranoid schizophrenic.” —— <a href="https://edu-cyberpg.com/Linguistics/Parry.html" target="_blank" rel="noopener">查看原文</a></p><p>根据PARRY，Colby证实，电脑芯片可以通过编程模仿偏执型精神障碍</p></blockquote><h4 id="ALICE"><a href="#ALICE" class="headerlink" title="ALICE"></a><a href="https://home.pandorabots.com/home.html" target="_blank" rel="noopener">ALICE</a></h4><p>是一个更高级的聊天机器人，赢得了2004年的Loebner Prize</p><blockquote><p>Loebner Prize是关于图灵测试的奖项</p><p>每年，最“像人”的系统将获得2000美金。第一个通过图灵测试的系统将获得10万美金（还没完成）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dialogue Act Markup in Several Layers (DAMSL) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/18%20%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/18%20%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="文本搜索"><a href="#文本搜索" class="headerlink" title="文本搜索"></a>文本搜索</h4><p>提供搜索的资源，如图书馆、网页、文本语料库等</p><h4 id="语音搜索"><a href="#语音搜索" class="headerlink" title="语音搜索"></a>语音搜索</h4><p>比如从音频文件中搜索一段语音，但当前的技术还不足以实现完整的功能。目前已经实现的功能有：</p><ul><li>识别一段对话属于什么语言</li><li>识别对话中开始的新话题</li></ul><p><strong>正文主要专注于文本搜索</strong></p><a id="more"></a><h4 id="数据的种类"><a href="#数据的种类" class="headerlink" title="数据的种类"></a>数据的种类</h4><p>结构化数据：有组织的，可按类别搜索的数据，比如动物学的划分</p><p>非结构化数据：没有固定的结构，比如互联网的网页</p><p>半结构化数据：包含一定的类别，但也缺少许多结构，比如博客、评论等</p><h3 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h3><p>例子，图书馆目录检索：</p><ul><li>馆藏数据储存在数据库中，数据库前端与用户进行交互。如<a href="https://iucat.iu.edu/" target="_blank" rel="noopener">IUCAT</a>、WorldCat<ul><li>用户可以使用不同属性的查询字符串，比如作者、标题、文章类型等</li></ul></li></ul><h4 id="ICUAT中，字符串查询的基本规则"><a href="#ICUAT中，字符串查询的基本规则" class="headerlink" title="ICUAT中，字符串查询的基本规则"></a>ICUAT中，字符串查询的基本规则</h4><ul><li>字符编码：查询字符串的字符编码必须与数据库使用的字符编码一致，比如ASCII, ISO8859-1, UTF-8</li><li>不区分大小写：对于查询字符串，不区分大小写字符（比如因为他们没有太多的含义）</li><li>临近词作为短语搜索：比如 vitamin c</li><li>停用词Stop words：在搜索时忽略停用词（如a, an, as, at, be, but, by, do, for, if, in, is, it, of, on, the, to），除非它们被双引号标记</li></ul><h4 id="特殊字符和操作符"><a href="#特殊字符和操作符" class="headerlink" title="特殊字符和操作符"></a>特殊字符和操作符</h4><p>除了通过【字符串查询】，查询语句还支持使用【特殊字符】</p><ul><li><p>特殊字符（正则表达式）</p><ul><li>$：截断单词末尾的字符</li><li>?：表示任意一个字符</li></ul></li><li><p>boolean表达式，将两个查询合并</p><ul><li>使用and or xor。比如art <u>xor</u> therapy，将排除art therapy</li><li>当使用多个操作符时，使用圆括号将多个单词组合在一起，比如 ((music or dance) therapy))</li></ul></li></ul><h3 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h3><p>文档没有明确的分类来进行检索，比如网页页面</p><ul><li>没有一个通用的结构适用于所有页面，因此搜索引擎只能用【词袋】【倒排索引】这样的方法支持网页检索</li><li>数据的规模比结构化数据大得多（对比网页数量与图书馆藏数量）<ul><li>因此查询方式和优化方式也跟结构化数据不同</li></ul></li></ul><p>一些非结构化数据包含隐藏的结构（比如中英文互译：中文-&gt;英文，中文-&gt;英文…），但这也的结构对搜索引擎没有帮助。</p><p>非结构化数据意味着：</p><ul><li>数据的结构是无法预先确定的</li><li>无法统一标准化或统一应用</li><li>无法针对特定的结构类型进行查询</li></ul><h4 id="信息需求"><a href="#信息需求" class="headerlink" title="信息需求"></a>信息需求</h4><p>查询涉及【信息需求】，即查询者寻找的信息。该【信息需求】需要被转化为查询语句，然后通过查询语句获得希望得到的【信息需求】，在这个过程中必然会出现损失。</p><p>比如：【信息需求】是英语单词table的俄语翻译；可能的查询语句为：russian translation table。在这里【信息需求】是明确的，但查询语句是不明确的。它可能查到一张俄语翻译表，而不是单词table的翻译。</p><h4 id="评估搜索结果"><a href="#评估搜索结果" class="headerlink" title="评估搜索结果"></a>评估搜索结果</h4><p> <a href="https://trec.nist.gov/" target="_blank" rel="noopener">TREC</a>（the Text REtrieval Conference）会议的评估展示了如何使用【信息需求】，如【信息需求】的标题、描述和限制</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gemmb898nkj30zi0mqgqb.jpg" alt="截屏2020-05-09 下午4.31.33" style="zoom: 33%;" /></p><p>以上信息，可以用于评估获取的结果是否满足【信息需求】。</p><p>TREC将”正确的结果“定义为：</p><blockquote><p>If you were writing a report on the subject of the topic and would use the information contained in the document in the report, then the document is relevant. <a href="https://trec.nist.gov/data/reljudge_eng.html" target="_blank" rel="noopener">引用源</a></p></blockquote><h4 id="互联网搜索"><a href="#互联网搜索" class="headerlink" title="互联网搜索"></a>互联网搜索</h4><p>最简单的步骤为：</p><ol><li>打开搜索引擎</li><li>输入查询语句</li><li>获取响应列表</li><li>评估结果</li></ol><h4 id="互联网的本质"><a href="#互联网的本质" class="headerlink" title="互联网的本质"></a>互联网的本质</h4><p>与图书馆数据库的记录相比，网页通常更缺少结构。通常查询的是网页中包含的文字。但一个页面可能还会包含【元数据】标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META name&#x3D;&quot;keywords&quot; lang&#x3D;&quot;en-us&quot; content&#x3D;&quot;vacation, Greece&quot;&gt;</span><br></pre></td></tr></table></figure><p>【元数据】标签是可选的，它是结构化的数据，但并不展示在页面上，而是在在源代码的HTML标签中。</p><h4 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h4><p>搜索引擎（比如Google），存储了所有网页的备份。它为大量的页面创建了索引（对于谷歌，有超过万亿的页面），来提供高效的访问。对于所有查询，都会返回一个有排名的结果集。</p><p>不同的搜索引擎可能会采用不同的技术：</p><ul><li>如何识别单词【word token】<ul><li>stemming：bird和birds是否被认为相同</li><li>capitalization：trip和Trip是否被认为相同</li></ul></li><li><p>高级搜索：是否支持使用【操作符】or and xor 或【特殊的接口】</p></li><li><p>如何对结果进行排名，以及如何聚类相似的结果</p></li></ul><h4 id="搜索引擎建立索引"><a href="#搜索引擎建立索引" class="headerlink" title="搜索引擎建立索引"></a>搜索引擎建立索引</h4><p>当搜索引擎在爬取网页（使用网络爬虫）时，会建立【term-by-document matrix】，即【倒排索引】：</p><ul><li>它映射了哪个单词出现在哪个文档中，数字表示文档ID</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gemn5gf5g8j30k209oab1.jpg" alt="截屏2020-05-09 下午5.00.38" style="zoom: 33%;" /></p><h4 id="结果排名"><a href="#结果排名" class="headerlink" title="结果排名"></a>结果排名</h4><p>理性情况下，结果应该根据相关性进行排名。问题在于，如何让搜索引擎判断查询和结果之间的相关性。</p><ol><li>计算一个页面的”出度“和”入度“，即【Weblinking】，来判断这个【页面的受欢迎程度】。对于不受欢迎的页面，就需要更精确关键词查询才能找到。</li><li>对【网站的质量】高低给予”奖励“和”惩罚“</li><li>查询【元数据】中的关键词</li><li>对于返回的网页，计算它们被点击的频率，即【click-through measurement】</li><li>等等</li></ol><h4 id="Google-PageRank"><a href="#Google-PageRank" class="headerlink" title="Google PageRank"></a>Google PageRank</h4><p>假设对页面A进行打分，指向A的页面有：XYZ。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gemnrut1zpj30io08oaad.jpg" alt="截屏2020-05-09 下午5.22.10" style="zoom:33%;" /></p><p>计算公式为：</p><p>$R(A)=\frac{R(X)}{C(X)}+\frac{R(Y)}{C(Y)}+\frac{R(Z)}{C(Z)}$</p><p>其中X除了指向A，还指向页面BC：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gemnscsqbpj30ii09gmxj.jpg" alt="截屏2020-05-09 下午5.22.40" style="zoom:33%;" /></p><p>根据公式，假设X的得分为R(x)=15，X所指向的页面数量C(X)=3，则A从X页面中获得<script type="math/tex">\frac{R(X)}{C(X)}=5</script>分。然后再分别计算YZ，则可以最终得出A的得分。</p><h3 id="半结构化数据"><a href="#半结构化数据" class="headerlink" title="半结构化数据"></a>半结构化数据</h3><p>包含一些类别，但并非完全结构化的数据。比如维基百科词条，不同用户添加的词条有不同的结构和分类</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>Boolean表达式不足以描述更复杂的文本或单词模式，这时可以用【正则表达式 regular expression】。正则表达式是一种对字符串集更紧凑的描述方式。它用来描述字符串中有规律的部分。</p><p>关于【正则表达式的语法】可自行百度</p><h5 id="Grep"><a href="#Grep" class="headerlink" title="Grep"></a>Grep</h5><blockquote><p>grep是一个最初用于Unix操作系统的命令行工具。在给出文件列表或标准输入后，grep会对匹配一个或多个正则表达式的文本进行搜索，并只输出匹配的行或文本。</p><p>对于更复杂的正则表达式运算符，可以使用egrep</p></blockquote><h4 id="语料库"><a href="#语料库" class="headerlink" title="语料库"></a>语料库</h4><p>预料库是一个文本集合。它集合了不同作者的著作、报纸、文本等。</p><ul><li><a href="http://www.natcorp.ox.ac.uk/" target="_blank" rel="noopener">英国国家语料库</a>包含了1亿个用于英语口语和写作的单词的集合</li><li><a href="http://www.statmt.org/europarl/" target="_blank" rel="noopener">欧洲议会议事平行语料库1996–2011</a>：会议上的所有记录都要翻译为欧洲各国的语言</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构化数据 </tag>
            
            <tag> Boolean表达式 </tag>
            
            <tag> 非结构化数据 </tag>
            
            <tag> Google PageRank </tag>
            
            <tag> 半结构化数据 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 语料库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息采集</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/08%20%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/08%20%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="信息采集不是信息检索"><a href="#信息采集不是信息检索" class="headerlink" title="信息采集不是信息检索"></a>信息采集不是信息检索</h4><p><strong>Information Retrieval</strong>信息检索，从大的本文集中（通常是网站），根据关键字或查询，获取文档documents。用于分析文档。（如搜索引擎）</p><ul><li>返回的文档，文档可能包含需求相关的信息（不一定）</li></ul><p><strong>Information Extraction</strong>信息采集，从大的文本集的内容中（语料库），获取事实facts，和结构化的信息。用于分析事实</p><ul><li>返回结构化的信息</li></ul><h4 id="通过信息采集来访问文档"><a href="#通过信息采集来访问文档" class="headerlink" title="通过信息采集来访问文档"></a>通过信息采集来访问文档</h4><p>通过传统的查询引擎来获取事实是比较困难和缓慢的，同时还要求选择合适的查询词。信息检索将返回文档，在文档中可能包含相关信息。</p><p>而信息采集则可以返回结构化的信息。</p><h4 id="用信息采集代替信息检索"><a href="#用信息采集代替信息检索" class="headerlink" title="用信息采集代替信息检索"></a>用信息采集代替信息检索</h4><ul><li>IE比IR返回的知识层次更加深入</li><li><p>通过IE构建数据库，并与文档关联，可以形成另一种形式的搜索工具。</p><ul><li>即使结果不够精确，人们也可以从关联的原始文档中查找。（相当于另一种形式的IR）</li></ul></li><li><p>使用场景：</p><ul><li>新闻：分辨主要的关系 major relations，和事件种类 event types；</li><li>科学报告：分辨关系relations和涉及的科学领域subfield</li></ul></li><li><p>例子：HASIE、KIM、Threat tracker</p><ul><li><p><strong>HaSIE</strong>，IE系统，自动找出公司对健康和安全问题的报告，自动识别文档的每个部分，从中提取出关于健康和安全问题的句子，并存入数据库。</p></li><li><p><strong>KIM</strong>，简化的数据库查询页面</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gei4ajealfj310e0h043a.jpg" alt="截屏2020-05-05 下午7.05.52"></p></li><li><p><strong>Threat tracker</strong>：识别文章中出现的实体（名词）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gei4ayzrp5j30z00kk11m.jpg" alt="截屏2020-05-05 下午7.06.17"></p></li></ul></li></ul><h4 id="如何识别命名实体-Named-Entity-NE-Recognition"><a href="#如何识别命名实体-Named-Entity-NE-Recognition" class="headerlink" title="如何识别命名实体 Named Entity (NE) Recognition"></a>如何识别命名实体 Named Entity (NE) Recognition</h4><p>识别文字中的命名实体，并将他们分类到提前定义好的类别中</p><p>命名实体包括：人、组织、地点、日期、其他</p><p>是构建复杂IE系统的基础；命名实体之间的关系可以用于追踪tracking、信息本体论ontological information、情景构建scenario building（<strong>NE的重要性</strong>）</p><ul><li>Tracking (co-reference) “Dr Head, John, he”</li><li>Ontologies “Manchester, CT”</li><li>Scenario “Dr Head became the new director of Shiny Rockets Corp”</li></ul><blockquote><p>本体就是一种特殊类型的<a href="https://zh.wikipedia.org/wiki/术语集" target="_blank" rel="noopener">术语集</a>，具有结构化的特点，且更加适合于在<a href="https://zh.wikipedia.org/wiki/信息系统" target="_blank" rel="noopener">计算机系统</a>之中使用；或者说，本体实际上就是「对特定<a href="https://zh.wikipedia.org/wiki/论域" target="_blank" rel="noopener">领域</a>之中某套<a href="https://zh.wikipedia.org/wiki/概念" target="_blank" rel="noopener">概念</a>及其相互之间<a href="https://zh.wikipedia.org/wiki/关系_(数学" target="_blank" rel="noopener">关系</a>)的形式化表达（formal representation）」</p></blockquote><h4 id="两种途径"><a href="#两种途径" class="headerlink" title="两种途径"></a>两种途径</h4><p><strong>知识工程Knowledge Engineering</strong>：基于规则、由有经验的语言学工程师开发、采用人类的直觉、开发周期长、有些变化很难适应</p><p><strong>学习系统Learning System</strong>：采用统计学或机器学习、开发者不需要语言学专业技能、需要大量的带注解的训练数据annotated training data、有些更改可能需要重新标注整个训练语料库</p><h4 id="NE命名实体中的问题"><a href="#NE命名实体中的问题" class="headerlink" title="NE命名实体中的问题"></a>NE命名实体中的问题</h4><p>基础问题：</p><ul><li><p>实体的多样性：John Smith / Mr Smith, John</p></li><li><p>实体种类的不确定性：John Smith 人或公司</p></li><li><p>常用词的一词多义：may 可能或五月</p></li></ul><p>更复杂的问题还有：类型、结构、域、体裁、符号、拼写、所占空间、格式</p><h4 id="列表查询List-lookup-approach——最简单"><a href="#列表查询List-lookup-approach——最简单" class="headerlink" title="列表查询List lookup approach——最简单"></a>列表查询List lookup approach——最简单</h4><p>系统只识别在列表(lists / gazetteers)中所列的实体</p><p>优点：简单、快速、与语言无关，易于重置（创建新的列表）</p><p>缺点：需要收集实体和维护列表，无法解决名称的多样性，无法解决不确定性</p><h4 id="浅层分析Shallow-Parsing-Approach（内部结构）"><a href="#浅层分析Shallow-Parsing-Approach（内部结构）" class="headerlink" title="浅层分析Shallow Parsing Approach（内部结构）"></a>浅层分析Shallow Parsing Approach（内部结构）</h4><p>先分析句子的各个组成部分（e.g. 名词、动词）然后连接成具有不同意义的整体（e.g. 词组、俗语）如：</p><p>Cap. Word + {City, Forest, Center, River}<br>e.g. Sherwood Forest</p><blockquote><p>Is an analysis of a <a href="https://en.wikipedia.org/wiki/Sentence_(linguistics" target="_blank" rel="noopener">sentence</a>) which first identifies constituent parts of sentences (nouns, verbs, adjectives, etc.) and then links them to higher order units that have discrete grammatical meanings (<a href="https://en.wikipedia.org/wiki/Noun" target="_blank" rel="noopener">noun</a> groups or <a href="https://en.wikipedia.org/wiki/Noun_phrase" target="_blank" rel="noopener">phrases</a>, verb groups, etc.).</p><p>It is a technique widely used in <a href="https://en.wikipedia.org/wiki/Natural_language_processing" target="_blank" rel="noopener">natural language processing</a>. It is similar to the concept of <a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank" rel="noopener">lexical analysis</a> for computer languages. Under the name, “shallow structure hypothesis”, it is also used as an explanation for why <a href="https://en.wikipedia.org/wiki/Second_language" target="_blank" rel="noopener">second language</a> learners often fail to parse complex sentences correctly.</p></blockquote><p><strong>问题：</strong></p><p>单词首字母大写带来的不确定性（英文句子首字母大写）：[All American Bank] vs. All [State Police]</p><p>语义的不确定性：John F. Kennedy（机场/地点），Philip Morris（组织）</p><p>结构的不确定性：[Center for Computational Linguistics]（计算语言学中心） vs. message from [City Hospital] for [John Smith] ；[Cable and Wireless] vs. [Microsoft] and [Dell]。一个词组和两个词的区别</p><p><strong>解决方式：基于语境的模式</strong></p><p>比如【David Walton】和【Goldman Sachs】是难以区分的，但在句子【David Walton of Goldman Sachs】，使用【[Person] of [Organization]】则可以正确识别2个实体</p><h4 id="语境信息的识别"><a href="#语境信息的识别" class="headerlink" title="语境信息的识别"></a>语境信息的识别</h4><p>使用关键字索引 (Key Word in Context, KWIC)和concordancer查找实体附近的上下文（语境）窗口</p><p>查询字符串、实体的重复语境的模式</p><p>手动创建新的模式或规则</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gei5kz4jx3j30po0ikgot.jpg" alt="截屏2020-05-05 下午7.50.32" style="zoom:33%;" /></p><blockquote><p>A <strong>concordancer</strong> is a <a href="https://en.wikipedia.org/wiki/Computer_program" target="_blank" rel="noopener">computer program</a> that automatically constructs a <a href="https://en.wikipedia.org/wiki/Concordance_(publishing" target="_blank" rel="noopener">concordance</a>). </p></blockquote><h4 id="语境模式"><a href="#语境模式" class="headerlink" title="语境模式"></a>语境模式</h4><ol><li>自动采集带有具体特征的语境词，比如采集人名之前出现的所有动词</li><li>按词频对动词列表排序，可以排除低频词（可选）</li><li>这些动词可以用来查找新的人名</li><li>对于新识别出的人名，重复1-3步骤</li></ol><h4 id="多源实体识别-MUSE-–-MUlti-Source-Entity-Recognition"><a href="#多源实体识别-MUSE-–-MUlti-Source-Entity-Recognition" class="headerlink" title="多源实体识别 MUSE – MUlti-Source Entity Recognition"></a>多源实体识别 MUSE – MUlti-Source Entity Recognition</h4><ul><li><p>在<a href="https://gate.ac.uk/" target="_blank" rel="noopener">GATE</a>内部开发的信息采集系统</p></li><li><p>对不同的文本类型和体裁，支持命名实体和coreference（共指）</p><blockquote><p>Determine if word A refers to the same real world entity as word B，比如John和he</p></blockquote></li><li><p>使用手动制定规则的知识工程方法</p></li><li><p>性能可与机器学习方法媲美</p></li><li><p>适应性强</p></li></ul><h4 id="MUSE模型"><a href="#MUSE模型" class="headerlink" title="MUSE模型"></a>MUSE模型</h4><ul><li><p>文档格式和体裁分析</p></li><li><p>词令化（将句子差分为单词列表）（Tokenisation）</p></li><li><p>句子拆分（Sentence splitting）</p></li><li><p>词性标记/语法标记（Part-Of-Speech tagging, POS）</p><blockquote><p>在<a href="https://en.wikipedia.org/wiki/Corpus_linguistics" target="_blank" rel="noopener">语料库语言学中</a>，<strong>词性标记</strong>（<strong>POS标记</strong>或<strong>PoS标记</strong>或<strong>POST</strong>），也称为<strong><a href="https://en.wikipedia.org/wiki/Grammar" target="_blank" rel="noopener">语法</a>标记</strong>或<strong><a href="https://en.wikipedia.org/wiki/Lexical_category" target="_blank" rel="noopener">单词类别</a>歧义消除</strong>，是将文本（语料库）中的单词标记为与特定<a href="https://en.wikipedia.org/wiki/Parts_of_speech" target="_blank" rel="noopener">部分</a>相对应的过程<a href="https://en.wikipedia.org/wiki/Parts_of_speech" target="_blank" rel="noopener">语音的</a>，<a href="https://en.wikipedia.org/wiki/Part-of-speech_tagging#cite_note-1" target="_blank" rel="noopener">[1]</a>同时基于其定义和其<a href="https://en.wikipedia.org/wiki/Context_(language_use" target="_blank" rel="noopener">上下文</a>) -即，其<a href="https://en.wikipedia.org/wiki/Lexicography" target="_blank" rel="noopener">与相邻的和相关词语关系</a>在一个<a href="https://en.wikipedia.org/wiki/Phrase" target="_blank" rel="noopener">短语</a>，<a href="https://en.wikipedia.org/wiki/Sentence_(linguistics" target="_blank" rel="noopener">句子</a>)，或<a href="https://en.wikipedia.org/wiki/Paragraph" target="_blank" rel="noopener">段落</a>。通常将这种简化形式教给学龄儿童，将单词识别为<a href="https://en.wikipedia.org/wiki/Noun" target="_blank" rel="noopener">名词</a>，<a href="https://en.wikipedia.org/wiki/Verb" target="_blank" rel="noopener">动词</a>，<a href="https://en.wikipedia.org/wiki/Adjective" target="_blank" rel="noopener">形容词</a>，<a href="https://en.wikipedia.org/wiki/Adverb" target="_blank" rel="noopener">副词</a>等。</p></blockquote></li><li><p>名词查询（Gazetteer lookup）</p></li><li><p>语义语法</p></li><li><p>拼写 coreference </p></li><li><p>名词和代词 coreference（如John和he）</p></li></ul><h4 id="MUSE多语言适应"><a href="#MUSE多语言适应" class="headerlink" title="MUSE多语言适应"></a>MUSE多语言适应</h4><p>MUSE有多个模块，可以处理多种语言：英语、法语、德语、罗马尼亚语Romanian，保加利亚语Bulgarian，俄语，宿务语Cebuano（菲律宾），印地语Hindi，中文，阿拉伯语</p><h4 id="多语言实体需要什么"><a href="#多语言实体需要什么" class="headerlink" title="多语言实体需要什么"></a>多语言实体需要什么</h4><ul><li>广泛支持非拉丁脚本和文本编码，包括转换实用程序<ul><li>自动识别编码</li><li>占用TIDES印地语努力的2/3</li></ul></li><li>双语词典</li><li>带注释的语料库，用于评估</li><li>提供名词列表（gazetteer list ）的互联网资源（例如，电话簿，黄页，双语页）</li></ul><h4 id="信息采集IE的未来"><a href="#信息采集IE的未来" class="headerlink" title="信息采集IE的未来"></a>信息采集IE的未来</h4><ul><li>用于语义网的工具</li><li>分层命名实体的识别</li><li>在生物信息和医学领域</li><li>混合使用IE和IR，比如问题回答</li><li>在IE和计算属于之间的合作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RNN 循环神经网络</title>
      <link href="/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/05%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN/"/>
      <url>/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/05%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN/</url>
      
        <content type="html"><![CDATA[<h4 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h4><p><a href="https://blog.csdn.net/hellowuxia/article/details/86529575" target="_blank" rel="noopener">链接</a></p><p>循环神经网络的主要用途是处理和预测序列数据。</p><p>在全连接神经网络或者卷积神经网络中，都是从输入层到隐藏层再到输出层的，层与层之间都的全连接的，但<strong>每层之间的结点是无连接的</strong>。这就导致当前神经元没有前一个的记忆。而RNN的隐藏层之间的结点是有连接的，RNN的当前节点的输入包含上一层的输出和本层上一个节点的输出。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdrer62l38j30ys0ae791.jpg" alt="截屏2020-04-12 下午4.37.36" style="zoom:33%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdreshd3cuj30wg0d4wit.jpg" alt="截屏2020-04-12 下午4.38.49" style="zoom:33%;" /></p><p>它对短距离依赖很有效，但对长距离依赖的效果则变差</p><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p>LSTM 是一种特殊的RNN。通过精巧的设计（CNN中的深度残差网络也是类似）<strong>解决长序列训练过程中的梯度消失和梯度爆炸问题</strong>，即远距离传递导致的信息丢失问题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdret6tzvnj30vo0ca0yo.jpg" alt="截屏2020-04-12 下午4.39.32" style="zoom:33%;" /></p><a id="more"></a><h4 id="LSTM-参考文章"><a href="#LSTM-参考文章" class="headerlink" title="LSTM 参考文章"></a>LSTM 参考文章</h4><p><a href="https://www.jianshu.com/p/89f3b045d9cb" target="_blank" rel="noopener">从结构上描述</a></p><p><a href="https://www.jianshu.com/p/7e6e55c48972" target="_blank" rel="noopener">从算法层面描述</a></p><p><a href="https://www.jianshu.com/p/9dc9f41f0b29" target="_blank" rel="noopener">整体描述LSTM</a></p><h4 id="RNN中的循环图"><a href="#RNN中的循环图" class="headerlink" title="RNN中的循环图"></a>RNN中的循环图</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf09vnxqnhj30pe0i0abk.jpg" alt="截屏2020-05-21 上午11.59.18" style="zoom:33%;" /><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf09vsqmqhj30ok0fyjsx.jpg" alt="截屏2020-05-21 上午11.59.28" style="zoom:33%;" /></p><p>右图为左图的展开形式。计算公式如下：</p><p>【当前神经元的记忆h】与【上一层神经元的记忆h】和【当前神经元的输入x】有关</p><p>【当前神经元的输出o】与【当前神经元的记忆h】有关。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf09xqalarj30hq09ywfc.jpg" alt="截屏2020-05-21 下午12.00.56" style="zoom:50%;" /></p><h4 id="tanh激活函数"><a href="#tanh激活函数" class="headerlink" title="tanh激活函数"></a>tanh激活函数</h4><p>激活后得到的取值范围为[-1,1]</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf09ynba0uj30xk0h240i.jpg" alt="截屏2020-05-21 下午12.02.13" style="zoom:33%;" /></p><h4 id="输入序列到输入序列的多种匹配变化"><a href="#输入序列到输入序列的多种匹配变化" class="headerlink" title="输入序列到输入序列的多种匹配变化"></a>输入序列到输入序列的多种匹配变化</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0afykw7gj311u0bs10g.jpg" alt="截屏2020-05-21 下午12.18.50" style="zoom:50%;" /></p><p>（Figure from Karpathy, A., The unreasonable effectiveness of recurrent neural networks, accessed Feb-2020.）</p><h5 id="一对多——图像字幕"><a href="#一对多——图像字幕" class="headerlink" title="一对多——图像字幕"></a>一对多——图像字幕</h5><p>比如输入一张图像，输出一段字幕描述图片。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0ahmsaajj30ty0a679q.jpg" alt="截屏2020-05-21 下午12.20.28"></p><h5 id="多对一——情感分析"><a href="#多对一——情感分析" class="headerlink" title="多对一——情感分析"></a>多对一——情感分析</h5><p>比如输入一段文字，判断文字情绪是正面的还是负面的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0aildobij30xw0j6afb.jpg" alt="截屏2020-05-21 下午12.21.23" style="zoom: 33%;" /></p><h5 id="多对多——翻译、语音转换"><a href="#多对多——翻译、语音转换" class="headerlink" title="多对多——翻译、语音转换"></a>多对多——翻译、语音转换</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0cazxfrsj30s20euwhq.jpg" alt="截屏2020-05-21 下午1.23.10" style="zoom:33%;" /></p><h4 id="构建一个字符级别的语言模型"><a href="#构建一个字符级别的语言模型" class="headerlink" title="构建一个字符级别的语言模型"></a>构建一个字符级别的语言模型</h4><p>提供一个输入，告诉它输出的样子。由模型调整每个输入对应的输出的可能性分布，使得对应的输出为最大的可能性</p><p>这里输入时hello和一个起始标记符，以【独热向量】表示，而输出同样是hello，但是去掉了起始标记符，多了结束标记符，并提前了一步。</p><p>这是一个unrolled two hidden layer RNN。</p><p>这里，起始标记符对应的输出为h，h对应的输出为e，以此类推。</p><p>而这个网络最大的好处是，它的隐藏层能够记住之前的输出，也就是说网络知道：前两个输入为起始符+h，当前输入是e时，则对应的输出应该为l。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0cw8h9npj30v60ik41a.jpg" alt="截屏2020-05-21 下午1.43.41" style="zoom:50%;" /></p><h5 id="cross-entropy-loss"><a href="#cross-entropy-loss" class="headerlink" title="cross-entropy loss"></a>cross-entropy loss</h5><p>根据【目标字符y】和【输出o的可能性分布】，计算【cross-entropy loss】，一个字符串（实例）的loss，是所有字符的loss之和。由于【cross-entropy loss】使用的是【-log】函数，而-log的输入的可能性分布取值范围为[0,1]，因此可能性越大，cross-entropy loss越小。我们的目的是使得总的【cross-entropy loss】最小。</p><p><strong>【注意梯度消失和梯度爆炸问题】</strong></p><h4 id="如何使用训练好的模型——采样"><a href="#如何使用训练好的模型——采样" class="headerlink" title="如何使用训练好的模型——采样"></a>如何使用训练好的模型——采样</h4><p>输入起始标记符x，得到输出o，即可能性分布；然后计算o的softmax，并根据结果进行采用（【注意，采样并不代表着只取最大可能性的元素，而是随机的选择】），得到唯一输出y，并同时将y作为下一个time-step的输入。直到最后得到终止符。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0nqzwumlj30nw0aq763.jpg" alt="截屏2020-05-21 下午7.59.14" style="zoom:50%;" /></p><h4 id="梯度消失-Gradients-Vanish"><a href="#梯度消失-Gradients-Vanish" class="headerlink" title="梯度消失 Gradients Vanish"></a>梯度消失 Gradients Vanish</h4><p>尽管RNN原则上是能够记忆过去的信息，然实际上，梯度还是会随着训练逐渐变小，这会导致丢失过去的重要信息。解决方案是【长短时记忆LSTM】</p><h4 id="传统的RNN"><a href="#传统的RNN" class="headerlink" title="传统的RNN"></a>传统的RNN</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdreshd3cuj30wg0d4wit.jpg" alt="截屏2020-04-12 下午4.38.49" style="zoom:33%;" /></p><h4 id="LSTM-1"><a href="#LSTM-1" class="headerlink" title="LSTM"></a>LSTM</h4><p><a href="https://www.jianshu.com/p/95d5c461924c" target="_blank" rel="noopener">链接</a></p><p><a href="https://www.cnblogs.com/chihaoyuIsnotHere/p/10604085.html" target="_blank" rel="noopener">关于gate</a></p><p>LSTM 是一种特殊的RNN。通过精巧的设计（CNN中的深度残差网络也是类似）<strong>解决长序列训练过程中的梯度消失和梯度爆炸问题</strong>，即远距离传递导致的信息丢失问题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdret6tzvnj30vo0ca0yo.jpg" alt="截屏2020-04-12 下午4.39.32" style="zoom:33%;" /></p><ul><li><p>从细胞状态中决定遗忘什么以及记忆什么</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0xf602aqj310u0doacl.jpg" alt="截屏2020-05-22 上午1.33.52" style="zoom:50%;" /></p></li><li><p>决定将那些数据更新到细胞状态中</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0xh1xlz0j312k0ckq5k.jpg" alt="截屏2020-05-22 上午1.35.38" style="zoom:50%;" /></p></li><li><p>更新细胞状态</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0xhmzqq1j30z20cugnt.jpg" alt="截屏2020-05-22 上午1.36.05" style="zoom:50%;" /></p></li><li><p>决定从细胞状态中输出什么</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf0xi0g06nj31100d6aco.jpg" alt="截屏2020-05-22 上午1.36.35"></p></li></ul><h4 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h4><blockquote><p>Long-Term Dependencies —— 长距离依赖</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RNN </tag>
            
            <tag> LSTM </tag>
            
            <tag> tanh激活函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库和存储</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/10%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%AD%98%E5%82%A8/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/10%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p>大数据系统需要存储大量的数据，并且需要花费大量的金钱对存储的数据进行获取和维护。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3phyt1uoj30tw0hgaf0.jpg" alt="截屏2020-03-23上午3.35.43"  /></p><a id="more"></a><h3 id="数据库的结构"><a href="#数据库的结构" class="headerlink" title="数据库的结构"></a>数据库的结构</h3><p>以下类型的数据可以被归类为：关系型数据库，或非关系型数据库（后4种）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3pmrg1u5j30r20fwn8e.jpg" alt="截屏2020-03-23上午3.40.17"></p><p><img src="../../../Library/Application Support/typora-user-images/截屏2020-03-23上午3.42.55.png" alt="截屏2020-03-23上午3.42.55"></p><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>关键特征：</p><ul><li><p>Edgar Codd’s 12 rules <a href="https://baike.baidu.com/item/%E7%A7%91%E5%BE%B7%E5%8D%81%E4%BA%8C%E5%AE%9A%E5%BE%8B/10138377?fr=aladdin" target="_blank" rel="noopener">科德十二定律</a></p></li><li><p>使用<u>表</u>储存<u>结构化数据</u></p></li><li><p>支持ACID事务的一致性</p><blockquote><p>Atomic 原子性：事务中的所有操作全部成功或者全部回滚</p><p>Consistent 一致性：事务不能让数据库处于不一致的状态</p><p>Isolated 隔离性：事务之间不能相互影响</p><p>Durable 耐用性：对完成的事务进行持久化，即使服务器重启</p></blockquote></li><li><p>通常使用SQL进行查询</p></li><li><p>通过主键和外键管理关系</p></li><li><p>使用SQL和关系来执行<u>关联joins</u></p><blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3pu209rij30xc0owjyl.jpg" alt="截屏2020-03-23上午3.47.23" style="zoom:50%;" /></p></blockquote></li></ul><h3 id="大数据系统中数据库的挑战"><a href="#大数据系统中数据库的挑战" class="headerlink" title="大数据系统中数据库的挑战"></a>大数据系统中数据库的挑战</h3><ul><li>大数据的规模，对数据库空间的要求是很大的挑战</li><li>传统的RDBMS无法扩展到真正”大数据“的级别</li><li>ACID原则不一定适用于大规模</li><li>CAP定理提出了一个问题</li></ul><h4 id="CAP定理："><a href="#CAP定理：" class="headerlink" title="CAP定理："></a>CAP定理：</h4><p>是Eric Brewer在1998年提出的一个假设，由Gilbert和Lynch在2002年证明。</p><p>它指出，分布式系统不可能同时确保<u>一致性</u>，<u>可用性</u>和<u>分区容错性</u>。</p><ul><li>一致性：所有客户都能看到最新的数据，不管执行过什么操作（比如更新或删除）</li><li>可用性：即使某些节点发送错误，系统也需要继续客户的操作</li><li>分区容错：即使网络或消息发送错误，系统也需要继续执行可续操作（比如一个节点向另一个节点发送的消息，允许发送错误并被丢弃）</li></ul><h4 id="ACID-和-BASE"><a href="#ACID-和-BASE" class="headerlink" title="ACID 和 BASE"></a>ACID 和 BASE</h4><p>ACID：</p><ul><li>Atomic 原子性：事务的所有操作都成功，不然就回滚</li><li>Consistent 一致性：事务不能使数据库的最终状态出现不一致</li><li>Isolated 隔离性：事务使独立的，不能影响其他事务</li><li>Durable 耐用性：即使服务器重新启动等，已完成的事务也会保留。</li></ul><p>BASE</p><ul><li><strong>B</strong>asic <strong>A</strong>vailability 基础可用性：系统在CAP定理方面，保证系统的可用性</li><li><strong>S</strong>oft-state 软状态：系统的状态会随时间改变，即使没有输入（因为要确保最终一致性）</li><li><strong>E</strong>ventual consistency 最终一致性：只要数据库最终变得一致，在每个事务之后就不需要一致性。</li></ul><h3 id="NoSQL-——-Not-only-SQL"><a href="#NoSQL-——-Not-only-SQL" class="headerlink" title="NoSQL —— Not only SQL"></a>NoSQL —— Not only SQL</h3><p><strong>严格的一致性</strong>会在大规模的系统中带来巨大的性能和能源开销。</p><p>妥协方案是<strong>最终一致性</strong>：给定足够长的时间不发送任何更改，可以期望所有更新都将通过系统进行传播，且所有副本都将最终保持一致。</p><p>NoSQL数据库比传统的数据库采用<u>更宽松的一致性模型</u>，它是非关系的数据库，没有固定的schema，也没有joins。NoSQL描述为克服RDBMS的可扩展性限制而开发的许多非关系数据库。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3qpwtjf1j310m0l2tsl.jpg" alt="截屏2020-03-23上午4.18.00" style="zoom:33%;" /></p><h4 id="NoSQL的好处"><a href="#NoSQL的好处" class="headerlink" title="NoSQL的好处"></a>NoSQL的好处</h4><ul><li>适合处理大量的数据</li><li>NoSQL数据库针对<u>检索</u>和<u>添加</u>操作进行了高度优化，并且通常除了记录存储之外几乎没有其他功能（尽管有时它们确实可以有）</li><li>当实时性能比一致性更重要时，可以采用NoSQL</li><li>例子：对大量文档进行索引、在高流量网站上提供页面、传递流媒体</li></ul><h4 id="NoSQL的种类"><a href="#NoSQL的种类" class="headerlink" title="NoSQL的种类"></a>NoSQL的种类</h4><p>键值对存储、面向列的数据库、文档型数据库、图数据库</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3qxs5kfej30r20fwgnj.jpg" alt="截屏2020-03-23上午3.40.17"></p><h4 id="类型1：键值对存储"><a href="#类型1：键值对存储" class="headerlink" title="类型1：键值对存储"></a>类型1：键值对存储</h4><ul><li>是最简单的NoSQL类型，且易于实现，比如MapReduce。</li><li>它允许数据以<u>无shcema</u>和<u>无固定数据模型</u>的方式存储。</li><li>Key可以用简单的值表示。</li><li>当它仅用于查询或对部分数据进行更新时，效率很低</li></ul><div class="table-container"><table><thead><tr><th>例子</th><th>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</th></tr></thead><tbody><tr><td>经典的应用</td><td>内容缓存（专注于向大量的数据进行扩展，为处理大量负载而设计），日志等</td></tr><tr><td>数据模型</td><td>一系列的键值对</td></tr><tr><td>优点</td><td>快速查询</td></tr><tr><td>缺点</td><td>存储的数据没有schema</td></tr><tr><td>适合</td><td>存储会话session信息、用户资料、偏好、购物车信息</td></tr><tr><td>不适合</td><td>查询信息、存储的数据之间有关系、同时操作多个Key</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3r8esu5ej310k0hy0zc.jpg" alt="截屏2020-03-23上午4.35.48" style="zoom:33%;" /></p><h4 id="面向列的数据库"><a href="#面向列的数据库" class="headerlink" title="面向列的数据库"></a>面向列的数据库</h4><p>数据库的常用查询需要对数据集进行聚合处理，以面向列的方式存储数据，能使需要对大规模数据进行聚合的查询更高效</p><p>面向列的数据库还可以处理非常大的数据，因为数据是按列组织的，并且可以轻松分区（称为分片）。在这种情况下，列会按列族（也称为组）进行组织，以将相关列保持在一起（如用于客户地址的列组等）</p><p><a href="https://blog.csdn.net/nieson2012/article/details/79551337" target="_blank" rel="noopener">行式与列式的关键区别</a></p><div class="table-container"><table><thead><tr><th>例子</th><th>Cassandra, HBase, Riak</th></tr></thead><tbody><tr><td>经典的应用</td><td>分布式文件系统</td></tr><tr><td>数据模型</td><td>列 -&gt; 族</td></tr><tr><td>优点</td><td>快速查询、分布式的数据存储</td></tr><tr><td>缺点</td><td>低级别的接口</td></tr><tr><td>适合</td><td>内容管理系统、博客平台、大量写入（日志聚合）、maintaining counters、expiring usage</td></tr><tr><td>不适合</td><td>早期开发、变化的查询模式</td></tr></tbody></table></div><h4 id="面向文档的数据库"><a href="#面向文档的数据库" class="headerlink" title="面向文档的数据库"></a>面向文档的数据库</h4><ul><li>面向文档的数据库类似于键值存储，不同之处在于，值指向标准格式/编码的文档（入XML，JSON等）</li><li>文档数据库将这些文档理解为字段的集合，除了通过键进行检索之外，还可以直接进行查询和更新。</li><li>文档数据库实质上是键值存储的下一个级别，允许与每个键与嵌套的值关联。 它们支持更有效的查询。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3sg7kp29j30ku0gymzg.jpg" alt="截屏2020-03-23上午5.17.51" style="zoom:25%;" /></p><div class="table-container"><table><thead><tr><th>例子</th><th>CouchDB, MongoDb</th></tr></thead><tbody><tr><td>经典的应用</td><td>网络应用</td></tr><tr><td>数据模型</td><td>列 -&gt; 族</td></tr><tr><td>优点</td><td>快速查询、分布式的数据存储</td></tr><tr><td>缺点</td><td>查询性能、没有标准的查询语法</td></tr><tr><td>适合</td><td>内容管理系统、博客平台、网络分析、实时分析、电商应用</td></tr><tr><td>不适合</td><td>跨多个业务的复杂事务、针对不同聚合结构的查询</td></tr></tbody></table></div><h4 id="图-树结构数据库"><a href="#图-树结构数据库" class="headerlink" title="图/树结构数据库"></a>图/树结构数据库</h4><p>图数据库使用灵活的图模型，代替行列式表和硬性结构（如SQL），它可以跨多台计算机进行扩展。目标是性能和灵活性。</p><p>图包括<u>节点</u>和<u>关系</u>两个元素，每个<u>节点</u>代表一个 实体（如人、地点等），每个<u>关系</u>代表两个节点之间的联系。Twitter是图数据库的例子之一</p><ul><li>图的存储：有些图数据库使用，专门为存储和管理图而设计的，自带存储方式，；其他的则使用<u>关系数据库</u>或<u>对象数据库</u></li><li>图的处理引擎：本地图处理（也称为“无索引邻接”）是处理图数据的最有效方法，因为连接的节点在数据库中彼此物理“指向”。非本机图处理使用其他方式来处理CRUD操作。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3sqmtdb2j30ku0f40ze.jpg" alt="截屏2020-03-23上午5.27.55" style="zoom:50%;" /></p><p>性能：</p><ul><li>数据之间的连接（关系）数量比数据量增长得更快。</li><li>随着关系的数量和深度的增加，传统的数据库将变得混乱。 图数据库的性能可以更好地解决这一问题。</li></ul><p>灵活性：</p><ul><li>图的结构和方案可以随着解决方案/行业的变化而灵活变化。</li><li>无需对域进行详尽的建模。 可以在现有结构上进行添加，而不必担心当前的功能。</li></ul><div class="table-container"><table><thead><tr><th>例子</th><th>Neo4J, InfoGrid, Infinite Graph</th></tr></thead><tbody><tr><td>经典的应用</td><td>社交网络、推荐系统（专注于对数据结构建模 - 内部联系性）</td></tr><tr><td>数据模型</td><td>属性图 - 节点</td></tr><tr><td>优点</td><td>图算法：如最短路径、连通性、n度关系等</td></tr><tr><td>缺点</td><td>必须遍历整个图形才能获得确定的答案。不容易集群。</td></tr><tr><td>适合</td><td>关联数据的问题空间：社交网络、空间数据、货物和金钱的路由信息（物流）、推荐引擎</td></tr></tbody></table></div><h4 id="更多NoSQL的例子"><a href="#更多NoSQL的例子" class="headerlink" title="更多NoSQL的例子"></a>更多NoSQL的例子</h4><p>外部数据集成：</p><ul><li>许多公司需要集成来自业务合作伙伴的数据。 即使双方进行了大量的讨论和谈判，企业也几乎无法控制数据格式</li></ul><ul><li>同样，在许多情况下，由于业务需求等的变化，这些格式会非常频繁地更改。</li></ul><p>前端订单处理系统：</p><ul><li>每当最终用户从世界任何地方进行交易时，系统都需要不被中断的接受请求。</li><li>之后，协调系统通常会将其更新到后端系统，并更新最终用户的订单状态。</li></ul><p>企业内容管理服务：</p><ul><li>现在，内容管理已在公司的不同职能部门（例如HR或Sales）中使用。</li><li>挑战是，将使用不同元数据结构的部门，一起合并到公共内容管理服务中</li></ul><h4 id="NoSQL-VS-RDBMS"><a href="#NoSQL-VS-RDBMS" class="headerlink" title="NoSQL VS RDBMS"></a>NoSQL VS RDBMS</h4><p>NoSQL：</p><ul><li>存储应该能够处理非常高的负载，能够在存储上执行许多写操作</li><li>支持水平可扩展的存储</li><li>简单，因为使用非常简单的查询语言（无联接）</li></ul><p>RDBMS：</p><ul><li>存储应该是高负载的，但主要由读取操作组成</li><li>希望在复杂的数据结构中得到性能</li><li>需要强大的SQL查询语言</li></ul><p>NewSQL</p><ul><li>使用SQL查询（虽然不完全支持）</li><li>关系型</li><li>保持ACID事务的一致性</li><li>像NoSQL一样扩展</li></ul><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><blockquote><p>RDBMS —— Relational Database Management System —— 关系型数据库管理系统<br>column families —— 族</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非关系型数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> ACID </tag>
            
            <tag> BASE </tag>
            
            <tag> CAP定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据仓库</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/12%20%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/12%20%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>数据无处不在，而知识/信息则是另一个概念。数据仓库的目标是让正确的信息在正确的时间可用。数据仓库是一个【标准化的数据存储】和【处理】，【存储】指的是数据库、文件存储等，【处理】指的是将贯穿组织的不同的数据整合，以支持决策。</p><p>数据仓库是数据挖掘的天然盟友（可以很好地协同工作）；数据挖掘可以满足数据仓库的部分目标；</p><a id="more"></a><h4 id="数据仓库的特点"><a href="#数据仓库的特点" class="headerlink" title="数据仓库的特点"></a>数据仓库的特点</h4><ul><li>面向主题的</li><li>整合的：从多个数据源中获取，合并到标准格式中</li><li>随时间变化：twitter等数据源的数据会不断更新</li><li>稳定的non-volatile：数据本身不会无故改变</li></ul><blockquote><p>数据仓库和数据库的区别：<br>Data warehouses and databases are both relational data systems, but were built to serve different purposes. A data warehouse is built to store large quantities of <strong>historical data</strong> and enable fast, complex queries across all the data, typically using Online Analytical Processing (OLAP). A database was built to store <strong>current transactions</strong> and enable fast access to specific transactions for ongoing business processes, known as Online Transaction Processing (OLTP).</p></blockquote><h4 id="数据仓库的作用"><a href="#数据仓库的作用" class="headerlink" title="数据仓库的作用"></a>数据仓库的作用</h4><p>数据仓库以一致、有效的方式，将多个数据源的数据整合在一起，用于分析和查询</p><p>数据挖掘技术的数据源由数据仓库进行维护管理（比如arff格式的文件也是数据仓库的形式之一）。</p><h4 id="数据集市-Data-Mart"><a href="#数据集市-Data-Mart" class="headerlink" title="数据集市 Data Mart"></a>数据集市 Data Mart</h4><p>数据集市是一个更小更集中的数据仓库</p><p>数据集市通常反映了一个公司中特定的业务单位的业务规则</p><h4 id="开源数据仓库"><a href="#开源数据仓库" class="headerlink" title="开源数据仓库"></a>开源数据仓库</h4><ul><li>ICAME International Computer Archive of Modern English</li><li>ICAME CORPORA forum</li><li>Martin Krallinger etc on UK vs US English <a href="https://mailman.uib.no/public/corpora/2006-November/subject.html" target="_blank" rel="noopener">https://mailman.uib.no/public/corpora/2006-November/subject.html</a></li><li>Linguistic Data Consortium <a href="http://www.ldc.upenn.edu/" target="_blank" rel="noopener">http://www.ldc.upenn.edu/</a></li><li>ELRA <a href="http://www.elra.info/" target="_blank" rel="noopener">http://www.elra.info/</a></li><li>Leeds Internet Corpora <a href="http://corpus.leeds.ac.uk/internet.html" target="_blank" rel="noopener">http://corpus.leeds.ac.uk/internet.html</a></li><li>SketchEngine <a href="https://www.sketchengine.co.uk/" target="_blank" rel="noopener">https://www.sketchengine.co.uk/</a></li><li>Kaggle <a href="https://www.kaggle.com/datasets" target="_blank" rel="noopener">https://www.kaggle.com/datasets</a></li><li>KDnuggets <a href="http://www.kdnuggets.com/datasets/" target="_blank" rel="noopener">http://www.kdnuggets.com/datasets/</a></li><li>Data.gov.uk <a href="https://data.gov.uk/data/search" target="_blank" rel="noopener">https://data.gov.uk/data/search</a></li><li>UCI ML <a href="https://archive.ics.uci.edu/ml/datasets.html" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/datasets.html</a></li><li>国内各省开放数据汇总 <a href="http://www.tanmer.com/blog/451" target="_blank" rel="noopener">http://www.tanmer.com/blog/451</a></li></ul><h4 id="数据的一般结构"><a href="#数据的一般结构" class="headerlink" title="数据的一般结构"></a>数据的一般结构</h4><p>从顶层到底层分别是：</p><ol><li>业务规则</li><li>元数据</li><li>数据库schema</li><li>归纳数据</li><li>运营数据（事务数据）</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekan13qvdj30y40hwk04.jpg" alt="截屏2020-05-07 下午4.16.37"></p><h4 id="运营（事务）数据"><a href="#运营（事务）数据" class="headerlink" title="运营（事务）数据"></a>运营（事务）数据</h4><p>由运营的系统（产品）产生的大量事务，比如销售、购买、存款、取款、电话、道路收费、网页行为等。事务是数据的最基础级别，是理解用户行为的原材料。数据仓库策略需要注意，运营系统是可能改变的（比如由于业务需求改变，而采用新的格式），</p><h4 id="归纳数据"><a href="#归纳数据" class="headerlink" title="归纳数据"></a>归纳数据</h4><p>【归纳数据】是指对一定时间段的【运营（事务）数据】进行归纳，能够帮助进行业务决策</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekavi5fbyj30v609awge.jpg" alt="截屏2020-05-07 下午4.24.46" style="zoom: 50%;" /></p><p><strong>用于支持决策</strong></p><p>但通常用于审计的金融数据是源于数据库，而不是数据仓库。数据仓库的主要目标是存储历史记录，而不是当前的事务</p><h4 id="数据库架构-Schema"><a href="#数据库架构-Schema" class="headerlink" title="数据库架构 Schema"></a>数据库架构 Schema</h4><p>定义了数据的结构（不是数据的值）</p><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>元数据是关于数据本身的数据。比如，</p><ul><li>图书馆的卡片目录（元数据）描述了出版物（数据）</li><li>文件系统维护有关文件（数据）的权限（元数据）</li></ul><p>系统文档的元数据包括：</p><ul><li>字段的合法值</li><li>每个字段内容的描述，如开始日期</li><li>数据加载的日期</li><li>数据最后更新的时间</li><li>映射关系，如A.this = B.that</li></ul><p>这些元数据是无法估值的，如果缺少元数据，当我们需要的时候，需要花费大量的时间来调查这些数据。</p><h4 id="业务规则"><a href="#业务规则" class="headerlink" title="业务规则"></a>业务规则</h4><p>从运营（事务）数据中得到的最高级别的抽象，它描述了数据之间的关系以及如何应用数据，比如：</p><ul><li>credit需要3种ID</li><li>每日最多取款$200</li><li>3次登陆失败后，锁定登陆</li></ul><h4 id="OLAP-Online-Analytical-Processing-在线分析过程"><a href="#OLAP-Online-Analytical-Processing-在线分析过程" class="headerlink" title="OLAP Online Analytical Processing 在线分析过程"></a>OLAP Online Analytical Processing 在线分析过程</h4><p>OLAP描述了一类工具，这些工具能够从不同对的角度处提取和展示多维数据。便于可视化数据。它的分析功能超过了SQL。OLAP的关键特征是：相关的多维观点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekbugk0frj30kc0liae5.jpg" alt="截屏2020-05-07 下午4.58.21" style="zoom: 67%;" /></p><h4 id="数据仓库的一般结构"><a href="#数据仓库的一般结构" class="headerlink" title="数据仓库的一般结构"></a>数据仓库的一般结构</h4><ul><li>源系统</li><li>提取、清洗、事务、加载</li><li>中心的仓库</li><li>元数据仓库</li><li>数据市场</li><li>运营反馈</li><li>终端用户：分析、OLAP、数据挖掘</li></ul><h4 id="数据挖掘-VS-OLAP"><a href="#数据挖掘-VS-OLAP" class="headerlink" title="数据挖掘 VS OLAP"></a>数据挖掘 VS OLAP</h4><p>【数据挖掘】可以处理具有复杂数据属性的数据，以及处理聚合的数据，是一个更自动化的处理过程。</p><p>【在线分析过程OLAP（可视化）】受限于较少的维度和类型，是一个受用户控制的处理过程。</p><h4 id="数据挖掘-可视化"><a href="#数据挖掘-可视化" class="headerlink" title="数据挖掘+可视化"></a>数据挖掘+可视化</h4><p>【可视化】受限于少量的模式，由用户选择使用哪种模式</p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack：虚拟基础设施管理者</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/08%20OpenStack%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%AE%A1%E7%90%86%E8%80%85/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/08%20OpenStack%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%AE%A1%E7%90%86%E8%80%85/</url>
      
        <content type="html"><![CDATA[<p>OpenStack是为应用于各种项目而设计的，而项目的结构各有不同，因此OpenStack的结构也十分复杂</p><a id="more"></a><h4 id="OpenStack由7个核心组件构成"><a href="#OpenStack由7个核心组件构成" class="headerlink" title="OpenStack由7个核心组件构成"></a>OpenStack由7个核心组件构成</h4><ul><li>Compute(Nova)</li><li>Storage(Cinder)</li><li>Network(Neutron)</li><li>Dashboard(Horizon)</li><li>Image(Glance)</li><li>Identity(Keystone)</li><li>Object Storage(Swift)</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6qig0ykqj30so0kywjl.jpg" alt="截屏2020-05-27 上午2.08.14" style="zoom:50%;" /></p><h4 id="计算组件：提供功能齐全且可扩展的云计算平台"><a href="#计算组件：提供功能齐全且可扩展的云计算平台" class="headerlink" title="计算组件：提供功能齐全且可扩展的云计算平台"></a>计算组件：提供功能齐全且可扩展的云计算平台</h4><p>关键能力：</p><ul><li>管理虚拟的服务器资源：<u>CPU、内存、磁盘、网络</u>的接口</li><li>认证接口</li><li><p>分布式的和异步的架构：可大规模扩展，且高度可用的系统</p></li><li><p>用户实时迁移：在物理主机之间迁移正在运行的客户机</p></li><li>实时虚拟机管理：<u>运行、启动、挂起、修改大小、终止</u>实例</li><li>安全组</li><li>基于角色的访问控制：通过<u>用户、角色、项目</u>确保安全性</li><li>项目及限额</li></ul><h4 id="计算组件：基于队列和数据库的管理堆栈控制"><a href="#计算组件：基于队列和数据库的管理堆栈控制" class="headerlink" title="计算组件：基于队列和数据库的管理堆栈控制"></a>计算组件：基于队列和数据库的管理堆栈控制</h4><p>关键能力：</p><ul><li>消息队列：负责提供通信中心和管理数据持久化</li><li><p>基于AMQP的消息传递技术：</p><ul><li>默认的队列是RabbitMQ+MySQL数据库</li><li>一个cell（1个队列，一个数据库）通常可以扩展到500-1000个物理机器</li></ul></li><li><p>通过【队列】进行通信路由</p><ul><li>API请求经过验证并放在队列中</li><li>workers基于角色监听队列</li><li>响应通过队列往回分发</li></ul></li></ul><h4 id="消息队列模型"><a href="#消息队列模型" class="headerlink" title="消息队列模型"></a>消息队列模型</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6r9xoixwj30wu0ig40q.jpg" alt="截屏2020-05-27 上午2.34.37" style="zoom:50%;" /></p><p>消息队列的基本接口</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6rbzbpy1j310g0akwg5.jpg" alt="截屏2020-05-27 上午2.36.37" style="zoom: 50%;" /></p><h4 id="消息队列的通用结构"><a href="#消息队列的通用结构" class="headerlink" title="消息队列的通用结构"></a>消息队列的通用结构</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6rd1vk99j30ys0dowgp.jpg" alt="截屏2020-05-27 上午2.37.39" style="zoom:50%;" /></p><p>包含路由器的结构：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6rdiniftj30ok0jmtaj.jpg" alt="截屏2020-05-27 上午2.38.06" style="zoom:50%;" /></p><h4 id="高级消息队列协议-AMQP"><a href="#高级消息队列协议-AMQP" class="headerlink" title="高级消息队列协议 AMQP"></a>高级消息队列协议 AMQP</h4><p>【Advanced Message Queueing Protocol】</p><p>AMQP提供了一种与平台无关的方法，可确保在<u>应用程序之间，组织之间，移动基础架构内，以及整个云之间</u>安全地传输信息</p><ul><li>AMQP被应用于不同的领域：金融前台交易，运输，智能电网，计算机生成的动画，在线游戏等</li><li>许多操作系统都包含AMQP实现</li><li>有云托管的AMQP产品，并已嵌入虚拟化基础架构中</li></ul><p>AMQP的实现产品：</p><ul><li><a href="https://www.rabbitmq.com" target="_blank" rel="noopener">RabbitMQ</a></li><li><a href="https://qpid.apache.org/" target="_blank" rel="noopener">Qpid</a></li><li><a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ</a> </li></ul><h4 id="Nova-compute：管理独立的虚拟机监控程序和计算节点"><a href="#Nova-compute：管理独立的虚拟机监控程序和计算节点" class="headerlink" title="Nova-compute：管理独立的虚拟机监控程序和计算节点"></a>Nova-compute：管理独立的虚拟机监控程序和计算节点</h4><blockquote><p>Nova is the OpenStack project that provides a way to provision compute instances (aka virtual servers)</p></blockquote><p>关键能力：</p><p>负责管理与提供计算资源的各个端点的所有交互，例如</p><ul><li>将数据存储卷附加到物理主机，作为附加的硬盘驱动器映射到GuestOS<ul><li>直接针对本地hypervisor接口的实现<ul><li>更好的利用【hypervisor differentiators区分符】</li></ul></li></ul></li><li>服务的实例在每个物理计算节点上运行，有助于最大程度地减少故障域</li><li>支持定义防火墙规则的安全组</li><li>支持 KVM, VMware ESX/ESXi (4.1 update 1), Xen (XenServer 5.5, Xen Cloud Platform), Hyper V</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6s4j9m1kj30gw0fotem.jpg" alt="截屏2020-05-27 上午3.04.00" style="zoom:50%;" /></p><h4 id="Nova-scheduler：分配虚拟资源到物理硬件上"><a href="#Nova-scheduler：分配虚拟资源到物理硬件上" class="headerlink" title="Nova-scheduler：分配虚拟资源到物理硬件上"></a>Nova-scheduler：分配虚拟资源到物理硬件上</h4><p>关键能力：</p><ul><li>确定要分配给虚拟资源的物理硬件</li><li>【默认调度器】使用一系列过滤器来减少可分配的主机（为了降低欠载），并使用【成本核算功能】来提供权重（考虑能耗、存储等参数）</li></ul><p>非重点能力</p><ul><li>默认实现是【finds first fit】</li><li>工作负载寿命较短，对放置决策的要求不那么严格</li><li>如果默认设置不起作用，则部署人员通常有特定要求并制定自定义</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6sl84g1kj30h00fo44f.jpg" alt="截屏2020-05-27 上午3.20.05" style="zoom:50%;" /></p><h4 id="Nova-api：支持多种API实现，并且是云的入口点"><a href="#Nova-api：支持多种API实现，并且是云的入口点" class="headerlink" title="Nova-api：支持多种API实现，并且是云的入口点"></a>Nova-api：支持多种API实现，并且是云的入口点</h4><p>关键能力：</p><ul><li>接口支持：<ul><li>Openstack 计算组件接口（基于REST）</li><li>EC2接口</li><li>Admin接口 （nova-manage）</li></ul></li><li>健壮的扩展机制来进行新功能的添加</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6sl32rdcj30gu0fuwke.jpg" alt="截屏2020-05-27 上午3.19.53" style="zoom:50%;" /></p><h4 id="Neutron-网络组件：自动管理网络和附件（网络连接即服务）"><a href="#Neutron-网络组件：自动管理网络和附件（网络连接即服务）" class="headerlink" title="Neutron 网络组件：自动管理网络和附件（网络连接即服务）"></a>Neutron 网络组件：自动管理网络和附件（网络连接即服务）</h4><blockquote><p>Neutron在以前的版本称为Quantum</p></blockquote><p>关键能力：</p><ul><li>负责管理虚拟资源基础结构上的网络，端口和附件</li><li>创建/删除<u>租户指定</u>的L2网络</li><li><p>L3 support（【浮动Floating IPs】，DHCP，路由）</p><ul><li>Floating IP：当VM从物理机1迁移到物理机2上时，VM的IP地址需要保持不变</li></ul></li><li><p>将主机与网络连接/分离</p></li><li>类似于动态VLAN支持</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6slzspioj30g60ge788.jpg" alt="截屏2020-05-27 上午3.20.51" style="zoom:50%;" /></p><h4 id="Cinder：管理基于块的存储，启用持久存储"><a href="#Cinder：管理基于块的存储，启用持久存储" class="headerlink" title="Cinder：管理基于块的存储，启用持久存储"></a>Cinder：管理基于块的存储，启用持久存储</h4><p>关键能力：</p><ul><li>负责管理卷的生命周期，并开放以支持附加</li><li><p>与【Nova】的结构相同，因此在API服务器、调度器上，与Nove有一样的特点和结构</p></li><li><p>启用额外的持久化【块式存储】到虚拟机</p></li><li>支持从【nova-volume】备份存储中启动虚拟机</li><li>允许每个虚拟机附加多个卷</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6sujdysnj30do0fm0va.jpg" alt="截屏2020-05-27 上午3.29.03" style="zoom:50%;" /></p><h4 id="Keystone：为整合现有系统而设计的【身份服务】，旨在提供统一的、项目范围内的身份，令牌，服务目录和策略服务"><a href="#Keystone：为整合现有系统而设计的【身份服务】，旨在提供统一的、项目范围内的身份，令牌，服务目录和策略服务" class="headerlink" title="Keystone：为整合现有系统而设计的【身份服务】，旨在提供统一的、项目范围内的身份，令牌，服务目录和策略服务"></a>Keystone：为整合现有系统而设计的【身份服务】，旨在提供统一的、项目范围内的身份，令牌，服务目录和策略服务</h4><p>关键能力：</p><ul><li><p>身份服务，提供<u>身份凭证</u>的验证以及<u>有关用户和角色的数据</u>的验证</p></li><li><p>令牌服务，验证和管理令牌，用于在<u>初始凭证验证</u>后<u>验证请求</u></p></li><li><p>策略服务，提供了基于规则的验证引擎，和相关的规则管理接口。</p></li><li>经过配置，每个【服务】都能为数据提供服务</li><li>基于REST的接口</li><li>一次只有一个服务能与一个特定的令牌交互</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6tac1jt9j30hq076tau.jpg" alt="截屏2020-05-27 上午3.44.13" style="zoom:50%;" /></p><h4 id="Glance：镜像服务，为虚拟磁盘映像提供基本的发现，注册和交付服务"><a href="#Glance：镜像服务，为虚拟磁盘映像提供基本的发现，注册和交付服务" class="headerlink" title="Glance：镜像服务，为虚拟磁盘映像提供基本的发现，注册和交付服务"></a>Glance：镜像服务，为虚拟磁盘映像提供基本的发现，注册和交付服务</h4><p>关键能力</p><ul><li>映像注册表，而不是映像仓库</li><li>基于REST的接口</li><li>在公有和私有磁盘镜像中查询信息</li><li>注册新的磁盘镜像</li><li>磁盘镜像可以在各种存储中进行存取</li><li>支持的格式<ul><li>Raw，VHD (Hyper-V)（Virtual Hard Disk），VDI (VirtualBox) （Virtual DIsk Image），qcow2 (Qemu/KVM)， VMDK (VMWare) （Virtual Machine Disk），OVF (VMWare, others)（Open Virtualization format）等</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6tc233cej305w0aq75d.jpg" alt="截屏2020-05-27 上午3.45.40" style="zoom: 67%;" /></p><h4 id="Horizon：Dashboard，使管理员和用户可以通过自助门户访问和提供基于云的资源"><a href="#Horizon：Dashboard，使管理员和用户可以通过自助门户访问和提供基于云的资源" class="headerlink" title="Horizon：Dashboard，使管理员和用户可以通过自助门户访问和提供基于云的资源"></a>Horizon：Dashboard，使管理员和用户可以通过自助门户访问和提供基于云的资源</h4><p>关键能力：</p><ul><li>注册模式，让应用程序可以挂载</li><li>随附三个中央仪表板：“用户”，“系统”和“设置”</li><li>对所有核心的OpenStack项目的开箱即用支持<ul><li>Nova, Glace, Swift, Quantum</li></ul></li><li>任何人都可以将新组件添加为“头等公民”<ul><li>遵循设计和样式指导</li></ul></li><li>视觉和交互范式始终保持不变</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6tjqjcb3j30fk0aignp.jpg" alt="截屏2020-05-27 上午3.53.18" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云(1)</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/08%20CLOUD%20%E2%80%93%20PART%201/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/08%20CLOUD%20%E2%80%93%20PART%201/</url>
      
        <content type="html"><![CDATA[<p>实用计算：使<u>计算资源</u>像水电这样按表计量的服务一样按需使用；按需动态提供资源的能力</p><p>云计算：是一种模型，用于支持对可配置计算资源（例如，网络，服务器，存储，应用程序和服务）共享池的普遍，方便，按需的网络访问，这些资源可通过最少的管理工作或与服务提供商的交互，快速地进行配置和发布。（美国国家标准技术研究院（NIST））</p><a id="more"></a><h4 id="数据的类型"><a href="#数据的类型" class="headerlink" title="数据的类型"></a>数据的类型</h4><p>关系型数据（表、事务）、文本数据、半结构化数据（XML）、图类数据（社交网络）、流数据（只能被扫描一次）</p><h4 id="数据与生俱来的特点"><a href="#数据与生俱来的特点" class="headerlink" title="数据与生俱来的特点"></a>数据与生俱来的特点</h4><p>复杂、大量、半结构化</p><h4 id="大数据与云计算的关联"><a href="#大数据与云计算的关联" class="headerlink" title="大数据与云计算的关联"></a>大数据与云计算的关联</h4><ol><li>数据可视化</li><li>实时数据流、实时处理</li><li>实时的结构化数据库、交互式分析、批量处理</li><li>结构化和非结构化数据（HDFS、S3）</li><li>云基础设施</li><li>存储、网络、计算资源</li></ol><h4 id="例子：百事可乐和阿里巴巴"><a href="#例子：百事可乐和阿里巴巴" class="headerlink" title="例子：百事可乐和阿里巴巴"></a>例子：百事可乐和阿里巴巴</h4><p>百事可乐公司与阿里巴巴达成战略协议，以利用后者的数据来增强其客户体验并推动其在中国的发展。这是阿里巴巴达成的第二笔此类交易，允许公司利用其数据和见解为客户提供更好的服务。阿里巴巴是中国最大的电子商务平台。公司可以使用这些数据更好地了解消费者的偏好，并相应地修改其产品。 除了为外国企业提供进入中国市场的电子商务平台外，阿里巴巴现在还希望成为数据和见解提供。通过利用阿里巴巴客户数据产生的见解，百事可乐可以从事产品开发、创新和品牌建设，从而带动中国的增长。 据阿里巴巴称，此次合作“引领了中国食品饮料行业不断发展的数字化转型”（2017.05.16 Forbe）</p><h4 id="实用计算-Utility-Computing"><a href="#实用计算-Utility-Computing" class="headerlink" title="实用计算 Utility Computing"></a>实用计算 Utility Computing</h4><p>“到目前为止，计算机网络仍处于起步阶段，但是随着它们的成长和日趋成熟，我们可能会看到<u>计算机设施 computer utilities</u>的普及，像现在的电力和电话这类实用设施一样，它将为整个国家的家庭和办公室提供服务”（1969 – Leonard Kleinrock, ARPANET project）</p><p>什么是实用计算：使<u>计算资源</u>像水电这样按表计量的服务一样按需使用；按需动态提供资源的能力</p><p>为什么：成本（购买设备 VS 操作付费），可扩展性，弹性（按需扩展或收缩）</p><h4 id="云计算的定义"><a href="#云计算的定义" class="headerlink" title="云计算的定义"></a>云计算的定义</h4><p>个人设备可以通过网络获得各种各样的计算服务（不需要安装在本地）</p><p>云计算是一种模型，用于支持对可配置计算资源（例如，网络，服务器，存储，应用程序和服务）共享池的普遍，方便，按需的网络访问，这些资源可通过最少的管理工作或与服务提供商的交互，快速地进行配置和发布。（美国国家标准技术研究院（NIST））</p><p>主要特征： 1. 按需的自助服务 2. 广泛的网络访问 3. 资源池 4. 快速的弹性变化或扩展 5. 测量服务</p><p>三种服务模型：1. 软件 2. 平台 3. 基础设施</p><p>四种部署模型：1. 私有 2. 社区 3. 公开 4. 混合</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>成本和管理（经济的扩展方式，将资源管理外包）</li><li>减少部署时间（大部分工作由服务提供商完成）</li><li>可扩展性（按需使用，按需付费）</li><li>可靠性（大量的、冗余的、共享的资源）</li><li>可持续性（不需要自己购买设备）</li></ul><h4 id="虚拟化的基础设施"><a href="#虚拟化的基础设施" class="headerlink" title="虚拟化的基础设施"></a>虚拟化的基础设施</h4><p>整合服务器系统、降低成本、降低复杂性、简化管理、按使用付费</p><p>是一个新兴的计算范例，数据和服务位于大规模的数据中心，并且可以被任何联网设备访问</p><h4 id="云"><a href="#云" class="headerlink" title="云"></a>云</h4><p>当今互联网应用的历史根源：搜索、Email、社交网络、文件存储（Dropbox等）</p><p>Cloud infrastructure提供了一个框架，管理对应用程序的可扩展的、可靠的、按需的访问</p><p>对于终端的移动应用来说，云是不可见的</p><h4 id="云数据中心"><a href="#云数据中心" class="headerlink" title="云数据中心"></a>云数据中心</h4><p>10-100k的主机，通常紧密靠近以及紧密耦合。比如亚马逊的电商，YouTube、Apple、微软的内容服务器，Google的搜索引擎、数据挖掘</p><p>挑战：多应用，每个应用都要服务于大量的客户端；管理/负载平衡、处理、网络、数据管理（动态负载平衡）</p><h4 id="云结构的分层"><a href="#云结构的分层" class="headerlink" title="云结构的分层"></a>云结构的分层</h4><div class="table-container"><table><thead><tr><th>用户层、服务层、虚拟化层、物理层</th><th>用户级、用户级的中间件、核心中间件、系统级</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3eoih37ij312a0k87a2.jpg" alt="截屏2020-03-22下午9.21.28" style="zoom:33%;" /></td><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3enjxli1j31160nan5m.jpg" alt="截屏2020-03-22下午9.20.34" style="zoom: 33%;" /></td></tr></tbody></table></div><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>cloud infrastructure —— 云基础设施</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云(2)</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/09%20CLOUD%20PART%202/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/09%20CLOUD%20PART%202/</url>
      
        <content type="html"><![CDATA[<p>云数据中心——物理层（系统级）：存储、网络</p><p>虚拟机——虚拟化层（核心中间件）：Hypervisor、Infrastructure</p><p>编程模型 —— 结构层（用户级中间件）：MapReduce、Hadoop</p><a id="more"></a><h3 id="云计算的好处"><a href="#云计算的好处" class="headerlink" title="云计算的好处"></a>云计算的好处</h3><ol><li>用户似乎可以按需使用无限的计算资源，从而消除了云用户为资源调配而提前计划的需求</li><li>消除了云用户的前期投入，公司可以从小做起，并在将来需要时再增加硬件资源。</li><li>根据需要，在短期内购买计算资源，并在完成后释放它们，从而可以节约资源和成本（例如，按小时计算的处理器和按天存储的处理器，在服务使用的高峰期扩展服务器）。</li></ol><h3 id="云的三种服务模型"><a href="#云的三种服务模型" class="headerlink" title="云的三种服务模型"></a>云的三种服务模型</h3><p>服务可以在三层中的任何一层公开，较低的层对用户是透明的</p><ol><li>SaaS 软件即服务：是本地运行程序的代替方案，即远程运行程序。如Google Apps</li><li>PaaS 平台即服务：也是本地运行程序的代替方案。通过软件堆栈促进应用程序的部署。如微软Azure</li><li>IaaS 基础设施即服务：通过虚拟化，基础设施提供商可以拆分、分配和动态管理服务提供商，服务提供商将在这些系统上部署运行其服务的软件堆栈。 Amazon EC2</li></ol><div class="table-container"><table><thead><tr><th>服务模型</th><th>服务模型与典型软件结构</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3fespzsmj30gm0eedgi.jpg" alt="截屏2020-03-22下午9.46.47" style="zoom:33%;" /></td><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3gursrjoj30mq0k47ax.jpg" alt="截屏2020-03-22下午10.36.43" style="zoom:50%;" /></td></tr></tbody></table></div><h4 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h4><ul><li>通过互联网构建</li><li>任何为该服务付费的用户都可以访问</li><li>由服务提供商拥有</li><li>可通过订阅访问</li></ul><h4 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h4><ul><li>在单个组织拥有的Intranet域内构建</li><li>客户拥有和管理</li><li>访问仅限于拥有客户及其合作伙伴</li><li>可能影响云标准化，同时保留更大的自定义和组织控制权。</li></ul><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><ul><li>多个云协同工作，包括公共云和私有云</li><li>混合云可以由<u>联合的云提供商</u>交付，该供应商将其自身的资源与其他提供商的资源相结合</li></ul><h2 id="云数据中心——物理层（系统级）"><a href="#云数据中心——物理层（系统级）" class="headerlink" title="云数据中心——物理层（系统级）"></a>云数据中心——物理层（系统级）</h2><p>大规模：10万-100万的服务器，大约是足球场的11.5倍</p><p>小服务器集群：大约1000台服务器，通过 Ethernet switch 以太网交换机相连，放置在仓库或容器环境中</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>存储选项：</p><ul><li>使用服务器内部的磁盘，或通过无限带宽的网络附加存储（NAS）</li><li>WSCs 通常依赖于本地磁盘</li><li>Google文件系统（GFS）使用本地磁盘，并至少维护三个副本</li></ul><p>连接多个机架的交换机</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>包含：边界路由器，访问路由器、负载均衡器、一层交换机、二层交换机、架顶交换机、服务器机架</p><p>负载均衡器：应用层路由</p><ul><li>接收外部客户请求</li><li>在数据中心内分配工作负载</li><li>将结果返回给外部客户端（隐藏数据中心的内部细节）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3fssnn4hj30ya0m444x.jpg" alt="截屏2020-03-22下午10.00.01" style="zoom:50%;" /></p><h2 id="虚拟机——虚拟化层（核心中间件）"><a href="#虚拟机——虚拟化层（核心中间件）" class="headerlink" title="虚拟机——虚拟化层（核心中间件）"></a>虚拟机——虚拟化层（核心中间件）</h2><p>虚拟化层相当于底层硬件和虚拟机的中间件</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3gdgnmdpj31100hqq9d.jpg" alt="截屏2020-03-22下午10.20.05" style="zoom: 40%;" /></p><h4 id="虚拟化的定义"><a href="#虚拟化的定义" class="headerlink" title="虚拟化的定义"></a>虚拟化的定义</h4><ul><li><p>不同的虚拟机（VM）可以在同一台物理计算机上运行不同的操作系统（OS）和多个应用程序。</p></li><li><p>支持虚拟化的主要技术是虚拟机监控程序Hypervisor</p><ul><li>VMM通过仿真或硬件辅助虚拟化，以透明的方式对物理主机进行划分</li><li>提供了完整的硬件环境模拟</li></ul><blockquote><p>虚拟机：真实机器通过软件，提供操作环境，运行 Guest OS</p><p>Guest OS：运行在虚拟机环境中的，或直接运行在物理机器上的（不同于Host OS），操作系统</p></blockquote></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>更好的利用资源；最大化硬件利用，降低硬件成本；改进容错；扩容；能耗</p></li><li><p>自由选择操作系统（即测试环境）</p></li><li>整合服务器和基础架构</li><li>节省时间和金钱</li><li>使管理和保护桌面环境更加容易</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>GuestOS对硬件的要求更高（主机需要更多的内存，磁盘空间等）</li><li>可能需要培训才能操作</li></ul><h3 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h3><p>VMware、ESXi（原Elastic Sky X）、Xen、KVM</p><h4 id="VMware-ESX-Server-——-Type-1-Hypervisor（裸机）"><a href="#VMware-ESX-Server-——-Type-1-Hypervisor（裸机）" class="headerlink" title="VMware ESX Server —— Type-1 Hypervisor（裸机）"></a>VMware ESX Server —— Type-1 Hypervisor（裸机）</h4><ul><li>企业数据中心的商用VMM</li><li>支持<u>全虚拟化</u>和<u>混合虚拟化技术</u></li><li>基于x86和x86-64结构的Linux和Widows的变体</li><li>GuestOS最高支持：32个虚拟CPU和1TB内存</li><li>每个主机最高支持：160个CPU，2TB内存，512个虚拟机</li><li>其他商业版：VMware Workstation and Server 是 Type-2 Hypervisor（有HostOS）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2g2esvvdj30l20d678f.jpg" alt="截屏2020-03-22上午1.23.51" style="zoom:50%;" /></p><h4 id="XEN-——-Type-1-Hypervisor（裸机）"><a href="#XEN-——-Type-1-Hypervisor（裸机）" class="headerlink" title="XEN —— Type-1 Hypervisor（裸机）"></a>XEN —— Type-1 Hypervisor（裸机）</h4><ul><li>例子：剑桥大学、Citrix System思杰系统</li><li>微核、</li><li>Domain 0（特权Guest）负责控制和I/O、其他Domain负责用户的程序</li><li>轻量（&lt;150k 代码行），高可扩展性，大于255个物理CPU</li><li>可以分配最高128个虚拟CPU和1TB内存给虚拟机</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2ftu1du4j30ya0d6tcl.jpg" alt="截屏2020-03-22上午1.15.39" style="zoom:50%;" /></p><h4 id="KVM-——-Type-2-Hypervisor（HostOS）"><a href="#KVM-——-Type-2-Hypervisor（HostOS）" class="headerlink" title="KVM —— Type 2 Hypervisor（HostOS）"></a>KVM —— Type 2 Hypervisor（HostOS）</h4><ul><li>由 Red Hat 支持</li><li>支持硬件辅助虚拟化、混合虚拟化</li><li>主要是X86和X86-64</li><li>移植到PowerPC和IA-64（Itanium）</li><li>通过kernel模块，将Linux内核转化为Hypervisor</li><li>通过QEMU进行设备模拟</li><li>支持多种GuestOS</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2gdbcx79j30iy0h8dpv.jpg" alt="截屏2020-03-22上午1.34.22" style="zoom:50%;" /></p><h3 id="云的结构"><a href="#云的结构" class="headerlink" title="云的结构"></a>云的结构</h3><ol><li>Hypervisor 虚拟机监控程序：创建、执行、管理同一台物理机上的多个虚拟机</li><li>虚拟基础设施管理者: 将虚拟机组织到分区组中</li><li>虚拟机群集：一组具有嵌入式软件的虚拟机，充当正在运行的应用程序的中间件</li><li>分布式应用程序：旨在在多台计算机上运行以执行特定任务的软件</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3gursrjoj30mq0k47ax.jpg" alt="截屏2020-03-22下午10.36.43" style="zoom:50%;" /></p><h4 id="云基础设施管理者-——-OpenNebula"><a href="#云基础设施管理者-——-OpenNebula" class="headerlink" title="云基础设施管理者 —— OpenNebula"></a>云基础设施管理者 —— OpenNebula</h4><p>代表终端用户，用于提供虚拟资源；具有庞大的用户群，和各种Linux发行版</p><p>功能：</p><ul><li>通过云插件支持多站点资源池</li><li>与Hypervisor无关</li><li>广泛采用云接口</li><li>简单的用户管理</li></ul><h4 id="云基础设施管理者-——-OpenStack"><a href="#云基础设施管理者-——-OpenStack" class="headerlink" title="云基础设施管理者 —— OpenStack"></a>云基础设施管理者 —— OpenStack</h4><p>用于生产出无处不在的开源云计算平台，无论规模大小，它都能满足公共云和私有云的需求，易于实现和可大规模扩展。（目标是称为云中的Linux）</p><p>功能：</p><ul><li>管理层增加了自动化和控制</li><li>有效分配资源</li><li>通过服务门户授权管理员和用户</li><li>开发人员能够通过API，能够使应用程序具有云感知能力</li><li>启用云联合</li></ul><h2 id="编程模型-——-结构层（用户级中间件）"><a href="#编程模型-——-结构层（用户级中间件）" class="headerlink" title="编程模型 —— 结构层（用户级中间件）"></a>编程模型 —— 结构层（用户级中间件）</h2><p>包括各种框架，允许对云中以及存在的服务和应用，进行编程和执行，包含一些分类：</p><ol><li>用于开发应用程序的新API：Microsoft Azure, Google App Engine</li><li>高性能计算：Message Passing Interface (MPI)</li><li>非通用目的编程模型：MapReduce、Aneka（用于在云上开发分布式应用的平台和框架）</li></ol><h4 id="MapReduce：可在大规模集群上扩展的数据处理模型"><a href="#MapReduce：可在大规模集群上扩展的数据处理模型" class="headerlink" title="MapReduce：可在大规模集群上扩展的数据处理模型"></a>MapReduce：可在大规模集群上扩展的数据处理模型</h4><ul><li>用于快速粗粒大数据集的编程模型</li><li>用于网络规模的搜索和云计算应用</li><li>用户编写map函数，生成键值对</li><li>用户编写的reduce函数，将键值对按照key合并</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3hllltgqj311y0e6ab7.jpg" alt="截屏2020-03-22下午11.02.22" style="zoom:50%;" /></p><h4 id="Hadoop：遵循MapReduce模型的分布式平台"><a href="#Hadoop：遵循MapReduce模型的分布式平台" class="headerlink" title="Hadoop：遵循MapReduce模型的分布式平台"></a>Hadoop：遵循MapReduce模型的分布式平台</h4><p>通过Hadoop，用户编写和执行程序，处理大规模的分布式数据</p><p>特点</p><ul><li>可扩展：扩展以存储和处理Web空间中的PB级数据</li><li>经济的：开源MapReduce最大限度地减少了任务生成和海量数据通信中的开销。</li><li>高效的：在大量的节点上以高度并行性处理数据</li><li>可轻松：自动维护数据的多个备份，以便于故障时重新部署计算任务</li></ul><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><blockquote><p>Hypervisor —— Virtual Machine Manager (VMM)  —— 虚拟机监控程序</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> Hypervisor </tag>
            
            <tag> 云计算的三种服务模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本分类</title>
      <link href="/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/04%20%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
      <url>/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/04%20%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>【出现在相似语境中的<u>单词</u>倾向于有相似的含义】，我们称之为【分布假设 distributional hypothesis】，这个概念能被追溯到1950年。</p><p>相关背景可查看<a href="https://web.stanford.edu/~jurafsky/slp3/" target="_blank" rel="noopener">《Speech and Language Processing》——Dan Jurafsky and James H Martin</a>，第6章。</p><a id="more"></a><h4 id="向量语义学"><a href="#向量语义学" class="headerlink" title="向量语义学"></a>向量语义学</h4><p>将单词的含义以向量的方式展示：相似语境下的单词，将会以相似的向量展示出来。因此单词的含义被嵌入在向量空间中</p><h4 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h4><p>在【word2vec skip-gram】方案中，输入和输出的大小是一致的，但隐藏层却小得多。通过训练，网络学习如何将输入嵌入到更低维度的空间中。在嵌入空间中，相似的实例彼此更加接近。</p><p><a href="https://zhuanlan.zhihu.com/p/26306795" target="_blank" rel="noopener">word2vec详细介绍（穆文）</a>；<a href="https://projector.tensorflow.org/" target="_blank" rel="noopener">可视化词嵌入空间</a>；<a href="https://github.com/liaoooyx/Artificial-Intelligence-practices/blob/master/word2vec-example/Word2Vec_embeddings.ipynb" target="_blank" rel="noopener">示例代码</a></p><p>word2vec的目的是训练出模型f，使得f(x)-&gt;y，这里的x和y是在一个上下文中紧挨着的词。更通俗点说就是：词语x和词语y放在一起，是不是人话（穆文，2019）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gezia04wedj30tu08wjsl.jpg" alt="截屏2020-05-20 下午8.04.22" style="zoom:50%;" /></p><p>其中输入是【目标词的独热向量】；输出是【语境词的独热向量】（语境词指的是目标附近的词，可以通过skip-gram建立）。我们的目标是对每个词，都找到一个全连接层的权重，使得<u>输入</u>和<u>输入</u>能够映射，而这个权重就是我们所需要的【词嵌入向量】。</p><h5 id="skip-gram"><a href="#skip-gram" class="headerlink" title="skip-gram"></a>skip-gram</h5><p>以5-gram为例：生成(target word, context word)格式的训练数据</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gezhgjtt6lj30zy0m244c.jpg" alt="截屏2020-05-20 下午7.36.01" style="zoom:50%;" /></p><blockquote><ul><li>如果是用一个词语作为输入，来预测它周围的上下文，那这个模型叫做『Skip-gram 模型』</li><li>而如果是拿一个词语的上下文作为输入，来预测这个词语本身，则是 『CBOW 模型』</li></ul></blockquote><h3 id="VDCNN——用于文本分类"><a href="#VDCNN——用于文本分类" class="headerlink" title="VDCNN——用于文本分类"></a>VDCNN——用于文本分类</h3><p>论文：Conneau, Alexis, Holger Schwenk, Loïc Barrault, and Yann Lecun. 2017. “Very Deep Convolutional Networks for Text Classification.” In Proceedings of the 15th Conference of the European Chapter of the Association for Computational Linguistics: Volume 1, Long Papers, 1107–1116. Valencia, Spain: Association for Computational Linguistics. <a href="https://www.aclweb.org/anthology/E17-1104" target="_blank" rel="noopener">https://www.aclweb.org/anthology/E17-1104</a>.</p><h4 id="数据集来源"><a href="#数据集来源" class="headerlink" title="数据集来源"></a>数据集来源</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gezois9ffjj30yk0moq6c.jpg" alt="截屏2020-05-20 下午11.40.24"></p><h4 id="字符嵌入-character-embedding"><a href="#字符嵌入-character-embedding" class="headerlink" title="字符嵌入 character embedding"></a>字符嵌入 character embedding</h4><p>论文中，将69个字符【abcdefghijklmnopqrstuvwxyz0123456789-,;.!?:’”/| #$%ˆ&amp;* ̃‘+=&lt;&gt;()[]{}】映射到16维的向量中，于是有69个16维向量。</p><p>目的是用这16维【字符嵌入向量】表示句子。（s表示以字符进行分割的句子）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gezpi53ra7j312g0aoaas.jpg" alt="截屏2020-05-21 上午12.14.23"></p><h4 id="VDCNN网络的结构"><a href="#VDCNN网络的结构" class="headerlink" title="VDCNN网络的结构"></a>VDCNN网络的结构</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gezpwn00xtj30dc0t478i.jpg" alt="截屏2020-05-21 上午12.28.19" style="zoom: 67%;" /></p><p>从最底部开始，输入是s个字符的字符串，然后得到16*s的输出【这一步为词嵌入】。</p><p>将16*s的向量，经过TCN卷积（卷积核为3，每个【16-D字符嵌入向量】得到一个【64-D的特征】），输出大小为64*s</p><p>注意，从最底部开始，使用的是1-D卷积，因为是一维的字符串而不是二维的图像。卷积核的大小是3，而不是3*3。</p><p>其中每个卷积块的结构为：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gezq2rr4h3j30i00cgq47.jpg" alt="截屏2020-05-21 上午12.34.13" style="zoom: 67%;" /></p><h4 id="Temporal-Convolutional-Network-TCN"><a href="#Temporal-Convolutional-Network-TCN" class="headerlink" title="Temporal Convolutional Network (TCN)"></a>Temporal Convolutional Network (TCN)</h4><blockquote><p><a href="https://www.jianshu.com/p/4280f104ddf7" target="_blank" rel="noopener">参考文章</a></p><p>百度关键词：TCN</p></blockquote><h4 id="一维卷积"><a href="#一维卷积" class="headerlink" title="一维卷积"></a>一维卷积</h4><p><a href="https://www.cnblogs.com/szxspark/p/8445406.html" target="_blank" rel="noopener">详细解释</a></p><p>当s=8时，表示8个字符组成，于是输入为表示长度为8的一维数组。（类比二维卷积中的黑白图像）</p><p>卷积核为3（类比二维卷积中的3*3卷积核）</p><p>卷积后得到的特征大小为8-3+1=6（类比二维卷积中的对应计算）。</p><p>此时再引入channel的概念，这里channel=16，即【字符嵌入向量】的长度（类比二维卷积中的RGB通道），于是对于一个s，有16个大小为3的卷积核。将16个卷积核的输出相加，最终还是得到一个大小为6的特征（同样类比二维卷积中RBG通道卷积后相加）。</p><h4 id="K-max-pooling"><a href="#K-max-pooling" class="headerlink" title="K-max pooling"></a>K-max pooling</h4><p>（LeCun et al., 1998）选择序列p中，最大的k个值，以p中出现的顺序进行排序。注意着会丢失q中的元素在对应的p中的绝对位置</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gezqmihspyj30k207q3yy.jpg" alt="截屏2020-05-21 上午12.53.10" style="zoom:50%;" /></p><h4 id="批度归一化-Batch-normalisation"><a href="#批度归一化-Batch-normalisation" class="headerlink" title="批度归一化 Batch normalisation"></a>批度归一化 Batch normalisation</h4><p>通过减去均值并除以标准偏差来进行归一化。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> word2vec </tag>
            
            <tag> skip-gram </tag>
            
            <tag> VDCNN </tag>
            
            <tag> TCN </tag>
            
            <tag> 一维卷积 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>混淆矩阵中的精确率和召回率 Precision and Recall</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/10%20%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%B2%BE%E7%A1%AE%E7%8E%87%E5%92%8C%E5%8F%AC%E5%9B%9E%E7%8E%87/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/10%20%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%B2%BE%E7%A1%AE%E7%8E%87%E5%92%8C%E5%8F%AC%E5%9B%9E%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<h4 id="Precision"><a href="#Precision" class="headerlink" title="Precision"></a>Precision</h4><p>所有预测为正的值中，有多少是正确的</p><p>$\frac{正确预测的正值TP}{所有预测为正的值TP+FP}$</p><h4 id="Recall"><a href="#Recall" class="headerlink" title="Recall"></a>Recall</h4><p>所有正值中，有多少被正确预测</p><p>$\frac{正确预测的正值TP}{所有正值TP+FN}$</p><a id="more"></a><p>圆圈内是预测值，圆圈外是实际值，绿色是正值，红色是负值</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gek4thn8ulj30960got98.jpg" alt="File:Precisionrecall.svg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gek5n11mhfj31ly0n2wp7.jpg" alt="截屏2020-05-07 下午1.23.36"></p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混淆矩阵 </tag>
            
            <tag> Precision </tag>
            
            <tag> Recall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词汇语义学：词义消歧</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/17%20%E5%8D%95%E8%AF%8D%E7%9A%84%E5%90%AB%E4%B9%89/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/17%20%E5%8D%95%E8%AF%8D%E7%9A%84%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>人类可以完成词义消歧的工作，但是难以自动化</p><p>词典编撰者Lexicographers 使用 词语索引concordance（比如通过SketchEngine）来可视化 单词含义word senses</p><p>部分词性标记PoS-tagging 能在一定程度上消除歧义（bank a plane VS. the river bank）</p><p>监督学习：基于含义标记语料库 sense-tagged corpus，单词搭配模式collocation patterns</p><p>非、半监督学习：无标签语料库no tagged corpus，Lesk算法</p><a id="more"></a><h4 id="语义标签"><a href="#语义标签" class="headerlink" title="语义标签"></a>语义标签</h4><p>对于一个特定的领域，一个本体论ontology能够为单词提供标签，比如SNOMED-tagger作为标准医学标签。</p><p>朗文当代英语词典LDOCE 使用朗文定义词典LDV1000。也就是说，任何一个单词都能够由这1000个单词定义。如，WordToLDOCEvector将任意一个单词匹配为一个1000维向量。</p><h4 id="词义消歧-Word-Sense-Disambiguation-WSD"><a href="#词义消歧-Word-Sense-Disambiguation-WSD" class="headerlink" title="词义消歧 Word Sense Disambiguation (WSD)"></a>词义消歧 Word Sense Disambiguation (WSD)</h4><p>给定语境中的一个单词，以及由潜在词义组成的固定列表。</p><p>目标是决定一个单词的意思是什么。比如：</p><ul><li>英文到中文的翻译</li><li>语音合成和识别。比如确定具有不同发音的同形异义词，比如 bass 贝斯/鲈鱼</li><li>混淆集的歧义消除。比如to two too<ul><li>参考文献 Michelle Banko and Eric Brill 2001 “Scaling to very very large corpora for natural language disambiguation”</li></ul></li></ul><h4 id="SketchEngine"><a href="#SketchEngine" class="headerlink" title="SketchEngine"></a>SketchEngine</h4><blockquote><p>Sketch Engine是Lexical Computing Limited自2003年以来开发的语料库管理器和文本分析软件。其目的是使学习语言行为的人们能够根据复杂的，基于语言的查询来搜索大型文本集合。</p></blockquote><p>【单词概述word sketch】是对单词的语法和搭配行为进行的单页的，自动的，语料库驱动的摘要。</p><p>【概述引擎】展示了<u>单词概述</u>或<u>一系列搭配</u>或<u>出现频率比超过预期的，与目标单词一起出现的单词</u></p><p>【Lexicographer】可以将相关的搭配用颜色标记分组，表示不同目标单词的不同含义</p><p>在大规模的语料库中，Lexicographer应该找出更符合语境的含义，而不是依靠直觉。</p><p>对于缺少语料库资源的少部分语言，比如阿姆哈拉语Amharic，概述引擎可以与网络引导Web-Bootcat结合，从而让研究者收集自己的基于网络的语料库</p><h4 id="两种不同的自动化的词义消歧-WSD"><a href="#两种不同的自动化的词义消歧-WSD" class="headerlink" title="两种不同的自动化的词义消歧 WSD"></a>两种不同的自动化的词义消歧 WSD</h4><p>简单：词汇采样任务</p><ul><li>少量的提前选择的目标单词集，以及包含每个单词的含义的清单</li></ul><p>困难：全单词任务</p><ul><li>整个文本中的所有单词，以及包含每个单词含义的词汇表</li><li>排序，比如按照【部分词性标记 part-of-speech tagging, PoS】</li></ul><blockquote><p>在语料库语言学中，【部分词性标记】（也称为语法标记或词目类别消歧）是根据词的定义和上下文在文本中标记与词性特定部分相对应的词的过程，即，它与短语，句子或段落中相邻和相关单词的关系。通常向学龄儿童教授这种简化形式，将单词标识为名词，动词，形容词，副词等。</p></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>【部分词性标记】。但只能解决小部分消歧问题，如 bank a plane VS the river bank</p></li><li><p>对有含义标记的语料库的【单词搭配模式】进行监督机器学习</p></li><li><p>非监督或半监督学习：无标记的语料库，使用基于字典的语言学知识</p></li><li><p>Lesk算法：字典定义中的重叠</p></li></ul><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>需要以下4个步骤：</p><ul><li>标签集（含义清单 sense inventory）（每个数据的分类）</li><li>训练语料库（数据集）</li><li>特征集，同于表达每个单词的含义，从训练语料库中提取（数据预处理）</li><li>分类器（训练模型）</li></ul><h4 id="监督学习——词义消歧，第一步：WSD标签"><a href="#监督学习——词义消歧，第一步：WSD标签" class="headerlink" title="监督学习——词义消歧，第一步：WSD标签"></a>监督学习——词义消歧，第一步：WSD标签</h4><p>什么是标签？由语法学家确定的名词、动词、形容词、副词、介词、连词等</p><p>但没有相同的【语义标签集】能覆盖所有英文单词。</p><p>【自然语言处理工具包 NLTK】</p><blockquote><p>Natural Language Toolkit（更常见的是NLTK）是一套以Python编程语言编写的用于英语的符号和统计自然语言处理的库和程序。它是由宾夕法尼亚大学计算机与信息科学系的Steven Bird和Edward Loper开发的。NLTK包括图形演示和示例数据。</p></blockquote><p>【单词网WordNet】是每个单词的一组含义</p><p>比如单词bass在WordNet中有8个含义：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelr5v2l15j31100e4n0b.jpg" alt="截屏2020-05-08 下午10.33.52"></p><p>【含义标签清单 Sense Tag Inventory】</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelr7gmfiqj30xu07otbk.jpg" alt="截屏2020-05-08 下午10.35.25"></p><h4 id="监督学习——词义消歧，第二步：构建语料库"><a href="#监督学习——词义消歧，第二步：构建语料库" class="headerlink" title="监督学习——词义消歧，第二步：构建语料库"></a>监督学习——词义消歧，第二步：构建语料库</h4><p>简单的，词汇采样，比如：</p><ul><li>Line-hard-serve corpus，Interest corpus，auto-generate confusion sets on very very large corpora (Banko&amp;Brill)</li></ul><p>复杂的，全词语料库：【语义的一致性】，即语料库中所有开放类别的单词都带有含义标签，标签来源于特定的字典或同义词。比如：</p><ul><li>SemCor：234,000 words from Brown Corpus, manually tagged with WordNet senses</li><li>SENSEVAL-3 competition corpora - 2081 tagged word tokens</li></ul><h4 id="监督学习——词义消歧，第三步：提取特征向量"><a href="#监督学习——词义消歧，第三步：提取特征向量" class="headerlink" title="监督学习——词义消歧，第三步：提取特征向量"></a>监督学习——词义消歧，第三步：提取特征向量</h4><p>【特征向量】：属性集合表示的向量，比如.csv .arff文件中的一行：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geluhbehvaj316202s753.jpg" alt="截屏2020-05-09 上午12.28.39"></p><p>对于【词义消歧】来说，特征向量需要表示目标词窗口的范围内的单词。但问题是，如何确定窗口的最小大小，使我们能够理解一个单词的意思。比如：<br>（通常采用+/-2的窗口）</p><ul><li><p>窗口大小为+/- 0：bass</p></li><li><p>窗口大小为+/- 1：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geluabe3jnj311q05kaap.jpg" alt="截屏2020-05-09 上午12.21.58" style="zoom: 33%;" /></p></li><li><p>窗口大小为一句话：</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelub9m094j311i0ig0xc.jpg" alt="截屏2020-05-09 上午12.22.52" style="zoom:33%;" /></p><h5 id="向量中的特征的类型"><a href="#向量中的特征的类型" class="headerlink" title="向量中的特征的类型"></a>向量中的特征的类型</h5><p>【词袋 Bag-of-words】，任何出现在窗口中的单词（不考虑位置）。通常用于词频计算或权重，可以包括其他可计算的权重，比如TF/IDF</p><p>比如：原文如下，窗口大小为+/- 2，</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelutexk6pj30ys05smye.jpg" alt="截屏2020-05-09 上午12.40.19" style="zoom:33%;" /></p><ol><li><p>第一步是创建词袋。假设词袋中有12个词：</p><p>[fish,fishing,viol, guitar, double,cello…]</p></li><li><p>然后是创建【词向量】，用<u>基于词袋的向量</u>表示目标词窗口的内容。假设词袋中包含guitar和player，但没有and和stand，于是得到【guitar and bass player stand】对应的【词向量】：（按出现频率计数）</p><p>[0,0,0,1,0,0,0,0,0,1,0,0]</p></li></ol><h5 id="词向量技术：词嵌入word-embedding"><a href="#词向量技术：词嵌入word-embedding" class="headerlink" title="词向量技术：词嵌入word embedding"></a>词向量技术：词嵌入word embedding</h5><p>【词向量】的构建是基于【词袋】的。如果将所有的词都加入词袋中，那么构建出来的词向量可能绝大部分的值都是0。因此出现了【词嵌入】技术，比如：</p><ul><li><a href="https://www.tensorflow.org/tutorials/text/word_embeddings" target="_blank" rel="noopener">word2vec</a>：由Mikolov et al (Google, Facebook)发表</li><li>Neural Network “deep learning” maps word to 1000-vector</li></ul><blockquote><p>词嵌入是自然语言处理中语言模型与表征学习技术的统称。概念上而言，它是指把一个维数为所有词的数量的高维空间嵌入到一个维数低得多的连续向量空间中，每个单词或词组被映射为实数域上的向量。 词嵌入的方法包括人工神经网络、对词语同现矩阵降维、概率模型以及单词所在上下文的显式表示等。</p></blockquote><h4 id="监督学习——词义消歧，第四步：分类器"><a href="#监督学习——词义消歧，第四步：分类器" class="headerlink" title="监督学习——词义消歧，第四步：分类器"></a>监督学习——词义消歧，第四步：分类器</h4><p>当我们把歧义消除问题视为分类问题时，我们就可以采用机器学习的解决方案，比如在WEKA中可以使用：</p><ul><li>朴素贝叶斯</li><li>决策列</li><li>决策树</li><li>神经网络</li><li>支持向量机</li><li>最临近算法，等</li></ul><p>如何选择以上算法，依赖于使用的特征集。有些算法在【数值类型的特征】上表现更好/更差；有些算法需在有大量的【表示可能性的特征】上表现得更好/更差。比如决策树可能不适合特征值特别多的场景，因为会产生大量的分支，而朴素贝叶斯可以将所有特征一起考虑，因此可能更适合。</p><h4 id="分类器的评估"><a href="#分类器的评估" class="headerlink" title="分类器的评估"></a>分类器的评估</h4><p>对同一个任务比较不同的分类器，找出效果最好的分类器</p><p>使用同一个分类器比较不同任务，找出最难的任务</p><h4 id="词义消歧的评估"><a href="#词义消歧的评估" class="headerlink" title="词义消歧的评估"></a>词义消歧的评估</h4><p>对手动标记的语料库进行评估</p><ul><li>准确率：预测单词标签与人工分类的含义标签是否一样</li><li>通常采用测试集进行评估：从训练集中保留一部分作为测试集</li></ul><p>比较基线和上限的准确率</p><ul><li><p>基线 Baseline(s)：最常出现的含义</p><ul><li><p>比如WordNet是按频率排序的，于是WordNet中的第一个就是最常见的含义</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelwo33gjij310o07q0vl.jpg" alt="截屏2020-05-09 上午1.44.20" style="zoom:50%;" /></p></li></ul></li><li><p>上限 Ceiling：得到的最好结果</p><ul><li>对某个标签的划分需要多个人一起评估，取得一致。</li><li>比如，人们对【all-words corpora with Wordnet style senses】的标签只有大约75-80%能达成一致，如果模型划分的准确率超过这个数值，则是不合理的。</li></ul></li></ul><h3 id="词义消歧：字典-同义词方法——Lesk算法"><a href="#词义消歧：字典-同义词方法——Lesk算法" class="headerlink" title="词义消歧：字典/同义词方法——Lesk算法"></a>词义消歧：字典/同义词方法——Lesk算法</h3><p>Lesk算法——分监督学习算法，即训练集没有分类（标签）。但还是需要人们干涉字典和规则</p><blockquote><p>Lesk算法是Michael E. Lesk在1986年提出的一种经典的词义消歧算法</p></blockquote><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>比如有PINE和CONE两个单词，它们的含义分别如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelx5wdiexj30hw05wwey.jpg" alt="截屏2020-05-09 上午2.01.30"></p><p>当出现词组搭配【pine cone】时，由于pine1和cone3中的单词有重叠：“evergreen” + “tree”，于是可以认为pine cone中的pine是1，cone是3。</p><h4 id="简化Lesk算法-Simplified-Lesk-algorithm"><a href="#简化Lesk算法-Simplified-Lesk-algorithm" class="headerlink" title="简化Lesk算法 Simplified Lesk algorithm"></a>简化Lesk算法 Simplified Lesk algorithm</h4><p><strong>任务：定义【原文】中bank的含义</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelxdc9dfwj30yq02k0tr.jpg" alt="截屏2020-05-09 上午2.08.40"></p><p><strong>参数：给定的【WordNet sense】为：</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelxebmxpfj30ya08k41i.jpg" alt="截屏2020-05-09 上午2.09.36"></p><p>计算步骤：</p><ol><li>分别计算【原文】与bank1和bank2的【Gloss和Examples】重叠的单词数量</li><li>选择计数最高的【word sense】，即bank1或bank2</li></ol><h4 id="为什么谷歌不需要歧义消除技术——搜索引擎的匹配方案"><a href="#为什么谷歌不需要歧义消除技术——搜索引擎的匹配方案" class="headerlink" title="为什么谷歌不需要歧义消除技术——搜索引擎的匹配方案"></a>为什么谷歌不需要歧义消除技术——搜索引擎的匹配方案</h4><p>因为谷歌搜索引擎只需要找到匹配关键字的文本即可。</p><p>方法一：【词嵌入技术】</p><p>方法二：计算相似度</p><ul><li>【词袋】包含1000个基础单词</li><li>任何一个单词都匹配能用一个1000维的向量表示</li><li>任何一个文档，都能用每个单词所表示的向量相加</li><li>文档之间（或文档和查询词之间）的相似度可以通过计算两个向量的距离。</li></ul><p>方法三：【倒排索引】</p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SketchEngine </tag>
            
            <tag> 词义消歧WSD </tag>
            
            <tag> 部分词性标记PoS tagging </tag>
            
            <tag> 构建语料库 </tag>
            
            <tag> Lesk算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务级别协议 SLA</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/06_%20Service%20Level%20Agreement/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/06_%20Service%20Level%20Agreement/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>A service-level agreement is an agreement between two or more parties, where one is the customer and the others are service providers. This can be a legally binding formal or an informal “contract” (for example, internal department relationships). The agreement may involve separate organizations, or different teams within one organization. Contracts between the service provider and other third parties are often (incorrectly) called SLAs – because the level of service has been set by the (principal) customer, there can be no “agreement” between third parties; these agreements are simply “contracts.” Operational-level agreements or OLAs, however, may be used by internal groups to support SLAs. If some aspect of a service has not been agreed with the customer, it is not an “SLA”.</p><p>SLAs commonly include many components, from a definition of services to the termination of agreement. To ensure that SLAs are consistently met, these agreements are often designed with specific lines of demarcation and the parties involved are required to meet regularly to create an open forum for communication. Rewards and penalties applying to the provider are often specified. Most SLAs also leave room for periodic (annual) revisitation to make changes.</p><p>Since late 1980s SLAs have been used by fixed line telecom operators. SLAs are so widely used these days that larger organizations have many different SLAs existing within the company itself. Two different units in an organization script a SLA with one unit being the customer and another being the service provider. This practice helps to maintain the same quality of service amongst different units in the organization and also across multiple locations of the organization. This internal scripting of SLA also helps to compare the quality of service between an in-house department and an external service provider.</p><p>The output received by the customer as a result of the service provided is the main focus of the service level agreement.</p><p>Service level agreements are also defined at different levels:</p><ul><li><p><strong>Customer-based SLA</strong>: An agreement with an individual customer group, covering all the services they use. For example, an SLA between a supplier (IT service provider) and the finance department of a large organization for the services such as finance system, payroll system, billing system, procurement/purchase system, etc.</p></li><li><p>Service-based SLA: An agreement for all customers using the services being delivered by the service provider</p><p>For example:</p><ul><li>A mobile service provider offers a routine service to all the customers and offers certain maintenance as a part of an offer with the universal charging.</li><li>An email system for the entire organization. There are chances of difficulties arising in this type of SLA as level of the services being offered may vary for different customers (for example, head office staff may use high-speed <a href="https://en.wikipedia.org/wiki/Local_area_network" target="_blank" rel="noopener">LAN</a> connections while local offices may have to use a lower speed leased line).</li></ul></li><li><p>Multilevel SLA: The SLA is split into the different levels, each addressing different set of customers for the same services, in the same SLA.</p><ul><li><strong>Corporate-level SLA</strong>: Covering all the generic <a href="https://en.wikipedia.org/wiki/Service_level_management#Service_level_management" target="_blank" rel="noopener">service level management</a> (often abbreviated as SLM) issues appropriate to every customer throughout the organization. These issues are likely to be less volatile and so updates (SLA reviews) are less frequently required.</li><li><strong>Customer-level SLA</strong>: covering all SLM issues relevant to the particular customer group, regardless of the services being used.</li><li>Service-level SLA: covering all SLM issue relevant to the specific services, in relation to this specific customer group.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动设备虚拟化</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/07%20Introduction%20to%20Mobile%20Device%20Virtualization/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/07%20Introduction%20to%20Mobile%20Device%20Virtualization/</url>
      
        <content type="html"><![CDATA[<p>大规模的物联网设备及其数据需要有效利用云资源，但随之而来的是隐私和性能问题</p><p>解决方案：物联网设备的虚拟化</p><a id="more"></a><h4 id="动机：为什么"><a href="#动机：为什么" class="headerlink" title="动机：为什么"></a>动机：为什么</h4><p>大规模的物联网设备及其数据需要有效利用云资源，但随之而来的是隐私和性能问题</p><p>解决方案：使物联网设备的虚拟化</p><h4 id="移动设备的虚拟化"><a href="#移动设备的虚拟化" class="headerlink" title="移动设备的虚拟化"></a>移动设备的虚拟化</h4><p>虚拟化：在多个操作系统之间，高效的共享物理资源</p><p>混合关键性Mixed criticality设置：通用操作系统（实时OS，安全OS，遗留的旧版OS）</p><blockquote><p>混合关键性系统是包含计算机硬件和软件的系统，可以执行多个具有不同关键性的应用程序，例如安全性关键性和非安全性关键性或不同的安全完整性级别。不同关键性应用程序的设计具有不同的保证级别，高关键性应用程序的设计和验证成本最高。这些类型的系统通常嵌入在必须确保安全性的机器（例如飞机）中。</p><p>传统的安全关键系统必须进行完整的测试和认证，以表明它们可以安全使用。然而，许多这样的系统由安全关键部分和非关键部分的混合物组成，例如，当飞机包含与安全关键飞行系统隔离的乘客娱乐系统时。混合关键系统中要解决的一些问题包括实时行为，内存隔离，数据和控制耦合。</p></blockquote><p>减少软件移植费用和硬件成本</p><p>虚拟化的主要的组件：硬件设备、Hypervisor（虚拟机监控程序 Virtual Machine Monitor）、GuestOS（虚拟机 ）</p><p>移动设备的高效虚拟化：通过同时执行多个操作系统，不会损害<u>虚拟硬件</u>的<strong>实时特性</strong></p><h4 id="服务器虚拟化-VS-移动虚拟化"><a href="#服务器虚拟化-VS-移动虚拟化" class="headerlink" title="服务器虚拟化 VS 移动虚拟化"></a>服务器虚拟化 VS 移动虚拟化</h4><div class="table-container"><table><thead><tr><th>问题/特征</th><th>服务器虚拟化</th><th>移动设备虚拟化</th></tr></thead><tbody><tr><td>设备能源</td><td>高</td><td>低</td></tr><tr><td>资源限制</td><td>无</td><td>有</td></tr><tr><td>用例</td><td>异构操作系统</td><td>异构操作系统</td></tr><tr><td>硬实时能力</td><td>无</td><td>有</td></tr><tr><td>硬件支持</td><td>2005年起</td><td>2012年起</td></tr><tr><td>主要硬件ISA</td><td>Intel</td><td>ARM</td></tr></tbody></table></div><h4 id="移动虚拟化：硬件创新"><a href="#移动虚拟化：硬件创新" class="headerlink" title="移动虚拟化：硬件创新"></a>移动虚拟化：硬件创新</h4><p>早期阻碍：</p><ul><li>资源的限制（CPU、内存、电池）</li><li>额外的性能开销，因此会降低响应速度</li></ul><p>当前的推动：</p><ul><li><p>各种需要资源的应用设备。如游戏，多媒体</p></li><li><p>CPU的发展：从MHz的单核CPU，到限制GHz的多核CPU</p></li><li><p>内存容量的扩展：GB级别</p></li><li>多处理器的单片系统（System-on-Chip）设计</li></ul><blockquote><p>单片系统或片上系统是一个将电脑或其他电子系统集成到单一芯片的集成电路。单片系统可以处理数字信号、模拟信号、混合信号甚至更高频率的信号。单片系统常常应用在嵌入式系统中。单片系统的集成规模很大，一般达到几百万门到几千万门。</p></blockquote><h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><p>共存的异构操作系统：企业为了节约成本，让员工使用自己的设备，因此员工的个人资料和企业资料共存于员工的个人设备中。（采用虚拟化将企业与个人资料分开）</p><p>多核管理：与对称/非对称多处理相比，资源分配灵活</p><p>安全：同时执行不同安全级别的任务，比如同时执行用户程序和安全至上security-critical的程序</p><h4 id="移动虚拟技术的分类"><a href="#移动虚拟技术的分类" class="headerlink" title="移动虚拟技术的分类"></a>移动虚拟技术的分类</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2apgkp80j31240jg7ao.jpg" alt="截屏2020-03-21下午10.18.29"></p><h5 id="虚拟化的类型"><a href="#虚拟化的类型" class="headerlink" title="虚拟化的类型"></a>虚拟化的类型</h5><ul><li>Type-1：之间在硬件上部署虚拟机guest OS</li><li>Type-2：在主操作系统host OS 上部署虚拟机guest OS</li></ul><h5 id="硬件平台"><a href="#硬件平台" class="headerlink" title="硬件平台"></a>硬件平台</h5><p>移动设备&amp;手机领域：ARM</p><p>笔记本、网络设备、游戏机领域：Intel Atom、MIPS、PowerPC</p><h5 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h5><p>虚拟化技术可捕获ARM ISA中敏感的非特权指令</p><p>CPU虚拟化模型：二进制翻译 Binary translation、半虚拟化Paravirtualization、硬件辅助Hardware assisted</p><h5 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h5><p>内存保护模型：固定分区Fixed partitions、域访问控制标记Domain Access Control Tagging、VMID标记 VMID tagging</p><h5 id="中断虚拟化"><a href="#中断虚拟化" class="headerlink" title="中断虚拟化"></a>中断虚拟化</h5><p>陷阱和模拟程序：Emulated interrupt controller</p><p>由中断控制器配置：Virtual interrupt interfaces</p><h5 id="I-O虚拟化"><a href="#I-O虚拟化" class="headerlink" title="I/O虚拟化"></a>I/O虚拟化</h5><p>I/O访问模型：专用的dedicated（基于优先权）、共享的shared（在所有虚拟机之间）</p><h5 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h5><p>网络虚拟化模型：半虚拟的Paravirtual（基于超级调用的接口）、陷阱和模拟 Trap and emulate（用于网络接口访问）、硬件辅助Hardware assisted（多接口访问虚拟机）、悬挂和恢复Suspend and resume（路由）</p><blockquote><p>在计算和操作系统中，陷阱Trap（也称为异常或错误）通常是由异常情况（例如，断点，零除，无效的内存访问）引起的一种同步中断。 陷阱通常会导致切换到内核模式，其中操作系统在将控制权返回到原始进程之前执行某些操作。内核进程中的陷阱比用户进程中的陷阱更严重，并且在某些系统中是致命的。在某些用法中，陷阱一词特指旨在启动上下文切换到监视程序或调试器的中断。</p></blockquote><h4 id="移动虚拟化技术：Type1-amp-2"><a href="#移动虚拟化技术：Type1-amp-2" class="headerlink" title="移动虚拟化技术：Type1 &amp; 2"></a>移动虚拟化技术：Type1 &amp; 2</h4><p>Type-1：</p><ul><li>全虚拟化 Full virtualization：不需要修改虚拟机操作系统，本地代码的执行效率高</li><li>半虚拟化 Para-virtualization：修改虚拟机操作系统，支持超级调用 Hypercall()，能够获得更多的性能，但代价是更多的开发成本和不支持开源</li><li>动态二进制翻译 Dynamic Binary Translation (DBT)：有更多的内存空间</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2ce723bwj30p40eiaf3.jpg" alt="截屏2020-03-21下午11.16.49" style="zoom: 67%;" /></p><p>Type-2：对虚拟机操作系统进行轻量级的修改，以及基于自动化脚本的翻译。相比Type-1，多了一层host OS</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2cn7q4fej30920eamyq.jpg" alt="截屏2020-03-21下午11.25.30" style="zoom:50%;" /></p><h4 id="全虚拟化和半虚拟化"><a href="#全虚拟化和半虚拟化" class="headerlink" title="全虚拟化和半虚拟化"></a>全虚拟化和半虚拟化</h4><div class="table-container"><table><thead><tr><th>虚拟化技术</th><th>分类</th><th>原则</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>全虚拟化</td><td>硬件辅助</td><td>利用Hypervisor模式和虚拟化扩展</td><td>更低的Hypervisor复杂度；不需要修改GuestOS</td><td>敏感的非优先的ISA指令；频繁的陷入导致昂贵的上下文切换</td></tr><tr><td></td><td>动态二进制翻译</td><td>动态翻译敏感的非优先的指令</td><td>可应用于不可虚拟化的平台；可以不修改GuestOS</td><td>更高的Hypervisor复杂度（因为要扫描所有指令）；陷阱和仿真进程的过度消耗；需要内存空间来存储指令</td></tr><tr><td>半虚拟化</td><td>纯半虚拟化</td><td>修改GuestOS，用精确的hypercall代替敏感非优先的指令</td><td>在硬件的数量和OS平台方面具有可扩展性</td><td>要对GuestOS进行内核级的修改（补丁）；每次更新GuestOS都要同步更新补丁；没有标准的Hypervisor接口；无法使用不开源的GuestOS</td></tr><tr><td></td><td>轻量级半虚拟化</td><td>基于脚本识别和替换敏感非优先的指令</td><td>需要更少的汇编代码（以脚本代替）</td><td>每个GuestOS需要不同的脚本</td></tr><tr><td></td><td>基于微核的半虚拟化</td><td>将操作系统服务移动到用户空间中，减少内核的大小</td><td>更小的内核，因此获得更高的安全性和效率</td><td><u>用户-内核空间通道</u>需要高效的通信补丁（IPC）</td></tr></tbody></table></div><blockquote><p>在任何操作系统中，都必须具有双模式操作，以确保系统受到未经授权或错误用户的保护和安全。此双重模式将用户模式与系统模式或内核模式分开。</p><p>优先指令（内核模式）：I/O指令、暂停指令、上下切换、清除内存、从内存中移除进程等</p><p>非优先指令（用户模式）：读取处理器状态、读取系统时间、生成任何陷阱指令、发送打印机的最终打印结果</p></blockquote><h4 id="各版本Hypervisor比较"><a href="#各版本Hypervisor比较" class="headerlink" title="各版本Hypervisor比较"></a>各版本Hypervisor比较</h4><div class="table-container"><table><thead><tr><th>Hypervisor</th><th>VT</th><th>RT</th><th>Sc-M-OS</th><th>Sc-M-C</th><th>VE</th><th>PA</th><th>Se</th><th>MP</th><th>In</th><th>VM-M</th></tr></thead><tbody><tr><td>虚拟机监控程序</td><td>虚拟化技术</td><td>实时能力</td><td>可扩展性——多操作系统</td><td>可扩展性——多核</td><td>虚拟化扩展</td><td>处理器结构</td><td>安全性</td><td>内存保护</td><td>入侵性</td><td>虚拟器迁移</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2duy8usjj30xo0j846m.jpg" alt="截屏2020-03-22上午12.07.27"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2duda4u1j30xs0j4qat.jpg" alt="截屏2020-03-22上午12.06.40"></p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>Heterogeneous OS —— 异构操作系统<br>Host OS —— 主机操作系统<br>Guest OS —— 虚拟机操作系统<br>Hypervisor —— 虚拟机监控程序<br>Hypercall —— 超级调用<br>Assembly code —— 汇编代码</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
            <tag> 移动设备虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档分类</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/09%20%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/09%20%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="文档分类-Document-classification"><a href="#文档分类-Document-classification" class="headerlink" title="文档分类 Document classification"></a>文档分类 Document classification</h4><p>根据内容将文档划分到用户定义的类中。</p><p>文档分类包括以下几种类型：</p><ul><li>情感分析：文本的属性是什么<ul><li>自动探测文档中积极和消极的陈述</li><li>让人们可以追踪关于政策、产品和立场的观点</li></ul></li><li>著作权属性：<ul><li>作者识别：</li><li>法证 Forensic Evidence（这个签名是谁写的）</li><li>抄袭检测 Plagiarism Detection</li></ul></li><li>垃圾邮件过滤</li><li>语言识别：文档中使用的是什么语言</li></ul><a id="more"></a><h4 id="语言识别"><a href="#语言识别" class="headerlink" title="语言识别"></a>语言识别</h4><p>语言识别是相对简单的任务。当发现文本中出现特定则字符时，可以确定该文档使用了某种语言，比如【Liebe Gru ̈ße】中的【u ̈】和【ß】是德语符号；也可以通过检查字符编码，比如【ISO 8859-8】对应希伯来语。但这并不适用于所有语言，比如瑞典语和挪威语。</p><p>其中一种简单的解决方案是【n-gram】技术，即同时检查n个词令（单词或字母）。</p><ul><li>首先，我们从确定语言的文档中进行n-gram划分，比如对【Go through texts for…】这句话进行3-gram划分，得到【Go , o t, th, thr, hro, rou, . . .】</li><li>然后通过该数组，我们能够知道某种语言的【字母的使用顺序以及频率】，比如【thr】就不太可能是日语字符串</li></ul><p>更具体来说：我们将两种要比较的语言进行n-gram划分，然后按照频率排序，如下图。然后对一个新的文本进行同样的n-gram划分，然后就能计算出该文本属于某种语言的可能性。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gej81x03emj30h208wmxp.jpg" alt="截屏2020-05-06 下午6.01.35" style="zoom: 33%;" /></p><h4 id="机器学习、监督学习、非监督学习"><a href="#机器学习、监督学习、非监督学习" class="headerlink" title="机器学习、监督学习、非监督学习"></a>机器学习、监督学习、非监督学习</h4><p>【机器学习】通过训练集对模型进行训练，通过测试集对训练后的模型进行评估，最终构建一个健壮的系统，来对未知的数据进行预测。【文档划分】是【人工智能-机器学习】下的一个实例。</p><p>【监督学习】中的训练集和测试集都<u>有分类标签</u>，经过学习后，模型能够对未知的数据进行分类。</p><p>【非监督学习】中的数据集没有分类标签，目的是使模型能够自动将相似的数据聚类，最终形成多个类别。优点是不需要训练集，因此没有对数据进行人工划分的开销。缺点是聚类的结果可能不够准确，并且有时难以评估。</p><h4 id="特征-amp-证据"><a href="#特征-amp-证据" class="headerlink" title="特征&amp;证据"></a>特征&amp;证据</h4><p>对文档进行聚类的第一步是【提取与决策最相关的特征】。</p><p>比如对于垃圾邮件过滤，相关的特征包括：是否有提到大量的钱；是否出现比较奇怪的问候词，如Respected Madam；是否出现整个词都是大写的；是否出现Viagra或Sex之类的词。虽然这些词都不能明确的指示出垃圾邮件，但这些特征出现在垃圾邮件中的可能性更大。</p><p>我们需要告诉计算机</p><ol><li>如何使用这些特征，以及如何探测出这些特征，这涉及【特征工程】。</li><li>如何对这些特征带来的证据进行加权，这涉及【机器学习】</li></ol><h4 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h4><p>两个用于特征工程的常用策略</p><ol><li>Kitchen sink strategy：使用大量的特征，希望其中的一部分是相关且有用的。<ul><li>比如把邮件中所有可能的词特征都丢给垃圾邮件探测器。</li><li>需要选择合适的机器学习算法，该算法能够专注于更相关的特征，忽略大部分无关特征</li></ul></li><li>Hand-crafted strategy：识别可能相关的一小部分特征<ul><li>优点：由于无关特征更少，因此机器学习算法不需要擅长忽略</li><li>缺点：选择特征比较困难</li></ul></li></ol><p>迭代方法：</p><ol><li>选择一组初始特征</li><li>训练分类器，并评估</li><li>找出哪些特征效果好，哪些效果差，改进特征选择</li></ol><p>由于可能最佳的特征可能难以采集，因选择次佳的，但更容易采集的特征可能是更好的选择</p><h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gej9rnyvtrj30uw05ggms.jpg" alt="截屏2020-05-06 下午7.00.56"></p><h4 id="文档分类器：朴素贝叶斯-Naive-Bayes"><a href="#文档分类器：朴素贝叶斯-Naive-Bayes" class="headerlink" title="文档分类器：朴素贝叶斯 Naive Bayes"></a>文档分类器：朴素贝叶斯 Naive Bayes</h4><p>根据采集的【证据】，比较两个假设的可能性：假设一个文本是垃圾邮件，另一个假设是该文本不是垃圾邮件。</p><p>假设有2个分类的的词列表统计，如下图。现将预测文本的词拆分入袋，从词袋中去一个词出来，比如是【Emily】，Emily是垃圾邮件中出现的概率是2/250=0.8，在非垃圾邮件中出现的概率是25/200=12.5，于是该文本是非垃圾邮件与垃圾邮件的比率是12.5/0.8=16，因此更可能是非垃圾邮件。</p><p>这时再取出一个词【credit】，概率分别为垃圾邮件12/250，非垃圾邮件2/200，比率为0.29。</p><p>将两个词的比率相乘16*0.29=4.63，大于1，目前为止，可以表明这个文本亦然更可能是非垃圾邮件</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gej9wp9teoj30eu0jiq4i.jpg" alt="截屏2020-05-06 下午7.05.46" style="zoom:33%;" /></p><h4 id="文档分类器：感知机"><a href="#文档分类器：感知机" class="headerlink" title="文档分类器：感知机"></a>文档分类器：感知机</h4><p>朴素贝叶斯的思想：计算在测试集中发生的事情</p><p>感知机的思想：错误驱动的学习</p><ul><li>模型的输入：对测试集中的每个单词都维护一个权重</li><li>模型的输出：文档将被划分为2类，垃圾邮件和非垃圾邮件</li></ul><p>训练时，将文本的单词作为输入参数，分别与权重进行加权，并对结果进行划分，如果最终的划分结果错误（不在超平面的两侧），则需要通过【梯度下降】更新权重</p><h4 id="文档分析：著作权属性"><a href="#文档分析：著作权属性" class="headerlink" title="文档分析：著作权属性"></a>文档分析：著作权属性</h4><blockquote><p>Mosteller and Wallace(1964) applied authorship detection techniques to The Federalist Papers. The Federalist Papers were a series of 85 articles written between 1787 and 1788 by James Madison, Alexander Hamilton and John Jay to persuade New York to ratify the Constitution.</p></blockquote><p>通过分析文章中的惯用词（不同的词出现的频率），来判断作者。</p><h4 id="文体-Stylometry"><a href="#文体-Stylometry" class="headerlink" title="文体 Stylometry"></a>文体 Stylometry</h4><p>文体定义了作者的写作风格的特征，这些特征，比较多个文本之间的相似性。</p><p>风格越相似，那么两个文本就越可能是同一个作者写的。</p><p>主要思想是：风格作用于潜意识水平，因此更加一致（所以可测量？）</p><p>换句话说，写作风格就是语言学的指纹。</p><h4 id="文体方法"><a href="#文体方法" class="headerlink" title="文体方法"></a>文体方法</h4><p>提取【风格标记 style markers】，可能是基于单词、语法、或者两者的组合</p><h5 id="词汇的风格标记-Lexical-style-markers"><a href="#词汇的风格标记-Lexical-style-markers" class="headerlink" title="词汇的风格标记 Lexical style markers"></a>词汇的风格标记 Lexical style markers</h5><p>它是一些有关作者身份的线索。有两种标记：功能词的词汇丰富度和频率。</p><p>【功能词function words】比如”to“”that“含义很少，但出现很频繁。虽然功能词是与话题无关的，但功能词的选择和使用位置足以用来识别出作者，比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejbizsls5j30s407ydh2.jpg" alt="截屏2020-05-06 下午8.01.47" style="zoom:50%;" /></p><h4 id="抄袭-plagiarism"><a href="#抄袭-plagiarism" class="headerlink" title="抄袭 plagiarism"></a>抄袭 plagiarism</h4><blockquote><p>􏰀Clough(2003) defines text reuse is the deliberate or unintentional use of existing text for the creation of a new text.</p><ul><li>􏰀Plagiarism is one kind of text reuse.</li><li>Reusing newswire text in journalistic publications is another instance of text reuse.</li></ul></blockquote><p>抄袭的种类：</p><ol><li>逐字逐句：整个短语，句子或段落均被复制，但未被赋予属性。</li><li>释义 Paraphrasing：未归类的原始资料已被重写，但在新文本中仍可识别。</li><li>次要来源：引用来源，但来源是次要来源（不是原始来源）。</li><li>源格式：来源的参数结构/文本组织被复制。</li><li>想法：思想（与形式无关）被复制而没有署名。</li><li>著作权：整个文本的著作权被错误地声明。</li></ol><h4 id="识别抄袭"><a href="#识别抄袭" class="headerlink" title="识别抄袭"></a>识别抄袭</h4><p>以下因素可能暗示着抄袭：</p><ol><li>词汇的使用超过作者的写作级别（高级术语）</li><li>与前文相比，写作的质量发生巨大变化</li><li>文章的风格或词汇不一致<ul><li>对于前3项，比如：Vocabulary use,word length, syllable structure, rhyme and grammar</li></ul></li><li>缺少过度的混乱文本，表示文章可能是剪贴的”cut-and-paste“</li><li>不同的提交有明显相似性<ul><li>其中一个文本是衍生与另一个</li></ul></li><li>不同的提交有相似的错误（e.g. 拼写、语法错误）</li><li>在正文中引用却没有写入参考文献</li><li>缺乏一致的引用风格</li></ol><h4 id="抄袭检测"><a href="#抄袭检测" class="headerlink" title="抄袭检测"></a>抄袭检测</h4><ol><li>单文本<ul><li>识别文章中的不一致性</li><li>找到不一致的来源</li></ul></li><li>多文本<ul><li>识别不可接受的合作</li><li>识别直接复制</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档分析 </tag>
            
            <tag> 抄袭识别 plagiarism </tag>
            
            <tag> 文体 Stylometry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenNebula——虚拟基础设施管理者</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/07%20OpenNebula%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%AE%A1%E7%90%86%E8%80%85/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/07%20OpenNebula%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%AE%A1%E7%90%86%E8%80%85/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="需要虚拟基础设施管理者的原因"><a href="#需要虚拟基础设施管理者的原因" class="headerlink" title="需要虚拟基础设施管理者的原因"></a>需要虚拟基础设施管理者的原因</h4><ul><li>我们需要知道虚拟机放置的位置——调度和监控</li><li>我们需要如何提供一个新的集群节点——克隆和上下文配置</li><li>我们需要知道哪些MAC地址可用——网络</li></ul><p>对资源池进行统一管理</p><p>虚拟机的生命周期管理和监控</p><p>整合镜像、网络和虚拟化</p><h4 id="将虚拟化的优势扩展到集群中"><a href="#将虚拟化的优势扩展到集群中" class="headerlink" title="将虚拟化的优势扩展到集群中"></a>将虚拟化的优势扩展到集群中</h4><p>在物理资源池上，动态部署和重新放置虚拟机</p><p>将固定的【分布式物理基础设施】转化为灵活、敏捷的【虚拟基础设施】</p><h4 id="虚拟机管理模型"><a href="#虚拟机管理模型" class="headerlink" title="虚拟机管理模型"></a>虚拟机管理模型</h4><p>【分布式虚拟机管理系统】的三大支柱：网络、镜像管理、虚拟化</p><p>服务被放置在虚拟机上，虚拟机之间通过网络关联，客户端通过网络获取服务</p><h4 id="OpenNebula的作用"><a href="#OpenNebula的作用" class="headerlink" title="OpenNebula的作用"></a>OpenNebula的作用</h4><p>对于私有云：简化和优化内部操作</p><p>对于混合云：补充私有云的容量</p><p>对于公有云：提供接口给外部用户访问“内部资源”</p><h4 id="OpenNebula的好处"><a href="#OpenNebula的好处" class="headerlink" title="OpenNebula的好处"></a>OpenNebula的好处</h4><p>对于基础设施管理者</p><ul><li>对虚拟机工作负载和分布式的基础实施，进行【中心化的管理】</li><li>支持【虚拟机安置策略】：工作负载平衡、服务器整合等</li><li>动态调整基础设施的大小</li><li>动态分隔和隔离集群</li><li>私有基础设施的动态扩展，以满足需求波动</li><li>组合本地和远程云资源，带来更低的基础设施花费，</li></ul><p>对于基础设施使用者：</p><ul><li>对于服务来说，更快的交付和扩展性</li><li>支持【异质的】执行环境</li><li>虚拟化服务管理的生命周期的完全控制</li></ul><p>在云消费者和云供应商的角度：支持内部可交互性 interoperability</p><h5 id="对系统整合商的好处"><a href="#对系统整合商的好处" class="headerlink" title="对系统整合商的好处"></a>对系统整合商的好处</h5><ul><li>由于其开放、灵活、可扩展的界面、体系结构和组件，OpenNebula可适用于任何现存的数据中心</li><li>构建任何类型的云部署</li><li>开源软件、Apache开源许可</li><li>与云生态中的任何产品和服务，与数据中心的管理工具，都能无缝整合，比如<ul><li>云供应商、虚拟机管理者、虚拟镜像管理者、服务管理者、管理工具、调度器</li></ul></li></ul><h4 id="OpenNebula的主要特征"><a href="#OpenNebula的主要特征" class="headerlink" title="OpenNebula的主要特征"></a>OpenNebula的主要特征</h4><p>内部接口、调度（任务、负载）、虚拟化管理、镜像管理、网络管理、服务管理和语境化、安全、容错、可扩展性Scalability、安装、灵活且可扩展Extensibility</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6hqdvt0ej31240kwaex.jpg" alt="截屏2020-05-26 下午9.04.25"></p><h4 id="OpenNebula结构"><a href="#OpenNebula结构" class="headerlink" title="OpenNebula结构"></a>OpenNebula结构</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6hr3xz6bj30xu0kktc3.jpg" alt="截屏2020-05-26 下午9.05.05" style="zoom: 33%;" /></p><h5 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h5><ul><li>请求管理：提供XML-RPC接口，用于管理和获取实体信息</li><li>SQL池：储存实体信息</li><li>虚拟机管理者：负责虚拟机生命周期</li><li>主机管理者：持有关于主机的控制信息</li><li>虚拟网络（VN）管理者：负责生成虚拟的MAC和IP地址</li></ul><h5 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h5><ul><li><p>调度器：查询物理主机，并将新的虚拟机部署在物理主机上</p></li><li><p>命令行接口：管理OpenNebula的命令</p></li></ul><h5 id="驱动层"><a href="#驱动层" class="headerlink" title="驱动层"></a>驱动层</h5><p>转换驱动：负责镜像的管理，如克隆、删除、创建swap交换镜像</p><p>虚拟机驱动：管理虚拟机的生命周期，如部署、关闭、迁移等</p><p>信息驱动：：在物理主机上执行脚本，来获取主机的信息：比如内存、cpu的使用情况</p><h4 id="进程拆分"><a href="#进程拆分" class="headerlink" title="进程拆分"></a>进程拆分</h4><p>【调度器】和【命令行接口CLI】是分离的任务进程；</p><p>【驱动】也是分离的进程，它们使用简单的文件传输协议以OpenNebula的核心进程进行通信</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6kag1to1j30r60hogr6.jpg" alt="截屏2020-05-26 下午10.32.56" style="zoom: 50%;" /></p><h4 id="构造私有云"><a href="#构造私有云" class="headerlink" title="构造私有云"></a>构造私有云</h4><h5 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h5><p>虚拟机和虚拟机镜像以文件的储存</p><p>镜像仓库：用于存放虚拟机镜像的任何储存媒介</p><ul><li>OpenNebula支持多个后端，并由前端展示，之间通过网络连接</li></ul><p>虚拟机目录：集群节点中的虚拟机主页</p><ul><li>储存检查点、描述文件和虚拟机磁盘</li><li>在虚拟机目录上的实际的操作取决于存储媒介</li><li>应该相互共享，以支持【实时迁移】</li></ul><blockquote><p>例子 A 64 core cluster will typically <strong>run around 80VMs</strong>, each VM will require an average of 10GB of <strong>disk space</strong>. So you will need ~800GB for /srv/cloud/one, you will also want to <strong>store 10-15 master images</strong> so ~200GB for /srv/cloud/images. A 1TB /srv/cloud will be enough for this example setup.</p><p>The master image is the final operating system image that contains all of the software, configuration settings and other customizations requested by the solution provider.</p></blockquote><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><p>使用SSH连接各个节点</p><p>镜像传输可能需要移动大量文件（虚拟机镜像，检查点），解决方案之一是：专用的存储链接</p><p>使用多个NICs（Network Interface Cards）来支持虚拟机通信</p><p>为每个虚拟机定义单独的MAC和IP地址空间，每个虚拟网络都通过网桥与物理网络关联</p><ul><li>OpenNebula中的虚拟网络，由<u>onevnet</u>组件管理</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6l1l7e2kj310a0ksjxd.jpg" alt="截屏2020-05-26 下午10.59.02"></p><h4 id="OpenNebula的生命周期"><a href="#OpenNebula的生命周期" class="headerlink" title="OpenNebula的生命周期"></a>OpenNebula的生命周期</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6ltiv2wnj310a0jstga.jpg" alt="截屏2020-05-26 下午11.25.54" style="zoom: 50%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6ltwlfx7j30ug0u01kx.jpg" alt="OpenNebula_lifecycle"></p><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><p>虚拟机可以放置在本地或远程。</p><p>对于本地云来说，外部云就相当于一个主机。</p><p>虚拟机之间通过VPN连接</p><h5 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h5><p>计算集群的按需扩展：当工作节点达到上限时，通过Amazon EC2，动态的扩展工作节点数量来满足需求</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6mislutuj30u00udk3a.jpg" alt="截屏2020-05-26 下午11.50.06" style="zoom: 50%;" /></p><p>网络服务器的按需扩展：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6ml2slfmj30og0hqk0c.jpg" alt="截屏2020-05-26 下午11.52.22" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云资源管理和调度</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/06%20%E4%BA%91%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E8%B0%83%E5%BA%A6/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/06%20%E4%BA%91%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>资源管理和调度是任何“人造”系统的的关键功能；对系统的评估包括3个基本准则：功能性、性能、成本</p><p>计算机系统的调度：如何分配系统的资源：如CPU cycles，内存，次级存储空间，I/O，网络带宽，用户事件和任务</p><p>资源调度的</p><ul><li>Policy：指导决策的原则；</li><li>机制：如何实现policies</li></ul><a id="more"></a><h4 id="资源管理和调度"><a href="#资源管理和调度" class="headerlink" title="资源管理和调度"></a>资源管理和调度</h4><p>是任何“人造”系统的的关键功能；对系统的评估包括3个基本准则：功能性、性能、成本</p><p>计算机系统的调度：如何分配系统的资源：如CPU cycles，内存，次级存储空间，I/O，网络带宽，用户事件和任务</p><p>资源调度的</p><ul><li>Policy：指导决策的原则；</li><li>机制：如何实现policies</li></ul><h4 id="虚拟机资源管理"><a href="#虚拟机资源管理" class="headerlink" title="虚拟机资源管理"></a>虚拟机资源管理</h4><blockquote><p>服务级别协议（英語：service-level agreement，缩写SLA）也称服务等级协议、服务水平协议，是服务提供商与客户之间定义的正式承诺。服务提供商与受服务用户之间具体达成了承诺的服务指标——质量、可用性，责任。</p><p>SLA最常见的组成部分是以合同约定向客户提供的服务。例如，互联网服务供应商（ISP）和電訊公司通常在与客户的合同条款内包含简单定义的服务级别协议。在此事例下，SLA通常定义有平均故障間隔（MTBF）、平均修复时间或平均修復時間（MTTR）；哪一方负责报告错误与支付费用；吞吐量；抖动；或类似的可衡量细节。</p><p>服务级别协议是一种两方或多方间协议，其中一方为客户，另一方为服务提供商。这可以是具有法律约束力的正式合同或非正式合约。协议有可能涉及单独的组织，也可以是同一个组织内的不同团队。服务提供商与其他第三方之间的合同经常被误称为SLA——由于服务级别是由出资客户要求，与第三方之间则不是“协议”，而只是“合约”。</p><p>服务级别协议通常包含许多部分，从服务的定义到协议的终止。</p></blockquote><p>【基于服务级别协议(Service Level Agreement, SLA)的资源分配器】，包括</p><ul><li>服务请求检查<strong>Service Request Examiner</strong> 和准入控制<strong>Admission Control</strong><ul><li>消费者驱动服务管理</li><li>计算风险管理</li><li>自动化资源管理</li></ul></li><li>计费、账户</li><li>虚拟机监控、分发器、服务请求监控</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf6b7hputkj30zk0nygvo.jpg" alt="截屏2020-05-26 下午5.18.40" style="zoom:50%;" /></p><p>当本地资源不足时，可以将用户分配到其他云</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>云资源管理的问题：</p><ul><li><p>对于multi-objective optimization，需要复杂的策略和决策</p><blockquote><p>Multi-objective optimization多目标优化: 需要在权衡的情况下做出最佳决策在两个或多个相互矛盾的目标之间。比如：load balance, energe, cost, fault tolerance, security</p></blockquote></li><li><p>挑战性：由于系统的复杂性，获取精确的全局状态信息是不可能的</p></li><li><p>与（系统）环境的交互是不可预测的，因此会受到影响：如系统故障、受攻击</p></li><li><p>云服务的提供商需要面对，巨大的负载波动，对云的弹性（可伸缩性）的影响</p></li></ul><h4 id="资源管理策略-Policies"><a href="#资源管理策略-Policies" class="headerlink" title="资源管理策略 Policies"></a>资源管理策略 Policies</h4><ul><li>准入控制 Admission control：防止系统违反高层系统策略接受工作负载</li><li>容量分配 Capacity allocation：分配资源以单独激活服务</li><li>负载平衡 Load balancing：在服务器之间平均分配工作负载</li><li>能源优化 Energy optimization：能源消耗最小化</li><li>服务质量（QoS）保证 Quality of service guarantees：能够满足服务级协议(SLA)规定的时间或其他条件。</li></ul><blockquote><p>准入控制是通信系统中的一种验证过程，在建立连接之前先进行检查，以查看当前资源是否足以用于建议的连接。</p><p>对于某些应用，可能需要专用资源（例如，整个光网络中的波长），在这种情况下，准入控制必须在可以接受请求之前验证此类资源的可用性。</p><p>对于更具弹性的应用程序，在某个截止日期之前可能需要总量的资源才能满足新的请求，在这种情况下，准入控制需要验证当时的资源可用性并执行调度以保证满足所接纳的请求。</p><p>比如：is about look at the resource that i have, can i fulfil the customers request, if i dont have enough resources, i will find resources for the customer from other resource providers, if i have agreement with them. if i can provide anyway, the access will be denied.</p></blockquote><h4 id="云的调度-Scheduling"><a href="#云的调度-Scheduling" class="headerlink" title="云的调度 Scheduling"></a>云的调度 Scheduling</h4><p>什么是调度：负责多个级别的资源共享：</p><ul><li>物理主机可以在多个虚拟机之间共享</li><li>虚拟机可以支持多个应用程序</li><li>一个应用程序可能包含多个线程</li></ul><blockquote><p>调度在计算机中是分配工作所需资源的方法。资源可以指虚拟的计算资源，如线程、进程或数据流；也可以指硬件资源，如处理器、网络连接或扩展卡。</p><p>进行调度工作的程序叫做调度器。调度器通常的实现使得所有计算资源都处于忙碌状态（在负载均衡中），允许多位用户有效地同时共享系统资源，或达到指定的服务质量。调度是计算自身的基础，同时也是编程语言计算模型固有的部分。调度器使得在单处理器上通过多任务处理，从而让执行多个进程成为可能。</p></blockquote><p>调度程序的目标：</p><ul><li>批处理系统：最大吞吐量和最小周转时间</li><li>实时系统：按时完成并具有可预测性</li></ul><blockquote><p>调度器可能会针对不同的目标设计，例如：吞吐率最大化、响应时间最小化、最低延迟[1]、或最大化公平。在实践中，这些目标通常是互相冲突的，因此，调度器会实现一个权衡利弊的折中方案，而侧重点则可能是前文提到的任何一种，这取决于用户的需求和目的。</p><p>在实时环境，例如工业上用于自动控制（如机器人）的嵌入式系统，调度器必须保证进程的调度不能超过最后期限 —— 这是保持系统稳定运行的关键因素。调度也可能是通过一个管理性的后端进行，而任务是通过网络发配到若干远程设备上的。</p></blockquote><p>常见算法：</p><ul><li>Round-Robin(RR)</li><li>First-Come-First Serve (FCFS)</li><li>Shortest-Job-First (SJF)</li><li>Priority Algorithms</li></ul><h4 id="OpenNebula的虚拟机调度"><a href="#OpenNebula的虚拟机调度" class="headerlink" title="OpenNebula的虚拟机调度"></a>OpenNebula的虚拟机调度</h4><p>调度器算法：【match making】算法，将“挂起的虚拟机 pending VM”分配给“已知的主机 known Hosts” （匹配VM的需求和硬件层正好有的资源）</p><p>该算法实现了【Rank Scheduling Policy】，该策略的目标是优先考虑那些更适合VM的资源。</p><h4 id="虚拟机调度方式：例子"><a href="#虚拟机调度方式：例子" class="headerlink" title="虚拟机调度方式：例子"></a>虚拟机调度方式：例子</h4><ul><li>Power-aware：重点是如何最大程度地减少物理主机消耗的能源（比如电），从而最大程度地提高云提供商的收入；比如将多个VMs迁移到同一个节点上，降低总的能耗。</li><li>Performance-aware: 通过动态布局机制，重点在于保持服务级别，同时提高资源利用率（如Real-time system）</li><li>Network-aware: 重点是如何最大程度地减少虚拟机实例和数据存储之间的数据传输时间的影响（如Big data system，Hadoop distributed file system）</li><li>Heuristics 启发式的: 包括先到先得（FCFS），贪婪和循环机制。 例如，FCFS使用First Fit（FF）启发式方法，将VM分配给可以容纳它的第一台物理主机。</li></ul><h4 id="虚拟机管理：例子"><a href="#虚拟机管理：例子" class="headerlink" title="虚拟机管理：例子"></a>虚拟机管理：例子</h4><ol><li>监控云的使用和负载</li><li>服务器整合 server consolidation：当负载降低时，实时转移虚拟机，到负载更高的节点上；不使用的节点关闭</li><li>当负载增加时：启动待机节点；对新的虚拟机和新的节点进行调度</li></ol><h4 id="能源感知算法"><a href="#能源感知算法" class="headerlink" title="能源感知算法"></a>能源感知算法</h4><p>主机过载检测：</p><ul><li>Adaptive utilisation threshold based algorithms<ul><li>Median Absolute Deviation (MAD) algorithm</li></ul></li></ul><p>主机underload（低负载）检测算法：</p><ul><li>Migrate the VMs from the least utilised host（如Power-aware场景）</li></ul><p>虚拟机选择算法：</p><ul><li>Minimum Migration Time (MMT) policy</li><li>Random Selection (RS) policy</li></ul><p>虚拟机放置算法：Power-Aware Best Fit</p><h4 id="虚拟机转移"><a href="#虚拟机转移" class="headerlink" title="虚拟机转移"></a>虚拟机转移</h4><p>转移的发生是透明的</p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>何时迁移：</p><ul><li>Host overload detection algorithms</li><li>Host underload detection algorithms</li></ul><p>迁移哪个：</p><ul><li>VM selection algorithms</li></ul><p>迁移到哪：</p><ul><li>VM placement algorithms</li></ul><h4 id="需要考虑：内存、网络、存储"><a href="#需要考虑：内存、网络、存储" class="headerlink" title="需要考虑：内存、网络、存储"></a>需要考虑：内存、网络、存储</h4>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟化</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/07%20Virtualization/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/07%20Virtualization/</url>
      
        <content type="html"><![CDATA[<p>虚拟机监控程序：Type 1 &amp; 2<br>虚拟化技术：全虚拟化、硬件辅助虚拟化、半虚拟化等<br>流行的几种虚拟机技术产品</p><a id="more"></a><h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h2><p>虚拟化可以广义地定义为：概念性资源或服务与提供它的物理方式的（有益）分离</p><p>创建虚拟资源：硬件平台，操作系统，存储设备，计算机网络资源</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>虚拟机：真实机器的一种表示，使用软件模拟操作环境</p><p>Guest Operating System：运行在虚拟机里的操作系统</p><p>Host OS：运行虚拟机的操作系统</p><p>Hypervisor/VMM 虚拟机监控程序：将资源虚拟化的中间件；位于基础资源和虚拟机之间</p><h4 id="虚拟化的好处"><a href="#虚拟化的好处" class="headerlink" title="虚拟化的好处"></a>虚拟化的好处</h4><p>原因：资源利用不足；数据中心空间不足；环保；管理成本上升</p><p>特点：Sharing、Aggregation，Emulation，Isolation</p><p>好处：随意选择操作系统（比如测试环境）；合并服务器和基础设施；节约时间和金钱；简化管理，保护桌面环境：比如将不安全的程序隔离进虚拟机中，可以将虚拟机复制到其他机器中，相同的操作系统/软件可以快速安装。</p><p>缺点：Guest OS对硬件要求更高；需要学习如何使用；不够精确；硬件问题：比如Intel IA-32</p><h3 id="虚拟机监控程序-Hypervisor"><a href="#虚拟机监控程序-Hypervisor" class="headerlink" title="虚拟机监控程序 Hypervisor"></a>虚拟机监控程序 Hypervisor</h3><p>Qemu, VMware Player, Microsoft Virtual PC etc，Sometimes called Emulation, e.g. x86 Emulation</p><h4 id="Hypervisor的分类"><a href="#Hypervisor的分类" class="headerlink" title="Hypervisor的分类"></a>Hypervisor的分类</h4><p><strong>裸机模式 Bare Metal: Type 1 hypervisor</strong></p><p>位于裸机计算机硬件上，例如CPU，内存等；所有GuestOS都在Hypervisor之上；Hypervisor是硬件之上的第一层。如：Microsoft Hyper-V</p><p><strong>托管模式 Hosted Approach：Type 2 Hypervisor</strong></p><p>在主操作系统上运行；Hypervisor是硬件之上的第二层；Guest OS在hypervisor上的一层运行</p><p>比如：VMWare Workstations、Microsoft Virtual PC、FreeBSD</p><h4 id="Hypervisor的主要属性"><a href="#Hypervisor的主要属性" class="headerlink" title="Hypervisor的主要属性"></a>Hypervisor的主要属性</h4><p><strong>Equivalence 等价性</strong>：程序应该表现的像是直接在同样的硬件上执行</p><p><strong>Resource control 资源控制</strong> ：Hypervisor对虚拟资源有完整的控制</p><p><strong>Efficiency 效率</strong>：必须在无Hypervisor的干预下执行绝大部分机器指令machine instruction</p><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>全虚拟化，硬件辅助虚拟化，部分虚拟化：半虚拟化、混合、OS Level</p><h3 id="全虚拟化"><a href="#全虚拟化" class="headerlink" title="全虚拟化"></a>全虚拟化</h3><p>在全虚拟化技术中，Guest OS并不知道自己处于虚拟的环境，以Guest OS的角度，它直接与硬件进行通信（实际上是虚拟的硬件）</p><ul><li>主机系统模拟硬件，使Guest OS无需任何修改即可运行</li><li>不同的架构可以独立运行</li><li>因为GuestOS与仿真硬件通信（due to the overhead associated with emulating hardware at the transistor level），导致相当大的性能损失</li></ul><h3 id="硬件辅助虚拟化"><a href="#硬件辅助虚拟化" class="headerlink" title="硬件辅助虚拟化"></a>硬件辅助虚拟化</h3><p>是全虚拟化的一种，其中的微处理器架构有特殊的指令，可以协助硬件的虚拟化（而不是完全靠主机操作系统模拟硬件）。这种方式以“Virtual Machine Extensions”的形式，充分利用了硬件的能力，如Intel VT和AMD V</p><p><strong>促进虚拟机的性能</strong>：可以直接与主机的处理器通信，而不需要由Hypervisor进行翻译和隔离；要求GuestOS与主机使用一样的命令集</p><p><strong>完整的硬件协助虚拟化</strong>（如I/O和内存管理），还没有在任何VMM中完整实现</p><h3 id="部分虚拟化"><a href="#部分虚拟化" class="headerlink" title="部分虚拟化"></a>部分虚拟化</h3><p>只模拟主机的大部分硬件，而非全部；支持资源共享，但不保证GuestOS实例被隔离</p><p>比如：半虚拟化、混合虚拟化、操作系统级别虚拟化</p><h4 id="半虚拟化"><a href="#半虚拟化" class="headerlink" title="半虚拟化"></a>半虚拟化</h4><p>在半虚拟化中，GuestOS知道自己的身份，并且直接与HostOS通信（而不是与模拟的硬件通信）</p><ul><li>GuestOS需要进行修改</li><li>提供定义好的“钩子“，在GuestOS和HostOS中执行特定的任务</li><li>在半虚拟的平台中，虚拟机监控程序更简单，因为重要的任务都从VMM中移交给了操作系统<ul><li>优点：虚拟化开销减少，因此性能提高</li></ul></li><li>缺点：兼容性和可移植性降低（因为修改了操作系统）、维护成本增加（因为对操作系统的深度修改）</li><li>例子：KVM (Kernel-based VM)</li></ul><h4 id="比较：半虚拟化和全虚拟化"><a href="#比较：半虚拟化和全虚拟化" class="headerlink" title="比较：半虚拟化和全虚拟化"></a>比较：半虚拟化和全虚拟化</h4><div class="table-container"><table><thead><tr><th>全虚拟化</th><th>半虚拟化</th></tr></thead><tbody><tr><td>不需要修改OS</td><td>需要修改OS</td></tr><tr><td>通过二进制翻译，由软件模拟关键的指令</td><td>用Hypercall代替不可虚拟化的指令，GuestOS直接与VMM通信</td></tr><tr><td><strong>二进制翻译会降低性能</strong></td><td>减少开销</td></tr><tr><td></td><td>维护半虚拟化的GuestOS成本很高（修改、更新系统补丁）</td></tr><tr><td>如：VMware</td><td>如：Xen，VMware ESX (Elastic Sky X)</td></tr></tbody></table></div><h4 id="混合虚拟化"><a href="#混合虚拟化" class="headerlink" title="混合虚拟化"></a>混合虚拟化</h4><p>组合<u>半虚拟化</u>和<u>硬件辅助虚拟化</u>，为创建新的基于云的系统奠定了良好的基础，减少了高峰需求所需的物理机数量，从而减少了硬件运行和设置成本</p><p>优点：能够在GuestOS上获得接近本机的性能</p><p>缺点：包含双方的缺点，如可移植性低、兼容性低、开发维护成本增加</p><ul><li>大多数VMM支持多种类型的虚拟化，因此可以略微减轻这些缺点</li></ul><h4 id="操作系统级的虚拟化"><a href="#操作系统级的虚拟化" class="headerlink" title="操作系统级的虚拟化"></a>操作系统级的虚拟化</h4><p>对多个用户空间的实例进行隔离，GuestOS需要与HostOS一致</p><p>优点：GuestOS上的执行能够达到本机的性能</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2fphsuk8j30m60gq0xe.jpg" alt="截屏2020-03-22上午1.11.29" style="zoom:33%;" /></p><h2 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h2><h4 id="XEN-——-Type-1-Hypervisor（裸机）"><a href="#XEN-——-Type-1-Hypervisor（裸机）" class="headerlink" title="XEN —— Type-1 Hypervisor（裸机）"></a>XEN —— Type-1 Hypervisor（裸机）</h4><ul><li>例子：剑桥大学、Citrix System思杰系统</li><li>微核、</li><li>Domain 0（特权Guest）负责控制和I/O、其他Domain负责用户的程序</li><li>轻量（&lt;150k 代码行），高可扩展性，大于255个物理CPU</li><li>可以分配最高128个虚拟CPU和1TB内存给虚拟机</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2ftu1du4j30ya0d6tcl.jpg" alt="截屏2020-03-22上午1.15.39" style="zoom:50%;" /></p><h4 id="VMware-ESX-Server-——-Type-1-Hypervisor（裸机）"><a href="#VMware-ESX-Server-——-Type-1-Hypervisor（裸机）" class="headerlink" title="VMware ESX Server —— Type-1 Hypervisor（裸机）"></a>VMware ESX Server —— Type-1 Hypervisor（裸机）</h4><ul><li>企业数据中心的商用VMM</li><li>支持<u>全虚拟化</u>和<u>混合虚拟化技术</u></li><li>基于x86和x86-64结构的Linux和Widows的变体</li><li>GuestOS最高支持：32个虚拟CPU和1TB内存</li><li>每个主机最高支持：160个CPU，2TB内存，512个虚拟机</li><li>其他商业版：VMware Workstation and Server 是 Type-2 Hypervisor（有HostOS）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2g2esvvdj30l20d678f.jpg" alt="截屏2020-03-22上午1.23.51" style="zoom:50%;" /></p><h4 id="KVM-——-Type-2-Hypervisor（HostOS）"><a href="#KVM-——-Type-2-Hypervisor（HostOS）" class="headerlink" title="KVM —— Type 2 Hypervisor（HostOS）"></a>KVM —— Type 2 Hypervisor（HostOS）</h4><ul><li>由 Red Hat 支持</li><li>支持硬件辅助虚拟化、混合虚拟化</li><li>主要是X86和X86-64</li><li>移植到PowerPC和IA-64（Itanium）</li><li>通过kernel模块，将Linux内核转化为Hypervisor</li><li>通过QEMU进行设备模拟</li><li>支持多种GuestOS</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2gdbcx79j30iy0h8dpv.jpg" alt="截屏2020-03-22上午1.34.22" style="zoom:50%;" /></p><h4 id="VirtualBox-——-Type-2-Hypervisor（HostOS）"><a href="#VirtualBox-——-Type-2-Hypervisor（HostOS）" class="headerlink" title="VirtualBox —— Type 2 Hypervisor（HostOS）"></a>VirtualBox —— Type 2 Hypervisor（HostOS）</h4><ul><li>由Oracle支持，是一个桌面的虚拟机监控程序</li><li>支持混合虚拟化</li><li>开源</li><li>不开源的免费版本扩展包，用于支持远程桌面协议（RDP）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2giho173j30fq0jm0z9.jpg" alt="截屏2020-03-22上午1.39.20" style="zoom:50%;" /></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2gnooutkj30zw0juki9.jpg" alt="截屏2020-03-22上午1.44.18" style="zoom:50%;" /></p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><blockquote><p>Host OS —— 主机操作系统<br>Guest OS —— 虚拟机操作系统<br>Hypervisor —— Virtual Machine Monitor (VMM)—— 虚拟机监控程序<br>Para-Virtualization —— 半虚拟化<br>Hybrid Virtualization —— 混合虚拟化<br>Bare Metal —— 裸机<br>Overhead —— 开销<br>Portability —— 可移植性<br>Hypercall —— 超级调用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
            <tag> Hypervisor </tag>
            
            <tag> 全虚拟化 </tag>
            
            <tag> 半虚拟化 </tag>
            
            <tag> 硬件辅助虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非监督学习：关联规则，聚类</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/07%20%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%EF%BC%8C%E8%81%9A%E7%B1%BB/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/07%20%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%EF%BC%8C%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="关联规则-Assoication-Rules"><a href="#关联规则-Assoication-Rules" class="headerlink" title="关联规则 Assoication Rules"></a>关联规则 Assoication Rules</h3><h4 id="关联规则与分类规则（上一章）"><a href="#关联规则与分类规则（上一章）" class="headerlink" title="关联规则与分类规则（上一章）"></a>关联规则与分类规则（上一章）</h4><p>分类规则中，左边部分表示分类条件（条件属性），右边部分表示分类结果（分类属性）</p><p>关联规则中，左右部分既可以是条件，也可以是结果</p><p>比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehoq331tnj30d409qmxx.jpg" alt="截屏2020-05-05 上午10.07.14" style="zoom: 33%;" /></p><ul><li>IF F=yes and I=no then Risk=High (3/3) </li><li><p>IF F=yes and Risk=High then I=no (3/4)</p></li><li><p>IF Risk=High then I=no and F=yes (3/4)</p></li><li>IF _ then Risk=High and I=no and F=yes (3/7)</li></ul><h4 id="关联规则-Assoication-Rules-1"><a href="#关联规则-Assoication-Rules-1" class="headerlink" title="关联规则 Assoication Rules"></a>关联规则 Assoication Rules</h4><p>关联规则的搜索空间比决策树大得多，为了减小搜索空间，我们仅考虑满足最小覆盖度coverage的实例（即规定了最少出现次数）</p><p>基本算法：</p><ul><li>agreed minimum coverage：关联规则中的相关实例出现次数要大于n</li><li>agreed minimum accuracy：关联规则的最小精确度大于a</li></ul><h4 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h4><ol><li><p>找到满足指定最小覆盖度（出现次数）的所有属性-值对（attr-val对），这些键值对称为item-sets</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehp3ih42aj30xg0kwwi1.jpg" alt="截屏2020-05-05 上午10.20.09" style="zoom:33%;" /></p></li><li><p>以item-set所列作为限制条件（可以作为关联规则的左边或右边），找出所有的规则，并计算覆盖度coverage和准确度accuracy，以3-item set为例：</p><p><strong>Coverage</strong>：满足“attr=val”的所有实例</p><p><strong>Accuracy</strong> = Coverage / Cases</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehp8w91mwj310o0hegpi.jpg" alt="截屏2020-05-05 上午10.25.17" style="zoom:33%;" /></p></li><li><p>将准确度不满足指定要求的部分去除，比如指定准确率为100%，则只有2个关联规则满足：IF I=no and Risk=High then F=yes</p><p>IF F=yes and I=no then Risk=High </p></li></ol><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p>计算方法：欧几里得距离Euclidean distance</p><p>向量表示：将属性从nominal转化为numerical。可以是一个数字，或者独热的二进制数组。</p><p>通常还需要对向量进行标准化normalise</p><h4 id="聚类和分类"><a href="#聚类和分类" class="headerlink" title="聚类和分类"></a>聚类和分类</h4><p><u>决策树</u>和<u>分类规则</u>将实例（样本）划分到提前确定的分类中。<u>关联规则</u>并不会将实例按照分类划分在一起，而是找到<u>特征</u>或<u>属性</u>之间的连接。</p><p><u>聚类</u>的目的是从原始（未分类）数据中推断出分类，<u>分析聚类</u>则可能发现划分分类的基本机制</p><h4 id="聚类-1"><a href="#聚类-1" class="headerlink" title="聚类"></a>聚类</h4><p>计算方法：欧几里得距离Euclidean distance</p><p>向量表示：将属性从nominal转化为numerical。可以是一个数字，或者独热的二进制数组。</p><p>通常还需要对向量进行标准化normalise</p><h4 id="聚类算法1：K-means"><a href="#聚类算法1：K-means" class="headerlink" title="聚类算法1：K-means"></a>聚类算法1：K-means</h4><ol><li>选择要划分的分类的数量k</li><li>随机选择k个向量（数据集空间中的任意k个点），作为聚类中心centroid</li><li>使用距离函数将数据点划分到最近的聚类中心</li><li>按照划分的k个类，重新计算出k个聚类中心（均值）</li><li>重复34，直到聚类中心不变。</li></ol><h4 id="聚类算法：增量聚类-Incremental-Clustering"><a href="#聚类算法：增量聚类-Incremental-Clustering" class="headerlink" title="聚类算法：增量聚类 Incremental Clustering"></a>聚类算法：增量聚类 Incremental Clustering</h4><p>算法：根据category utility，把每一个实例添加到当前的树中最合适的位置。</p><ul><li>一次添加一个实例，建立树状图</li><li>根据<strong>category utility</strong>，对与每一个新的实例，决定该实例应该划分到哪个簇cluster，或划分为一个新的簇</li><li><strong>category utility</strong>是一个测量方法，用于判断一个簇（部分partition）的好坏，它不需要属性值为数字</li></ul><h4 id="比较Kmeans和增量聚类"><a href="#比较Kmeans和增量聚类" class="headerlink" title="比较Kmeans和增量聚类"></a>比较Kmeans和增量聚类</h4><p>两者都无法保证全局最优</p><p>Kmeans的效果取决于聚类的数量和聚类中心的初始位置</p><p>增量聚类生成可以检查和推理的层次结构</p><p>增量聚类的效果取决于实例被添加的顺序</p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 非监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据通信和存储层（Hadoop分布式文件系统）</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/06%20MESSAGING%20AND%20STORAGE%20LAYER/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/06%20MESSAGING%20AND%20STORAGE%20LAYER/</url>
      
        <content type="html"><![CDATA[<p>介绍Hadoop分布式文件系统的特点和行为</p><a id="more"></a><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><p>Hadoop是包括多个不同产品的完整生态系统，由Apache软件基金会负责</p><p>是开源框架，实现MapReduce，用于处理、存储和分析数据</p><p>最初用于10亿级的网页搜索引擎</p><p>基本原则是将一个大块的数据拆分成多个小块，然后把多个小块分散存储</p><h4 id="Hadoop的基本结构"><a href="#Hadoop的基本结构" class="headerlink" title="Hadoop的基本结构"></a>Hadoop的基本结构</h4><p>Hadoop包括两个方面：</p><ul><li><p>HDFS：Hadoop分布式文件系统</p></li><li><p>MapReduce：集群资源管理和批数据处理</p></li></ul><h4 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h4><blockquote><p>HDFS采用了主从（Master/Slave）结构模型，一个HDFS集群是由一个NameNode和若干个DataNode组成的。其中NameNode作为主服务器，管理文件系统的命名空间和客户端对文件的访问操作；集群中的DataNode管理存储的数据。</p></blockquote><p>HDFS公开文件系统的命名空间，并允许用户数据储存在文件中。HDFS由Java编写，因此只要能运行Java的机器，就能成为NameNode或DataNode</p><p>在内部，一个文件被拆分成1个或多个块blocks，并且这些块被存储在一系列的DataNodes中</p><p>HDFS包括一个NameNode和多个DataNodes：</p><ul><li><p>NameNode：作为主服务器，管理文件系统的命名空间和客户端对文件的访问操作；</p><p>执行文件系统操作，例如打开，关闭和重命名文件/目录。 它确定Block到DataNode的映射（找到所需的Block在哪些DataNodes中）。</p></li><li><p>DataNodes：通常，集群中的每个节点都有一个DataNode，DataNode运行在该节点之上，并管理该节点的存储</p><p>DataNode处理来自文件系统客户端的读写请求。 它们根据NameNode的指令执行块创建，删除和复制。</p></li></ul><p>根据系统偏好设置，DataNode中的块将跨多个节点复制，因此，如果一个DataNode发生故障，则包含所需数据的另一个DataNode会自动联机。</p><h4 id="HDFS-File-Writes"><a href="#HDFS-File-Writes" class="headerlink" title="HDFS File Writes"></a>HDFS File Writes</h4><ol><li>HDFS客户端把一个文件File.txt分成了多个块BlockA B C，</li><li>HDFS客户端发送写文件请求给NameNode，NameNode分配DataNodes，并返回DataNodes的地址</li><li>HDFS客户端直接将文件块写入被分配好的DataNodes</li><li>DataNode会复制数据块到其他DataNode中</li><li>下一个DataNode重复该复制操作</li></ol><p>一个文件被拆分的块blocks越多，那么在并行处理数据时，就有越多的机器可以参与进来</p><p>对于容错，每个块将在被写入时复制。Hadoop的标准是在一个集群中，每个block至少有3个copies（可配置）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u5a70f7j30rs0do77l.jpg" alt="截屏2020-03-24上午3.01.58" style="zoom:50%;" /></p><h4 id="Hadoop-Rack-Awareness-机架感知"><a href="#Hadoop-Rack-Awareness-机架感知" class="headerlink" title="Hadoop Rack Awareness 机架感知"></a>Hadoop Rack Awareness 机架感知</h4><p>机架感知确保每个块Block至少被储存在2个以上的机架Rack中（至少有一个block的备份在不同的机架中）。通过机架感知，我们可以确保数据不会因为整个机架崩溃failure而丢失</p><p>机架感知还可以尽可能让大数据在机架中流动（flows in-rack）：我们认为机架内in-rack有更高的带宽和更低的延迟</p><p>每个从属数据节点DataNode的机架号需要手动定义</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u5wn3soj30t60ciafe.jpg" alt="截屏2020-03-24上午3.02.46" style="zoom:50%;" /></p><h4 id="HDFS-Pipeline-Write-管道写"><a href="#HDFS-Pipeline-Write-管道写" class="headerlink" title="HDFS Pipeline Write 管道写"></a>HDFS Pipeline Write 管道写</h4><ol><li>在HDFS将一个块block写入集群cluster之前，它会确认是否所有需要保存块备份的DataNode都准备好了</li><li>客户端首先连接DataNode1，DN1会询问DN2，DN2会询问DN3（至少有一个DataNode在另一个机架中，不同机架的DataNode需要通过交换机Switch进行连接，同一个机架上的DataNode则通过架顶交换机TOR Switch进行连接）</li><li>如果所有DataNode都准备好了，那么DataNode1会通知客户端</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u7g7td3j30um0lwafy.jpg" alt="截屏2020-03-24上午3.03.57" style="zoom:50%;" /></p><ol><li>每个块被写入集群后，都会创建一个复制管道replication pipeline。<ul><li>意思是，当一个DataNode接受到了block数据，它会同时将block的备份推送到管道的下一个节点中</li><li><strong>机架感知</strong>会在这部分有所体现（机架内intra-rack通信速度更快）</li></ul></li><li>各个管道的初始节点都是不一样的（即两个管道的初始节点不会是同一个）</li><li>Hadoop根据配置的复制因素，使用大量的带宽和存储</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u8rk18ij31qg0j21ak.jpg" alt="截屏2020-03-24上午3.05.27"></p><h4 id="File-Spread-文件传播"><a href="#File-Spread-文件传播" class="headerlink" title="File Spread 文件传播"></a>File Spread 文件传播</h4><ul><li>理想情况下，文件最终应散布在整个机器集群中</li><li>组成文件的块blocks越多，数据可传播到的机器越多，并行处理能力越强，结果越快。</li><li>当群集扩展时，我们的网络需要适当地扩展。 </li><li>提高性能的另一种方法：pre-process some data in the edge</li></ul><h4 id="NameNode监控DataNode"><a href="#NameNode监控DataNode" class="headerlink" title="NameNode监控DataNode"></a>NameNode监控DataNode</h4><ul><li>除了持有文件系统的所有元数据，NameNode还监控DataNodes的运行状况，并协调数据访问</li><li>每3秒，通过TCP，DataNodes发送“心跳heartbeat”消息给NameNode；<ul><li>第10次心跳的消息是block report。这允许NameNode构建其元数据，并确保Block的备份数量是足够的</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u9s5nbuj30qi0aggoi.jpg" alt="截屏2020-03-24上午3.06.30" style="zoom:50%;" /></p><ul><li>如果NameNode没有收到DataNode的心跳消息，那么就会假设DataNode出故障了。</li><li>基于NameNode之前收到的block report，它知道故障的数据节点持有哪个block，因此可以重新备份将该block到其他DataNode中<ul><li>这里再次涉及到<strong>机架感知</strong>（备份在不同的机架上）</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4uawzzyjj30sw0bqaen.jpg" alt="截屏2020-03-24上午3.07.31" style="zoom:50%;" /></p><h4 id="Secondary-NameNode-辅助节点"><a href="#Secondary-NameNode-辅助节点" class="headerlink" title="Secondary NameNode 辅助节点"></a>Secondary NameNode 辅助节点</h4><p>该辅助NameNode定时与主NameNode进行连接（默认是1小时），辅助主节点的元数据（基于内存和基于文件）</p><p>辅助NameNode合并（检查点）上述信息，并将其传递回NameNode，同时为其自身维护副本。</p><p>如果NameNode死亡，则可以使用Secondary NameNode恢复。</p><p>在繁忙的群集中，管理员可以将整理工作设置得更加频繁。</p><h4 id="HDFS客户端读文件"><a href="#HDFS客户端读文件" class="headerlink" title="HDFS客户端读文件"></a>HDFS客户端读文件</h4><p>要读取文件，客户端会查询NameNode并询问文件的块位置。</p><p>对于每个块，NameNode会返回包含该块的DataNode的列表。</p><p>客户端从每个block列表中选择一个DataNode，并使用TCP一次读取一个块。 </p><p>在前一个块完成之前，它不会进行到下一个块。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4ucqx0msj30nm0c6n0e.jpg" alt="截屏2020-03-24上午3.09.21" style="zoom:50%;" /></p><p>有时候DataNode本身也需要从HDFS中读取数据块（比如它需要处理自身没有的数据时）。这时将再次涉及<strong>机架感知</strong>，它将告诉DN最优的网络路由来从其他DN获取数据</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4uhghtkjj30vo0dudks.jpg" alt="截屏2020-03-24上午3.13.52" style="zoom:50%;" /></p><h4 id="DataNode读文件"><a href="#DataNode读文件" class="headerlink" title="DataNode读文件"></a>DataNode读文件</h4><p>有时，DataNode自身可能需要从HDFS中读取一个数据块：比如该节点被要求处理非本地数据。</p><p>该节点的机架感知Rack Awareness 可以提供最优的网络方案（比如优先选择同一机架内节点的block）</p><h4 id="HDFS的特点"><a href="#HDFS的特点" class="headerlink" title="HDFS的特点"></a>HDFS的特点</h4><p><strong>硬件故障 Hardware Failure</strong>：故障检测和快速自动恢复是HDFS的核心架构目标。</p><p><strong>可移植性 Portability</strong>：HDFS被设计为可从一个平台轻松移植到另一个平台。</p><p><strong>大数据集 Large Data Sets</strong>：典型文件的大小应为GB，TB或PB，因此HDFS已调整为支持大文件。 它可以在单个实例中支持数千万个文件。</p><p><strong>流数据访问 Streaming Data Access</strong>：HDFS设计用于批处理，而不是用户交互使用。 重点在于数据的高吞吐量而不是数据访问的低延迟。</p><p><strong>简单一致性模型 Simple Coherency Model</strong>：文件通常只创建和写入一次，不需要更改。 该假设简化了数据一致性问题。 有计划在将来支持对文件的追加写入。</p><p><strong>计算应移至数据 Move Computing To Data</strong>：如果在要处理的数据附近执行计算，效率会大大提高，尤其是在数据量很大时。 HDFS为应用程序提供了使自己更接近数据的接口。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《语音与语言处理》——目录</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/%E3%80%8A%E8%AF%AD%E9%9F%B3%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/%E3%80%8A%E8%AF%AD%E9%9F%B3%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>《Speech and Language Processing》——Dan Jurafsky and James H. Martin</p><p><a href="https://web.stanford.edu/~jurafsky/slp3/" target="_blank" rel="noopener">https://web.stanford.edu/~jurafsky/slp3/</a></p><a id="more"></a><h4 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h4><div class="table-container"><table><thead><tr><th>Chapter</th><th><strong>Slides</strong></th><th><strong>Relation to 2nd ed.</strong></th><th></th></tr></thead><tbody><tr><td>1:</td><td>Introduction</td><td></td><td>[Ch. 1 in 2nd ed.]</td></tr><tr><td>2:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/2.pdf" target="_blank" rel="noopener">Regular Expressions, Text Normalization, and Edit Distance</a></td><td>Text [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/2_TextProc.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/2_TextProc.pdf" target="_blank" rel="noopener">pdf</a>] Edit Distance [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/2_EditDistance.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/2_EditDistance.pdf" target="_blank" rel="noopener">pdf</a>]</td><td>[Ch. 2 and parts of Ch. 3 in 2nd ed.]</td></tr><tr><td>3:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/3.pdf" target="_blank" rel="noopener">Language Modeling with N-Grams</a></td><td>LM [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/LM_4.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/LM_4.pdf" target="_blank" rel="noopener">pdf</a>]</td><td>[Ch. 4 in 2nd ed.]</td></tr><tr><td>4:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/4.pdf" target="_blank" rel="noopener">Naive Bayes Classification and Sentiment</a></td><td>NB [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/7_NB.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/7_NB.pdf" target="_blank" rel="noopener">pdf</a>] Sentiment [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/7_Sent.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/7_Sent.pdf" target="_blank" rel="noopener">pdf</a>]</td><td>[new in this edition]</td></tr><tr><td>5:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/5.pdf" target="_blank" rel="noopener">Logistic Regression</a></td><td></td><td></td></tr><tr><td>6:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/6.pdf" target="_blank" rel="noopener">Vector Semantics and Embeddings</a></td><td>Vector1 [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/vector1.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/vector1.pdf" target="_blank" rel="noopener">pdf</a>] Vector2 [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/vector2.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/vector2.pdf" target="_blank" rel="noopener">pdf</a>]</td><td></td></tr><tr><td>7:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/7.pdf" target="_blank" rel="noopener">Neural Nets and Neural Language Models</a></td><td></td><td>[new in this edition]</td></tr><tr><td>8:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/8.pdf" target="_blank" rel="noopener">Part-of-Speech Tagging</a></td><td></td><td>[Ch. 5 in 2nd ed.]</td></tr><tr><td>9:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/9.pdf" target="_blank" rel="noopener">Sequence Processing with Recurrent Networks</a></td><td></td><td>[new in this edition]</td></tr><tr><td>10:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/10.pdf" target="_blank" rel="noopener">Encoder-Decoder Models, Attention, and Contextual Embeddings</a></td><td></td><td>[new in this edition]</td></tr><tr><td>11:</td><td>Machine Translation</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>12:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/12.pdf" target="_blank" rel="noopener">Constituency Grammars</a></td><td></td><td>[Ch. 12 in 2nd ed.]</td></tr><tr><td>13:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/13.pdf" target="_blank" rel="noopener">Constituency Parsing</a></td><td></td><td>[Ch. 13 in 2nd ed.]</td></tr><tr><td>14:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/14.pdf" target="_blank" rel="noopener">Statistical Constituency Parsing</a></td><td></td><td>[Ch. 14 in 2nd ed.]</td></tr><tr><td>15:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/15.pdf" target="_blank" rel="noopener">Dependency Parsing</a></td><td></td><td>[new in this edition]</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>16:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/16.pdf" target="_blank" rel="noopener">Logical Representations of Sentence Meaning</a></td><td></td><td></td></tr><tr><td>17:</td><td>Computational Semantics and Semantic Parsing</td><td></td><td></td></tr><tr><td>18:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/18.pdf" target="_blank" rel="noopener">Information Extraction</a></td><td></td><td>[Ch. 22 in 2nd ed.]</td></tr><tr><td>19:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/19.pdf" target="_blank" rel="noopener">Word Senses and WordNet</a></td><td></td><td></td></tr><tr><td>20:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/20.pdf" target="_blank" rel="noopener">Semantic Role Labeling and Argument Structure</a></td><td>SRL [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/22_SRL.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/22_SRL.pdf" target="_blank" rel="noopener">pdf</a>] Select [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/22_select.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/22_select.pdf" target="_blank" rel="noopener">pdf</a>]</td><td>[expanded from parts of Ch. 19, 20 in 2nd ed]</td></tr><tr><td>21:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/21.pdf" target="_blank" rel="noopener">Lexicons for Sentiment, Affect, and Connotation</a></td><td>SentLex [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/21_SentLex.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/21_SentLex.pdf" target="_blank" rel="noopener">pdf</a>]</td><td>[new in this edition]</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>22:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/22.pdf" target="_blank" rel="noopener">Coreference Resolution</a></td><td></td><td>[expanded from parts of Ch 21 in 2nd ed]</td></tr><tr><td>23:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/23.pdf" target="_blank" rel="noopener">Discourse Coherence</a></td><td></td><td>[expanded from parts of Ch 21 in 2nd ed]</td></tr><tr><td>24:</td><td>Summarization</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>25:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/25.pdf" target="_blank" rel="noopener">Question Answering</a></td><td></td><td>[expanded from parts of Ch 23 in 2nd ed]</td></tr><tr><td>26:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/26.pdf" target="_blank" rel="noopener">Dialog Systems and Chatbots</a></td><td>Dialog [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/convagents1.pptx" target="_blank" rel="noopener">pptx</a>] [<a href="https://web.stanford.edu/~jurafsky/slp3/slides/convagents1.pdf" target="_blank" rel="noopener">pdf</a>]</td><td>[expanded from Ch 24 in 2nd ed]</td></tr><tr><td>27:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/27.pdf" target="_blank" rel="noopener">Phonetics</a></td><td></td><td></td></tr><tr><td>28:</td><td>Speech Processing</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td>Appendix Chapters (likely just on the web)</td><td></td><td></td></tr><tr><td>A:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/A.pdf" target="_blank" rel="noopener">Hidden Markov Models</a></td><td></td><td></td></tr><tr><td>B:</td><td><a href="https://web.stanford.edu/~jurafsky/slp3/B.pdf" target="_blank" rel="noopener">Spelling Correction and the Noisy Channel</a></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟化：托管模式和裸机模式</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/04_%20%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%9A%E6%89%98%E7%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%B8%E6%9C%BA%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/04_%20%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%9A%E6%89%98%E7%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%B8%E6%9C%BA%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>When choosing a <a href="https://searchservervirtualization.techtarget.com/definition/hypervisor" target="_blank" rel="noopener">virtualization hypervisor</a>, you have to consider both <a href="https://searchservervirtualization.techtarget.com/tip/Virtualization-hypervisor-comparison-Type-1-vs-Type-2-hypervisors" target="_blank" rel="noopener">hypervisor types</a>.</p><p>A virtualization hypervisor comes in one of two forms: a bare-metal hypervisor, also known as Type 1; or a hosted hypervisor, also known as Type 2. There are important differences between a hosted and bare-metal virtualization hypervisor, and each has pretty specific use cases.</p><a id="more"></a><p><strong>Bare-metal virtualization hypervisors</strong></p><p>A bare-metal virtualization hypervisor does not require admins to install a server operating system first. Bare-metal virtualization means the hypervisor has direct access to hardware resources, which results in better performance, scalability and stability. One disadvantage of a bare-metal virtualization hypervisor, however, is that hardware support is typically more limited, because the hypervisor usually has limited device drivers built into it.</p><p>Bare-metal virtualization  is well suited for enterprise data centers, because it usually comes with advanced features for resource management, high availability and security. Admins can centrally manage this kind of virtualization hypervisor, which is critical when you have many hosts in your virtual infrastructure. The most popular bare-metal virtualization hypervisors are:</p><ul><li>VMware ESX and ESXi</li><li><a href="https://searchservervirtualization.techtarget.com/tip/How-the-Hyper-V-architecture-differs-from-VMware-ESXi" target="_blank" rel="noopener">Microsoft Hyper-V</a></li><li>Citrix Systems XenServer</li></ul><h3 id="Hosted-virtualization-hypervisors"><a href="#Hosted-virtualization-hypervisors" class="headerlink" title="Hosted virtualization hypervisors"></a><strong>Hosted virtualization hypervisors</strong></h3><p>Unlike the bare-metal virtualization hypervisor, a hosted hypervisor requires you to first install an OS. These hypervisors are basically like applications that install on a guest OS. This approach provides better hardware compatibility than bare-metal virtualization, because the OS is responsible for the hardware drivers instead of the hypervisor.</p><p>But, as with the bare-metal hypervisor, there are disadvantages. A hosted virtualization hypervisor does not have direct access to hardware and must go through the OS, which increases resource overhead and can degrade virtual machine (VM) performance. Also, because there are typically many services and applications running on the <a href="https://searchvmware.techtarget.com/definition/host-operating-system" target="_blank" rel="noopener">host OS</a>, the hypervisor often steals resources from the VMs running on it.</p><p>Hosted hypervisors are common for desktops, because they allow you to run multiple OSes. These virtualization hypervisor types are also popular for developers, to maintain application compatibility on modern OSes. The most popular hosted virtualization hypervisors are:</p><ul><li>VMware Workstation, Server, Player and Fusion</li><li>Oracle VM VirtualBox</li><li>Microsoft Virtual PC</li><li>Parallels Desktop</li></ul><p>Once you understand the differences between a hosted and bare-metal virtualization hypervisor — and the best use cases for each — it’s time to consider hypervisor vendors, cost and features.</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟化技术：容器</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/05%20%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%9A%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/05%20%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%9A%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>容器技术，VM和Containers，Docker</p><a id="more"></a><h4 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h4><p>虚拟层被认为是Hypervisor或虚拟机监视器 Virtual Machine Monitor</p><h4 id="虚拟机-vs-容器"><a href="#虚拟机-vs-容器" class="headerlink" title="虚拟机 vs 容器"></a>虚拟机 vs 容器</h4><p>容器虚拟化操作系统，而不是硬件</p><p>使用单核来运行多个操作系统的实例，每个实例都在完全隔离的环境中运行，保证了安全性</p><p>比传统的Hypervisor在效率和性能上更好</p><blockquote><p>我们用的传统虚拟机如 <code>VMware</code> ， <code>VisualBox</code> 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><p>而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p></blockquote><h4 id="容器和虚拟机的不同"><a href="#容器和虚拟机的不同" class="headerlink" title="容器和虚拟机的不同"></a>容器和虚拟机的不同</h4><p>容器的更加轻量，性能更好：</p><ul><li>便携性Portability：VM（GB级）Container（MB级），虚拟机受限于Hypervisor和硬件</li><li>性能：容器可以在几秒内启动和重启，虚拟机则需要几分钟；没有Hypervisor和GuestOS，因此减少了容器对的CPU和内存损耗</li><li>管理成本：每个虚拟机实例需要完整的操作系统，因此需要额外的管理</li></ul><p>适合用容器的场景：DevOps运维，批量计算 Batch Computing，微服务 Microservices</p><blockquote><p>DevOps是一种重视“软件开发人员”和“IT运维技术人员”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p></blockquote><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ul><li>容器内部是一个单独的可执行服务，该服务是一个应用的一小部分：微服务</li><li>微服务通过单独一小段可执行代码，提供一个简单的功能</li><li>应用由一系列的微服务组成，每个微服务提供应用整体的一小部分</li><li>单个微服务的多个副本可以在许多容器中运行，并且这些容器通过消息队列或负载平衡链接在一起。</li><li>应用程序本身是为了处理单个容器的故障而构建的，并且每个容器都有自己的微服务软件代码实例。</li><li>相同的微服务的容器运行相同的代码。</li></ul><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>分解为小的部分；松耦合；更容易扩展；易于隔离故障；每个服务可以单独开发和部署；将长周期的开发转为解决一个个技术问题</p><h4 id="容器管理平台"><a href="#容器管理平台" class="headerlink" title="容器管理平台"></a>容器管理平台</h4><p>也称为容器管理者container managers，container orchestration 容器编排 engines (COEs)/platforms，或containers-as-a-service (CaaS) platforms</p><p>用于帮助企业解决部署容器的问题；帮助管理者监控、管理、保护secure、扩展容器，就像是维护虚拟机和服务器一样（doing the same thing as virtualization）</p><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>Docker Engine：轻量级的运行和工具，用于管理容器，镜像，构建物；</p><p>组成包括：</p><ul><li>Docker Daemon 守护线程：在主机上运行；负责执行命令；构建，运行和分发容器；</li><li>Docker Client 客户端：是Docker的终端用户，与用户接口和进行通信，传达终端用户的指令到Docker Daemon；Docker客户端也可以在主机上运行，但是不需要。</li><li>REST API：与Docker线程远程交互</li><li>Dockerfile：由终端用户写命令，以构建Docker镜像</li><li>Docker Images 镜像：是最终用户根据Dockerfile中编写的一组指令构建的只读模板；镜像定义了终端用户打包的应用和相关依赖有哪些，以及当应用启动时需要运行哪些进程</li></ul><h4 id="Docker技术"><a href="#Docker技术" class="headerlink" title="Docker技术"></a>Docker技术</h4><ul><li>Docker容器将应用程序的软件包装到一个看不见的盒子中，其中包含应用程序需要运行的所有内容：包括操作系统，应用程序代码，运行时，系统工具，系统库</li><li>由于映像是只读的，因此Docker在映像的只读文件系统之上添加了一个读写文件系统，以创建一个容器。</li><li>Docker创建一个网络接口，以便容器可以与本地主机通信，将IP地址附加到容器，并执行在定义映像时指定运行应用程序的过程。</li></ul><p><strong>Singularity更安全</strong></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟化</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/04%20%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/04%20%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>虚拟化的实现级别，机器设备级别的虚拟化，基于虚拟机监视器的虚拟化：全虚拟化、半虚拟化、硬件辅助，操作系统级的虚拟化</p><a id="more"></a><h4 id="传统电脑和虚拟机的区别"><a href="#传统电脑和虚拟机的区别" class="headerlink" title="传统电脑和虚拟机的区别"></a>传统电脑和虚拟机的区别</h4><p>对于传统电脑来说，应用安装在电脑的操作系统上，操作系统管理和使用电脑的硬件资源；对于虚拟机来说，虚拟层安装在电脑的主操作系统上，虚拟层能够模拟硬件资源，管理多个虚拟操作系统，而不同客户的软件可以分别安装在不同的虚拟操作系统上。</p><h4 id="虚拟化的定义"><a href="#虚拟化的定义" class="headerlink" title="虚拟化的定义"></a>虚拟化的定义</h4><p>不同的虚拟机VM可以在同一个物理电脑上运行不同的操作系统OS和多个软件</p><p>Hyperviosr虚拟机监视器是主要的虚拟化技术：完全模拟硬件环境</p><ul><li>虚拟机管理者通过仿真（emulation）或者硬件辅助虚拟化（hardware-assisted virtualisation），以透明的方式，分隔物理服务器主机</li></ul><p>虚拟层是底层硬件和系统的虚拟机之间的中间件</p><h4 id="虚拟机的好处——用户角度："><a href="#虚拟机的好处——用户角度：" class="headerlink" title="虚拟机的好处——用户角度："></a>虚拟机的好处——用户角度：</h4><p>更好的利用资源；减少硬件成本；改进容错；扩展容量</p><h4 id="虚拟化的实现级别"><a href="#虚拟化的实现级别" class="headerlink" title="虚拟化的实现级别"></a>虚拟化的实现级别</h4><ul><li>应用程序：将应用程序虚拟化为VM；处理级别的虚拟化；比如.NET JVM CLR</li><li>库（用户级API）：API作为虚拟化的参与者；通过API hooks控制“应用程序与系统其余部分之间”的通信链接；比如：WINE，vCURD</li><li>操作系统：在单个物理服务器和操作系统实例上创建隔离的容器，来使用硬件和软件。比如：OpenVZ</li><li>硬件抽象层HAL（Hardware Abstraction Layer，虚拟化硬件）通过虚拟化来管理硬件（进程、内存、输入输出设备）：VMware、XEN</li><li>指令集结构ISA （Instruction Set Architecture）：通过主机的指令集模拟特定的指令；可以在新的主机上运行过时的二进制 legacy code 代码。比如：QEMU</li></ul><h4 id="机器级别的虚拟化"><a href="#机器级别的虚拟化" class="headerlink" title="机器级别的虚拟化"></a>机器级别的虚拟化</h4><p>2种不同的技术：托管 hosted；裸机 bare metal</p><p>技术的不同取决于所使用的Hypervisor的类型</p><p>目标是创建一个平台，使多个虚拟机可以共享相同的系统资源</p><h4 id="托管模式-Hosted-Approach：Type-2-Hypervisor"><a href="#托管模式-Hosted-Approach：Type-2-Hypervisor" class="headerlink" title="托管模式 Hosted Approach：Type 2 Hypervisor"></a>托管模式 Hosted Approach：Type 2 Hypervisor</h4><p>在主操作系统上运行；Hypervisor是硬件之上的第二层；Guest OS在hypervisor上的一层运行</p><p>比如：VMWare Workstations、Microsoft Virtual PC</p><blockquote><p>Unlike the bare-metal virtualization hypervisor, a hosted hypervisor requires you to first install an OS. These hypervisors are basically like applications that install on a guest OS. </p><p>与裸机虚拟化管理程序不同，托管管理程序<strong>要求您首先安装操作系统</strong>。 这些虚拟机管理程序基本上类似于安装在来宾OS上的应用程序。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5k4kj6qfj30hq0e40to.jpg" alt="截屏2020-05-26 上午1.41.31" style="zoom:33%;" /></p><h4 id="裸机模式-Bare-Metal-Type-1-hypervisor"><a href="#裸机模式-Bare-Metal-Type-1-hypervisor" class="headerlink" title="裸机模式 Bare Metal: Type 1 hypervisor"></a>裸机模式 Bare Metal: Type 1 hypervisor</h4><p>位于裸机计算机硬件上，例如CPU，内存等；所有来宾操作系统都在Hypervisor之上；Hypervisor是硬件之上的第一层</p><blockquote><p>A bare-metal virtualization hypervisor does not require admins to install a server operating system first. Bare-metal virtualization means the hypervisor has direct access to hardware resources, which results in better performance, scalability and stability. </p><p>裸机虚拟化管理程序不需要管理员首先安装服务器操作系统。裸机虚拟化意味着管理程序<strong>可以直接访问硬件资源</strong>，从而获得更好的性能，可伸缩性和稳定性。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5k4zutjdj30hu0c4gmf.jpg" alt="截屏2020-05-26 上午1.42.06" style="zoom:33%;" /></p><h4 id="Hypervisor-虚拟监控程序"><a href="#Hypervisor-虚拟监控程序" class="headerlink" title="Hypervisor 虚拟监控程序"></a>Hypervisor 虚拟监控程序</h4><p>Hyperviosr在客户系统之前展示了一个虚拟的操作平台；监控和管理客户系统和虚拟机的执行；基于Hypervisor的虚拟化技术可以被分为3类</p><h4 id="全虚拟化-Full-Virtualisation"><a href="#全虚拟化-Full-Virtualisation" class="headerlink" title="全虚拟化 Full Virtualisation"></a>全虚拟化 Full Virtualisation</h4><p><strong>全虚拟化和半虚拟化的区别在于，GuestOS是否能意识到自身是虚拟机</strong></p><blockquote><p>完全虚拟化提供底层物理系统的全部抽象化，且创建一个新的虚拟系统，客户机操作系统&gt;可以在里面运行。不需要对客户机操作系统或者应用程序进行修改（客户机操作系统或者应用程序像往常一样运行，意识不到虚拟环境的存在）。半虚拟化需要对运行在虚拟机上的客户机操作系统进行修改（这些客户机操作系统会意识到它们运行在虚拟环境里）并提供相近的性能，但半虚拟化的性能要比完全虚拟化更优越。</p></blockquote><p>通过Hypervisor，使用普通的操作系统（如Windows，Linux，即不需要专门定制）作为来宾OS运行：灵活性！</p><p><strong>Hypervisor完全模拟或仿真基础硬件</strong>：处理所有Guest OS的硬件呼叫</p><p>关键指令由软件通过使用二进制翻译来模拟</p><p>这种二进制翻译方法会降低性能：VMWare、Microsoft Virtual Server</p><h4 id="半虚拟化-Para-Virtualisation"><a href="#半虚拟化-Para-Virtualisation" class="headerlink" title="半虚拟化 Para-Virtualisation"></a>半虚拟化 Para-Virtualisation</h4><p><strong>将一部分虚拟化管理任务从Hypervisor中移交给了Guest OS</strong></p><ul><li><p>需要修改Guest OS以实现以下功能：porting移植</p></li><li><p>Guest OS已显式支持（ported for）Para-Application Program Interface（API）</p><p>需要事先知道：</p><ul><li>将在虚拟平台上运行</li><li>将在哪个特定的Hypervisor上运行</li></ul></li><li><p>在安装到VM之前，要重新编译Guest OS</p></li><li><p>Guest OS与虚拟机的接口，和Guest OS与基础硬件的接口，可以不同</p><ul><li>提供专门定义的“挂钩hooks”以在主机和来宾操作系统中执行某些任务</li></ul></li><li><p>半虚拟化平台中的Hypervisor更简单，因为关键任务现在在操作系统中执行，而不是由Hypervisor执行</p><ul><li>由于虚拟化开销减少，因此性能提高。</li></ul></li><li><p>缺点：</p><ul><li>由于修改了操作系统，降低了兼容性和可移植性；</li><li>由于OS的深层修改，维护成本很高。</li></ul></li></ul><h4 id="硬件辅助虚拟化-Hardware-Assisted-Virtualisation"><a href="#硬件辅助虚拟化-Hardware-Assisted-Virtualisation" class="headerlink" title="硬件辅助虚拟化 Hardware-Assisted Virtualisation"></a>硬件辅助虚拟化 <strong>Hardware-Assisted Virtualisation</strong></h4><p>不需要Hypervisor，虚拟客户操作系统直接与硬件交互</p><ul><li>硬件商专门为支持虚拟化定制的硬件</li><li>处理器中包含虚拟化特性</li><li>允许来Guest OS中的某些特权CPU调用直接由CPU处理：不需要通过Hypervisor对这些调用进行翻译</li><li>比如：AMD虚拟化（AMD-V）、英特尔-虚拟化技术（Intel-VT）</li></ul><h4 id="操作系统级别的虚拟化"><a href="#操作系统级别的虚拟化" class="headerlink" title="操作系统级别的虚拟化"></a>操作系统级别的虚拟化</h4><p>虚拟服务器：由操作系统的共享内核启用；与父系统具有相同的操作系统</p><p>如：FeeBSD jail，Linux Vserver，OpenVZ</p><p>优点：更轻量级</p><h4 id="Hypervisor的定义"><a href="#Hypervisor的定义" class="headerlink" title="Hypervisor的定义"></a>Hypervisor的定义</h4><p>是一个软件层，用于裸机硬件的虚拟化。该层可以被实现为操作系统的微型内核（micro-kernel）。它将物理设备转化为虚拟资源，使用户软件可以运行在虚拟机上</p><h4 id="XEN架构"><a href="#XEN架构" class="headerlink" title="XEN架构"></a>XEN架构</h4><p>特殊的Domain 0用于控制和I/O，其他Guest Domain用于用户的应用</p><h4 id="传统物理机器-vs-3种虚拟机结构"><a href="#传统物理机器-vs-3种虚拟机结构" class="headerlink" title="传统物理机器 vs 3种虚拟机结构"></a>传统物理机器 vs 3种虚拟机结构</h4><ul><li>Physical Machine 物理机器：操作系统以特权模式执行</li><li>Native VM 本地虚拟机：VMM在特权模式下运行</li><li>Hosted VM 托管虚拟机：在【Hosted VM系统】中，受信任的主机OS以特权模式执行。来宾操作系统驻留在虚拟机中，并以较低的特权级别运行</li><li>Dual-mode VM 双模虚拟机：VMM的某些部分在特权模式下运行。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5kmlnm6jj30w20bwq5n.jpg" alt="截屏2020-05-26 上午1.59.05" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监督学习分类器：决策树和分类规则 Decision Trees and Classification Rules</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/06%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E5%99%A8%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E5%88%86%E7%B1%BB%E8%A7%84%E5%88%99/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/06%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E5%99%A8%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E5%88%86%E7%B1%BB%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="数据挖掘的目标"><a href="#数据挖掘的目标" class="headerlink" title="数据挖掘的目标"></a>数据挖掘的目标</h4><p>发现数据中有用的模式，因此我们需要数据挖掘技术、算法、工具（如Weka），和用于采集数据，应用算法的方法学框架（CRISP-DM）</p><p>机器学习中的监督学习：训练集中每个样本都有确定的分类</p><h4 id="概念-Concept"><a href="#概念-Concept" class="headerlink" title="概念 Concept"></a>概念 Concept</h4><p>我们试图通过机器学习来发现一些【概念】，这些概念包括以下类型：</p><ul><li>数据集间的关键区别：比如某区域不同年份的销售额sales的区别</li><li>簇clusters 或自然分隔partitions：根据用户的购物习惯对用户进行分类</li><li><p>分类的规则：Adj+X+Verb =&gt; X=Noun</p></li><li><p>通用的关联：高频词一般是语法性的，而不是有含义的</p></li><li>数字的预测：找到预测数值的规则，比如根据成绩预测毕业生的工资</li></ul><h4 id="决策树的构建方法"><a href="#决策树的构建方法" class="headerlink" title="决策树的构建方法"></a>决策树的构建方法</h4><p>建立决策树</p><p>决定用哪个属性划分节点：基于entropy熵</p><p>避免过度拟合：决策树太复杂，能够精确的描述训练集，但不适合用于预测</p><p>异常点</p><h4 id="建立决策树"><a href="#建立决策树" class="headerlink" title="建立决策树"></a>建立决策树</h4><p>通过训练集进行构建，使用测试集进行评估</p><p>算法是递归的</p><p>节点表示在该属性值上进行分类（测试），分支表示分类（测试）的输出</p><p>决策树算法会选择information gain最高的属性进行划分</p><p>目标：更小更紧凑的树（节点数量少），和更低的错误率（错误划分）；如果精确度相同，那么优先选择更小的树</p><p>如果修剪后的树的错误的概率很小，则可以修剪覆盖率较小的叶节点。</p><h4 id="Entropy-熵"><a href="#Entropy-熵" class="headerlink" title="Entropy 熵"></a>Entropy 熵</h4><p>$H=E(I)=\sum_i(-p_ilog_2p_i)$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Information_Gain &#x3D; Entropy_before - Entropy_after</span><br></pre></td></tr></table></figure><p>ID3会选择information gain最高的属性进行划分</p><p>划分后的熵越低，最后得到的Information gain越高</p><p><strong>该属性中，如果多个分类的数量都一样，那么熵最高；如果只有一个分类，那么熵最低</strong></p><p><strong>所以，如果对一个属性划分后，只有一个种类，那么决策树就会选择该属性进行划分</strong></p><p>计算方式：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gev8r0e57vj30qu0f2dgs.jpg" alt="截屏2020-05-17 上午3.32.00" style="zoom:50%;" /></p><blockquote><p>ID3，C4.5，J48算法详解：<a href="https://cis.temple.edu/~giorgio/cis587/readings/id3-c45.html" target="_blank" rel="noopener">https://cis.temple.edu/~giorgio/cis587/readings/id3-c45.html</a></p></blockquote><h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><p>混淆矩阵</p><p>如果决策树算法已“过度拟合”数据，则基于训练集的错误率将远小于基于测试集的错误率。</p><p>10-fold cross-validation：将数据集随机分成10组（subsets），9组用于训练，1组用于测试，然后循环10次。</p><h4 id="决策树-gt-规则-Rules"><a href="#决策树-gt-规则-Rules" class="headerlink" title="决策树 =&gt; 规则 Rules"></a>决策树 =&gt; 规则 Rules</h4><p>决策树有时候可能不易于被理解：</p><ul><li>与较低节点相关的测试（属性），不得不在树的更远端中读取</li><li>有时可能会将“子概念”分解并分发到树的不同部分</li><li>计算机科学家可能更喜欢“If…then…”规则！</li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>决策树可用于预测或解释。<ul><li>预测：将未分类的实例与树进行比较，并预测其属于哪个类（带有错误估计）</li><li>解释：检查树并尝试了解实例为何最终归入它们所在的类。</li></ul></li><li>规则集通常更易于解释</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 监督学习 </tag>
            
            <tag> 决策树 </tag>
            
            <tag> 分类规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘和知识管理</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/04%20%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>数据挖掘采用机器学习来从数据中发现知识，并对知识进行管理</p><a id="more"></a><h4 id="什么是知识"><a href="#什么是知识" class="headerlink" title="什么是知识"></a>什么是知识</h4><h5 id="柯林斯英语词典"><a href="#柯林斯英语词典" class="headerlink" title="柯林斯英语词典"></a>柯林斯英语词典</h5><ul><li>被一个或一群人所知道的事实、感觉或经验</li><li>知道的状态</li><li>通过经历和学习获得的感知、意识、熟悉感</li><li>博学或者知情的学习</li><li>一个学科的具体信息</li><li>Sexual intercourse (<strong>carnal knowledge</strong>)。。。。。。（我还小我什么都不知道.jpg）</li></ul><h5 id="朗文当代英语词典"><a href="#朗文当代英语词典" class="headerlink" title="朗文当代英语词典"></a>朗文当代英语词典</h5><ul><li>你通过学习或经历获得的事实、技巧、理解</li><li>知道某事发生过或某事是真的</li><li>你有关于特定的状况、事件等的信息</li></ul><h5 id="在知识管理中的知识"><a href="#在知识管理中的知识" class="headerlink" title="在知识管理中的知识"></a>在知识管理中的知识</h5><ol><li>知道或者熟悉的状态（know about）</li><li>行动能力（know how）</li><li>整理、获取、积累-事实、方法、原理、技术</li></ol><h5 id="知识库系统"><a href="#知识库系统" class="headerlink" title="知识库系统"></a>知识库系统</h5><p>除了通过例子，没有办法对知识库系统进行定义，</p><p>知识库：通过事实、逻辑规则来推断新的规则</p><h4 id="Explicit-Knowledge-显性知识"><a href="#Explicit-Knowledge-显性知识" class="headerlink" title="Explicit Knowledge 显性知识"></a>Explicit Knowledge 显性知识</h4><p><strong>以文本形式记录下be articulated（清晰表达）的知识</strong>：产品规格、科学公式、电脑程序、专利、记录的最佳实践、手册。</p><p>可以储存于可以存储在知识库中（如果我们可以解决数据捕获/转换的问题，…）</p><h4 id="Tacit-Knowledge-隐性知识"><a href="#Tacit-Knowledge-隐性知识" class="headerlink" title="Tacit Knowledge 隐性知识"></a>Tacit Knowledge 隐性知识</h4><p><strong>无法以文本形式记录下来（无法清晰表达）的知识</strong>：如何骑单车、如何识别脸、如何理解句子、如何创造艺术</p><p>AI试图将隐性知识改写为显性知识，例如处理英语句子的规则</p><h4 id="Implicit-Knowledge-内含知识"><a href="#Implicit-Knowledge-内含知识" class="headerlink" title="Implicit Knowledge 内含知识"></a>Implicit Knowledge 内含知识</h4><p><strong>可以表达但尚未表达的知识</strong>：培训知识工程师和系统分析员，以识别隐性知识并帮助专家表达其知识。</p><p>可以储存于可以存储在知识库中（如果我们可以解决数据捕获/转换的问题，…）</p><h4 id="Cultural-Knowledge-文化知识"><a href="#Cultural-Knowledge-文化知识" class="headerlink" title="Cultural Knowledge 文化知识"></a>Cultural Knowledge 文化知识</h4><p><strong>（文化或环境带来的知识）</strong></p><p>一个组织对自身及其环境的了解（“元知识”？）：共同的信念，规范和价值观；组织成员在其中构筑现实的框架；需要了解和使用事实，规则和试探法；需要以与其他人相同的方式进行归纳，以便采取一致行动</p><h4 id="Terminology术语-and-Ontology本体"><a href="#Terminology术语-and-Ontology本体" class="headerlink" title="Terminology术语 and Ontology本体"></a>Terminology术语 and Ontology本体</h4><ul><li>本体Ontology：学科中的“概念”，和这些概念之间的意义关系<ul><li>“概念”大致等同于术语Terminology：学科中的专业单词和短语</li></ul></li><li>术语Terminology和本体论对学科中的知识进行编码</li></ul><h4 id="从数据到知识"><a href="#从数据到知识" class="headerlink" title="从数据到知识"></a>从数据到知识</h4><p>信号 Signals =1.=&gt; 数据 Data =2.=&gt; 信息 Information =3.=&gt; 知识 Knowledge</p><ol><li>物理 Physical 构造：感知、选择</li><li>认知 Cognitive 构造：意义、重要性</li><li>信念 Belief 构造：信念、证明</li></ol><h4 id="数据的不同角度（术语解释）"><a href="#数据的不同角度（术语解释）" class="headerlink" title="数据的不同角度（术语解释）"></a>数据的不同角度（术语解释）</h4><p>数据挖掘：发现数据中的模式（知识）</p><p>机器学习：算法，用于发现数据中的知识</p><p>知识发现：发现（数据中的）知识</p><p>数据库：存储知识</p><p>信息管理：使用数据</p><p>知识管理：发现并使用数据中的模式，“驯服数据”</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>数据挖掘不只是关于数据库技术</p><p>数据挖掘包括：获取数据、清洗数据、从数据中提取有用的结构或知识</p><p>数据不仅仅在数据库中</p><p>网络中大多数的数据或信息，是非结构化的文本（HTML/XML标记多少有点帮助）</p><p>所以我们需要提取、清洗、格式化数据，从“网络”的格式转化为“类似于数据库”的格式，用于数据挖掘</p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/05%20MapReduce/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/05%20MapReduce/</url>
      
        <content type="html"><![CDATA[<p>大数据的挑战、MapReduce、Hadoop、例子</p><a id="more"></a><h4 id="大数据的挑战"><a href="#大数据的挑战" class="headerlink" title="大数据的挑战"></a>大数据的挑战</h4><ul><li>大量的数据：数据产生的速度和数据的种类在快速的增长</li><li>数据描述：用于描述内容的媒体数据和语义</li><li>搜索：语义嵌入的搜索引擎</li><li>存储：重建比存储更容易；有用数据和噪音的比例；公司会存储所有类型的数据</li><li>数据采集：信息和知识；质量控制</li></ul><h4 id="解决方案：并行化"><a href="#解决方案：并行化" class="headerlink" title="解决方案：并行化"></a>解决方案：并行化</h4><p>将工作分割处理Partition，然后合并Combine</p><h4 id="并行化的挑战-1"><a href="#并行化的挑战-1" class="headerlink" title="并行化的挑战 1"></a>并行化的挑战 1</h4><ul><li>Scheduling 调度：如何分配任务给不同的worker</li><li>可用性：如果工作单元work units比worker更多该怎么做</li><li>依赖 Dependencies：process 不要相互依赖（并行化的关键）；workers如何共享资源；如何确定所有works的任务都完成了</li><li>容错：如果worker在执行中出错怎么办</li><li>通信和同步：workers之间交换状态state和访问共享资源（如数据）</li></ul><h4 id="当前的工具"><a href="#当前的工具" class="headerlink" title="当前的工具"></a>当前的工具</h4><p>编程模型：共享内存、消息传递</p><p>设计模式：主从（Master-slaves）模式、生产者消费者流模式（Producer-consumer flows）：1.循环；2.工作队列</p><h4 id="并行化的挑战-2"><a href="#并行化的挑战-2" class="headerlink" title="并行化的挑战 2"></a>并行化的挑战 2</h4><p>并发 <strong>Concurrency</strong>：当考虑数据中心的规模，错误，多个服务之间的交互</p><p>负载平衡 <strong>Shifting the burden</strong>：开发人员制定需要执行的计算；处理实际执行任务的执行框架（在运行时）。</p><h4 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h4><p>是一个编程模型，用于在大规模系统中表达分布式计算；是一个用于zu</p><p>怎么把计算任务拆分，分配到不同的处理器中</p><p>Hadoop是MapReduce的开源实现之一</p><h4 id="MapReduce的步骤"><a href="#MapReduce的步骤" class="headerlink" title="MapReduce的步骤"></a>MapReduce的步骤</h4><ol><li>对大量的记录进行迭代</li><li>对每个记录提取感兴趣的信息——Map</li><li>对中间结果进行shuffle和sort</li><li>把中间结果合并为可用的格式，并产生结果——Reduce</li></ol><h4 id="MapReduce模型"><a href="#MapReduce模型" class="headerlink" title="MapReduce模型"></a>MapReduce模型</h4><p><strong>map(k,v)：</strong>Map 把原始数据转化为键值对 <key,val></p><p><strong>reduce(k*,v*)：</strong>Reduce 对键值对组<key,[val, val, ...]>进行处理</p><ul><li>All values with the same key are sent to the same Reducer.把相同Key的值封装在一起</li></ul><p>Shuffle and Sort 把按照键值排序和合并<key,[val, val, ...]>，把相同Key的键值对发送给同一个Reduce进程</p><p>执行框架Execution framework处理其他所有的工作</p><p>其他可编程的部分还有</p><p><strong>partition(k’, number of partition)</strong>：按key将任务拆分，并行处理reduce操作，相同的Key交给相同的Reducer</p><p><strong>combine(k’, v’)</strong>：迷你Reducer，在内存中运行，在map阶段后运行；用于优化，减少网络负载network traffic（减少需要传递的数据）</p><h4 id="运行时-Runtime"><a href="#运行时-Runtime" class="headerlink" title="运行时 Runtime"></a>运行时 Runtime</h4><p>处理调度：将workers分配到Map和Reduce任务中</p><p>处理“数据分布”：将processes移动到data上</p><p>处理同步：采集、排序、重组中间（过渡）数据</p><p>处理错误：检测workers的错误，并重新开始</p><h4 id="分布式文件系统-DFS"><a href="#分布式文件系统-DFS" class="headerlink" title="分布式文件系统 DFS"></a>分布式文件系统 DFS</h4><p>不要移动数据，而是移动workers：将数据存储在集群节点的本地磁盘中，启动该节点中的workers。例子：</p><ul><li><strong>Job Tracker</strong> 查看 <strong>NameNode</strong> 以了解哪些 <strong>DataNode</strong> 具有文件块。然后，<strong>Job Tracker</strong> 为”具有文件块的节点“上的 <strong>Task Tracker</strong> 提供执行Map计算所需的Java代码，让代码在节点本地计算。Job Tracker将始终尝试为Map任务选择具有本地数据的节点。</li></ul><p>原因：memory中的RAM不足以存放所有的数据；磁盘访问很慢，但磁盘的吞吐量是合理的</p><p>解决方案：分布式文件系统：GFS、HDFS</p><h4 id="MapReduce的特征"><a href="#MapReduce的特征" class="headerlink" title="MapReduce的特征"></a>MapReduce的特征</h4><p>Map的输出和Reduce的输入和输出都是<strong>键值对</strong></p><p>任务相互独立：比如不同Map的输出不会相互依赖</p><p>Reduce阶段必须等到Map完成后才会开始</p><p>MapReduce关注调度任务scheduling tasks，对他们进行监控以及对错误的任务重新执行</p><p>数据在MapReduce中是不可改变的，也就是说无法更新</p><h4 id="Hadoop例子"><a href="#Hadoop例子" class="headerlink" title="Hadoop例子"></a>Hadoop例子</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4rwj3cqtj30kk0fkjv2.jpg" alt="截屏2020-03-24上午1.44.31" style="zoom:50%;" /></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ol><li>客户端将MapReduce任务提交给 <strong>Job Tracker</strong></li><li><strong>Job Tracker</strong> 查看 <strong>NameNode</strong> 以了解哪些 <strong>DataNode</strong> 具有 file blocks文件块。</li><li>然后，<strong>Job Tracker</strong> 为”具有文件块的节点“上的 <strong>Task Tracker</strong> 提供执行Map计算所需的Java代码，让代码在节点本地计算</li><li><strong>Task Tracker</strong>启动Map任务并监视其进度。 它将心跳和任务状态返回给<strong>Job Tracker</strong>。</li><li>每个Map任务完成时，其节点将结果存储在临时存储区中（中间数据 <strong>intermediate data</strong>）。</li><li>当所有Map都完成后，它将通过网络发送到运行reduce任务的节点</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4rx2v3fmj30me0d0dip.jpg" alt="截屏2020-03-24上午1.45.02" style="zoom:50%;" /></p><ul><li>Job Tracker将始终尝试为Map任务选择具有本地数据的节点。这可能做不到（例如，具有本地数据的节点可能已经在运行许多其他任务）</li><li>在这种情况下，Job Tracker将尝试尽可能将任务分配给与数据位于同一机架中的节（使用机架感知 Rack Awareness）。</li><li>NameNode将指示节点从相关DataNode复制数据。</li></ul><h5 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h5><ol><li>Job Tracker在集群中的任何节点上启动Reduce任务</li><li>它引导Reduce任务从“所需的每个已完成的Map任务”复制中间数据<strong>intermediate data</strong>。</li><li>如果Map任务几乎立即响应，那么网络会过载。</li><li>为了解决这个问题，群集网络很重要：交换机具有良好的内部流量管理功能和缓冲区（ <strong>good internal traffic management capabilities and buffers</strong>）</li><li>Reducer任务的输出将写入HDFS（拆分为块，管道复制等）</li><li>Hadoop支持：“在需要时合并多个Reduce Task jobs”的方法</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4sboduzkj30ky0ceacw.jpg" alt="截屏2020-03-24上午1.59.06" style="zoom:50%;" /></p><h4 id="Facebook例子——共同好友"><a href="#Facebook例子——共同好友" class="headerlink" title="Facebook例子——共同好友"></a>Facebook例子——共同好友</h4><p>共同好友列表的数据改变频率不高，所以我们可以用MapReduce来计算所有人的共同好友并储存结果，每天一次</p><p>当有人访问时，就可以展示结果</p><ol><li>Map：对于一个人A的好友列表，可以通过Map转换为，A与列表中每个好友分别组成键，其好友为值</li><li>排序和重组</li><li>Reduce：相同键所包含的列表中，如果值有相同，那么说明相同的值就是他们的共同好友</li><li>最后将结果输出到HDFS（Hadoop分布式文件系统）中</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>它是为<strong>批量处理</strong>设计的，但不适合实时处理，不适合处理大数据的“高速high velocity”特征，即缺乏可靠的实时处理能力</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> MapReduce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分类和目标检测——介绍</title>
      <link href="/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/02%20Image%20classification%20and%20object%20detection/"/>
      <url>/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/02%20Image%20classification%20and%20object%20detection/</url>
      
        <content type="html"><![CDATA[<p>包括以下内容：</p><p>目标检测的难点, 视频比特率计算, 混淆矩阵, AUC, precision, recall, Bounding-box, 人脸识别, Softmax, 激活函数, 线性分类器</p><a id="more"></a><h4 id="目标检测Object-Detection的难点"><a href="#目标检测Object-Detection的难点" class="headerlink" title="目标检测Object Detection的难点"></a>目标检测Object Detection的难点</h4><ul><li>拍摄视角和环境亮度的变化</li><li>同类别物品的差异</li><li>形状畸变 Shape deformation</li><li>其他环境物品和背景的干扰</li></ul><h4 id="标准视频的比特率-bit-rate"><a href="#标准视频的比特率-bit-rate" class="headerlink" title="标准视频的比特率 bit rate"></a>标准视频的比特率 bit rate</h4><p>640×480 解析度，3色，颜色编码 8 bit (0-255)，每秒25帧(25 frames per second)</p><p>Data rate：<script type="math/tex">640*480*3*8*25=184,000,000</script>  bits/seconds</p><h4 id="混淆矩阵-Confusion-matrix"><a href="#混淆矩阵-Confusion-matrix" class="headerlink" title="混淆矩阵 Confusion matrix"></a>混淆矩阵 Confusion matrix</h4><p>对角线为正确分类：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ges4pgnswdj30gs07kwff.jpg" alt="截屏2020-05-14 上午10.55.49" style="zoom:50%;" /></p><p><strong>Recall</strong>：表示有多少目标被找到：分母是所有实际为真的对象（找错了不影响，只要找到了就行）</p><p><strong>Precision</strong>：表示找到的目标中有多少是正确的：分母是所有预测为真的对象（没找到的不影响，只要找对就行）</p><h4 id="权衡-Precision-和-Recall"><a href="#权衡-Precision-和-Recall" class="headerlink" title="权衡 Precision 和 Recall"></a>权衡 Precision 和 Recall</h4><p>比如我们可以保证100%的precision，但这要求更严格的预测规则，也就是说会将许多不确定的目标排除在外，这部分目标中可以也有正确的值，因此会导致recall下降；同理，提高recall，则会将许多不确定的目标包含进来，其中不仅包括正确的目标，也包括错误的目标，因此会降低precision。</p><p>比如下图中：数据集有5把吉他和5把班卓琴。假设有一个吉他分类器，分类器重复进行了10次分类，第N次预测是将前N个目标都预测为吉他。比如第10次测试，将所有10个目标都分类为吉他：则其中有5个分类错误，因此precision为0.5，但所有的5个吉他都找出来了，因此recall为1。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ges5obgjooj30ek0hwq7e.jpg" alt="截屏2020-05-14 上午11.29.22" style="zoom: 50%;" /></p><p>可以通过调节预测规则，即分类器的阈值，来生成一条曲线：precision-recall curve。可以通过曲线下的面积Area Under the Curve (AUC)来评估分类器的表现，面积越大（越接近1）表示分类器的效果越好。</p><blockquote><p>在比较两种学习器的时候，如果一个被另一个完全包住，那么大的那个好。如果两个有交叉，一般而言，面积大的那个好。当然不排除有具体的案例，需要根据代价敏感性（对于查全查准）的特殊需求，来比较。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ges5kk7b7uj30am09kt98.jpg" alt="截屏2020-05-14 上午11.25.48" style="zoom:50%;" /></p><h4 id="MNIST数据集"><a href="#MNIST数据集" class="headerlink" title="MNIST数据集"></a>MNIST数据集</h4><p>有7万个手写的数字，每个数字都是28*28像素的图像，共10个类别。</p><h4 id="CIFAR-10"><a href="#CIFAR-10" class="headerlink" title="CIFAR-10"></a>CIFAR-10</h4><p>共10个类别的图像集，每个类别有6000张图片，图像大小为32*32像素。</p><h4 id="CIFAR-100"><a href="#CIFAR-100" class="headerlink" title="CIFAR-100"></a>CIFAR-100</h4><p>共100个类别的图像集，每个类别有600张图片，图像大小为32*32像素。</p><h4 id="物体探测中的【大规模视觉识别挑战LSVRC】"><a href="#物体探测中的【大规模视觉识别挑战LSVRC】" class="headerlink" title="物体探测中的【大规模视觉识别挑战LSVRC】"></a>物体探测中的【大规模视觉识别挑战LSVRC】</h4><p>对578482个图像中的200个分类的物体进行识别并框出，如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gesk40z2yzj30na0budrr.jpg" alt="截屏2020-05-14 下午7.48.52" style="zoom:33%;" /></p><h4 id="目标检测的效果"><a href="#目标检测的效果" class="headerlink" title="目标检测的效果"></a>目标检测的效果</h4><p>对于物体探测，我们使用precision和recall来衡量。</p><p>注意，我们在测量中不会使用True Negative，因为图像窗口的大部分都是没被Bounding-box框选中的目标。</p><p>我们使用 mean Average Precison （其中分母为200）。</p><h4 id="Acceptable-Bounding-box"><a href="#Acceptable-Bounding-box" class="headerlink" title="Acceptable Bounding-box"></a>Acceptable Bounding-box</h4><p>Area Of Overlap (AO)：$AO=\frac{轮廓的交集}{轮廓的并集}（真实物体的轮廓和预测物体的轮廓）$，即$AO(B_{gt},B_p)=|\frac{B_{gt}\cap B_p}{B_{gt}\cup B_p}|$</p><p>当<script type="math/tex">AO>0.5</script>时为合格。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geskgjghqzj30cy0cmdg6.jpg" alt="截屏2020-05-14 下午8.00.55" style="zoom: 33%;" /></p><h4 id="2013-2017目标检测的效果的进步"><a href="#2013-2017目标检测的效果的进步" class="headerlink" title="2013-2017目标检测的效果的进步"></a>2013-2017目标检测的效果的进步</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geskj53lm0j30zm0i2aej.jpg" alt="截屏2020-05-14 下午8.03.24" style="zoom:33%;" /></p><h4 id="目标检测中的常用分类器"><a href="#目标检测中的常用分类器" class="headerlink" title="目标检测中的常用分类器"></a>目标检测中的常用分类器</h4><p>使用遮罩对窗口进行完整扫描，对于同一个目标，只选择探测效果最好的遮罩框，因为在LSVRC中，对同一个目标得到多个探测结果将受到处罚</p><p><img src="../../../../../Library/Application Support/typora-user-images/截屏2020-05-14 下午8.12.16.png" alt="截屏2020-05-14 下午8.12.16" style="zoom:33%;" /></p><h4 id="早期的人脸识别"><a href="#早期的人脸识别" class="headerlink" title="早期的人脸识别"></a>早期的人脸识别</h4><p>Viola and Jones, CVPR 2001，非深度学习算法，而是基于特征的简单算法，分类速度十分快，它能得到较好的分类效果的原因是因为它的数据库十分庞大。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gesl27z0cpj30y40fgwqi.jpg" alt="截屏2020-05-14 下午8.21.43" style="zoom:50%;" /></p><h4 id="用于二维特征的线性分类器-Linear-classifier"><a href="#用于二维特征的线性分类器-Linear-classifier" class="headerlink" title="用于二维特征的线性分类器 Linear classifier"></a>用于二维特征的线性分类器 Linear classifier</h4><p>找到一条直线使两个数据集线性可分。最终将扩展为【<a href="https://blog.csdn.net/u011848397/article/details/102598084" target="_blank" rel="noopener">感知机</a>】和【<a href="https://blog.csdn.net/u011848397/article/details/102733351" target="_blank" rel="noopener">多层感知机</a>】。</p><p>【感知机】的思想就是：找到一条直线，使得两个集合的所有点<u>线性可分</u>。在这个过程中，可能会有点被错误分类，即<u>误差点</u>，错误点到直线的距离为<u>损失或误差</u>，建立【损失函数】。这时可以使用【梯度下降】的原理<u>最大程度的降低损失</u>，更新直线（权重）。不断重复这个过程，最终将得到该直线。</p><p>【多层感知机】实际上就是将多个感知机组合在一起，形成多层，从而支持对多个集合进行划分。由于增加了了多个隐藏层，因此训练过程中，使<u>误差</u>对每一个隐藏层代表的直线进行更新的计算过程就会更加复杂，该过程被称为【误差的反向传播——BP算法】，核心思想依旧是使用【梯度下降】更新权重。</p><blockquote><p>经典的多层感知机（Multi-Layer Perceptron）形式上是全连接（fully-connected）的邻接网络（adjacent network）。</p><p>全连接的多层感知机中，输入视为（或者需转化为）一个列向量。</p><p>在卷积神经网络中，以手写字符识别为例，输入不再 reshape 为 (28*28, 1) 的列向量，而是作为 28×2828×28 的像素灰度矩阵。</p><p>对于CNN，BP中更新的权重不仅包括全连接层的权重，还包括卷积层的卷积核</p></blockquote><h4 id="Softmax-function"><a href="#Softmax-function" class="headerlink" title="Softmax function"></a>Softmax function</h4><p>维度归一化，且所有维度之和为1</p><p>softmax设计的初衷，是希望特征对概率的影响是乘性的。</p><p>我们希望分值大的那一项被经常取到，而分值较小的那一项也有一定的概率偶尔被取到，所以我们就应用到了soft的概念，即最后的输出是每个分类被取到的概率。</p><h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>比如：非线性激活函数 RELU（ Rectified Linear Unit），它的基本思想是将注意力集中在正值。</p><p>一个线性方程的线性方程还是线性方程，所以线性方程的多层感知机实际上还是单层的，所以需要非线性的激活函数（激活函数的输入是上一层神经元输出的加权求和，输出是神经元的输入）</p><p>多层感知机中建立神经元的方式是一样的，但权重是不同的</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混淆矩阵 </tag>
            
            <tag> 目标检测的难点 </tag>
            
            <tag> 视频比特率计算 </tag>
            
            <tag> AUC </tag>
            
            <tag> precision </tag>
            
            <tag> recall </tag>
            
            <tag> Bounding-box </tag>
            
            <tag> 人脸识别 </tag>
            
            <tag> Softmax </tag>
            
            <tag> 激活函数 </tag>
            
            <tag> 线性分类器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CNN卷积神经网络进行图像识别</title>
      <link href="/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/03%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN/"/>
      <url>/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/03%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="卷积-Convolution"><a href="#卷积-Convolution" class="headerlink" title="卷积 Convolution"></a>卷积 Convolution</h4><ol><li><p>将三通道的彩色图片转化为单通道的【灰度图片】，即对每个像素的三通道求平均值<script type="math/tex">f=\frac{r+g+b}{3}</script></p><ul><li>在卷积操作中，分别对三通道进行卷积，然后将结果相加</li></ul></li><li><p>【平滑图像】以去除小规模的细节。</p><ul><li><p>使用一个3*3（或任何大小）的遮罩窗口，以某像素为中心的窗口范围内的加权值（比如平均值），代替该像素原本的像素值。该操作被称为【互相关cross-correlation】</p><blockquote><p>注意，【卷积】和【互相关】的区别在于，卷积是将【互相关】的遮罩进行180度的反转。</p><p>在机器学习中，使用所谓【卷积核（遮罩窗口）】在提取特征时，使用的是【互相关】的操作。而在后面的反向传播更新权重时，才是真正的【卷积】，也就是将卷积核进行水平垂直翻转，再进行加权求和。</p><p>当遮罩窗口是对称的时，【卷积】与【互相关】等价。</p></blockquote></li><li><p>当使用3*3的窗口时，<script type="math/tex">u,v\in [-1,1]</script>；当使用5*5的窗口时，<script type="math/tex">u,v\in [-2,2]</script>；<script type="math/tex">u,v</script> 代表着周围像素的相对位置索引</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gesqx4bojcj30t80bodil.jpg" alt="截屏2020-05-14 下午11.44.25" style="zoom: 50%;" /></p><ul><li>如果我们的目标是平滑图像，那么选择合适的权重很重要。</li></ul></li><li><p>移动遮罩窗口有多种方式：</p><ul><li><p>【No Padding】，输出的图像会比原图像缩小，比如3*3的窗口会导致原图像上下左右各减少一排像素。</p></li><li><p>【Zero Padding】，在最外侧填充一圈0像素，保证输出图像与原图像大小一致</p></li><li><p>【Stride步长】，即移动遮罩窗口的距离，步长为1，则每次移动一格像素。当步长为2时，输出图像大小变为原来的一半</p></li><li><p>【Dilation扩大】，即放大遮罩窗口到原图像上的映射间隔。如右下图</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getaq7ww1lj30mk0dgn1x.jpg" alt="截屏2020-05-15 上午11.09.43" style="zoom:33%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getar0wf71j30r40f8n3o.jpg" alt="截屏2020-05-15 上午11.10.32" style="zoom: 33%;" /></p></li></ul></li></ol><h4 id="Gaussian-mask-高斯模糊遮罩"><a href="#Gaussian-mask-高斯模糊遮罩" class="headerlink" title="Gaussian mask 高斯模糊遮罩"></a>Gaussian mask 高斯模糊遮罩</h4><blockquote><p>图像的高斯模糊过程就是图像与<a href="https://zh.wikipedia.org/wiki/正态分布" target="_blank" rel="noopener">正态分布</a>做卷积，由于正态分布又叫作“高斯分布”，所以这项技术就叫作高斯模糊。</p><p>高斯模糊是一种图像模糊<a href="https://zh.wikipedia.org/wiki/濾波器" target="_blank" rel="noopener">滤波器</a>，它用<a href="https://zh.wikipedia.org/wiki/正态分布" target="_blank" rel="noopener">正态分布</a>计算图像中每个像素的<a href="https://zh.wikipedia.org/w/index.php?title=变换&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">变换</a>。</p></blockquote><p>每个像素的值都是周围相邻像素值的<a href="https://zh.wikipedia.org/wiki/加權平均" target="_blank" rel="noopener">加权平均</a>。</p><p>如果目标是彩色图像，可以对每个颜色通道单独计算。</p><p>为了保证处理后的图像不会变得更亮或更暗，需要对遮罩的权重进行标准化，即遮罩窗口的权重之和为1，方法是对遮罩中的每个权重都除以遮罩窗口的总权重。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getbfyp0swj307a01c745.jpg" alt="截屏2020-05-15 上午11.34.31"></p><p>其中<script type="math/tex">u,v</script>表示遮罩窗口的大小；<script type="math/tex">\sigma</script>控制权重散布的范围，<script type="math/tex">\sigma</script>越大，则正太分布的范围越大，边缘的权重值越高，中间的权重值越低，原像素点受到周围像素的影响越大，图像越模糊。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getbk1fsswj30ao0a63zg.jpg" alt="截屏2020-05-15 上午11.38.26" style="zoom: 50%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getblp16k7j30qm0em7br.jpg" alt="截屏2020-05-15 上午11.39.44" style="zoom: 67%;" /></p><h4 id="局部对比度归一化-Local-Contrast-Normalisation"><a href="#局部对比度归一化-Local-Contrast-Normalisation" class="headerlink" title="局部对比度归一化 Local Contrast Normalisation"></a>局部对比度归一化 Local Contrast Normalisation</h4><p>该技术用于移除整张图像像素的大范围变动。通过减去邻近像素的平均值并除以邻近像素的标准差来修改每个像素。</p><blockquote><p>如果我们有一个场景，包含了一个大的黑暗区域和一个大的明亮的区域（例如一个城市广场有一半的区域处于建筑物的阴影之中），则全局对比度归一化将确保暗区域的亮度与亮区域的亮度之间存在大的差异。然而，它不能确保暗区内的边缘突出。</p><p>局部对比度归一化更多地改变了图像，丢弃了所有相同强度的区域这使，得模型能够只关注于边缘。</p></blockquote><p>有原图A，对其进行平滑后得到图像B，B的每个像素都是A的局部像素的平均值。通过<script type="math/tex">A-B</script> 得到图像C，C展示了图像的细节。</p><ul><li>在图像B中，原图光亮的部分对应的值比较高，黑暗的部分对应的值比较低</li><li>将A-B后，所得到的C可能是正值也可能是负值（像素点周围的值很大，本身的像素值很小）。<ul><li>为了可视化该步骤图像，假设C中所有的像素值都在[-b,b]之间，可以将所有的像素值缩放到[0,1]之间。</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getiemz1a4j30l60gaq8q.jpg" alt="截屏2020-05-15 下午3.35.00" style="zoom:50%;" /></p><ul><li>由于图像C的值有正负，于是对每个像素，将对应的遮罩窗口拉成向量，然后计算该向量到原点的欧式距离（平方之和再开方），得到图像D<ul><li>缩放后可视化如下图</li></ul></li><li>将图像C的每个像素除以图像D的对应像素，得到最终输出。注意，如果D中的像素值为0，则用一个大于0的数代替，比如1。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getpdv454oj30os0hg45x.jpg" alt="截屏2020-05-15 下午7.36.52" style="zoom: 50%;" /></p><blockquote><p>对输入图像的每一个像素，我们计算其邻域（例如3x3窗口）的均值，然后每个像素先减去这个均值，再除以这个邻域窗口（例如3x3窗口）拉成的9维向量的欧几里德范数（如果这个范数大于1的时候才除：这个约束是为了保证归一化只作用于减少响应（除以大于1的数值变小），而不会加强响应（除以小于1的数值变大））。也有论文在计算均值和范数的时候，都加入了距离的影响，也就是距离离该窗口中心越远，影响越小，例如加个高斯权重窗口（空间上相邻的像素点的相关性随着距离变大而变小）。</p></blockquote><h4 id="学习图像特征"><a href="#学习图像特征" class="headerlink" title="学习图像特征"></a>学习图像特征</h4><p>学习图像特征，也就是从图片中自动发现局部特征，使用这些学习到的特征来构建特征地图。</p><p>人脑会适应从视觉中观察到的物体特征，这一过程称之为学习。神经元的这一属性称为可塑性 plasticity。</p><p>我们的目的是建立【可塑性】的计算模型，也就是学习如何检测图像特征。该步骤很简单，就是从图像中提取上千个n*n大小的小块：</p><ol><li><p>数据采集：采样大量图像补丁patch（例如20,000个15x15补丁）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geurvpkgktj30sq0buahe.jpg" alt="截屏2020-05-16 下午5.48.40" style="zoom:50%;" /></p></li><li><p>聚类：将二维向量转化为一维向量（该步骤称为：vectorizing the patch），在此向量空间中查找聚类，这些聚类定义了不同的特征。比如使用K-means，可以使上图的特征集最终被划分为9种类型。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geus3nvk2kj30rg0a80ud.jpg" alt="截屏2020-05-16 下午5.56.24" style="zoom:50%;" /></p></li></ol><h4 id="特征图"><a href="#特征图" class="headerlink" title="特征图"></a>特征图</h4><p>用图像特征（过滤器）过滤图像，对匹配的部分进行上色。原图的特征图如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geus5f1rqrj30qu09kmzw.jpg" alt="截屏2020-05-16 下午5.58.08" style="zoom:33%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geusdpjf1hj30ia0dsgr7.jpg" alt="截屏2020-05-16 下午6.06.05" style="zoom:50%;" /></p><p>这里的特征图与CNN中的特征图意思不同，CNN的特征地图指的是经过卷积核得到的卷积层的输出，这里的特征地图指的根据不同聚类中心的距离划分出来的特征图。简单来说就是使用的方法不一样。<strong>一个是CNN用卷积核进行卷积（互相关），一个这里是分块后聚类。</strong></p><p>局部对比度均一化后的特征图如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geusgo5aqzj30qc092n13.jpg" alt="截屏2020-05-16 下午6.08.54" style="zoom:50%;" /></p><p>对比：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geusgvj7zqj30os0gytpe.jpg" alt="截屏2020-05-16 下午6.09.08" style="zoom: 50%;" /></p><h4 id="使用词袋-Bag-of-Words-进行图像分类"><a href="#使用词袋-Bag-of-Words-进行图像分类" class="headerlink" title="使用词袋 Bag of Words 进行图像分类"></a>使用词袋 Bag of Words 进行图像分类</h4><p>具体思想：假设数据集是带有标签的图像。使用上述方法，提取训练集的特征图，并进行聚类，将划分后的各个分类称为<strong>codeword</strong>。我们可以计算每个图像包含的codeword的数量。然后使用标准的分类器，对图像进行分类。这是CNN出现前最前沿的图像识别方法（Csurka et al. 2004）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geusk31eg3j30s40kyqc3.jpg" alt="截屏2020-05-16 下午6.12.13" style="zoom:50%;" /></p><p>缺点：“词袋”在构建直方图时会失去空间排列。CNN的卷积模型对此作出了改进</p><h3 id="对于卷积网络中的单层"><a href="#对于卷积网络中的单层" class="headerlink" title="对于卷积网络中的单层"></a>对于卷积网络中的单层</h3><h4 id="权值共享"><a href="#权值共享" class="headerlink" title="权值共享"></a>权值共享</h4><p>一个卷积层的一个卷积核，将应用于图像的所有窗口位置。换句话说，卷积核在图像中移动时，权重不变。</p><h4 id="ReLU激活函数"><a href="#ReLU激活函数" class="headerlink" title="ReLU激活函数"></a>ReLU激活函数</h4><p>rectified linear activation function（ReLU），该算法的关键思想是让感知机专注于strong response</p><blockquote><p>线性整流函数（Rectified Linear Unit, ReLU），又称修正线性单元，是一种人工神经网络中常用的激活函数（activation function），通常指代以斜坡函数及其变种为代表的非线性函数：即对于输入的负值，输出全为0，对于正值，则原样输出</p></blockquote><h4 id="RGB图像"><a href="#RGB图像" class="headerlink" title="RGB图像"></a>RGB图像</h4><p>对于RGB图像，每个颜色通道都使用不同的卷积核，经过ReLU，最后将3个输出相加，得到最终的特征图。</p><h3 id="卷积神经网络-Convolutional-Neural-Network-CNN"><a href="#卷积神经网络-Convolutional-Neural-Network-CNN" class="headerlink" title="卷积神经网络 Convolutional Neural Network, CNN"></a>卷积神经网络 Convolutional Neural Network, CNN</h3><p>CNN全连接层输出的每一个值，都是通过如下方式进行计算，一个输出值对应一个神经元。</p><blockquote><p>思考：假设对于每一个图像，卷积层最终输出为128个10*10的特征图像，拉长后变为128维的向量，对于全连接层来说，有12800个输入参数，最终输出为10个分类，中间可以再添加一层全连接层，比如12800-&gt;512-&gt;10。其中512是我们通过经验或调参得出的数值，是否有方法，可以基于12800*N个参数（N为图像数量），发现潜在的聚类数量，比如x，使得12800-&gt;x-&gt;10。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geut29yssgj30oc07cab1.jpg" alt="截屏2020-05-16 下午6.29.43"></p><h4 id="Pooling-池化"><a href="#Pooling-池化" class="headerlink" title="Pooling 池化"></a>Pooling 池化</h4><p>池化就是将输入图像进行缩小，减少像素信息，只保留重要信息，能有效地减少计算量<br>池化的操作也很简单，通常情况下，池化区域是2*2大小，然后按一定规则转换成相应的值，例如取这个池化区域内的最大值（max-pooling）、平均值（mean-pooling）等，以这个值作为像素值。</p><h4 id="CNN的模型结构"><a href="#CNN的模型结构" class="headerlink" title="CNN的模型结构"></a>CNN的模型结构</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geuw7gtgthj30f9052wen.jpg" alt="截屏2020-05-16 下午8.17.53"  /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geuzz7x8kvj30q60hydli.jpg" alt="截屏2020-05-16 下午10.28.55" style="zoom: 50%;" /></p><p>第一个卷积层中，<script type="math/tex">32*32*32</script>中的第一个32表示32个卷积核，后面两个32表示图像大小</p><p>参数量 =（前一层特征图的通道数 <em> 卷积核大小 ）</em> 当前层卷积核数量 + 偏置项数量（当前层卷积核数量）</p><p><a href="https://zhuanlan.zhihu.com/p/77471991" target="_blank" rel="noopener">具体计算方式</a></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>选择数据集</li><li>将数据集拆分为训练集和测试集<ul><li>为了防止【过拟合】，还需要把训练集拆分为训练集和验证集</li></ul></li><li>选择损失函数（如何测量模型）<ul><li>模型学习的过程是：迭代更新weight和bias，以最小化损失函数</li></ul></li><li>调整参数（最小化训练集loss）</li><li>评估模型（使用测试集）</li></ol><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于分类任务，分类器的输出是一个【概率分布】。对于图像x，它分类y的概率为<script type="math/tex">p(y|x;\theta)</script></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geuwqlfmzmj30rk086tbb.jpg" alt="截屏2020-05-16 下午8.36.53"></p><p>对于深度神经网络，我们的目标是找到一组参数，使得【likelihood cost function】<strong>最大化</strong>，其中<script type="math/tex">x^i</script>是输入，<script type="math/tex">y^i</script>是对应分类的独热编码，<script type="math/tex">\theta</script>表示模型的参数</p><ul><li>我们称该乘积为【似然likelihood】而不是【概率probability】，是因为该变量的所有值之和并不为1</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geuyu7dqp3j30sc0aydjq.jpg" alt="截屏2020-05-16 下午9.49.31" style="zoom:50%;" /></p><h4 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h4><p>由0，1组成的二维数组，数组的长度是分类的数量，1表示数据的标签为该分类，0表示否。</p><p>(标签1,2,3,4) &lt;=&gt; [0,1,0,0]</p><h4 id="negative-log-likelihood-loss-和-cross-entropy-loss"><a href="#negative-log-likelihood-loss-和-cross-entropy-loss" class="headerlink" title="negative log likelihood loss 和 cross-entropy loss"></a>negative log likelihood loss 和 cross-entropy loss</h4><p>在【输出】一节中提到，我们的目标是最大化<script type="math/tex">\prod p(y|x;\theta)</script>，即<script type="math/tex">argmax_\theta(\prod p(y|x;\theta))</script>。由于取对数log不会改变<script type="math/tex">\theta</script>的最大值（log是单调递增的），因此我们可以将乘积操作改为求和操作（根据公式<script type="math/tex">log(ab)=log(a)+log(b)</script>），最后一个式子称为【交叉熵损失】或【负对数似然损失】。</p><blockquote><p>注意，negative log likelihood loss 和 cross-entropy loss，在pytorch中的实现是不同的：</p><p>Technical note that can be ignored: Averaging log probability over the dataset is equal to the expected value over the data distribution. Hence the cross-entropy is between the data distribution and the model. Note that in PyTorch the losses differ since nn.NLLLoss takes log probabilities as input and averages (assuming “mean” default is used), whereas nn.CrossEntropyLoss takes raw confidence values as input and starts out by applying nn.LogSoftMax.</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geuzl1ept3j30rc0k2n30.jpg" alt="截屏2020-05-16 下午10.15.17" style="zoom:50%;" /></p><h4 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h4><p>我们可以对图像进行微小的旋转和平移，来扩充数据。更大的数据集，能够提高模型的准确率。</p><h4 id="特征图像"><a href="#特征图像" class="headerlink" title="特征图像"></a>特征图像</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geuzuhi15pj30li0aa0v3.jpg" alt="截屏2020-05-16 下午10.24.23" style="zoom:50%;" /></p><p>注意，对于RGB图像，三个通道的卷积核是不同的，最后叠加为一个特征图像。</p><p>关于卷积核（滤波器）与通道数（特征图像数量）的关系：</p><blockquote><p>实际上，真实的情况是，卷积过程中，输入层有多少个通道，滤波器就要有多少个通道，但是滤波器的数量是任意的，滤波器的数量决定了卷积后 feature map 的通道数。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf3g2milxcj30nn0dkmxr.jpg" alt="截屏2020-05-24 上午5.50.19" style="zoom:50%;" /></p><p><a href="https://blog.csdn.net/briblue/article/details/83063170" target="_blank" rel="noopener">多通道图像卷积过程及计算方式</a></p></blockquote><h4 id="梯度下降更新损失函数"><a href="#梯度下降更新损失函数" class="headerlink" title="梯度下降更新损失函数"></a>梯度下降更新损失函数</h4><h4 id="反向传播-BP"><a href="#反向传播-BP" class="headerlink" title="反向传播 BP"></a>反向传播 BP</h4><h4 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h4><p><a href="https://blog.csdn.net/u011848397/article/details/102598084" target="_blank" rel="noopener">以上三个概念，详见</a></p><h4 id="感受野-receptive-field"><a href="#感受野-receptive-field" class="headerlink" title="感受野 receptive field"></a>感受野 receptive field</h4><p>就是特征图上的一个点对应输入图上的区域。其实就是假设卷积后的特征图像大小为一个像素点，反推原图大小。</p><blockquote><p><a href="https://blog.csdn.net/program_developer/article/details/80958716" target="_blank" rel="noopener">例子</a>：<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gev13nlporj30hw0dgacs.jpg" alt="img"></p></blockquote><p><a href="https://www.cnblogs.com/carsonzhu/p/11884501.html" target="_blank" rel="noopener">详细描述</a></p><p><a href="https://fomoro.com/research/article/receptive-field-calculator#3,1,1,VALID;2,2,1,VALID;3,1,1,VALID;2,2,1,VALID;3,1,1,VALID;3,1,1,VALID;2,2,1,VALID" target="_blank" rel="noopener">在线计算网站</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从数据中挖掘什么样的知识</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/05%20%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%8C%96%E6%8E%98%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/05%20%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%8C%96%E6%8E%98%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="数据挖掘、知识发现、文本挖掘"><a href="#数据挖掘、知识发现、文本挖掘" class="headerlink" title="数据挖掘、知识发现、文本挖掘"></a>数据挖掘、知识发现、文本挖掘</h4><p>数据挖掘是关于如何发现“知识”：大数据集中的模式、关系、预测规则</p><p>因此需要数据挖掘技术、算法、工具，如Weka、MatLab、R；和指导我们采集数据和发现模型的方法学框架（指导方针）：CRISP-DM</p><p>数据挖掘最初是关于从数据库中学习模式，以及将数据结构化为记录，字段</p><p>越来越多的非结构化数据（如文本），因此文本挖掘是新的数据挖掘的子领域，专注于从非结构化的文本数据中发现知识</p><h4 id="实例-Instance"><a href="#实例-Instance" class="headerlink" title="实例 Instance"></a>实例 Instance</h4><p>每个实例是被学习或描述的概念的一个例子；实例由它自身属性的值进行描述</p><p>Instance的定义取决于分类的目标：如果分类单词，那么单词是实例，如果分类句子，那么句子是实例。</p><p>数据挖掘算法的输入就是一系列实例的集合</p><p>实例表示为一系列的特征feature或属性attribute：通常来说，在文件中，一个实例instance就是文件中的一条记录record，一个属性attribute就是记录的一个字段field（attribute-instance，record-field）</p><p>从一系列实例instances中发现模式patterns，从而形成概念concepts</p><h4 id="概念-Concept"><a href="#概念-Concept" class="headerlink" title="概念 Concept"></a>概念 Concept</h4><p>Concept 的定义：</p><ul><li>数据集间的关键区别：比如某区域不同年份的销售额sales的区别</li><li>簇clusters 或自然分隔partitions：根据用户的购物习惯对用户进行分类</li><li><p>分类的规则：Adj+X+Verb =&gt; X=Noun</p></li><li><p>通用的关联：高频词一般是语法性的，而不是有含义的</p></li><li>数字的预测：找到预测数值的规则，比如根据成绩预测毕业生的工资</li></ul><h4 id="Kmeans"><a href="#Kmeans" class="headerlink" title="Kmeans"></a>Kmeans</h4><p>cluster centroids 聚类中心</p><h4 id="聚类的例子"><a href="#聚类的例子" class="headerlink" title="聚类的例子"></a>聚类的例子</h4><p>销售数据点包含买方和购物篮的信息；我们希望对不同的用户推送不同的广告；聚类分析把用户分成不同的类别的组，每个类别有不同的特征；聚类的特征与广告的种类相关联（每个簇的用户都有不同的购买偏好）；最后对用户分类</p><h4 id="输出：聚类"><a href="#输出：聚类" class="headerlink" title="输出：聚类"></a>输出：聚类</h4><p>如果不知道有多少聚类，可以先做出树状图Dendrogram</p><ul><li>根据聚类的数量/名字，对每个实例进行分类</li><li>聚类中心点</li><li>用树状图Dendrogram对结果进行展示，可以根据需求对树状图进行切割，得到不同数量的簇</li></ul><h4 id="使用案例：比较数据集"><a href="#使用案例：比较数据集" class="headerlink" title="使用案例：比较数据集"></a>使用案例：比较数据集</h4><p>寻找US vs UK专门的术语；比较这个月和上个月的数据；和几个月前的数据比较；注意新的销售增长区域；趋势：上升、下降、循环；关键的区别可能表示聚类的簇；不同的规模；</p><h4 id="输出：数据集间的不同"><a href="#输出：数据集间的不同" class="headerlink" title="输出：数据集间的不同"></a>输出：数据集间的不同</h4><p>最明显不同的关键实例/属性；关键术语的划分：names；不同数据集的趋势；整体的差别度量</p><h4 id="分类器的使用例子"><a href="#分类器的使用例子" class="headerlink" title="分类器的使用例子"></a>分类器的使用例子</h4><p>医疗记录中的大量症状和诊断数据集是可用的；找到规则来通过病人的症状预测疾病；</p><h4 id="关于决策树"><a href="#关于决策树" class="headerlink" title="关于决策树"></a>关于决策树</h4><p>无叶子节点表示特定属性的测试；边表示测试的结果；数字属性的测试通常有二元输出；普通属性的测试，通常在领域中的每个元素都有一个结果；叶子节点表示一个分类；每条路径都表示一个“实例关联到分类”的预测</p><h4 id="关于分类规则-Classification-Rules"><a href="#关于分类规则-Classification-Rules" class="headerlink" title="关于分类规则 Classification Rules"></a>关于分类规则 Classification Rules</h4><p>是决策树的替换形式：If &lt;前因antecedent&gt; then &lt;后果consequent&gt;；结果表示一个类；通常前因是条件的结合，表现在属性值上；通常我们将规则集解释为单个规则的分离</p><p>评估，规则的准确性Accuracy：它正确预测的实例数的比例，和匹配该前因的实例总数之比。</p><p>规则的优点：比树更容易理解；更紧凑；每个规则都表示一部分知识和对应得准确性</p><h4 id="例外规则"><a href="#例外规则" class="headerlink" title="例外规则"></a>例外规则</h4><p>If A then B except if C then D；比普通规则更紧凑；心理学认为这更接近人类组织知识的方式；当新实例引入时更好扩展；</p><p>对于编程的角度来说，程序会先处理异常（例外）情况，最后处理通用规则</p><h4 id="输出：其他分类器"><a href="#输出：其他分类器" class="headerlink" title="输出：其他分类器"></a>输出：其他分类器</h4><p>ZeroR、JRIP、NaiveBayes、VotedPerceptron、IB1、Bagging；输出分类器可能难以可视化、一个可以分类新实例的黑盒</p><h4 id="输出：关联规则"><a href="#输出：关联规则" class="headerlink" title="输出：关联规则"></a>输出：关联规则</h4><p>找出销售数据点之间的依赖关系可以帮助我们发现购物行为；学习规则的过程可能并不有趣</p><h4 id="关于关联规则-Assoication-Rules"><a href="#关于关联规则-Assoication-Rules" class="headerlink" title="关于关联规则 Assoication Rules"></a>关于关联规则 Assoication Rules</h4><p>类似于分类规则，但不仅可以预测分类，还能<strong>预测属性</strong></p><p>评估，规则的覆盖面Coverage：正确预测的实例的数量</p><p>评估，规则的准确性Accuracy：它正确预测的实例数的比例，和匹配该前因的实例总数之比。</p><h4 id="输出：数字预测"><a href="#输出：数字预测" class="headerlink" title="输出：数字预测"></a>输出：数字预测</h4><p>最适合使用公式；广泛应用于数学maths和统计学statistics</p><p>例子：给出关于物理环境和作物田的数字化信息，找出帮助我们在某些新条件下预测作物田的规则</p><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><p>数据挖掘工具能够半自动化的发现数据的规则</p><p>不同工具用于发现不同的概念（差异，聚类，决策树，规则，数值预测）和提供不同的输出（提供聚类中心或者树状图的聚类算法）</p><p>根据业务目标选择合适的工具以用于工作：发现知识的用途是什么</p><h4 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h4><p>我们应该：</p><ul><li>确定哪些属性与给定的数据挖掘任务相关</li><li>确定根据业务目标定义的给定问题的适当数据挖掘技术。</li><li>确定最合适的输出形式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据的分层结构</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/03%20HIGH%20LEVEL%20ARCHITECTURE/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/03%20HIGH%20LEVEL%20ARCHITECTURE/</url>
      
        <content type="html"><![CDATA[<p>针对大数据的5大特征，使用分布式资源解决大数据的存储、检索、合并、分析问题</p><a id="more"></a><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p>大数据的5大特征可以总结为4个方面：存储、检索、合并、分析</p><p>解决方案：使用分布式资源</p><h4 id="流程：原始数据到最终执行"><a href="#流程：原始数据到最终执行" class="headerlink" title="流程：原始数据到最终执行"></a>流程：原始数据到最终执行</h4><p>流程：1.数据获取 -&gt; 3.Infrastructure -&gt; 5.数据管理 -&gt; 7.分析和自动化 -&gt; 9.可视化 -&gt; 11.最终执行 (&lt;1%)</p><p>故障点：0.不可获取 -&gt; 2.不可流化或存储 -&gt; 4.不可访问 -&gt; 6.不可分析 -&gt; 8.不可通信 -&gt; 10.不可用于决策</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4damkojgj311s0i6jx2.jpg" alt="截屏2020-03-23下午5.19.07" style="zoom:50%;" /></p><h4 id="相关技术领域"><a href="#相关技术领域" class="headerlink" title="相关技术领域"></a>相关技术领域</h4><p>基础设施：Multiple nodes、CPU或GPUs、FPGAs、ASICs、Memory、Storage、Network</p><p>方法：并行化任务、并行化数据（分布数据）</p><p>应用：大规模并行 (Massive parallelism)、庞大的数据量存储、分布式数据、高速网络、高性能计算、任务和线程管理、数据挖掘和分析、数据检索、机器学习、数据可视化</p><h4 id="分层结构-Layered-architecture"><a href="#分层结构-Layered-architecture" class="headerlink" title="分层结构 Layered architecture"></a>分层结构 Layered architecture</h4><p>Layered approach最适合组织大数据系统的结构</p><p>是逻辑上的分层，而不一定要在把不同层的功能分别放在不同的机器上</p><p>按商业分层：大数据资源、数据传输和存储层、分析层、消费层</p><p>按技术分层：信息整合、大数据统治、系统管理、服务质量</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4dk6olm1j312m0cmjuy.jpg" alt="截屏2020-03-23下午5.28.15"></p><h4 id="大数据来源层-Big-Data-Sources-layer"><a href="#大数据来源层-Big-Data-Sources-layer" class="headerlink" title="大数据来源层 Big Data Sources layer"></a>大数据来源层 Big Data Sources layer</h4><p>指的是“来自于所有渠道的，可用于分析的，所有数据”。分析的类型和来源密切相关</p><ul><li><p>格式：结构化的、半结构化的、非结构化的</p></li><li><p>Velocity和Volume：数据传入(arrives)的速度，以及数据传递速率(rate)根据数据源而不同</p></li><li><p>采集点：实时或分批采集数据的来源（直接采集或者源自数据提供者）。数据可以来自主要或次要来源。</p></li><li><p>数据源的地点：数据源可以在企业内部或外部。 <u>需要标识限制访问的数据，因为对数据的访问会影响可用于分析的数据范围</u></p></li></ul><h4 id="数据通信和存储层-Data-Messaging-and-Store-Layer"><a href="#数据通信和存储层-Data-Messaging-and-Store-Layer" class="headerlink" title="数据通信和存储层 Data Messaging and Store Layer"></a>数据通信和存储层 Data Messaging and Store Layer</h4><p>Storage manager管理多个数据节点（将存储拆分）</p><p>负责从数据源获取数据——<strong>数据获取Acquisition</strong>：从数据源采集数据，然后对数据进行格式化或存储。</p><p>如果有必要，该层还能负责对数据进行格式化用于分析——<strong>数据消化Digest</strong>：简单的转化逻辑或复杂的统计算法对数据进行格式化，最大的挑战是对<strong>非结构化</strong>数据的格式化。</p><p>服从规定regulations和统治政策governance policies，为不同类型的数据提供适当的存储——<strong>分布式存储Distributed storage</strong>：负责存储数据，通常提供多种数据存储方式，比如分布式文件存储DFS、cloud、结构化数据源、NoSQL等</p><h4 id="分析层-Analysis-Layer"><a href="#分析层-Analysis-Layer" class="headerlink" title="分析层 Analysis Layer"></a>分析层 Analysis Layer</h4><p>Job manager管理多个处理节点（将分析任务拆分）</p><p>分析层的职责（如何设计分析层）：产生所需的分析；从数据中推断出观点insight；找到所需的实体；定位可以为实体提供数据的数据源；了解所需的算法和工具</p><ul><li><p>辨别实体 Entity：负责表示和填充上下文的实体；需要高效的高性能处理；定义了数据的格式；提供给分析引擎</p></li><li><p>分析引擎：使用其他组件进行分析和处理数据</p></li><li><p>模型管理：负责维护不同的统计模块，并通过不断训练确保这些模块的精确性</p></li></ul><h4 id="消费层Consumption-Layer"><a href="#消费层Consumption-Layer" class="headerlink" title="消费层Consumption Layer"></a>消费层Consumption Layer</h4><p>使用分析层的数据；消费者是以可视化软件、人、商业过程、服务；</p><p>难点在于可视化数据（可以向竞争者学习 look at what competitors in similar markets are doing）</p><p>组件：</p><ul><li>事务拦截：实时拦大量额事务，并将之转化为合适的格式给实时分析；使用不同的适配器和接口，对不同来源的数据进行整合和处理</li><li>商业过程管理进程：API，BPEL和其他流程可以使用来自分析层的Insight，从而通过自动化上下游应用程序，人员和流程的功能来推动价值。</li><li>实时监测：使用分析层的输出可以生成警告Alerts，并发送给设备或用户；实时数据可以以仪表板的形式提供。</li><li>报告引擎：生成类似于传统商业智能报告的报告至关重要。 用户可以基于来自分析层的洞察力Insight来创建临时报告，计划的报告或自我查询和分析。</li><li>推荐引擎：根据分析结果，向用户提供个性化的实时相关建议。引擎会实时处理可用信息，并根据用户的实时活动动态响应每个用户。</li><li>可视化和发现：可以在企业内部和外部的各种联合数据源之间导航数据。 数据的内容和格式可以不同，可以合并以进行可视化。</li></ul><h4 id="信息整合层-Information-Integration-Layer"><a href="#信息整合层-Information-Integration-Layer" class="headerlink" title="信息整合层 Information Integration Layer"></a>信息整合层 Information Integration Layer</h4><p>负责连接不同的数据源；需要优质的连接器和适配器（比如通信协议、API、网络服务），工业4.0平台的作用就是简化这部分</p><h4 id="大数据统治层-Big-Data-Governance-Layer"><a href="#大数据统治层-Big-Data-Governance-Layer" class="headerlink" title="大数据统治层 Big Data Governance Layer"></a>大数据统治层 Big Data Governance Layer</h4><p>核心原则：合法、公正、透明；目的限制、数据最小化、准确性、存储限制、诚信和保密、问责制Accountability</p><p>至少需要考虑：数据发现、保障措施、同意管理、数据最小化、使用情况监控、违规Breach通知</p><p>通用数据保护规则：数据控制器、数据处理器</p><h4 id="系统管理层-System-Management-Layer"><a href="#系统管理层-System-Management-Layer" class="headerlink" title="系统管理层 System Management Layer"></a>系统管理层 System Management Layer</h4><p>监视和管理整个大数据生态系统的健康状况。</p><p>包括：云消费者、云审计者 Auditor、云提供者、云中介者 Broker、云运输者 Carrier</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4e7scrruj311q0m2tb5.jpg" alt="截屏2020-03-23下午5.49.32" style="zoom:50%;" /></p><h4 id="服务质量层-QoS-Quality-of-Service-Layer"><a href="#服务质量层-QoS-Quality-of-Service-Layer" class="headerlink" title="服务质量层 (QoS) Quality of Service Layer"></a>服务质量层 (QoS) Quality of Service Layer</h4><p>定义数据质量，有关隐私和安全性的政策，数据的频率等</p><h4 id="大数据层结构总览"><a href="#大数据层结构总览" class="headerlink" title="大数据层结构总览"></a>大数据层结构总览</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4e8myag4j319l0u0kb9.jpg" alt="截屏2020-03-23下午5.51.46"></p><h4 id="传统系统-VS-大数据系统"><a href="#传统系统-VS-大数据系统" class="headerlink" title="传统系统 VS 大数据系统"></a>传统系统 VS 大数据系统</h4><p>应用开发：传统系统利用高级HPC专家开发的并行性进行优化和调整的应用程序；大数据系统简化了应用程序执行模型（分布式文件系统，编程模型，分布式数据库和调度程序）。</p><p>平台：传统系统使用高成本的大规模并行处理（MPP）计算机，利用高带宽网络和大规模I/O设备；大数据系统创建可扩展但具有弹性的虚拟化平台的创新方法。</p><p>数据管理：传统系统限于使用标准的面向行的数据布局的基于文件或RDBMS；大数据系统使用数据管理的可替换模型（通常为NoSQL），具有根据需要管理信息的多种方法。</p><p>资源：传统系统需要大量资本投资来购买要在内部安装和管理的高端硬件。大数据系统能够在虚拟平台（尤其是云）上部署系统，从而降低了进入门槛。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据分层结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据来源层</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/04%20Data%20Sources/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/04%20Data%20Sources/</url>
      
        <content type="html"><![CDATA[<p>大数据来源层 Sources layer 指的是“来自于所有渠道的，可用于分析的，所有数据”。分析的类型和来源密切相关</p><p>格式：结构化的、半结构化的、非结构化的</p><p>Velocity和Volume：数据传入(arrives)的速度，以及数据传递速率(rate)根据数据源而不同</p><p>采集点：实时或分批采集数据的来源（直接采集或者源自数据提供者）。数据可以来自主要或次要来源。</p><p>数据源的地点：数据源可以在企业内部或外部。 <u>需要标识限制访问的数据，因为对数据的访问会影响可用于分析的数据范围</u></p><a id="more"></a><h4 id="来源层-Sources-layer"><a href="#来源层-Sources-layer" class="headerlink" title="来源层 Sources layer"></a>来源层 Sources layer</h4><p>指的是“来自于所有渠道的，可用于分析的，所有数据”。分析的类型和来源密切相关</p><p>格式：结构化的、半结构化的、非结构化的</p><p>Velocity和Volume：数据传入(arrives)的速度，以及数据传递速率(rate)根据数据源而不同</p><p>采集点：实时或分批采集数据的来源（直接采集或者源自数据提供者）。数据可以来自主要或次要来源。</p><p>数据源的地点：数据源可以在企业内部或外部。 <u>需要标识限制访问的数据，因为对数据的访问会影响可用于分析的数据范围</u></p><h4 id="第四次工业革命"><a href="#第四次工业革命" class="headerlink" title="第四次工业革命"></a>第四次工业革命</h4><p>2000年开始：IoT，数字整合，大数据，AI等</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4exgwmtkj31160ekjwo.jpg" alt="截屏2020-03-23下午6.15.40"></p><h4 id="IoT和IIoT"><a href="#IoT和IIoT" class="headerlink" title="IoT和IIoT"></a>IoT和IIoT</h4><p>IoT：基于消费者；低成本端点设备</p><p>Industrial IoT：以企业为重点；高成本工业资产</p><h4 id="从Cloud到Edge"><a href="#从Cloud到Edge" class="headerlink" title="从Cloud到Edge"></a>从Cloud到Edge</h4><p>Cloud 云计算：基于数据中心，TCP/IP访问，使用虚拟化基础架构可大规模扩展</p><p>Edge 边缘计算：地理位置本地化的服务器，将计算向终端设备靠近</p><p>Fog 雾计算：联合Cloud和Edge，在Could和Edge之间的去中心化计算</p><h4 id="云计算、边缘计算、雾计算"><a href="#云计算、边缘计算、雾计算" class="headerlink" title="云计算、边缘计算、雾计算"></a>云计算、边缘计算、雾计算</h4><p><strong>云计算</strong>是把大量数据放到“云”里去计算或存储，解决诸如电脑或手机存储量不够，或者是运算速度不够快的问题</p><p><strong>雾计算</strong>是定义边缘计算应如何工作的标准，它促进了终端设备与云计算数据中心之间的计算，存储和网络服务的运行。此外，许多人将雾作为边缘计算的起点。</p><p><strong>边缘计算</strong>使处理靠近数据源，不需要将其发送到远程云或其他集中式系统进行处理。通过消除将数据发送到集中式源所需的距离和时间，我们可以提高数据传输以及边缘设备和应用程序的速度和性能。</p><p>优点：以减少“云”的压力，提高了效率，也提升了传输速率，减低了时延</p><p>缺点：如果终端设备end devices（如传感器）太多，那么边缘处理器和存储平台可能不堪重负overloaded；安全性问题，分布的边缘节点edge node意味着更高的安全风险higher risk of security，比如飞机引擎被黑Imagine if a jet engine could be hacked in flight.</p><p>对于时间敏感、计算量小的任务，如紧急情况的监控和警告，应该由边缘计算负责，比如飞机引擎是否过热（such as in-flight analysis about if the engine is overheating）</p><p>对于需要计算大量数据的任务，如进行预测分析、深度数据分析或机器学习，则应该由云计算负责，比如根据过去几个月的数据预测未来的天气、找出飞机引擎过热的原因</p><h4 id="例子：无人驾驶汽车"><a href="#例子：无人驾驶汽车" class="headerlink" title="例子：无人驾驶汽车"></a>例子：无人驾驶汽车</h4><p>大量的传感器数据，要求本地数据处理能力；需要连接云端的高级数据分析工具；全新的分布式计算结构的出现，拆分不同元素间的大量工作负载（大数据分析、实时应用）；边缘计算</p><h4 id="例子：航空"><a href="#例子：航空" class="headerlink" title="例子：航空"></a>例子：航空</h4><p>对于时间敏感、计算量小的任务，如紧急情况的监控和警告，应该由边缘计算负责，比如飞机引擎是否过热（such as in-flight analysis about if the engine is overheating）</p><p>对于需要计算大量数据的任务，如进行预测分析、深度数据分析或机器学习，则应该由云计算负责，比如根据过去几个月的数据预测未来的天气、找出飞机引擎过热的原因</p><h4 id="例子：自动测试"><a href="#例子：自动测试" class="headerlink" title="例子：自动测试"></a>例子：自动测试</h4><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><p>无线连接：NFC/RFID、Bluetooth/ZigBee、WiFi、Radio、LTE、IEEE 802</p><p>通信协议：TCP/IP、HTTP/HTTPS/WebSocket、REST、SOAP、WS-*、WCF、AMQP</p><p>专用RTI：DDS、HLA(IEEE 1516.2010)</p><p>非同步消息队列：RabbitMQ、Apache kafka、ActiveMQ</p><p>特定的应用API</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云平台架构：基于虚拟化数据中心</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03%20%E4%BA%91%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%99%9A%E6%8B%9F%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03%20%E4%BA%91%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%99%9A%E6%8B%9F%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>公有云，私有云，混合云；云计算；数据中心设计；仓库规模计算 Warehouse scale Computing；异质性heterogeneity</p><a id="more"></a><h4 id="Cloud-Computing在硬件方面的好处"><a href="#Cloud-Computing在硬件方面的好处" class="headerlink" title="Cloud Computing在硬件方面的好处"></a>Cloud Computing在硬件方面的好处</h4><p>计算资源可以随时按需获取，使用户不需要提前规划将来的资源使用；</p><p>消除了云用户的前期承诺，从而使公司可以从小做起，并在将来需要时增加硬件资源。</p><p>能够根据需要在短期内支付计算资源成本的能力（例如，按小时计算的处理器和按天存储的处理器），并在完成后释放它们，从而可以节约资源。</p><h4 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h4><p>建立在网络上；能够被任何购买了服务的用户访问；被服务提供商拥有；可以通过订阅访问</p><p>例子：Google App Engine、Amazon Web Services、Microsoft Azure</p><h4 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h4><p>建立在企业的内部网中；企业自己拥有并管理；访问仅限于企业本身及其合作伙伴；可能与云的标准冲突，但更能自定义和更可控</p><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><p>包含了公有云和私有云的特性；如果需要更多资源，那么可以让私有云访问公有云</p><ul><li>比如IBM Reserach Compute Cloud (RC2)：<ul><li>IBM构建的私有云</li><li>互连分布在美国，欧洲和亚洲的8个IBM研究中心的计算和IT资源</li><li>混合云提供对客户端，合作伙伴网络和第三方的访问。</li></ul></li></ul><h4 id="公有云和私有云的特征"><a href="#公有云和私有云的特征" class="headerlink" title="公有云和私有云的特征"></a>公有云和私有云的特征</h4><p><strong>技术杠杆leverage和拥有权</strong>：公有云的拥有者是服务提供者。私有云利用现有的IT基础架构和人员； 由单个组织拥有</p><blockquote><p>（技术杠杆Technology leverage作用是在资源稳定或减少的情况下创造增值的能力，同时又提高了以更快的速度发展的能力）</p></blockquote><p><strong>供应资源的管理</strong>：公有云在专门的基础设备中创建和管理虚拟实例，促进<strong>标准化</strong>、减少资金支出、增加应用的灵活性。私有云由客户（企业）管理，实现<strong>定制化</strong>和更高的效率</p><p><strong>工作负载workload分配方法和负载策略</strong>：公有云处理工作负载而没有通信依赖性，分配数据和虚拟机资源，高峰工作负载被转移到其他设备(off-loaded)。私有云动态的处理工作负载，但可以更好的平衡工作负载；分布数据和虚拟资源。</p><blockquote><p>off-load：1.卸载。2.转移到其他设备</p></blockquote><p><strong>安全和数据隐私强化</strong>：公有云通过远程接口可被公开访问。私有云的访问时受限的，提供生产前测试并执行数据隐私和安全策略</p><p><strong>例子</strong>：公有云：Google App Engine、Amazon Web Services、Microsoft Azure。私有云：IBM Reserach Compute Cloud (RC2)</p><h4 id="云计算的部署场景——Bursted-internal-cloud、Federated-clouds、Multi-clouds"><a href="#云计算的部署场景——Bursted-internal-cloud、Federated-clouds、Multi-clouds" class="headerlink" title="云计算的部署场景——Bursted internal cloud、Federated clouds、Multi-clouds"></a>云计算的部署场景——Bursted internal cloud、Federated clouds、Multi-clouds</h4><p><strong>Brusted internal cloud</strong>：比如电商平台某一小时打折，这一小时内的用户流量将会激增并超过平时的负载。根据云爆发的思想，该平台应该提前准备好一组闲置的资源（比如在Azure上租赁），能够在这一小时内应对流量高峰的情况。</p><blockquote><p>Cloud bursting is an application deployment model in which an application runs in a private cloud or data center, but also have a set of cloud accounts sitting idle, ready to bursts into a public cloud when there is a necessity to meet peak demands or computing capacity spikes. </p><p>云爆发是一种应用程序部署模型，其中应用程序在私有云或数据中心中运行，但是还有一组闲置的云帐户，并在需要满足峰值需求或计算能力高峰时爆发到公共云中。</p></blockquote><p><strong>Federated cloud</strong>：联合云是两个或更多个独立的云，它们遵循一致的策略（例如，共享身份验证，存储和计算资源），使客户可以根据他们的预算和投资计划从许多供应商中进行选择。Federated cloud is two or more independent clouds follow consistent policies (e.g. share either authentication, storage and computing resources), giving customers many vendors to choose from based on their budgets and investment plans.</p><p><strong>Multi-clouds</strong>：与联合云相反，多个云之间并不会通信或共享资源，他们是完全独立的。Broker帮助服务提供商发现适合的云（which call indermediate）；或者由Broker直接代理基础设施提供者与服务提供者通信，infrastructure providers对service provider来说透明（which call virtual infrastructure provider）</p><p>A multicloud environment aims to eliminate the reliance on any single cloud provider. There are many reasons to do so, such as cost-efficiencies, flexibility, deploy the application to the cloud closer to the user (choose clouds which in the UK instead of the US for British users), etc.</p><p>多云环境旨在消除对任何单个云提供商的依赖。 原因有很多，例如成本效益，灵活性，将应用程序部署到更靠近用户的云中（对于英国用户，选择在英国而不是美国的云）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5eeo7qmrj30xy0pcdq0.jpg" alt="截屏2020-05-25 下午10.23.45" style="zoom:50%;" /></p><h4 id="云建于大规模数据中心之上"><a href="#云建于大规模数据中心之上" class="headerlink" title="云建于大规模数据中心之上"></a>云建于大规模数据中心之上</h4><p>规模的范围：从“边缘”设施到大规模（100K至1M服务器）</p><p>成本比较：小型中心（1K服务器），和较大的400K服务器中心成本</p><h4 id="仓库规模计算Warehouse-Scale-Computing-WSC"><a href="#仓库规模计算Warehouse-Scale-Computing-WSC" class="headerlink" title="仓库规模计算Warehouse Scale Computing (WSC)"></a>仓库规模计算Warehouse Scale Computing (WSC)</h4><p><strong>数据仓库中数据的主要特点是：历史数据，即插入和查询多，更新和删除少</strong></p><p>提供互联网服务：搜索、社交网络、在线地图、视频分享、在线购物、邮件、云计算等</p><p>与高性能计算集群的区别：集群有更高的处理器和网络性能；集群强化线程级并行和请求级并行</p><p>数据中心：将不同的机器和软件合并在同一个位置；强化虚拟机和硬件以服务不同的消费者</p><h4 id="仓管规模计算WSC的设计思想"><a href="#仓管规模计算WSC的设计思想" class="headerlink" title="仓管规模计算WSC的设计思想"></a>仓管规模计算WSC的设计思想</h4><p>性价比Cost-performance；能源效率：影响配电power distribution和散热cooling；通过冗余增强可靠性；网络输入和输出；交互式和批处理工作负载；运营成本计算：功耗是设计系统时的主要限制；规模、机遇、问题</p><h4 id="小规模服务器集群的结构（1000-servers）"><a href="#小规模服务器集群的结构（1000-servers）" class="headerlink" title="小规模服务器集群的结构（1000 servers）"></a>小规模服务器集群的结构（1000 servers）</h4><p>通过以太网交换机互连，并位于仓库或容器环境中</p><h4 id="比较服务器、机架、集群"><a href="#比较服务器、机架、集群" class="headerlink" title="比较服务器、机架、集群"></a>比较服务器、机架、集群</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5es5dbwij30vc0iqnd9.jpg" alt="截屏2020-05-25 下午10.36.47" style="zoom:50%;" /></p><h4 id="存储和数组交换"><a href="#存储和数组交换" class="headerlink" title="存储和数组交换"></a>存储和数组交换</h4><p>存储选项：服务器内部的磁盘；通过无线带宽技术的网络附加存储 Network Attached Storage (NAS) through Infiniband；WSC通常依赖于本地磁盘；Google文件系统（GFS）使用本地磁盘，并至少维护三个副本</p><blockquote><p>InfiniBand是一个用于高性能计算的计算机网络通信标准，它具有极高的吞吐量和极低的延迟，用于计算机与计算机之间的数据互连。InfiniBand也用作服务器与存储系统之间的直接或交换互连，以及存储系统之间的互连。 截至2014年，它是超级计算机最常用的互连技术。</p></blockquote><h4 id="数据中心的负载平衡"><a href="#数据中心的负载平衡" class="headerlink" title="数据中心的负载平衡"></a>数据中心的负载平衡</h4><p>边界border路由器 =&gt; 访问Access路由器 =&gt; 负载平衡器 =&gt; 一层交换机 =&gt; 二层交换机 =&gt; TOR (top of the rack) 交换机 =&gt; 服务器机架</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5eznbyv2j30wy0jotfj.jpg" alt="截屏2020-05-25 下午10.43.57" style="zoom:50%;" /></p><h4 id="数据中心的网络"><a href="#数据中心的网络" class="headerlink" title="数据中心的网络"></a>数据中心的网络</h4><p>交换机，机架之间的丰富互连（一层交换机与二层交换机之间）：增加机架之间的吞吐量（可能有多个路由路径）；通过冗余提高可靠性</p><h4 id="异质性-Heterogeneity-的方面"><a href="#异质性-Heterogeneity-的方面" class="headerlink" title="异质性 Heterogeneity 的方面"></a>异质性 Heterogeneity 的方面</h4><p>异质性Heterogeneity是并行环境中出现的最深远和最有挑战的任务之一。</p><p>层次包括：</p><ul><li><p>宏观层Macro level：分布式计算机（云）的网络，由不同的<u>节点结构</u>组成（单核、多核），与潜在的异构网络互连</p></li><li><p>微观层Micro level：更深的内存层次结构（内存，高速缓存，磁盘存储，三级tertiary存储）和各种加速器体系结构（固定的，可编程的（例如GPU）和可重新配置的（例如FPGA））</p></li><li><p>其他：软件（操作系统）、中间件、工具</p></li></ul><h4 id="通用处理器-General-Purpose-Processors-（GPP）"><a href="#通用处理器-General-Purpose-Processors-（GPP）" class="headerlink" title="通用处理器 General Purpose Processors （GPP）"></a>通用处理器 General Purpose Processors （GPP）</h4><ol><li>通用微处理器 Microprocessors（通用电脑）：为一般的电脑设计，如PC、workstations、Laptops、notePads；执行多个程序和多个任务</li><li>微控制器 Microcontrollers（<strong>嵌入式系统</strong>）：为专门的任务设计；具有面向控制的外围设备；低耗、低性能、低电量、比微处理器小；适用于对成本，功率和空间有限制的应用</li></ol><h4 id="专用处理器"><a href="#专用处理器" class="headerlink" title="专用处理器"></a>专用处理器</h4><p>通用处理器可为所有不同的应用程序提供良好的性能，但专用处理器可为特定任务提供更好的性能</p><p>专门应用处理器方案的出现：面向高性能、低能耗、低成本</p><p>专用处理器已成为我们生活的一部分，几乎可以在我们每天使用的每台设备中找到：比如电视、手机、GPS</p><p>3种类型：</p><ul><li><p>DSP 数字信号处理器 Digital Signal Processor：用于广泛的实时数学计算的可编程微处理器–它们支持乘法累加单元</p></li><li><p>ASIP 专用指令集处理器 Application Specific Instruction Set Processors：可编程微处理器，其中硬件和指令集是为一种特殊应用而设计的</p><ul><li>指令集，微体系结构和/或存储系统是针对某个应用程序或一系列应用程序定制的</li><li>比GPP（通用处理器）更好的性能，更低的成本和更低的功耗</li></ul><blockquote><p>ASIP（应用特定指令处理器）通常是在使用的SoC（片上系统）。ASIP是一种体系结构，包括两部分，它们是最小的ISA（指令集体系结构）和可配置的逻辑，您可以使用它们来设计自己的指令集。因此，与ASIC相比，它具有相对较高的灵活性，而与FPGA（现场可编程门阵列）相比，它具有更好的性能。而且，它比FPGA便宜，但比ASIC贵。</p><ul><li>ASIP可以帮助您建立自己的指令集以满足您的特定要求；它提供了最小的ISA，可以缩短TTM（上市时间）。</li></ul></blockquote></li><li><p>ASIC 专用集成电路 Application Specific Integrated Circuit：算法完全在硬件中实现</p><ul><li>为公司特定生产线设计的集成电路</li><li>本质上是专有的，而不是（始终）对公众开放</li></ul><blockquote><p>ASIC（应用指定的集成电路）是一个定制的集成电路。通常由个人或公司使用，用途非常有限。因此，在开发它时，只有订购它的人或公司才能使用它。它不适用于其他用途，例如，为公司的特定移动电话线设计的IC ，除属于该产品线的移动电话外，没有其他产品可以使用它。</p><ul><li>ASIC仅为一个客户和一个客户构建；ASIC仅在一个产品系列中使用；仅批量生产一种产品的ASIC这很有意义，这意味着大批量产品的单位成本较低，否则成本效率不高；可以利用并行性来实现高性能；低功耗</li></ul></blockquote></li></ul><h4 id="加速器-协处理器-Accelerators-Coprocessors"><a href="#加速器-协处理器-Accelerators-Coprocessors" class="headerlink" title="加速器-协处理器 Accelerators - Coprocessors"></a>加速器-协处理器 <strong>Accelerators - Coprocessors</strong></h4><p><strong>加速器/协处理器</strong>用于比CPU更有效地执行某些功能：更快、低能耗、但更难编程</p><p><strong>Graphics Processing Unit (GPU)</strong>：单指令多线程（SIMT）模型– CUDA代码；高效处理数据并行应用，和吞吐量密集型应用程序（该算法将要处理大量数据元素）</p><p><strong>FPGA (Field Programmable Gate Array)</strong> 现场可编程门阵列是逻辑门阵列，可以进行硬件编程以完成用户指定的任务：部分应用程序可以完全在硬件中实现</p><blockquote><p>它是作为专用集成电路（ASIC）领域中的一种半定制电路而出现的，既解决了定制电路的不足，又克服了原有可编程器件门电路数有限的缺点。</p><p>FPGA的优点是我们可以配置其可编程结构来实现所需的数字功能的任意组合。另外，我们可以大规模并行地实现算法，这意味着我们可以非常快速，高效地执行大量数据处理。</p></blockquote><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>CPU：与市场无关的；可供许多程序员使用；灵活、便携</p><p>FPGA：限制市场；难以编程；比SW更高效；比ASIC更贵</p><p>ASIC：针对特定市场；需要更少的开发者；不灵活rIgid，可编程性差；物理上难以构建</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbmyalczj7j310a0bs47h.jpg" alt="截屏2020-02-06下午12.20.57" style="zoom: 50%;" /></p><h4 id="Google-TPU-张量处理器-（tensor-processing-unit）"><a href="#Google-TPU-张量处理器-（tensor-processing-unit）" class="headerlink" title="Google TPU 张量处理器 （tensor processing unit）"></a>Google TPU 张量处理器 （tensor processing unit）</h4><blockquote><p>张量处理器（英語：tensor processing unit，缩写：TPU）是Google为机器学习全定制的人工智能加速器专用集成电路，专为Google的深度学习框架TensorFlow而设计。</p><p>与图形处理器（GPU）相比，TPU采用低精度（8位）计算，以降低每步操作使用的晶体管数量。降低精度对于深度学习的准确度影响很小，但却可以大幅降低功耗、加快运算速度。同时，TPU使用了脉动阵列的设计，用来优化矩阵乘法与卷积运算，减少I/O操作。此外，TPU还采用了更大的片上内存，以此减少对DRAM的访问，从而更大程度地提升性能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公有云 </tag>
            
            <tag> 私有云 </tag>
            
            <tag> 混合云 </tag>
            
            <tag> 云爆发 </tag>
            
            <tag> 联合云 </tag>
            
            <tag> 多云 </tag>
            
            <tag> 数据中心设计 </tag>
            
            <tag> 仓库规模计算 Warehouse scale Computing </tag>
            
            <tag> 异质性heterogeneity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是联合云 Federated Cloud</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E5%90%88%E4%BA%91%20Federated%20Cloud/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E5%90%88%E4%BA%91%20Federated%20Cloud/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>Federated cloud usually describes joining up and managing multiple public cloud environments – but there is nothing to prohibit joining multiple public clouds to a private one (so some overlap with Hybrid).</p><p>The central idea is that you have multiple IaaS and PaaS environments in the cloud. An application or a set of services may require the joining up and managing multiple PaaS and IaaS environments.</p><p>Now there are two classic scenarios:</p><ol><li>I have my storefront in the cloud. During peak periods, I want to quickly expand my capacity. I may choose to federate my load across multiple cloud providers both from a cost or location issue (for example: I am a US-based service, but I have an European sales promotion – I should probably choose a local cloud provider to federate my load across, etc.).</li><li>I have multiple cloud services (think RDS from Amazon, a CDN from Akamai, etc.). I will (either for cost or functionality) choose to federate my application across multiple different clouds.</li></ol><p>The reasons for doing it are usually either functional, location or cost-based. You can get a lot of flexibility here, as you don’t need to rely upon a single vendor to support you, so there is less vendor lock-in. However, the flexibility you gain can be at the cost of complexity. You now have multiple different SLAs, you have to manage potentially different APIs, monitoring and management and deployment approaches.</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>比较ASIC, ASSP, ASIP, SoC, FPGA的不同</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20%E6%AF%94%E8%BE%83ASIC,%20ASSP,%20ASIP,%20SoC,%20FPGA%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20%E6%AF%94%E8%BE%83ASIC,%20ASSP,%20ASIP,%20SoC,%20FPGA%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>ASIC</strong> (Application Specified Integrated Circuit) is a customized integrated circuit. It is usually used by a person or company for a very limited usage. So when it is developed, only the person or company who orders it can use it. It is not useful for other usages, for example, an IC designed for a specific line of cellular phones of a company, whereby no other products can use it except the cell phones belonging to that product line.<br>- ASIC is just built for one and only one customer.<br>- ASIC is used only in one product line<br>- Only volume production of ASICs for one product can make sense which means low unit cost for high volume products, otherwise the cost is not efficient.<br>- Can exploit parallelism to achieve high performance<br>- Low power consumption</p><p><strong>ASSP</strong> (Application Specified Standard Processor) is an integrated circuit that implements a specific function that appeals to a wide market, which means its function is specified for example a motor drive chip. But it is used widely, not limited to only one customer as ASIC does. So ASSPs are available as off-the-shelf components which means you can go to electronic shops and just buy it directly from the “shelf”. It means ASSPs have been developed well and you can just buy it without designing it from scratch.<br>- It addresses the product space between ASIC and generic processor based products<br>- Extremely useful for low to medium volume applications because it help reduce cost and design overheads.</p><p><strong>ASIP</strong> (application specific instruction processor) is usually used in SoC (System on a Chip). ASIP is an architecture including two parts which are a minimum ISA (Instruction Set Archietecture) and a configurable logic which you can use to design your own instruction set. So it provides relatively high flexibility compared to ASIC and better performance compared to FPGA (Field Programmable Gate Array). Also, it is cheaper than FPGA, but slightly more expensive than ASIC.<br>- ASIP can help build your own instruction set to meet your specific requirement.<br>- It provide a minimum ISA, which can make shorter TTM (Time to Market).</p><h4 id="How-to-choose-ASIC-or-ASSP"><a href="#How-to-choose-ASIC-or-ASSP" class="headerlink" title="How to choose ASIC or ASSP?"></a>How to choose ASIC or ASSP?</h4><p>- Whether TTM (Time-To-Marker) allows to design an ASIC<br>- Whether you have special requirement for your design which is not common in ASSPs, for example, you can exploit parallelism to achieve high performance<br>- Whether your products can have a big volume in market<br>- Power consumption requirement<br>- Whether software development tools are available<br>- How is the skill of the developers, whether they are capable for designing an ASIC<br>- Whether you can burden the technology risk for designing AISC<br>- How much is your plan for NRE (Non-Recurring Expense) cost to the project: ASIC needs relatively large NRE cost, and ASSP needs no NRE cost.</p><h4 id="There-is-a-lot-of-confusion-with-regard-to-devices-like-ASICs-ASSPs-SoCs-and-FPGAs-Is-an-SoC-an-ASIC-or-vice-versa-for-example"><a href="#There-is-a-lot-of-confusion-with-regard-to-devices-like-ASICs-ASSPs-SoCs-and-FPGAs-Is-an-SoC-an-ASIC-or-vice-versa-for-example" class="headerlink" title="There is a lot of confusion with regard to devices like ASICs, ASSPs, SoCs, and FPGAs. Is an SoC an ASIC, or vice versa, for example?"></a><strong>There is a lot of confusion with regard to devices like ASICs, ASSPs, SoCs, and FPGAs. Is an SoC an ASIC, or vice versa, for example?</strong></h4><p>I often receive questions about the differences between various types of devices, such as ASICs, ASSPs, SoCs, and FPGAs. Is an SoC an ASIC, or vice versa, for example? What’s the difference between an ASIC and an ASSP? And should a high-end FPGA be classed as a form of SoC?</p><p>There are several problems here, not the least that the technologies and terminologies have evolved over time. Keeping this in mind, the following is my highly simplified interpretation of where these terms came from and what they mean today.</p><p><strong>ASICs</strong><br>Let’s start with an application-specific integrated circuit (ASIC). As the name suggests, this is a device that is created with a specific purpose in mind. When most people hear the term ASIC, their “knee-jerk” reaction is to assume a digital device. In reality, any chip that is custom-made is an ASIC, irrespective of whether it is analog, digital, or a mix of both. For the purposes of these discussions, however, we shall assume a chip that is either wholly or predominantly digital in nature, with any analog and mixed-signal functions being along the lines of physical interfaces (PHYs) or phase-locked loops (PLLs).</p><p>ASICs are typically designed and used by a single company in a specific system. They are incredibly expensive, time-consuming, and resource-intensive to develop, but they do offer extremely high performance coupled with low power consumption.</p><p><strong>ASSPs</strong><br>Application-specific standard parts (ASSPs) are designed and implemented in exactly the same way as ASICs. This is not surprising, because they are essentially the same thing. The only difference is that an ASSP is a more general-purpose device that is intended for use by multiple system design houses. For example, a standalone USB interface chip would be classed as an ASSP.</p><p><strong>SoCs</strong><br>A System-on-Chip (SoC) is a silicon chip that contains one or more processor cores — microprocessors (MPUs) and/or microcontrollers (MCUs) and/or digital signal processors (DSPs) — along with on-chip memory, hardware accelerator functions, peripheral functions, and (potentially) all sorts of other “stuff.” One way to look at this is that if an ASIC contains one or more processor cores then it’s an SoC. Similarly, if an ASSP contains one or more processor cores then <em>it’s</em> an SoC.</p><p><img src="https://www.eetimes.com/wp-content/uploads/2019/12/asic-fpga-soc-max-0326-01.gif?resize=405%2C188" alt="img"></p><p>On this basis, we could view ASIC (and ASSP) as being the superset term because it embraces SoC, or we could regard the SoC as being the superset term because it includes everything in an ASIC (or ASSP) along with one or more processor cores. Are we having fun yet?</p><p><strong>FPGAs</strong><br>ASICs, ASSPs, and SoCs offer high-performance and low power consumption, but any algorithms they contain — apart from those that are executed in software on internal processor cores — are “frozen in silicon.” And so we come to field-programmable gate arrays (FPGAs). The architecture of early FPGA devices was relatively simple — just an array of programmable blocks linked by programmable interconnect.</p><p>The great thing about an FPGA is that we can configure its programmable fabric to implement any combination of digital functions we desire. Also, we can implement algorithms in a massively parallel fashion, which means we can perform a humongous amount of data processing very quickly and efficiently.</p><p><strong>SoC-class FPGAs</strong><br>Over time, the capabilities (capacity and performance) of FPGAs increased dramatically. For example, a modern FPGA might contain thousands of adders, multipliers, and digital signal processing (DSP) functions; megabits of on-chip memory, large numbers of high-speed serial interconnect (SERDES) transceiver blocks, and a host of other functions.</p><p>The problem is that the field-programmable gate array (FPGA) moniker no longer reflects the capabilities and functionality of today’s programmable devices. We really need to come up with some new terminology that embraces everything today’s state-of-the-art tools and technologies are capable of doing.</p><p>Of particular relevance to our discussions here is the fact that today’s FPGAs can contain one or more soft and/or hard core processors. On this basis, should we class this type of FPGA as being an SoC? Well, personally I have to say that SoC doesn’t work for me, because I equate the term “SoC” with a custom device created using ASIC technology.</p><p>Another alternative would be to call these devices Programmable SoCs, or PSoCs, but Cypress Semiconductor has already got the PSoC moniker locked down. The Cypress devices feature a hard microcontroller core augmented with some programmable analog and programmable digital fabric (the digital fabric is more CPLD than FPGA).</p><p>Altera used to call its versions of these devices — the ones that combine hard MCU cores with programmable FPGA fabric — SoC FPGAs, but they seem to have evolved to just calling them SoCs. Meanwhile, Xilinx calls its flavor of these devices “All Programmable SoCs.”</p><p>Personally, I’m undecided as to what would be the best name. I think I’d prefer to use PSoC if the folks at Cypress hadn’t already taken control of this appellation, but they have, so we can’t. Failing this, I guess I’d opt for SoC FPGA… unless you can suggest something better.</p><p>— Max Maxfield, Editor of All Things Fun &amp; Interesting</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云爆发 Cloud bursting</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20%E4%BA%91%E7%88%86%E5%8F%91%20Cloud%20Bursting/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20%E4%BA%91%E7%88%86%E5%8F%91%20Cloud%20Bursting/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="The-latest-hybrid"><a href="#The-latest-hybrid" class="headerlink" title="The latest hybrid"></a>The latest hybrid</h2><p>model could be a cost-effective way to take advantage of the cloud</p><p>Cloud bursting is a rather nebulous buzzword that sounds cool but, I’m afraid, has nothing to do with Kate Bush. Instead, it’s the term used to describe a setup where you run your business mostly on your own kit, but also have a set of cloud accounts sitting idle, ready to take on extra “bursts” of work when demand peaks.</p><h2 id="Isn’t-that-already-the-idea-behind-hybrid-cloud"><a href="#Isn’t-that-already-the-idea-behind-hybrid-cloud" class="headerlink" title="Isn’t that already the idea behind hybrid cloud?"></a>Isn’t that already the idea behind hybrid cloud?</h2><p>Yes and no. Hybrid cloud is an umbrella term for dividing up your computing resources across local and off-premises servers; cloud bursting is a specific way of using those resources.</p><p>In practice, a cloud burst setup might use containerised VMs and some form of load orchestration package to shift containers to locations where user sessions can reach them. It will probably require quite a lot of work at the database design level as well, so that this too can be replicated, multi-homed or remotely accessed. In short, cloud bursting isn’t an architecture or a computing philosophy, but a capability of your entire technology estate.</p><h2 id="Is-it-just-an-agile-implementation-of-hybrid-cloud"><a href="#Is-it-just-an-agile-implementation-of-hybrid-cloud" class="headerlink" title="Is it just an agile implementation of hybrid cloud?"></a>Is it just an agile implementation of hybrid cloud?</h2><p>That’s a question of semantics. A cloud bursting setup should quickly respond to unforeseen changes in demand, but this isn’t quite what’s conventionally meant by “agile”. Agility is about being able to retool your code quickly to adapt to changing circumstances, whereas cloud bursting requires everything to be in place well before the high-load day comes.</p><p>You need to have your cloud accounts in place and paid up, you need to be sure that your code platform will run on the cloud, and you need to make sure that it’s actually capable of meeting the demands you want to place on it. Doing this properly involves a great deal of pre-emptive development and testing. I’d be very wary of a business that went into a cloud bursting project with an “agile” mindset.</p><h2 id="Is-a-cloud-bursting-setup-is-cheaper-than-regular-cloud-hosting"><a href="#Is-a-cloud-bursting-setup-is-cheaper-than-regular-cloud-hosting" class="headerlink" title="Is a cloud bursting setup is cheaper than regular cloud hosting?"></a>Is a cloud bursting setup is cheaper than regular cloud hosting?</h2><p>It might work out that way, but the two models aren’t perfectly comparable. Hybrid cloud usually tends to imply an IAAS model, whereas cloud bursting finds most interest from heavy SAAS users.</p><p>Cloud bursting also relies on your orchestration software correctly working out when to spin up the offsite services and incur the associated charges - which involves an element of voodoo, as it’s exquisitely difficult to distinguish between blips and booms as they’re happening. A hybrid cloud setup with plenty of slack capacity may or may not work out cheaper, but it’s likely to be more dependable, and have a more predictable cost.</p><h2 id="When-is-cloud-bursting-the-right-answer"><a href="#When-is-cloud-bursting-the-right-answer" class="headerlink" title="When is cloud bursting the right answer?"></a>When is cloud bursting the right answer?</h2><p>There are some such scenarios, but they’re mostly inside the world of IT itself. For example, if you’re an antivirus developer combatting zero-day exploits, you’ll want the ability to scale your download links out into the cloud on bad virus days. Some classes of simulation can also easily parcel up workloads and hand them off to compute nodes with no regard for where those nodes are hosted. Unfortunately, this model has become controversial, since it’s currently mostly employed by Bitcoin-mining trojans.</p><h2 id="What’s-the-key-downside-of-a-cloud-bursting-approach"><a href="#What’s-the-key-downside-of-a-cloud-bursting-approach" class="headerlink" title="What’s the key downside of a cloud bursting approach?"></a>What’s the key downside of a cloud bursting approach?</h2><p>Finance directors probably aren’t going to love cloud burst projects, because (as we’ve noted) the costs are unpredictable by design. What’s more, since the whole point of cloud bursting is that you don’t use it regularly, it’s only when you really need to fire up those cloud servers that you discover that a recent update has unexpectedly broken your meticulously crafted handover routines.</p><p>These inherent risks will tend to push most businesses back in the direction of a more traditional hybrid architecture.</p><h2 id="Why-are-vendors-pushing-cloud-bursting-as-the-next-big-thing"><a href="#Why-are-vendors-pushing-cloud-bursting-as-the-next-big-thing" class="headerlink" title="Why are vendors pushing cloud bursting as the next big thing?"></a>Why are vendors pushing cloud bursting as the next big thing?</h2><p>I suspect that the vendors aren’t trying to get you specifically into cloud bursting. They want to make you think more generally about where your computing resources live.</p><p>A little research, and my own anecdotal experience, suggests that very few companies have actually committed to a full-on cloud bursting model - which probably tells you everything you need to know.</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘的标准化流程：CRISP-DM</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/03%20%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%9ACRISP-DM/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/03%20%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%9ACRISP-DM/</url>
      
        <content type="html"><![CDATA[<p>CRISP-DM (Cross-industry standard process for data mining) 是一种用于数据分析的方法，而不是一种工具或者技术。是一种广泛使用的数据分析模型。</p><a id="more"></a><p><strong>Cross-industry standard process for data mining</strong>, known as CRISP-DM, is an open standard process model that describes common approaches used by data mining experts. It is the most widely-used analytics model.</p><p>是一种用于数据分析的方法，而不是一种工具或者技术</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>通过定义子任务，在整个数据挖掘过程中使用可交互工具；使任何人都能进行数据挖掘工作，而不需要特别的专业技能</p><h4 id="为什么需要标准化流程"><a href="#为什么需要标准化流程" class="headerlink" title="为什么需要标准化流程"></a>为什么需要标准化流程</h4><ul><li><strong>数据挖掘工作 Data mining process</strong>，必须要可靠reliable 并且可被缺少数据挖掘背景的人重复repeatable</li><li>需要有框架记录经历experience，使项目是可复制的</li><li>协助项目的规划planning和管理</li><li>使新采纳者“感到舒适”的因素：展示数据挖掘的成熟性；减少对“明星”的依赖</li></ul><h4 id="CRISP-DM的特点"><a href="#CRISP-DM的特点" class="headerlink" title="CRISP-DM的特点"></a>CRISP-DM的特点</h4><ul><li>非专利的 Non-proprietary</li><li>行业中立的 Application/Industry neutral</li><li>中性的工具 Tool neutral</li><li>专注于商业问题和实践问题，以及技术分析</li><li>用于指导的框架</li><li>基于经验的：用于引导和分析的例子和案例学习</li></ul><h4 id="CRISP-DM的6个阶段"><a href="#CRISP-DM的6个阶段" class="headerlink" title="CRISP-DM的6个阶段"></a>CRISP-DM的6个阶段</h4><ul><li>商业理解<ul><li>理解用户（项目）的目标和需求</li><li>定义数据挖掘问题</li></ul></li><li>数据理解<ul><li>熟悉和采集原始数据</li><li>辨别数据质量问题</li><li>初始的、明显的结果</li></ul></li><li>数据准备<ul><li>记录record，和选择属性attribute</li><li>清洗数据</li></ul></li><li>建模<ul><li>运行数据分析和数据挖掘软件</li></ul></li><li>评估<ul><li>评估结果是否符合商业目标</li><li>辨别应该提前解决的商业问题</li></ul></li><li>部署<ul><li>将建立的模型应用到实践中</li><li>为数据重复采集和连续采集做好部署</li></ul></li></ul><h4 id="6个阶段的任务细节"><a href="#6个阶段的任务细节" class="headerlink" title="6个阶段的任务细节"></a>6个阶段的任务细节</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbij8b0fpbj31mx0u049s.jpg" alt="截屏2020-02-02下午4.41.12"></p><h4 id="1-商业理解"><a href="#1-商业理解" class="headerlink" title="1-商业理解"></a>1-商业理解</h4><p>关于商业目标、数据挖掘目标、和成功标准Success Criteria的陈述Statement</p><h4 id="2-数据理解"><a href="#2-数据理解" class="headerlink" title="2-数据理解"></a>2-数据理解</h4><p>采集数据、描述数据、探索数据、证实（确保）数据质量（特征和值有关联并且有意义）、辨别异常数据</p><p>Explore/verify that the features and values “<strong>seem relevant and sensible</strong>” – if not, how to transform?</p><h4 id="3-数据准备"><a href="#3-数据准备" class="headerlink" title="3-数据准备"></a>3-数据准备</h4><p>可能会占90%的时间（避免此情况）。</p><p><strong>合并Consolidation和清洗Cleaning数据</strong>：数值缺失、移除“noisy”数据（比如重复数据）、移除异常点（看情况）</p><p><strong>特征选取</strong>：选择特征、使用可视化工具</p><p><strong>转化Transformation</strong>：创建新变量、改变格式（比如拆分出训练集合测试集）</p><h4 id="4-建模"><a href="#4-建模" class="headerlink" title="4-建模"></a>4-建模</h4><p>建模方法的选择取决于数据挖掘的目标</p><p>建模可以是迭代过程</p><p>模型可能用于描述或预测（或both）</p><h4 id="5-模型评估"><a href="#5-模型评估" class="headerlink" title="5-模型评估"></a>5-模型评估</h4><p>评估模型的性能和对商业需求的达成度(how well it met)：比如是否找到并量化关键特征</p><p>方法methods和标准criteria取决于模型的种类：比如混淆矩阵用于分类模型，也满足“理解数据”的需求</p><p>说明模型Interpretation：重要性和难易程度取决于算法；不仅要展示结果，还要解释产生的可能原因</p><h4 id="6-部署"><a href="#6-部署" class="headerlink" title="6-部署"></a>6-部署</h4><p>确定结果应该如何被应用utilized，谁需要使用这些结果、以及使用的频率</p><p>如何部署数据挖掘的结果：生成报告给用户，其中包含（对商业的）改进建议；直接将结果应用在商业中</p><h4 id="为什么使用CRISP-DM"><a href="#为什么使用CRISP-DM" class="headerlink" title="为什么使用CRISP-DM"></a>为什么使用CRISP-DM</h4><p>对于指导方针guidelines和经验文件experience documentation，提供了独一无二的框架</p><p>可以灵活的考虑不同的商业/代理问题和不同的数据</p><h4 id="概念描述，Descriptive-VS-Predictive-data-mining"><a href="#概念描述，Descriptive-VS-Predictive-data-mining" class="headerlink" title="概念描述，Descriptive VS. Predictive data mining"></a>概念描述，Descriptive VS. Predictive data mining</h4><p><strong>描述性的Descriptive</strong> vs <strong>预测性的Predictive</strong>数据挖掘：</p><ul><li>描述性的数据挖掘：以简明扼要的形式描述概念或与任务相关的数据集：决策树，决策规则</li><li><p>预测性的数据挖掘：根据数据和分析，从数据集构建模型，并预测未知数据的趋势和属性：“模型”无需可视化，例如神经网络，集成</p><p><strong>概念描述 Concept description</strong>：</p></li><li><p>表征 Characterization：对给定的数据集合进行简洁明了的总结</p></li></ul><h4 id="数据挖掘-vs-可视化"><a href="#数据挖掘-vs-可视化" class="headerlink" title="数据挖掘 vs 可视化"></a>数据挖掘 vs 可视化</h4><p><strong>数据挖掘</strong>：可以处理复杂数据类型（有许多属性/特征/维度的数据）；更加自动化的过程</p><p><strong>可视化 —— OLAP Online Analytic Processing (Visualization)</strong>：限于少数尺寸和特征类型（例如，不适合文本）；由用户控制的过程</p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与文本分析 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRISP-DM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据的例子和技术前景</title>
      <link href="/2020/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/02%20EXAMPLES%20AND%20TECHNOLOGY%20LANDSCAPE/"/>
      <url>/2020/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/02%20EXAMPLES%20AND%20TECHNOLOGY%20LANDSCAPE/</url>
      
        <content type="html"><![CDATA[<p>大数据不是一个单独的科技、技术、或创新，而是一个可表征的趋势：对大量数据的收集，并从中获得收益</p><a id="more"></a><h4 id="什么是大数据"><a href="#什么是大数据" class="headerlink" title="什么是大数据"></a>什么是大数据</h4><ol><li>大量数据的收集</li><li>从中获得收益</li></ol><p>大数据不是一个单独的科技、技术、或创新，而是一个可表征的趋势</p><h4 id="大数据工具和技术"><a href="#大数据工具和技术" class="headerlink" title="大数据工具和技术"></a>大数据工具和技术</h4><ul><li>数据操控和分析：用于计算和回答明确的问题</li><li>数据挖掘：发现数据的模式(patterns)</li><li>机器学习：对缺失或未来的数据，进行预测或推断</li><li>数据可视化：把数据绘制成图像、Tableau</li><li>数据采集和准备：填充缺失数值、移除可疑的数据、格式化</li></ul><h4 id="如何理解大数据——Causation-因果关系-amp-Correlation-相关性"><a href="#如何理解大数据——Causation-因果关系-amp-Correlation-相关性" class="headerlink" title="如何理解大数据——Causation 因果关系 &amp; Correlation 相关性"></a>如何理解大数据——Causation 因果关系 &amp; Correlation 相关性</h4><p>相关性并不意味着因果关系，错误的把相关性当做是因果关系会导致经济损失等各种严重的后果</p><p>比如通过大数据发现：家里有书的孩子测试成绩更高，这几乎导致State of Illinois向州里的孩子们送书。但后来的研究发现：父母买书的家庭环境，学习是受到家长鼓励和回报的。在普通的视野里，这些是相关性而不是因果关系</p><h4 id="大数据的分类"><a href="#大数据的分类" class="headerlink" title="大数据的分类"></a>大数据的分类</h4><ul><li>分析类型：实时，分批</li><li>处理方法：预测分析，分析：社交网络分析、基于位置的分析、特征识别、文本分析、统计算法、转录(transcription)、语音分析，查询和报告，杂项(miscellaneous)：3D重建、翻译</li><li>数据频率：按需的、连续的、实时的、时间系列的；（the feeds可以是每月周日时分秒）</li><li>数据类型：媒体(Meta)数据，基准(Master)数据，历史数据、交易数据</li><li>内容格式：结构化的、非结构化的、半结构化的 —— 图像、文本、视频、文档、音频</li><li>数据来源：网页和社交媒体、机器、人类、网络数据源、交易数据、生物数据、通过数据供应商(Provider)、通过数据产生者(Originator)</li><li>数据的消费者：人、商业进程、其他企业应用、其他数据仓库</li><li>硬件：日常硬件、最新硬件</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4czdtd0rj30wi0nags9.jpg" alt="截屏2020-03-23下午5.08.16"  /></p><h4 id="场景例子"><a href="#场景例子" class="headerlink" title="场景例子"></a>场景例子</h4><p>人体佩戴设备：</p><ul><li>Volume：每个人每时每刻都会产生数据，如果所有人都佩戴，那么数据会不断积累；</li><li>Velocity：有些传感器需要实时更新数据到监控设备中，监控设备还需要即刻处理数据并反馈结果给用户；</li><li>Variety：各种各样的数据，比如Scanadu Scout测体温、心率、血压，EPOC - Emotiv 探测用户情绪，Rapid Rehab System测用户的走路模式；</li><li>Veracity：比如Asthmapolis需要精确的测量剂量dosage</li><li>Value：比如Hydration Sensor测量并分析用户的hydration level，可以提醒用户什么时候喝水，该喝多少水</li></ul><p>其他场景：智能商场，设备状况监控，汽车联网和自动驾驶，智能运输 Intelligent Transport，智能网格 Smart Grid，推荐系统，金融</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SaaS, PaaS, IaaS</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02_%20SaaS,%20PaaS,%20IaaS/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02_%20SaaS,%20PaaS,%20IaaS/</url>
      
        <content type="html"><![CDATA[<p>关键区别</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5deqnxu3j30sg0l3tcu.jpg" alt="Differences between SaaS, PaaS, &amp; IaaS"></p><a id="more"></a><h2 id="Common-Examples-of-SaaS-PaaS-amp-IaaS"><a href="#Common-Examples-of-SaaS-PaaS-amp-IaaS" class="headerlink" title="Common Examples of SaaS, PaaS, &amp; IaaS"></a>Common Examples of SaaS, PaaS, &amp; IaaS</h2><div class="table-container"><table><thead><tr><th><strong>Platform Type</strong></th><th><strong>Common Examples</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td>Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting</td></tr><tr><td><strong>PaaS</strong></td><td>AWS Elastic Beanstalk, Windows Azure, Heroku, Force.com, Google App Engine, Apache Stratos, OpenShift</td></tr><tr><td><strong>IaaS</strong></td><td>DigitalOcean, Linode, Rackspace, Amazon Web Services (AWS), Cisco Metapod, Microsoft Azure, Google Compute Engine (GCE)</td></tr></tbody></table></div><h2 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS: Software as a Service"></a>SaaS: Software as a Service</h2><p>Software as a Service, also known as cloud application services, represents the most commonly utilized option for businesses in the cloud market. SaaS utilizes the internet to deliver applications, which are managed by a third-party vendor, to its users. A majority of SaaS applications run directly through your web browser, which means they do not require any downloads or installations on the client side.</p><h3 id="SaaS-Delivery"><a href="#SaaS-Delivery" class="headerlink" title="SaaS Delivery"></a>SaaS Delivery</h3><p>Due to its web delivery model, SaaS eliminates the need to have IT staff download and install applications on each individual computer. With SaaS, vendors manage all potential technical issues, such as data, middleware, servers, and storage, resulting in streamlined maintenance and support for the business.</p><h3 id="SaaS-Advantages"><a href="#SaaS-Advantages" class="headerlink" title="SaaS Advantages"></a>SaaS Advantages</h3><p>As a reuslt, It can greatly reducing the time and money spent on tedious tasks such as installing, managing, and upgrading software. This frees up plenty of time for technical staff to spend on more pressing matters and issues within the organization.</p><h3 id="SaaS-Characteristics"><a href="#SaaS-Characteristics" class="headerlink" title="SaaS Characteristics"></a>SaaS Characteristics</h3><p>There are a few ways to help you determine when SaaS is being utilized:</p><ul><li>Managed from a central location</li><li>Hosted on a remote server</li><li>Accessible over the internet</li><li>Users not responsible for hardware or software updates</li></ul><h3 id="When-to-Use-SaaS"><a href="#When-to-Use-SaaS" class="headerlink" title="When to Use SaaS"></a>When to Use SaaS</h3><p>SaaS may be the most beneficial option in several situations, including:</p><ul><li>Startups or small companies that need to launch ecommerce quickly and don’t have time for server issues or software</li><li>Short-term projects that require quick, easy, and affordable collaboration</li><li>Applications that aren’t needed too often, such as tax software</li><li>Applications that need both web and mobile access</li></ul><h3 id="SaaS-Limitations-and-Concerns"><a href="#SaaS-Limitations-and-Concerns" class="headerlink" title="SaaS Limitations and Concerns"></a>SaaS Limitations and Concerns</h3><ul><li><strong>Interoperability.</strong> Integration with existing apps and services can be a major concern if the SaaS app is not designed to follow open standards for integration. In this case, organizations may need to design their own integration systems or reduce dependencies with SaaS services, which may not always be possible.</li><li><strong>Vendor lock-in.</strong> Vendors may make it easy to join a service and difficult to get out of it. For instance, the data may not be portable–technically or cost-effectively–across SaaS apps from other vendors without incurring significant cost or inhouse engineering rework. Not every vendor follows standard APIs, protocols, and tools, yet the features could be necessary for certain business tasks.</li><li><strong>Lack of integration support.</strong> Many organizations require deep integrations with on-premise apps, data, and services. The SaaS vendor may offer limited support in this regard, forcing organizations to invest internal resources in designing and managing integrations. The complexity of integrations can further limit how the SaaS app or other dependent services can be used.</li><li><strong>Data security.</strong> Large volumes of data may have to be exchanged to the backend data centers of SaaS apps in order to perform the necessary software functionality. Transferring sensitive business information to public-cloud based SaaS service may result in compromised security and compliance in addition to significant cost for migrating large data workloads.</li><li><strong>Customization.</strong> SaaS apps offer minimal customization capabilities. Since a one-size-fits-all solution does not exist, users may be limited to specific functionality, performance, and integrations as offered by the vendor. In contrast, on-premise solutions that come with several software development kits (SDKs) offer a high degree of customization options.</li><li><strong>Lack of control.</strong> SaaS solutions involves handing control over to the third-party service provider. These controls are not limited to the software–in terms of the version, updates, or appearance–but also the data and governance. Customers may therefore need to redefine their data security and governance models to fit the features and functionality of the SaaS service.</li><li><strong>Feature limitations.</strong> Since SaaS apps often come in a standardized form, the choice of features may be a compromising tradeoff against security, cost, performance, or other organizational policies. Furthermore, vendor lock-in, cost, or security concerns may mean it’s not viable to switch vendors or services to serve new feature requirements in the future.</li><li><strong>Performance and downtime.</strong> Because the vendor controls and manages the SaaS service, your customers now depend on vendors to maintain the service’s security and performance. Planned and unplanned maintenance, cyber-attacks, or network issues may impact the performance of the SaaS app despite adequate service level agreement (SLA) protections in place.</li></ul><h3 id="Examples-of-SaaS"><a href="#Examples-of-SaaS" class="headerlink" title="Examples of SaaS"></a>Examples of SaaS</h3><p>These are several popular examples of SaaS, including: <a href="https://gsuite.google.com/" target="_blank" rel="noopener">Google GSuite</a> (Apps), <a href="https://www.dropbox.com/" target="_blank" rel="noopener">Dropbox</a>, <a href="https://www.salesforce.com/" target="_blank" rel="noopener">Salesforce</a>, <a href="https://www.webex.com/" target="_blank" rel="noopener">Cisco WebEx</a>, <a href="https://www.concur.com/" target="_blank" rel="noopener">SAP Concur</a>, and <a href="https://www.gotomeeting.com/" target="_blank" rel="noopener">GoToMeeting</a>.</p><h2 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS: Platform as a Service"></a>PaaS: Platform as a Service</h2><p>Cloud platform services, also known as Platform as a Service (PaaS), provide cloud components to certain software while being used mainly for applications. PaaS delivers a framework for developers that they can build upon and use to create customized applications. All servers, storage, and networking can be managed by the enterprise or a third-party provider while the developers can maintain management of the applications.</p><h3 id="PaaS-Delivery"><a href="#PaaS-Delivery" class="headerlink" title="PaaS Delivery"></a>PaaS Delivery</h3><p>The delivery model of PaaS is similar to SaaS, except instead of delivering the software over the internet, PaaS provides a platform for software creation. This platform is delivered via the web, giving developers the freedom to concentrate on building the software without having to worry about operating systems, software updates, storage, or infrastructure.</p><p>PaaS allows businesses to design and create applications that are built into the PaaS with special software components. These applications, sometimes called middleware, are scalable and highly available as they take on certain cloud characteristics.</p><h3 id="PaaS-Advantages"><a href="#PaaS-Advantages" class="headerlink" title="PaaS Advantages"></a>PaaS Advantages</h3><p>No matter the size of your company, using PaaS offers numerous advantages, including:</p><ul><li>Simple, cost-effective development and deployment of apps</li><li>Scalable</li><li>Highly available</li><li>Developers can customize apps without the headache of maintaining the software</li><li>Significant reduction in the amount of coding needed</li><li>Automation of business policy</li><li>Easy migration to the hybrid model</li></ul><h3 id="PaaS-Characteristics"><a href="#PaaS-Characteristics" class="headerlink" title="PaaS Characteristics"></a>PaaS Characteristics</h3><p>PaaS has many characteristics that define it as a cloud service, including:</p><ul><li>Builds on virtualization technology, so resources can easily be scaled up or down as your business changes</li><li>Provides a variety of services to assist with the development, testing, and deployment of apps</li><li>Accessible to numerous users via the same development application</li><li>Integrates web services and databases</li></ul><h3 id="When-to-Use-PaaS"><a href="#When-to-Use-PaaS" class="headerlink" title="When to Use PaaS"></a>When to Use PaaS</h3><p>Utilizing PaaS is beneficial, sometimes even necessary, in several situations. For example, PaaS can streamline workflows when multiple developers are working on the same development project. If other vendors must be included, PaaS can provide great speed and flexibility to the entire process. PaaS is particularly beneficial if you need to create customized applications. This cloud service also can greatly reduce costs and it can simplify some challenges that come up if you are rapidly developing or deploying an app.</p><h3 id="PaaS-Limitations-and-Concerns"><a href="#PaaS-Limitations-and-Concerns" class="headerlink" title="PaaS Limitations and Concerns"></a>PaaS Limitations and Concerns</h3><ul><li><strong>Data security.</strong> Organizations can run their own apps and services using PaaS solutions, but the data residing in third-party, vendor-controlled cloud servers poses security risks and concerns. Your security options may be limited as customers may not be able to deploy services with specific hosting policies.</li><li><strong>Integrations.</strong> The complexity of connecting the data stored within an onsite data center or off-premise cloud is increased, which may affect which apps and services can be adopted with the PaaS offering. Particularly when not every component of a legacy IT system is built for the cloud, integration with existing services and infrastructure may be a challenge.</li><li><strong>Vendor lock-in.</strong> Business and technical requirements that drive decisions for a specific PaaS solution may not apply in the future. If the vendor has not provisioned convenient migration policies, switching to alternative PaaS options may not be possible without affecting the business.</li><li><strong>Customization of legacy systems.</strong> PaaS may not be a plug-and-play solution for existing legacy apps and services. Instead, several customizations and configuration changes may be necessary for legacy systems to work with the PaaS service. The resulting customization can result in a complex IT system that may limit the value of the PaaS investment altogether.</li><li><strong>Runtime issues.</strong> In addition to limitations associated with specific apps and services, PaaS solutions may not be optimized for the language and frameworks of your choice. Specific framework versions may not be available or perform optimally with the PaaS service. Customers may not be able to develop custom dependencies with the platform.</li><li><strong>Operational limitation.</strong> Customized cloud operations with management automation workflows may not apply to PaaS solutions, as the platform tends to limit operational capabilities for end users. Although this is intended to reduce the operational burden on end users, the loss of operational control may affect how PaaS solutions are managed, provisioned, and operated.</li></ul><h3 id="Examples-of-PaaS"><a href="#Examples-of-PaaS" class="headerlink" title="Examples of PaaS"></a>Examples of PaaS</h3><p>Popular examples of PaaS include <a href="https://aws.amazon.com/elasticbeanstalk/" target="_blank" rel="noopener">AWS Elastic Beanstalk</a>, <a href="https://azure.microsoft.com/en-us/free/windows-server-on-azure/" target="_blank" rel="noopener">Windows Azure</a>, <a href="https://www.heroku.com/" target="_blank" rel="noopener">Heroku</a>, <a href="https://developer.salesforce.com/platform/force.com" target="_blank" rel="noopener">Force.com</a>, <a href="https://cloud.google.com/appengine/" target="_blank" rel="noopener">Google App Engine</a>, and <a href="https://www.openshift.com/" target="_blank" rel="noopener">OpenShift</a>.</p><h2 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS: Infrastructure as a Service"></a>IaaS: Infrastructure as a Service</h2><p>Cloud infrastructure services, known as Infrastructure as a Service (IaaS), are made of highly scalable and automated compute resources. IaaS is fully <a href="https://www.bmc.com/blogs/self-service-thrives-clouds/" target="_blank" rel="noopener">self-service</a> for accessing and monitoring computers, networking, storage, and other services. IaaS allows businesses to purchase resources on-demand and as-needed instead of having to buy hardware outright.</p><h3 id="IaaS-Delivery"><a href="#IaaS-Delivery" class="headerlink" title="IaaS Delivery"></a>IaaS Delivery</h3><p>IaaS delivers cloud computing infrastructure, including servers, network, operating systems, and storage, through virtualization technology. These cloud servers are typically provided to the organization through a dashboard or an API, giving IaaS clients complete control over the entire infrastructure. IaaS provides the same technologies and capabilities as a traditional data center without having to physically maintain or manage all of it. IaaS clients can still access their servers and storage directly, but it is all outsourced through a “virtual data center” in the cloud.</p><p>As opposed to SaaS or PaaS, IaaS clients are responsible for managing aspects such as applications, runtime, OSes, middleware, and data. However, providers of the IaaS manage the servers, hard drives, networking, virtualization, and storage. Some providers even offer more services beyond the virtualization layer, such as databases or message queuing.</p><h3 id="IaaS-Advantages"><a href="#IaaS-Advantages" class="headerlink" title="IaaS Advantages"></a>IaaS Advantages</h3><p>IaaS offers many advantages, including:</p><ul><li>The most flexible cloud computing model</li><li>Easy to automate deployment of storage, networking, servers, and processing power</li><li>Hardware purchases can be based on consumption</li><li>Clients retain complete control of their infrastructure</li><li>Resources can be purchased as-needed</li><li>Highly scalable</li></ul><h3 id="IaaS-Characteristics"><a href="#IaaS-Characteristics" class="headerlink" title="IaaS Characteristics"></a>IaaS Characteristics</h3><p>Characteristics that define IaaS include:</p><ul><li>Resources are available as a service</li><li>Cost varies depending on consumption</li><li>Services are highly scalable</li><li>Multiple users on a single piece of hardware</li><li>Organization retain complete control of the infrastructure</li><li>Dynamic and flexible</li></ul><h3 id="When-to-Use-IaaS"><a href="#When-to-Use-IaaS" class="headerlink" title="When to Use IaaS"></a>When to Use IaaS</h3><p>Just as with SaaS and PaaS, there are specific situations when IaaS is most advantageous.</p><p>Startups and small companies may prefer IaaS to avoid spending time and money on purchasing and creating hardware and software. Larger companies may prefer to retain complete control over their applications and infrastructure, but they want to purchase only what they actually consume or need. Companies experiencing rapid growth like the scalability of IaaS, and they can change out specific hardware and software easily as their needs evolve. Anytime you are unsure of a new application’s demands, IaaS offers plenty of flexibility and scalability.</p><h3 id="IaaS-Limitations-and-Concerns"><a href="#IaaS-Limitations-and-Concerns" class="headerlink" title="IaaS Limitations and Concerns"></a>IaaS Limitations and Concerns</h3><p>Many limitations associated with SaaS and PaaS models – such as data security, cost overruns, vendor lock-in and customization issues – also apply to the IaaS model. Particular limitations to IaaS include:</p><ul><li><strong>Security.</strong> While the customer is in control of the apps, data, middleware, and the OS platform, security threats can still be sourced from the host or other virtual machines (VMs). Insider threat or system vulnerabilities may expose data communication between the host infrastructure and VMs to unauthorized entities.</li><li><strong>Legacy systems operating in the cloud.</strong> While customers can run legacy apps in the cloud, the infrastructure may not be designed to deliver specific controls to secure the legacy apps. Minor enhancement to legacy apps may be required before migrating them to the cloud, possibly leading to new security issues unless adequately tested for security and performance in the IaaS systems.</li><li><strong>Internal resources and training.</strong> Additional resources and training may be required for the workforce to learn how to effectively manage the infrastructure. Customers will be responsible for data security, backup, and business continuity. Due to inadequate control into the infrastructure however, monitoring and management of the resources may be difficult without adequate training and resources available inhouse.</li><li><strong>Multi-tenant security.</strong> Since the hardware resources are dynamically allocated across users as made available, the vendor is required to ensure that other customers cannot access data deposited to storage assets by previous customers. Similarly, customers must rely on the vendor to ensure that VMs are adequately isolated within the multitenant cloud architecture.</li></ul><h3 id="Examples-of-IaaS"><a href="#Examples-of-IaaS" class="headerlink" title="Examples of IaaS"></a>Examples of IaaS</h3><p>Popular examples of IaaS include <a href="https://www.digitalocean.com/" target="_blank" rel="noopener">DigitalOcean</a>, <a href="https://www.linode.com/" target="_blank" rel="noopener">Linode</a>, <a href="https://www.rackspace.com/" target="_blank" rel="noopener">Rackspace</a>, <a href="https://aws.amazon.com/" target="_blank" rel="noopener">Amazon Web Services (AWS)</a>, <a href="https://www.cisco.com/c/en/us/products/cloud-systems-management/metacloud/index.html" target="_blank" rel="noopener">Cisco Metacloud</a>, <a href="https://azure.microsoft.com/en-us/" target="_blank" rel="noopener">Microsoft Azure</a>, and <a href="https://cloud.google.com/compute/" target="_blank" rel="noopener">Google Compute Engine (GCE)</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>介绍大数据</title>
      <link href="/2020/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/01%20INTRODUCTION,%20HISTORY,%20AND%20DEFINITIONS/"/>
      <url>/2020/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/01%20INTRODUCTION,%20HISTORY,%20AND%20DEFINITIONS/</url>
      
        <content type="html"><![CDATA[<p>大数据指的是复杂和巨大的数据集，使得传统的<u>数据库</u>或<u>数据处理</u>的软件工具无法获取、储存、管理、处理、分析。</p><p>大数据的5V： Volume Velocity Variety Veracity Value</p><a id="more"></a><h4 id="IoT-物联网"><a href="#IoT-物联网" class="headerlink" title="IoT 物联网"></a>IoT 物联网</h4><p>指环境中的人、动物、或物体具有唯一标识符，能够通过网络传输数据，而不需要人与人或人与电脑的交互。也指<u>万物互联</u></p><h4 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h4><p>复杂和巨大的数据集，使得传统的<u>数据库</u>或<u>数据处理</u>的软件工具无法获取、储存、管理、处理、分析</p><h4 id="大数据的3个特征-——-Volume-Velocity-Variety"><a href="#大数据的3个特征-——-Volume-Velocity-Variety" class="headerlink" title="大数据的3个特征 —— Volume Velocity Variety"></a>大数据的3个特征 —— Volume Velocity Variety</h4><p>Volume：就存储和访问而言，数据量十分庞大</p><p>Velocity：数据传入的速度以及处理时间</p><p>Variety：文件的种类，数据的格式和来源</p><h4 id="Volume增长的因素"><a href="#Volume增长的因素" class="headerlink" title="Volume增长的因素"></a>Volume增长的因素</h4><ol><li>基于交易的数据的不断积累</li><li>来自社交媒体的 Unstructured data streaming 非结构化数据流，结合关系数据（评论、讨论、支持投票等）</li></ol><p>其他例子：</p><ol><li><p>Facebook and Youtube have billions of users, Twitter and Instagram have hundreds of millions users. Every day, these users contribute to billions of images, posts, videos, tweets etc.</p></li><li><p>Most of the companies in the US have at least 100 Terabytes of data stored.</p></li><li><p>It’s estimated that 2.5 quintillion bytes of data are created each day.</p></li></ol><h4 id="Velocity"><a href="#Velocity" class="headerlink" title="Velocity"></a>Velocity</h4><p>数据速度，既是数据流入(stream in)的速度，也是处理数据的速度以保证数据的时效性(timeliness)</p><p>比如：</p><ol><li><p>实时处理和储存国家天气信息、即时响应高频率的股票交易和快速分析、</p></li><li><p>Tmall’s total turnover exceeded 10 billion CNY in the first 96 seconds at 11th Nov 2019</p></li><li><p>Modern cars have close to 100 sensors that monitor items such as fuel level and tire pressure</p></li></ol><h4 id="Variety"><a href="#Variety" class="headerlink" title="Variety"></a>Variety</h4><p>Variety is all about the ability to classify the incoming data into various categories.<br>多样性是指将传入数据分类为各种类别的能力。</p><p>数据有各种各样的格式，但可以被分为2种：<strong>structured 结构化</strong> 和 <strong>unstructured 非结构化</strong></p><p><strong>结构化数据</strong>：是传统数据库中的数字数据，从业务线(line-of-business)和预格式化(pre-formatted)数据中创建，随时间推移收集</p><p><strong>非结构化数据</strong>：是相关的或看似无关的数据，来自非结构化来源（社交媒体，文本文档，电子邮件，视频，音频等）</p><p>比如：</p><p>data in healthcare、data from wearable, wireless health monitors、pieces of content from Facebook and Twitter</p><h4 id="Veracity-和-Value-——-用于描述大数据的特征，而不是定义特征"><a href="#Veracity-和-Value-——-用于描述大数据的特征，而不是定义特征" class="headerlink" title="Veracity 和 Value —— 用于描述大数据的特征，而不是定义特征"></a>Veracity 和 Value —— 用于描述大数据的特征，而不是定义特征</h4><p>Veracity：数据的准确性和意义的多少</p><p>Value：从数据中可获得的价值的多少</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5Vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍虚拟基础设施 Virtual infrastructure</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02_%20%E4%BB%8B%E7%BB%8D%E8%99%9A%E6%8B%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%20Virtual%20infrastructure/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02_%20%E4%BB%8B%E7%BB%8D%E8%99%9A%E6%8B%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%20Virtual%20infrastructure/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>A virtual infrastructure is a software-based IT infrastructure being hosted on another physical infrastructure and meant to be distributed as a service as in cloud computing’s infrastructure as a service (IaaS) delivery model. It provides organizations, particularly smaller ones that cannot afford to build their own physical infrastructure, access to enterprise-grade technology such as servers and applications. The distribution is often done via the cloud, meaning over large networks such as the internet.</p><p>The main purpose of a virtual infrastructure is to bring enterprise-level technology to organizations that cannot afford the large capital required to pay for the hardware, software licenses, setup and continual maintenance of an actual data center infrastructure. The technology involves virtualization, which is the utilization of physical server resources to host logical or virtual servers and networking hardware in order to optimize resources and drive costs down by hosting multiple virtual servers in a single host server.</p><p>The idea is that no single server is actually taxed enough to the point that its resource limits are reached so it would be more prudent to make use of these resources by running multiple logical servers that, together, can make use of the actual capacity of the host. This lean approach allows for sharing and distributing resources, which, in turn, promotes flexibility, scalability and lower total cost of ownership.</p><p>Benefits of a virtual infrastructure:</p><ul><li>Scalable – Allows provisioning as many or as few logical servers as required, and users only pay for what they use.</li><li>Flexible – Allows for multiple server and networking configurations as compared to a hardwired physical infrastructure, which requires more capital and effort to change.</li><li>Secure – Allows more security to be layered on top of whatever security is already present in the virtual infrastructure because all traffic to the virtual infrastructure goes through the actual physical infrastructure.</li><li>Load balancing – Allows software-based servers to share workloads easily and distribute them properly so that no single logical server is taxed more than the others.</li><li>Backup and recovery – Promotes easier backups because everything can be saved somewhere, allowing for quick recovery in other hosts if a few hosts are down. This is almost impossible with physical servers, which have to be revived before services can resume.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多重租赁技术 Multitenancy</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/01_%20%E5%A4%9A%E9%87%8D%E7%A7%9F%E8%B5%81%E6%8A%80%E6%9C%AF%20Multitenancy/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/01_%20%E5%A4%9A%E9%87%8D%E7%A7%9F%E8%B5%81%E6%8A%80%E6%9C%AF%20Multitenancy/</url>
      
        <content type="html"><![CDATA[<p>Allows a single implementation of a service to multiple customers.</p><p>A tenant (software vendor) can have many users (software customer) subscribed to its application and a user can be subscribed to different tenants’ applications, paying only for the ones that he really needs.</p><p>一个tenant的应用可以被许多用户订阅，一个用户可以订阅许多tenant的应用，并且只对需要的那个付费。</p><p>Multi-tenant 可以用在Saas, PaaS, IaaS上</p><p>影响：</p><ul><li>提高资源共享的效率(increase the efficiency of using resources - both hardware and human, achieving low priced software)，因此降低双方成本(decrease the cost)；</li><li>提高实现和管理的复杂度(comlexity of implementation and management)；</li><li>简化发布管理流程 (simplifies the release management process. For example, the central, single point updates that allow all customers to have the latest version)；</li><li>提高发布新版本带来的风险和影响（会影响所有租客/用户）;</li><li>All the code is in one place and it is much easier to maintain, update and back up,  and consequently, cheaper.</li></ul><p>特点：Multi-user environment（多个用户使用同一个软件资源）；Multi-property（把infrastructure集中在一起提供给tenant，improve the use and efficiency of underutilized resources, e.g. computer system）；</p><a id="more"></a><h1 id="Multitenancy"><a href="#Multitenancy" class="headerlink" title="Multitenancy"></a>Multitenancy</h1><p>A tenant is a group of users who share a common access with specific privileges to the software instance - including its data, configuration, user management, tenant individual functionality and non-functional properties.</p><p>Multitenancy contrasts with multi-instance architectures. Multi-instance architectures separate software instances operate on behalf of different tenants. Multitenancy provide every tenant a dedicated share of the instance but ensuring data isolation between users.</p><h2 id="Economics-of-multitenancy"><a href="#Economics-of-multitenancy" class="headerlink" title="Economics of multitenancy"></a>Economics of multitenancy</h2><h3 id="Cost-savings"><a href="#Cost-savings" class="headerlink" title="Cost savings"></a>Cost savings</h3><p>Multitenancy allows for cost savings over and above the basic economies of scale achievable from consolidating IT resources into a single operation.[6] An application instance usually incurs a certain amount of memory and processing overhead which can be substantial when multiplied by many customers, especially if the customers are small. Multitenancy reduces this overhead by spreading it over many customers. Further cost savings may come from licensing costs of the underlying software (such as operating systems and database management systems). Put crudely, if you can run everything on a single software instance, you only have to buy one software license. The cost savings can be eclipsed by the difficulty of scaling the single instance as demand grows - increasing the performance of the instance on a single server can only be done by buying faster hardware, such as fast CPUs, more memory, and faster disk systems, and typically these costs grow faster than if the load was split between multiple servers with roughly the same aggregate capacity.[citation needed] In addition, development of multitenant systems[7] is more complex, and security testing is more stringent owing to the fact that multiple customers’ data is being commingled.</p><h3 id="Data-aggregation-data-mining"><a href="#Data-aggregation-data-mining" class="headerlink" title="Data aggregation/data mining"></a>Data aggregation/data mining</h3><p>One of the most compelling reasons for vendors/ISVs to utilize multitenancy is for the inherent data aggregation benefits. Instead of collecting data from multiple data sources, with potentially different database schemas, all data for all customers is stored in a single database schema. Thus, running queries across customers, mining data, and looking for trends is much simpler. This reason is probably overhyped as one of the core multitenancy requirements is the need to prevent Service Provider access to customer (tenant) information. Further, it is common to separate the operational database from the mining database (usually because of different workload characteristics), thus weakening the argument even more.</p><h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h3><p>Because of the additional customization complexity and the need to maintain per-tenant metadata, multitenant applications require a larger development effort. Considerations such as vector-based data sequencing, encryptable algorithm infrastructure, and virtualized control interfaces, must be taken into account.[8]</p><h3 id="Release-management"><a href="#Release-management" class="headerlink" title="Release management"></a>Release management</h3><p>Multitenancy simplifies the release management process. In a traditional release management process, packages containing code and database changes are distributed to client desktop and/or server machines; in the single-instance case, this would be one server machine per customer. These packages then have to be installed on each individual machine. With the multitenant model, the package typically only needs to be installed on a single server. This greatly simplifies the release management process, and the scale is no longer dependent on the number of customers.</p><p>At the same time, multitenancy increases the risks and impacts inherent in applying a new release version. As there is a single software instance serving multiple tenants, an update on this instance may cause downtime for all tenants even if the update is requested and useful for only one tenant. Also, some bugs and issues resulted from applying the new release could manifest in other tenants’ personalized view of the application. Because of possible downtime, the moment of applying the release may be restricted depending on time usage schedule of more than one tenant.</p><h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><h3 id="Customization"><a href="#Customization" class="headerlink" title="Customization"></a>Customization</h3><p>Multitenant applications are typically required to provide a high degree of customization to support each target organization’s needs. Customization typically includes the following aspects:</p><ul><li>Branding: allowing each organization to customize the look-and-feel of the application to match their corporate branding (often referred to as a distinct “<a href="https://en.wikipedia.org/wiki/Skin_(computing" target="_blank" rel="noopener">skin</a>)”).</li><li><a href="https://en.wikipedia.org/wiki/Workflow" target="_blank" rel="noopener">Workflow</a>: accommodating differences in workflow to be used by a wide range of potential customers.</li><li>Extensions to the <a href="https://en.wikipedia.org/wiki/Data_model" target="_blank" rel="noopener">data model</a>: supporting an extensible data model to give customers the ability to customize the data elements managed by the application to meet their specific needs.</li><li><a href="https://en.wikipedia.org/wiki/Access_control" target="_blank" rel="noopener">Access control</a>: letting each client organization independently customize access rights and restrictions for each <a href="https://en.wikipedia.org/wiki/User_(computing" target="_blank" rel="noopener">user</a>).</li></ul><h3 id="Quality-of-service"><a href="#Quality-of-service" class="headerlink" title="Quality of service"></a>Quality of service</h3><p>Multitenant applications are expected to provide adequate isolation of security, robustness and performance[9] between multiple tenants which is provided by the layers below the application in case of multi-instance applications.</p><h2 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a>Virtualization</h2><p>The costs of redesigning applications for multitenancy can be significant, especially for software vendors who continue to offer an on-premises single tenant version of their product. They end up being forced to support two distinct products with all the resulting costs.</p><p>An increasingly viable alternative route to multitenancy that eliminates the need for significant architectural change is to use virtualization technology to host multiple isolated instances of an application on one or more servers. Indeed, when applications are repackaged as virtual appliances the same appliance image can be deployed in ISV hosted, on-premises or trusted-third party locations and even migrated from one deployment site to another over time.</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Multitenancy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算的背景和定义</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/01%20%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9A%E4%B9%89/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/01%20%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>相关技术、分布式系统的演化、云计算的定义、基础设施的可视化，概念云的结构</p><h4 id="分布式系统的演化"><a href="#分布式系统的演化" class="headerlink" title="分布式系统的演化"></a>分布式系统的演化</h4><p>Mainframes (打孔条，做计算，给出结果) -&gt; Clusters -&gt; Grids -&gt; Clouds</p><p>演化的方向为：面向服务的经济</p><p>云计算的特点：按需服务 on-demand services（需要新的范例paradigm的支持）</p><h4 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h4><p>作用：模拟真实世界的科学问题和工程学问题</p><p>【并行化 Parallelisation】的好处是提供更强的计算能力和更多内存memory。但也带来了挑战：进程间的通信相对而言比较慢</p><h4 id="发展速度"><a href="#发展速度" class="headerlink" title="发展速度"></a>发展速度</h4><p>网络速度network speed：Doubles every 9 months</p><p>计算速度computer speed：doubles every 18 months</p><p>存储容量storage density：doubles every 12 months</p><h4 id="分布式计算的变化范例（Could-云计算和-Grid-网格计算的区别）"><a href="#分布式计算的变化范例（Could-云计算和-Grid-网格计算的区别）" class="headerlink" title="分布式计算的变化范例（Could 云计算和 Grid 网格计算的区别）"></a>分布式计算的变化范例（Could 云计算和 Grid 网格计算的区别）</h4><ol><li>linked all <strong>machines 机器</strong> together：Internet, TCP/IP</li><li>linked all <strong>documents 文件</strong> together：WWW, HTTP, HTML, XML</li><li>linked all <strong>applications 应用</strong> together：Web services, SOAP, WSDL, UDDI, REST</li><li>linker <strong>everything else 其他</strong> together：<ul><li><strong>Grid：去中心化的的基础设施 decentralised infrasturctures</strong></li><li><strong>Could：中心化的基础设施 centralised infrastructrues</strong></li></ul></li></ol><h4 id="Delivery-Network-传输网络"><a href="#Delivery-Network-传输网络" class="headerlink" title="Delivery Network 传输网络"></a>Delivery Network 传输网络</h4><p>Water Distribution Network 水网, Power Grid 电网, Gas Netwrok 煤气网, Telecom Network 电信网</p><h4 id="云计算的定义"><a href="#云计算的定义" class="headerlink" title="云计算的定义"></a>云计算的定义</h4><p>是一个模型，提供对共享的计算资源的访问；访问通过网络支持，无论何地用户都可以按需访问；共享的可配置的计算资源，能够快速提供给客户，并且对管理者的工作需求减少到最低——NIST (National Institute of Standards and Technology)</p><ol><li><p>On-demand self-service 按需自助服务</p></li><li><p>Broad network access 广泛的网络访问</p></li><li><p>Resource pooling 资源池</p></li><li><p>Rapid elasticity or expansion 快速的弹性或扩展</p></li><li><p>Measured service 量化服务</p><p>比如：用了多少资源（带宽）是可以计算的</p></li></ol><h4 id="虚拟的基础设施："><a href="#虚拟的基础设施：" class="headerlink" title="虚拟的基础设施："></a>虚拟的基础设施：</h4><p>【虚拟的服务平台】的特点（好处）</p><ul><li>服务系统的整合</li><li>降低成本</li><li>降低复杂性</li><li>简化管理</li><li>按使用付费</li></ul><h4 id="云的定义"><a href="#云的定义" class="headerlink" title="云的定义"></a>云的定义</h4><p><strong>Cloud infrastructure 云基础设施 </strong>，提供了一个框架，用于管理对应用程序的访问，该访问可扩展、可靠、并且可以按需使用</p><p><strong>云</strong>，对于许多手机应用程序来说，是一个不可见的后端</p><h4 id="云数据中心"><a href="#云数据中心" class="headerlink" title="云数据中心"></a>云数据中心</h4><p>1~10万个主机，紧密耦合，相互紧挨着：电子商户（Amazon），内容服务器（YouTube、Apple、Microsoft），搜索引擎、数据挖掘（Google）</p><p><strong>挑战</strong>：多应用，每个应用服务于大量的客户；管理和平衡负载，处理、网络，数据管理</p><h4 id="Virtualised-Infrastructure-虚拟化的基础设施-——-Multitenancy"><a href="#Virtualised-Infrastructure-虚拟化的基础设施-——-Multitenancy" class="headerlink" title="Virtualised Infrastructure 虚拟化的基础设施 —— Multitenancy"></a>Virtualised Infrastructure 虚拟化的基础设施 —— Multitenancy</h4><p>是一个新兴的计算范例，其中数据和服务在可大规模扩展(massively scalable)的数据中心，并且通过互联网，可以被任何设备在任何地方进行访问</p><p>传统计算和云计算的比较</p><ul><li>获得：买设备/ 买服务</li><li>商业： 提前购买固定的设备和管理 / 按需购买</li><li>访问：通过内部网访问桌面/ 通过网络访问任何设备</li><li>技术：single tenant，静态的，非共享的 / <strong>multi-tenant</strong>，可扩展的，弹性的，动态</li></ul><h4 id="Multi-tenancy-model-多重租赁技术"><a href="#Multi-tenancy-model-多重租赁技术" class="headerlink" title="Multi tenancy model 多重租赁技术"></a>Multi tenancy model 多重租赁技术</h4><p>Allows a single implementation of a service to multiple customers.</p><p>A tenant (software vendor) can have many users (software customer) subscribed to its application and a user can be subscribed to different tenants’ applications, paying only for the ones that he really needs.</p><p>一个tenant的应用可以被许多用户订阅，一个用户可以订阅许多tenant的应用，并且只对需要的那个付费。</p><p>Multi-tenant 可以用在Saas, PaaS, IaaS上</p><p>影响：</p><ul><li>提高资源共享的效率(increase the efficiency of using resources - both hardware and human, achieving low priced software)，因此降低双方成本(decrease the cost)；</li><li>提高实现和管理的复杂度(comlexity of implementation and management)；</li><li>简化发布管理流程 (simplifies the release management process. For example, the central, single point updates that allow all customers to have the latest version)；</li><li>提高发布新版本带来的风险和影响（会影响所有租客/用户）;</li><li>All the code is in one place and it is much easier to maintain, update and back up,  and consequently, cheaper.</li></ul><p>特点：Multi-user environment（多个用户使用同一个软件资源）；Multi-property（把infrastructure集中在一起提供给tenant，improve the use and efficiency of underutilized resources, e.g. computer system）；</p><h4 id="云计算的好处"><a href="#云计算的好处" class="headerlink" title="云计算的好处"></a>云计算的好处</h4><p><strong>技术上</strong></p><ol><li>按需扩展资源</li><li>对按需增长的实时反应（elasticity弹性）</li><li>硬件整合（不再需要硬件同规格homogeneity；可避免加锁）</li><li>简化硬件配置</li><li>资源透明（自动化 / 容错：自动恢复机制）</li></ol><p><strong>经济上</strong></p><ol><li>服务供应链</li><li>减低维护成本</li><li>避免资金支出</li><li>降低准入门槛</li><li>减少电力和冷却成本</li></ol><h4 id="消费者和服务商的目的"><a href="#消费者和服务商的目的" class="headerlink" title="消费者和服务商的目的"></a>消费者和服务商的目的</h4><p><strong>消费者</strong>：达到服务质量，减少开支</p><p><strong>云服务提供商</strong>：吸引客户，最大化利润</p><h4 id="The-vision"><a href="#The-vision" class="headerlink" title="The vision"></a>The vision</h4><p>基础设施提供商：比如Google、Amazon，提供设备、硬件、网络等</p><p>服务提供商：使用基础设施提供商提供的资源，为消费者提供服务、应用等</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4sqoyxf5j30ye0huaf1.jpg" alt="截屏2020-05-25 上午9.54.09" style="zoom:67%;" /></p><h4 id="云的建立基础"><a href="#云的建立基础" class="headerlink" title="云的建立基础"></a>云的建立基础</h4><p>SOA, VMs, Web 2.0 technologies</p><h4 id="Could-Architecture-——-Adaptive-management"><a href="#Could-Architecture-——-Adaptive-management" class="headerlink" title="Could Architecture —— Adaptive management"></a>Could Architecture —— Adaptive management</h4><p>云的架构是结构化的，当面对不确定性时，进行稳健决策的迭代过程，其目的是通过系统监控来逐步减少不确定性。</p><p>因为云的环境和结构是动态且复杂的，比如能够提供各种各样的服务：SaaS、PaaS、IaaS甚至everything as a service，云的不同的层也需要不同的管理方式：比如Physical Layer、Virtualization Layer、Service Layer、User Lyaer</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4svbp409j30yo0ksgt3.jpg" alt="截屏2020-05-25 上午9.58.41" style="zoom:67%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>介绍云计算</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02%20%E4%BB%8B%E7%BB%8D%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02%20%E4%BB%8B%E7%BB%8D%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>云系统的分类、可视的基础架构管理者、云用例、云计算—开放问题</p><h4 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h4><p>“云”是一些可以自我维护和管理的虚拟计算资源，通常为一些大型服务器集群，包括计算服务器、存储服务器、宽带资源等等。云计算将所有的计算资源集中起来，并由软件实现自动管理，无需人为参与。</p><p>基本原理是将计算任务分布在云端的大量的分布式计算机上、数据也存储在云端，使得企业将有限的资源切换到需要的应用上，降低企业运行的成本。这样带来的结果是中小企业不需要购置专门的计算机系统去满足某一应用需求，只需要想云计算中心支付服务费即可获得响应服务，而云计算中心则大规模的云，以向用户提供服务。总的来说云计算具有如下的特点：<strong>超大规模云计算集群、虚拟化、高可靠性、通用性、按需服务、极其廉价。</strong></p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>分布式计算是一门计算机科学，它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多计算机进行处理，最后把这些计算结果综合起来得到最终的结果。分布式计算是利用互联网上的计算机的 CPU 的闲置处理能力来解决大型计算问题的一种计算科学。</p><p>一个分布式系统（Distributed System）是一组逻辑和物理上互联的处理单元的集合。其实质就是<strong>对资源的系统范围的分散控制，以达到应用程序的协同执行</strong>。这种系统不要求单台计算机的功能十分强大，故能降低成本。分布式系统具有快速访问、多用户使用的优点。系统中的每台计算机可以方便快捷的访问其他内部节点的信息文件，它既可以为本地用户的特殊要求服务，也可以为网络中其他用户服务，实现不同计算机之间的通信与协同工作。</p><h4 id="并行计算和分布式计算"><a href="#并行计算和分布式计算" class="headerlink" title="并行计算和分布式计算"></a>并行计算和分布式计算</h4><p>并行计算与分布式计算都是运用并行来获得更高性能，化大任务为小任务。<strong>简单说来，如果处理单元共享内存，就称为并行计算，反之就是分布式计算。</strong></p><p>但是分布式的任务包互相之间有独立性，上一个任务包的结果未返回或者是结果处理错误，对下一个任务包的处理几乎没有什么影响。因此，分布式的实时性要求不高，而且允许存在计算错误（因为每个计算任务给好几个参与者计算，上传结果到服务器后要比较结果，然后对结果差异大的进行验证。</p><h4 id="云系统的分类"><a href="#云系统的分类" class="headerlink" title="云系统的分类"></a>云系统的分类</h4><p>云的结构由3个服务层组成，服务可以在任何一层提供，更低的层对用户端隐藏</p><ol><li>Software as a Service：远程运行应用代替本地运行。比如通过浏览器运行应用程序，而不用下载安装。用户不需要管理任何东西。比如：Google Apps, Dropbox，Office365</li><li>Platform as a Service：Software stack软件堆栈促进应用程序的部署。比如提供一个平台（比如Apache）让开发者部署Web Application，开发者只需要管理和维护自己的应用(WebApp代码)和数据，运行状态、操作系统、网络等工作由平台自动管理和监控。比如：AWS Elastic Beanstalk</li><li>Infrastructure as a Service：由高度可扩展的自动化计算资源组成。 IaaS是完全自助服务，用于访问和监视计算机，网络，存储和其他服务。 IaaS允许企业按需和按需购买资源，而不必直接购买硬件。比如租一个Linux系统。用户需要管理自己的操作系统、中间件、运行状态、数据、应用。比如：Microsoft Azure</li></ol><p>Database、Function、Hardware、Sensor、Network … *  as a Service</p><h4 id="资源虚拟化"><a href="#资源虚拟化" class="headerlink" title="资源虚拟化"></a>资源虚拟化</h4><p>同一台机器上的不同的虚拟机可以运行不同的操作系统和多个应用</p><p>主要的虚拟化技术是：Hypervisor 虚拟机监控程序</p><ul><li><p>Virtual Machine Manager (VMM) 虚拟机管理者用户，通过仿真和硬件辅助虚拟化，透明地分割物理服务器主机</p></li><li><p>提供了一个全仿真的硬件环境：虚拟机、宾客操作系统</p></li></ul><p>Virtualization layer 虚拟层是一个中间层，位于硬件和系统的虚拟机之间</p><h4 id="云的结构"><a href="#云的结构" class="headerlink" title="云的结构"></a>云的结构</h4><ol><li><p>Distributed Application 分布式应用（SaaS）：被设计为 ”运行在多个机器上以执行一个特定的任务“ 的软件</p></li><li><p>Virtual Machine Cluster 虚拟机集群（PaaS）：一组包含内嵌程序的虚拟机，作为应用程序的中间层</p></li><li><p>Virtual Infrastructure Manager 虚拟基础架构管理者（IaaS）：把虚拟机分隔成组，管理上千的虚拟机</p></li><li><p>Hypervisor 虚拟机监控程序（IaaS）：在同一个机器上创建多个虚拟机的实例</p><p>如：VMware、ESX、Xen、KVM</p></li></ol><p>物理机器 -&gt; Hypervisor创建虚拟机镜像 -&gt; Virtual Infrastructure Manager管理上千的虚拟机镜像 -&gt; Virtual Machine Cluster 虚拟机镜像被上者分成不用的集群 -&gt; Distributed Application 应用分布在集群中，最后提供给用户 -&gt; User</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5cuwb3i0j310w0mmdpi.jpg" alt="截屏2020-05-25 下午9.30.13" style="zoom:50%;" /></p><h4 id="Virtual-Infrastructure-Manager-虚拟基础架构管理者"><a href="#Virtual-Infrastructure-Manager-虚拟基础架构管理者" class="headerlink" title="Virtual Infrastructure Manager 虚拟基础架构管理者"></a>Virtual Infrastructure Manager 虚拟基础架构管理者</h4><p>代表终端用户配置虚拟资源的供应。如Open Nebula </p><p>主要功能：</p><ul><li>虚拟资源调度<ul><li>镜像分段、创建、迁移、外包、终止</li></ul></li><li>虚拟和物理资源监控</li><li>用户访问控制</li></ul><h4 id="Virtual-Infrastructure-Manager和Hyperviosr的关系"><a href="#Virtual-Infrastructure-Manager和Hyperviosr的关系" class="headerlink" title="Virtual Infrastructure Manager和Hyperviosr的关系"></a>Virtual Infrastructure Manager和Hyperviosr的关系</h4><ul><li><strong>终端用户</strong>通过<strong>公开的云接口</strong>访问<strong><u>虚拟基础架构管理者</u></strong></li><li><p><strong>本地用户</strong>直接访问<strong><u>虚拟基础架构管理者</u></strong></p></li><li><p><strong><u>虚拟基础架构管理者</u></strong>通过本地的<strong><u>Hypervisor虚拟机监控程序</u></strong>访问<strong>私有本地物理资源（私有云）</strong></p></li><li><p><strong><u>虚拟基础架构管理者</u></strong>通过<strong>外包接口</strong>访问<strong>共有远程物理资源（公有云）</strong></p></li></ul><center><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbw4v6twoj30hw0hiac7.jpg" alt="截屏2020-01-27下午10.48.44" style="zoom:50%"/></center><h4 id="云结构各部分的关系"><a href="#云结构各部分的关系" class="headerlink" title="云结构各部分的关系"></a>云结构各部分的关系</h4><ol><li><u><strong>分布式应用</strong></u>部署在虚拟机集群中</li><li><strong>虚拟机集群资源</strong>由<strong>虚拟基础设施管理者</strong>统一管理</li><li><strong><u>基础设施管理者</u></strong>通过使用<u><strong>基础设施监控程序</strong></u>提供和管理物理资源</li></ol><p>物理机器 -&gt; Hypervisor创建虚拟机镜像 -&gt; Virtual Infrastructure Manager管理上千的虚拟机镜像 -&gt; Virtual Machine Cluster 虚拟机镜像被上者分成不用的集群 -&gt; Distributed Application 应用分布在集群中，最后提供给用户 -&gt; User</p><h4 id="Virtual-Infrastructure-Manager"><a href="#Virtual-Infrastructure-Manager" class="headerlink" title="Virtual Infrastructure Manager"></a>Virtual Infrastructure Manager</h4><p><strong>Open Nebula</strong></p><p>特点：通过云插件进行多站点资源池、Hypervisor监控程序诊断、广泛采用云接口、简单的用户管理、灵活的模块化设计、成熟</p><p><strong>Openstack</strong></p><p>特点：高效地分配资源、通过服务门户授权管理员和用户、开发者通过API授权使应用具有”云感知“的能力、使”云“能够联合(cloud federation)</p><h4 id="企业-云-企业"><a href="#企业-云-企业" class="headerlink" title="企业-云-企业"></a>企业-云-企业</h4><p>重点是将资源托管在云中，以便企业间的应用程序可以相互操作</p><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><p>”混合云“可以由”federated cloud provider联合云提供商”交付，将其自身的资源与其他提供商的资源相结合</p><h4 id="Cloud-federation"><a href="#Cloud-federation" class="headerlink" title="Cloud federation"></a>Cloud federation</h4><p>different clouds can share resources：</p><ul><li><p>如果其中一个云的负载满了，那么cloud1的虚拟机可以迁移到cloud2</p></li><li><p>用户与broker（代理人/经纪人）交互，broker决定是与cloud1或2或3进行交互，但对于用户来说，cloud1 2 3是透明的。</p></li></ul><h3 id="Worksheet-1-问题"><a href="#Worksheet-1-问题" class="headerlink" title="Worksheet 1 问题"></a>Worksheet 1 问题</h3><ol><li><p><strong>Make a list of activities that you do every day in which cloud computing is used. How would your life be altered if cloud services were suddenly switched off?</strong></p><p>Office 365，Outlook，Google Cloud Platform；</p><p>云计算能够为企业提供廉价的按需付费的服务，这样企业可以专注于自己的商业目标，减少了购买和维护额外计算机资源的花费（比如租用云服务器而不是购买硬件），进而降低了成本。如果没有了云计算，那么企业的成本会增加，也会导致产品定价上涨，因此消费者需要花更多的钱的购买产品</p><p>Cloud can help companies to focus on whatever their business domain is. The total cost will decrease by the form of cloud amortization</p></li><li><p>What is meant by ”cloud” in cloud computing?</p><p>“云”是一些可以自我维护和管理的虚拟计算资源，通常为一些大型服务器集群，包括计算服务器、存储服务器、宽带资源等等。云计算将所有的计算资源集中起来，并由软件实现自动管理，无需人为参与。</p></li><li><p>Where do the clouds reside?</p><p>cloud center / data center</p></li><li><p>Which of the following is an advantage of the cloud computing approach:</p><ul><li>it is ubiquitous</li><li>enabled by pay-for-usage model </li><li>responsiveness</li><li><strong>all of these</strong></li></ul></li><li><p>What is the main advantage of utility computing (公用计算) as compared to traditional computing?</p><p><strong>Utility computing</strong> is a service provisioning model in which a service provider makes computing resources and infrastructure management available to the customer as needed. Utility computing support a pay-per-use service while traditional computing is flat rate.</p></li><li><p>Check the Amazon Web Services (AWS) cloud Web site. How would you plan a real computing application using EC2 or S3? You must specify the resources requested and figure out the costs charged by Amazon.</p><p>系统、CPU、内存、硬盘大小、带宽、数据中心位置</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> 课件 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
