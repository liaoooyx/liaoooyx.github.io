<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Image Caption Generation 相关问题</title>
      <link href="/2020/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Image-Caption-Generation/"/>
      <url>/2020/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Image-Caption-Generation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://towardsdatascience.com/image-captioning-with-keras-teaching-computers-to-describe-pictures-c88a46a311b8" target="_blank" rel="noopener">参考文章</a></p><a id="more"></a><h3 id="Encoder-Decoder模型"><a href="#Encoder-Decoder模型" class="headerlink" title="Encoder-Decoder模型"></a>Encoder-Decoder模型</h3><p>图片字幕生成的细节：</p><ul><li><p>模型使用的词典不在乎单词的顺序问题</p></li><li><p>这是一个监督学习问题</p><ul><li><p>通过输入的Xi，预测输出的Yi</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdus9eyca0j311q0h8n0h.jpg" alt="截屏2020-04-15 下午2.33.57"></p></li><li><p>也即是给定图片向量，每次预测基于当前的部分字幕，生成下一个单词</p><ul><li>输入：图片向量和当前的部分字幕（以词典中的索引表示）<ul><li>将字幕转化为输入，涉及到词嵌入技术（the word embedding techniques），比如 GLOVE词嵌入模型，将每个单词都匹配为长度200（自定义）的向量</li><li>也可以单纯的只使用词典本身作为向量（在词典中存在为1，不存在为0）</li></ul></li><li>预测输出：下一个单词</li></ul></li></ul></li></ul><hr><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="Q1-What-the-advantages-disadvantages-might-be-of-using-lemmatized-vs-regular-tokens"><a href="#Q1-What-the-advantages-disadvantages-might-be-of-using-lemmatized-vs-regular-tokens" class="headerlink" title="Q1. What the advantages/disadvantages might be of using lemmatized vs regular tokens."></a><strong>Q1. What the advantages/disadvantages might be of using lemmatized vs regular tokens.</strong></h4><p>Tokenization is the process of splitting any string into words. It is an essential approach for data preparation relevant to field of language processing. In this process, there are lots of methods can be applied thus lead to different type of tokens such as lemmatized tokens and regular tokens. Lemmatization usually refers to transforming words from inflected, singular forms etc. to the base form, known as the lemma, which is an actual word in a dictionary. For example, <em>am</em>, <em>is</em>, <em>are</em> will be converted to <em>be</em>, and <em>runs</em>, <em>ran</em>, <em>running</em>, will be of <em>run</em>. During Lemmatization process, the transformation of a specific word relies on the current context, such as identifying whether the word <em>saw</em> is a noun or a verb.</p><p>The regular tokens are generated from simple process such as tokenization, removing punctuation, converting words into lowercase while lemmatized tokens have one more process which is Lemmatization. The mainly different is whether the token word is remaining same or converted to a base form.</p><p>There are many advantages of using lemmatized tokens. One of the most widely known advantages is it can give a better result by removing the inflectional endings only and therefore can properly represents a group of related words with same token. For example, in this Image Caption Generation task, where the data is not big enough, lemmatized tokens can represent the highly discrete words more aggregated. The inflected words with same meaning will be grouped and hence will not affect the weight differently in the network. From another perspective, it is equivalent to increasing the amount of data. As a result, the generated caption might be more accurate. However, it comes with the costs. Lemmatization uses a corpus to transform the words and takes the context of original text into account, which means more computing and storage consumption. On the other words, it will slow down the processing speed and use more memory.</p><p>On the other hand, the advantages and disadvantages of regular tokens are opposite to lemmatized tokens. As its simplicity, it is suitable for the tasks with constraints on time and memory. What’s more, English is not an inflection-rich language (comparing with Spanish and Arabic) thus not that much influence if using regular tokens. But the results may inevitably worse than using lemmatized tokens.</p><p>In conclusion, using lemmatized tokens is usually a better option, but still coms with its drawback. In some circumstances, the regular tokens might be more suitable. As a result, people should depend on the use case to choose a proper approach. </p><h4 id="Q2-Present-the-sample-images-and-generated-caption-for-each-epoch-of-training-for-both-the-RNN-and-LSTM-version-of-the-decoder-including-the-BLEU-scores"><a href="#Q2-Present-the-sample-images-and-generated-caption-for-each-epoch-of-training-for-both-the-RNN-and-LSTM-version-of-the-decoder-including-the-BLEU-scores" class="headerlink" title="Q2. Present the sample images and generated caption for each epoch of training for both the RNN and LSTM version of the decoder, including the BLEU scores."></a><strong>Q2. Present the sample images and generated caption for each epoch of training for both the RNN and LSTM version of the decoder, including the BLEU scores.</strong></h4><p>In this task, the report chooses the same two images for observing the generated caption for RNN and LSTM. Table 1 is listing the parameters which remain the same in the sampling process, including the image, the reference captions used for computing BLEU score, and the weights of BLEU for each gram. Table 2-6 are comparing the generated caption and the corresponding BLEU cumulative score between LSTM and RNN at each epoch. Noticed that the tokens <start> and <end> has been removed from generated caption.</p><p>Table 1: The same parameters when generating caption.</p><div class="table-container"><table><thead><tr><th style="text-align:center">Image Id</th><th>539705321_99406e5820.jpg</th></tr></thead><tbody><tr><td style="text-align:center">Image</td><td><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduyeba6gpj30kj0aggwj.jpg" alt="手机屏幕截图  描述已自动生成"></td></tr><tr><td style="text-align:center">Reference Captions</td><td>a kid in  red falls as he struggles with a kid in white to get to a soccer ball <br />children  chasing the ball in a soccer game<br />little  boys running and chasing a soccer ball<br />the boy  with the red soccer suit is falling down while the boy in the white shirt has  his eyes on the ball <br />two teams  of children one in red and the other in white are playing soccer</td></tr><tr><td style="text-align:center">BLEU Weights</td><td>1-gram: (1, 0, 0, 0)  <br />2-gram: (0.66, 0.33,  0, 0)  <br />3-gram: (0.6, 0.3,  0.1, 0) <br />4-gram: (0.5, 0.25,  0.15, 0.1)</td></tr></tbody></table></div><p>Table 2: BLEU cumulative score for n-gram on LSTM and RNN at 1st epoch.</p><div class="table-container"><table><thead><tr><th style="text-align:center">1st Epoch</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">LSTM</td><td style="text-align:center">RNN</td></tr><tr><td style="text-align:center">Generated Caption</td><td style="text-align:center">a man in a red shirt and a red shirt and a  woman in a red shirt and a</td><td style="text-align:center">a young girl in a red shirt and a white shirt  and a white shirt and a white shirt</td></tr><tr><td style="text-align:center">BLEU Score</td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye9r4a1j30fc040aan.jpg" alt="手机屏幕截图  描述已自动生成"></td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye7tkewj30fe03wjrz.jpg" alt="手机屏幕截图  描述已自动生成"></td></tr></tbody></table></div><p>Table 3: BLEU cumulative score for n-gram on LSTM and RNN at 2nd epoch.</p><div class="table-container"><table><thead><tr><th style="text-align:center">2nd Epoch</th><th style="text-align:center"></th><th></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">LSTM</td><td>RNN</td></tr><tr><td style="text-align:center">Generated Caption</td><td style="text-align:center">a group of children playing in a field</td><td>two girls are playing in a field</td></tr><tr><td style="text-align:center">BLEU Score</td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduyec0ufyj30fg03yq3j.jpg" alt="手机屏幕截图  描述已自动生成"></td><td><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye4j63ij30fk03u74w.jpg" alt="手机屏幕截图  描述已自动生成"></td></tr></tbody></table></div><p>Table 4: BLEU cumulative score for n-gram on LSTM and RNN at 3rd epoch.</p><div class="table-container"><table><thead><tr><th style="text-align:center">3rd Epoch</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">LSTM</td><td style="text-align:center">RNN</td></tr><tr><td style="text-align:center">Generated Caption</td><td style="text-align:center">a group of people are playing soccer on a  field</td><td style="text-align:center">two soccer players are playing soccer</td></tr><tr><td style="text-align:center">BLEU Score</td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduyecm1ecj30bz02y0t7.jpg" alt="手机屏幕截图  描述已自动生成"></td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye1an4bj30fi03yjrz.jpg" alt="手机屏幕截图  描述已自动生成"></td></tr></tbody></table></div><p>Table 5: BLEU cumulative score for n-gram on LSTM and RNN at 4th epoch.</p><div class="table-container"><table><thead><tr><th style="text-align:center">4th Epoch</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">LSTM</td><td style="text-align:center">RNN</td></tr><tr><td style="text-align:center">Generated Caption</td><td style="text-align:center">a boy in a red shirt and a baseball cap is  running on a grassy field</td><td style="text-align:center">three children play in a field</td></tr><tr><td style="text-align:center">BLEU Score</td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye2alcej30d303aaan.jpg" alt="手机屏幕截图  描述已自动生成"></td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduyeam4bnj30fc03smxr.jpg" alt="手机屏幕截图  描述已自动生成"></td></tr></tbody></table></div><p>Table 6: BLEU cumulative score for n-gram on LSTM and RNN at 5th epoch.</p><div class="table-container"><table><thead><tr><th style="text-align:center">5th Epoch</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">LSTM</td><td style="text-align:center">RNN</td></tr><tr><td style="text-align:center">Generated Caption</td><td style="text-align:center">a boy in a red shirt is running with a soccer  ball in a field of grass</td><td style="text-align:center">three children are playing soccer on a grassy  field</td></tr><tr><td style="text-align:center">BLEU Score</td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye1p276j30fc03ywf3.jpg" alt="手机屏幕截图  描述已自动生成"></td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye8r05jj30fg03ugm7.jpg" alt="手机屏幕截图  描述已自动生成"></td></tr></tbody></table></div><h4 id="Q3-Compare-training-using-an-RNN-vs-LSTM-for-the-decoder-network"><a href="#Q3-Compare-training-using-an-RNN-vs-LSTM-for-the-decoder-network" class="headerlink" title="Q3. Compare training using an RNN vs LSTM for the decoder network."></a><strong>Q3. Compare training using an RNN vs LSTM for the decoder network.</strong></h4><p>In this coursework, we are the using encoder-decoder model for image caption generation. For both RNN decoder or LSTM decoder, they are all using the same encoder with CNN, which is responsible for extracting and compressing the contents of images into small feature vectors. And the variable that might affect the generated captions is controlled between RNN and LSTM in the decoder. The comparison will start by comparing the structure and then move to the results of the CW code, including the overall loss and BLEU score, the difference for training with long or short captions and quality of generated captions.</p><p>From the structural level, the recurrent neural network (RNN) is a feedforward neural network that has internal memory and is recurrent in nature. The traditional convolutional neural network (CNN) in which the data stream is flowing from layer to layer has no connections between neurons (or nodes) inside the layer, causing current neuron lacks memory for the previous neurons. While RNN, on the contrary, has connections between neurons inside the hidden layers. The inputs of a current neuron include the outputs of the last layer and the previous neuron in the current layer. As a result, RNN is suitable for sequence-related tasks such as speech recognition, natural language processing, etc. </p><p>Long short-term memory network (LSTM) is a variant of RNN, belonging to feedback neural network. It is aiming to deal with the problems of gradient vanish that traditional RNN encountered during training, which means losing information in a long-distance propagation. LSTM has a similar structure as RNN in general but more complex in details. Comparing with RNN, a common LSTM has an additional parameter to keep the memory of previous data over arbitrary time intervals, called cell state, which is the core of LSTM. To regulate the information over the cell, there are three gates named forget gate, input gate and output gate. The forget gate decides which information will be removed from the last cell state. The input gate is deciding what information should be added to the current cell state. Concatenate these two steps with the last cell state, it can update the current cell state. Then, the output gate determines which information will be outputted based on above, and finally get the output. This structure helps LSTM to address the vanishing gradient problem, and accordingly, have better performance than traditional RNN in terms of longer time series tasks</p><p>To evaluate and compare models, the first criteria is observing the loss value on both the straining step and test step. Figure 1 illustrates the trends of loss for LSTM and RNN, including the loss values for every batch and the average loss values at each epoch. But the difference between them is hard to find. From table 7, which is showing the average loss in number, it can still be noticed that the loss of LSTM is slightly bigger than that of RNN at the first epoch and becomes slightly smaller at the final epoch.</p><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye45gbrj30h00cw0tx.jpg" alt="地图的截图  描述已自动生成"></th><th style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye5z19zj30hb0crmyc.jpg" alt="手机屏幕截图  描述已自动生成"></th></tr></thead><tbody><tr><td style="text-align:center">(1)    LSTM</td><td style="text-align:center">(2)    RNN</td></tr></tbody></table></div><p> Figure 1: Loss per batch and  average loss per epoch during training for LSTM (1)  and RNN (2).  </p><p>Table 7: Average loss for LSTM and RNN on training set at each epoch.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduylad30jj310y0900ts.jpg" alt="截屏2020-04-15 下午6.20.37"> </p><p>After finish training the model, we can evaluate the model using the test set. Here we compare the loss of model on the test set between LSTM and RNN, as well as the differences of BLEU score. In Table 8, the loss of model with LSTM decoder is also lower than that with RNN decoder. Figure 2 is illustrating the cumulative BLEU scores from 1-gram to 4-gram, which can describe the overall performance of generated captions in the perspective of words. The areas under the line are representing the percentage of captions with different scores, where blue lines stand for LSTM and orange lines stand for RNN. From the distribution of the area under the lines, we might find that the area of RNN is prone to the left than the area of LSTM, indicating a lower score. The vertical dash lines in the figures that point out the average score over the whole test set (figure 2, where the actual values are shown in table 9) prove this again. On the other hand, we have to notice that LSTM are more likely to get scores very close to zero.</p><p>Table 8: Loss for LSTM and RNN on test set</p><div class="table-container"><table><thead><tr><th></th><th>LSTM</th><th>RNN</th></tr></thead><tbody><tr><td>Test set</td><td>2.603</td><td>2.725</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduye539qzj30z80b341c.jpg" alt="图片包含 游戏机, 设备  描述已自动生成"></p><p>Figure 2: All of Cumulative BLEU scores and the average of scores on test set for LSTM and RNN, score from 0 to 1 separated into 30 bins.</p><p> Table 9: Average cumulative BLEU score for LSTM and RNN on test set.</p><div class="table-container"><table><thead><tr><th></th><th>LSTM</th><th>RNN</th></tr></thead><tbody><tr><td>1-gram</td><td>0.550</td><td>0.494</td></tr><tr><td>2-gram</td><td>0.461</td><td>0.416</td></tr><tr><td>3-gram</td><td>0.452</td><td>0.417</td></tr><tr><td>4-gram</td><td>0.467</td><td>0.442</td></tr></tbody></table></div><p>Table 10 is comparing the results between images with the longest reference captions and shortest captions on average in the test set. For the image with the longest reference captions, although the 1-gram BLEU score for LSTM is slightly lower than that for RNN, the other three type of cumulative BLEU scores, from 2-gram to 4-gram, are all higher. And for the image with the shortest one, all of the BLEU scores when using LSTM to train the decoder are higher than using RNN. However, if we compare the generated captions in a human perspective, it is obvious that all of them are misdescribing the corresponding images at the same point thus do not show much difference for people. </p><p>We compare the loss of LSTM decoder and RNN decoder, during the training epoch on the training set and after finish training on the test set, as well as the cumulative BLEU scores on the generated captions, on average and on both the longest and the shortest reference captions. In conclusion, the difference between Loss and BLEU score in overall may indicate that LSTM may have a better performance than RNN. But with human perception, it is hard to judge which is better. And the LSTM does not show its advantages in dealing with long captions. However, this insight may not obvious and convincing enough in this case as the training set, length of the captions and training epochs seem quite constrained.</p><p>Table 10: Comparing the images with long (left) or short (right) reference captions on average in test set.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduyncvc1mj30u00vu454.jpg" alt="截屏2020-04-15 下午6.21.38"> </p><h4 id="Q4-Among-the-text-annotations-files-downloaded-with-the-Flickr8k-dataset-are-two-files-we-did-not-use-ExpertAnnotations-txt-and-CrowdFlowerAnnotations-txt-Read-the-readme-txt-to-understand-their-contents-then-consider-and-discuss-how-these-might-be-incorporated-into-evaluating-your-models"><a href="#Q4-Among-the-text-annotations-files-downloaded-with-the-Flickr8k-dataset-are-two-files-we-did-not-use-ExpertAnnotations-txt-and-CrowdFlowerAnnotations-txt-Read-the-readme-txt-to-understand-their-contents-then-consider-and-discuss-how-these-might-be-incorporated-into-evaluating-your-models" class="headerlink" title="Q4. Among the text annotations files downloaded with the Flickr8k dataset are two files we did not use: ExpertAnnotations.txt and CrowdFlowerAnnotations.txt. Read the readme.txt to understand their contents, then consider and discuss how these might be incorporated into evaluating your models."></a><strong>Q4. Among the text annotations files downloaded with the Flickr8k dataset are two files we did not use: ExpertAnnotations.txt and CrowdFlowerAnnotations.txt. Read the readme.txt to understand their contents, then consider and discuss how these might be incorporated into evaluating your models.</strong></h4><p>The file ExpertAnnotations.txt contains a set of image-captions pairs with a score that rated by experts from 1 (the caption does not describe the image at all) to 4 (the caption describes the image correctly). The file CrowdFlowerAnnotations.txt contains a collection of image-captions pairs with the judgement, by asking human whether the caption describes the image or not. Both of them giving additional non-correct captions for images compared with the file Flickr8k.token.txt, while the Crowd Flower Annotations use a binary judgement and the Expert Annotations provides a finer-grained score.</p><p>One of the limitations within the encoder-decoder model is that the only connection between the encoder and decoder is a fixed-length feature vector which represents the images with an uncertain number of objects. The feature vector may not represent all of the information of the input image so that the accuracy of the decoder will hence be affected.</p><p>On the other hand, the domain of image caption generation is related to the supervised learning using an algorithm to find out the optimal solution for generating appropriate caption of a specific image based on a collection of caption-image pairs. It is similar to image classification but far more complex as there are more objects. Hodosh et al. (2013) [1] shows that using multiple captions for an image gives better results than using a single caption. Extending from this, we suppose that if the model has additional data about not only what is correct but also what could be wrong, it might be possible to improve the model and achieve better results.</p><p>For example, when converting the words to the vector at the decoder step, we can introduce finer-grain weights with non-correct caption instead of binary values based on the two additional files. Or use it to improve the performance of the word embedding functions.</p><p>Reference:</p><p>[1] M. Hodosh, P. Young, and J. Hockenmaier. Framing image description as a ranking task: Data, models and evaluation metrics. J. Artif. Int. Res., 47(1):853–899, May 2013.</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> RNN </tag>
            
            <tag> Image Caption </tag>
            
            <tag> encoder-decoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSTM和RNN</title>
      <link href="/2020/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/RNN%E5%92%8CLSTM/"/>
      <url>/2020/04/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/RNN%E5%92%8CLSTM/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.jianshu.com/p/89f3b045d9cb" target="_blank" rel="noopener">从结构上描述</a></p><p><a href="https://www.jianshu.com/p/7e6e55c48972" target="_blank" rel="noopener">从算法层面描述</a></p><p><a href="https://www.jianshu.com/p/9dc9f41f0b29" target="_blank" rel="noopener">整体描述LSTM</a></p><h4 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h4><p>循环神经网络的主要用途是处理和预测序列数据。</p><p>在全连接神经网络或者卷积神经网络中，都是从输入层到隐藏层再到输出层的，层与层之间都的全连接的，但<strong>每层之间的结点是无连接的</strong>。这就导致当前神经元没有前一个的记忆。而RNN的隐藏层之间的结点是有连接的，RNN的当前节点的输入包含上一层的输出和本层上一个节点的输出。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdrer62l38j30ys0ae791.jpg" alt="截屏2020-04-12 下午4.37.36" style="zoom:33%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdreshd3cuj30wg0d4wit.jpg" alt="截屏2020-04-12 下午4.38.49" style="zoom:33%;" /></p><p>它对短距离依赖很有效，但对长距离依赖的效果则变差</p><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p>LSTM 是一种特殊的RNN。通过精巧的设计（CNN中的深度残差网络也是类似）<strong>解决长序列训练过程中的梯度消失和梯度爆炸问题</strong>，即远距离传递导致的信息丢失问题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdret6tzvnj30vo0ca0yo.jpg" alt="截屏2020-04-12 下午4.39.32" style="zoom:33%;" /></p><h4 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h4><blockquote><p>Long-Term Dependencies —— 长距离依赖</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> LSTM </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算中的安全性</title>
      <link href="/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/16%20%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/16%20%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><p>互联网最初的设计并没有太多的考虑安全问题。最初的观点是：“通过互联网联系在一起的相互信任的用户”，而互联网协议的设计者在其中充当佐料的角色。</p><p>网络安全领域包括黑客如何攻击电脑网络，我们如何对这些攻击进行防御，以及如何设计能够免疫攻击的结构。</p><p>在每一层中都应该考虑安全性问题。</p><h4 id="什么是网络安全"><a href="#什么是网络安全" class="headerlink" title="什么是网络安全"></a>什么是网络安全</h4>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件度量工具的使用和比较：SonarQube、JDEPEND、</title>
      <link href="/2020/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AF%B9%E6%AF%94/"/>
      <url>/2020/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>软件度量是对程序本身进行数值化表示的一种方法，比如方法复杂度，代码行数，包数目等。目的是帮助开发者和管理者发现软件可能存在的缺陷、技术债务积累、代码气味等问题。</p><p><a href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis" target="_blank" rel="noopener">静态代码分析工具列表</a></p><a id="more"></a><h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><p>MacOS Catalina 10.15.4</p><p>Win10（虚拟机）</p><p>IntelliJ IDEA 2019.3</p><h3 id="SonarQube-8-2"><a href="#SonarQube-8-2" class="headerlink" title="SonarQube 8.2"></a>SonarQube 8.2</h3><p>提供多种安装方式，这里安装在本机：</p><p>下载压缩包并解压到对应目录后，使用命令行启动服务器，并访问<a href="http://localhost:9000/" target="_blank" rel="noopener">http://localhost:9000</a>即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../sonarqube/bin/[OS]/sonar.sh console</span><br></pre></td></tr></table></figure><p>SonarQube提供的度量方法，帮助用户了解自己是否满足代码质量的标准，好的代码质量能够减少许多代码问题和技术债务的积累。确保新写的代码是干净的，从不同的层面进行分析。</p><p>在GUI中，有相关的引导，能够轻易的将SonarQube引入项目中：基本原理是在GUI页面中为项目生成一个特定的Token，在Maven或Gradle项目的配置文件中添加SonarQube插件，最后执行提供的命令即可，命令中包含了之前生成的项目令牌。</p><p>在Measure栏，SonarQube中提供了许多实用的度量方法，包括：</p><ul><li>可靠性：Bugs、分级、补救措施</li><li>安全性：易损性、分级、补救措施</li><li>安全性审查：安全性热点、分级</li><li>可维护性（对会增加更新难度的代码进行标记）：代码气味、债务（时间）、债务比例、分级、达到A级的措施</li><li>覆盖率：覆盖率、需覆盖行、未覆盖行、已覆盖率<ul><li>单元测试数量、错误、故障、跳过、成功、执行时间</li></ul></li><li>重复率：密度、重复行、重复块、重复文件</li><li>大小（数量）：代码行、总行数、声明、函数、类、文件、注释行、注释行占比</li><li>复杂度：循环复杂度（全覆盖测试的最少测试用例）、感知复杂度（理解程序的困难程度）</li><li>问题：开放问题、重开问题、确认问题、False Positive问题，保留问题</li></ul><p>在Issues栏，SonarQube还能分析代码，检测出违反开发规范的代码，并给与提醒</p><p>在Activity栏，可以展示软件度量的变化趋势，主要包括：</p><ul><li>问题：Bugs、代码气味、易损性</li><li>覆盖率：需覆盖行和未覆盖行</li><li>重复率：代码行和重复行</li><li>定制：对任意的软件度量进行组合</li></ul><p>使用该功能，每执行一次命令行则记录一次数据日志</p><p>优点：全面</p><p>缺点：</p><ul><li>无法直接回顾以前的历史记录，需要对源码进行版本控制</li><li>不开源，研究人员/开发者无法使用自己的软件度量标准</li></ul><h3 id="JDepend"><a href="#JDepend" class="headerlink" title="JDepend"></a><a href="https://github.com/clarkware/jdepend" target="_blank" rel="noopener">JDepend</a></h3><p>说明文档在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$JDEPEND_HOME&#x2F;doc</span><br></pre></td></tr></table></figure><p>缺点：项目太老，需要修改源码重新编译，不支持可视化，没有历史记录，数据没有可视化，难以阅读，对新手来说难以理解</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdh8kjrwnij313t0u0qfg.jpg" alt="截屏2020-04-03 下午9.27.56"></p><h3 id="X-Ray"><a href="#X-Ray" class="headerlink" title="X-Ray"></a><a href="http://xray.inf.usi.ch/xray.php#download" target="_blank" rel="noopener">X-Ray</a></h3><p>2008年的工具</p><p>优点：多种可视化方式</p><p>缺点：只作为<a href="https://marketplace.eclipse.org/content/x-ray-software-visualization" target="_blank" rel="noopener">旧版Eclapse-Ganymede插件</a>使用，部分图片的内容让人感到混乱，扩展性差</p><h3 id="SourceMonitor"><a href="#SourceMonitor" class="headerlink" title="SourceMonitor"></a><a href="http://www.campwoodsw.com/sourcemonitor.html" target="_blank" rel="noopener">SourceMonitor</a></h3><p>优点：支持多语言，图形化设置，通过checkpoint可以保持和查看历史数据</p><p>缺点：只支持Windows，设置不合理，无历史记录，数据没有可视化，难以阅读，排版差</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdha02b0ilj30sg0no763.jpg" alt="截屏2020-04-03 下午10.17.29"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdha3u8dw5j31f20iwn8m.jpg" alt="截屏2020-04-03 下午10.17.29"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdha651nybj31f20hojup.jpg" alt="截屏2020-04-03 下午10.17.29"></p><h3 id="CodeCity"><a href="#CodeCity" class="headerlink" title="CodeCity"></a><a href="https://wettel.github.io/codecity.html" target="_blank" rel="noopener">CodeCity</a></h3><p>介绍，<a href="https://www.youtube.com/watch?v=HT3iw5l4l6U" target="_blank" rel="noopener">导入模型</a></p><p>优点：好看，功能多</p><p>缺点：复杂，旧，操作不易</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhb7tnianj31cv0u0qo0.jpg" alt="截屏2020-04-03 下午10.59.19"></p><h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a><a href="http://findbugs.sourceforge.net/publications.html" target="_blank" rel="noopener">FindBugs</a></h3><h3 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a><a href="https://pmd.github.io/" target="_blank" rel="noopener">PMD</a></h3><p>PMD is a source code analyzer. It finds common programming flaws like unused variables, empty catch blocks, unnecessary object creation, and so forth. It supports Java, JavaScript, Salesforce.com Apex and Visualforce, PLSQL, Apache Velocity, XML, XSL.</p><p>Additionally it includes CPD, the copy-paste-detector. CPD finds duplicated code in Java, C, C++, C#, Groovy, PHP, Ruby, Fortran, JavaScript, PLSQL, Apache Velocity, Scala, Objective C, Matlab, Python, Go, Swift and Salesforce.com Apex and Visualforce.</p><p>PMD的文档，它会对代码中的如下部分进行检查：<br>　　 未使用的本地变量<br>　　 空的catch块<br>　　 未使用参数<br>　　 空if语句<br>　　 重复的import语句<br>　　 未使用的私有方法<br>　　 可能是Singletons的类<br>　　 短/长变量及方法名字</p><p>PMD提供了一项叫作CPD的很有用的功能，它检查代码的拷贝粘贴部分。我使用PMD找到的最频繁的错误是未使用的import语句，未使用的私有变量以及意外重复拼写。</p><h3 id="CheckStyle"><a href="#CheckStyle" class="headerlink" title="CheckStyle"></a><a href="https://github.com/checkstyle/checkstyle" target="_blank" rel="noopener">CheckStyle</a></h3><p>Checkstyle is a tool for checking Java source code for adherence to a Code Standard or set of validation rules (best practices).</p><p>Checkstyle检查如下部分：<br>　　 Javadoc注释<br>　　 命名约定<br>　　 标题<br>　　 Import语句<br>　　 体积大小<br>　　 空白<br>　　 修饰符<br>　　 块<br>　　 混合检查（包活一些有用的比如非必须的System.out和printstackTrace）</p><p>不像PMD，Checkstyle能够检查Javadoc注释；Checkstyle可以发现更多的错误。包括漏掉的Javadoc注释，超过80个字符的行、不合约定的变量名、用tab来代替空格等等。两个工具都允许创建自定义的规则。</p><h3 id="Jalopy"><a href="#Jalopy" class="headerlink" title="Jalopy"></a><a href="http://jalopy.sourceforge.net/" target="_blank" rel="noopener">Jalopy</a></h3><p>商用版 <a href="https://www.triemax.com/" target="_blank" rel="noopener">TRIEMAX</a></p><p>　　Jalopy是一个易于配置的源代码格式程序，它能检测并修补Java代码中大量的习惯性缺陷。Jalopy更像一个代码整理器而不是检查器。Jalopy的插件现在已经支持大多数IDE，而且多数是无缝集成。我发现Jalopy特别强大，能够干许多很酷的事情。例如，它可以修改代码缩进、对齐括号、使行宽符合某个字符长度、插入相关的Javadoc注释以及对import语句排序。Jalopy最好的地方是超级自定义功能。一个简单的用户界面就可以让你选择Jalopy的所有功能的开关，不需要XML配置文件。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果想在你的组织中使用它们中的一个，Checkstyle似乎更好一些：它检查公司编码约定的大多数项目。如果增强代码质量是主要目标，那PMD是一个好的选择。但是如果你想要更多的功能并真正使用工具来修改代码，应该试试Jalopy。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件度量 </tag>
            
            <tag> SonarQube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《A Manifesto for Future Generation Cloud Computing&amp;#59 Research Directions for the Next Decade》 —— 读书笔记</title>
      <link href="/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8C%91%E6%88%98%E5%92%8C%E6%9C%AA%E6%9D%A5%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"/>
      <url>/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8C%91%E6%88%98%E5%92%8C%E6%9C%AA%E6%9D%A5%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>云计算和按需付费模型的出现，让用户可以随时随地获得基于订阅的服务。这带来的好处包括：更短的启动时间；创建可扩展的全球企业程序；给科学计算和高性能计算带来更好的成本价值关联；以及为无处不在的普适程序带来不同的调用/执行模型。</p><p>另一方面，无服务计算、软件定义网络、物联网、边缘计算等新技术为云计算带来了机遇，但也同时带来了新的挑战，对新方法和研究策略的需求。对于解决可扩展性、灵活性、可靠性、安全性、可持续性等问题的模型，也需要重新进行评估。</p><p>该文献将定义云计算中的主要的开放性挑战，调查最新的解决方案和它们的局限。接着讨论新兴的趋势和影响范围，以及它们如何推动未来云计算的挑战。据此再进一步讨论云计算的未来，并指出下一个十年的研究方向。</p><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>云计算模型，提供了对基于订阅的IT资源的按需访问，按需扩展，按使用付费。当前的三种主要服务模型为SaaS、PaaS、IaaS。在软件即服务SaaS中，用户通过互联网访问在数据中心上运行和管理的程序或软件，从而避免如版权、维护IT基础设施等费用；平台即服务PaaS，适合对IT资源需要更多控制的用户，但也同时为用户提供了一些框架来支持云程序的创建和部署；基础设施即服务IaaS，则允许用户访问计算资源，通常是提供虚拟机和存储空间。它不仅是前两者的基础，也是云计算的支柱。</p><p>云计算中旧有的技术同样在不断发展，在虚拟化中，容器技术的出现和广泛使用，甚至导致新的服务模型出现：容器即服务CaaS。</p><p>其中一些特定云服务专注于简化配置，以此满足特定的商业要求，这些旨在帮助企业创造价值的云服务，在种类和数量方面正在快速的增长：比如新兴的、易于使用的、基于云的数据分析服务和无服务结构。</p><p>云计算中的分布式计算是一个更明显的发展趋势，相关概念有雾计算、边缘计算、物联网、将服务分布在地理分布的数据中心等。边缘/雾计算的核心思想是将计算能力移动到更接近数据的地方，比如移动基站、网关、交换机、路由器等，从而降低延迟；</p><blockquote><p>cluster computing —— 网格计算<br>grid computing —— 集群计算</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfjn0ul31j311n0u04d1.jpg" alt="截屏2020-04-02 上午10.19.45"></p><h3 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h3><h4 id="可扩展性和可伸缩性（弹性）"><a href="#可扩展性和可伸缩性（弹性）" class="headerlink" title="可扩展性和可伸缩性（弹性）"></a>可扩展性和可伸缩性（弹性）</h4><ul><li>通过硬件的异质性来加速计算</li><li>资源虚拟化、性能、隔离、价值模型</li><li>用于可扩展弹性服务的软件</li><li>对性能进行监控和建模的中间件</li><li>适应性的程序编程模型</li></ul><p>网格计算和集群计算是早期的分布式计算模型，云计算与前两者不同，它的优点是可以保证按需提供几乎无限的计算资源。好处之一是<strong>云计算中预料之外的计算资源需求激增不会违反<a href="http://blog.sina.com.cn/s/blog_c3917d180101c8r6.html" target="_blank" rel="noopener">服务级别协议SLAs</a></strong>，因为用户购买的固定计算资源无法给用户提供预期之外的服务质量QoS。但<strong>前提</strong>是云服务提供商提供可扩展的服务，即用户可<strong>以按需增加计算资源</strong>，并且新的计算资源能够直接给当前程序带来性能和服务质量的提升；其二是<strong>客户不需要提前调查、规划、购买硬件设备，而是根据当前需求购买云计算资源，并灵活变动</strong>。</p><p>研究挑战在于可扩展的服务，它包括硬件级、中间件级和应用级。在硬件级中，要求云计算提供商有<strong>并行计算硬件</strong>，如多核、集群、加速器（GPUs），和非传统的架构（神经和量子），以及在<strong>IaaS服务</strong>中为用户提供<strong>异质硬件的抽象</strong>（如VMs、容器），同时提供隔离和性能保证。在<strong>中间件级别</strong>中，需要为用户提供<strong>编程模型和抽象</strong>，从而让使用PaaS服务的开发者可以专注于程序本身的功能（如Map、Reduce函数），而非功能性的问题（如可扩展性、容错）则交给中间件负责。在<strong>应用级</strong>中，需要开发新的算法，克服<strong>顺序确定性算法</strong>固有的可扩展性问题，包括非同步演化算法、近似算法、在线/增量算法（<a href="https://ieeexplore.ieee.org/document/5380857" target="_blank" rel="noopener">文献</a>）等，这些算法可能会通过<strong>牺牲精度或一致性来实现可扩展性和性能</strong>。</p><p>在弹性服务方面的挑战包括：如何<strong>精确预测</strong>计算资源需求和不同资源分配下的程序性能。这些工作负载和性能模型能够帮助中间件中的资源管理器进行决策，也使程序能够扩展和收缩，包括动态创建、迁移、回收虚拟机、容器和其他计算资源等。</p><p>成熟的<strong>虚拟机技术</strong>，使得CPU密集型应用中在虚拟机中的性能已经足以跟本机性能媲美，但依旧出现了<strong>容器技术</strong>，在快速启动的易于使用方面对虚拟机进行了改进。</p><p><strong>编程模型</strong>则使程序能够<strong>动态重新配置</strong>，让中间件在公有云和私有云之间迁移数据和计算，甚至是将计算移动到离数据源更近的地方，如IoT中的传感器网络。</p><p>云的可扩展性最终还是受各个<strong>组件</strong>（如计算、存储、相互联系）的扩展规模的限制。由Moore’s law 和 Dennard scaling可以推断，新的计算单元和用电量都将不再扩展，这直接影响了云的计算性能和成本。在这方面，需要研究CMOS（互补金属氧化物半导体）以外的新技术。类似的还有内存，DRAM（动态随机存取存储器）限制了成本和扩展，新的研究方向是非易失性技术，这些技术将在降低功耗的同时，进一步扩展负载存储操作内存。最后一个研究方向是<strong>光子互联</strong>，让所谓的硅光子通关光子连接传播到芯片中，改进性能、扩大规模、降低能耗。</p><blockquote><p>Service Level Agreement/SLA —— 服务协议级别<br>neuromorphic —— 神经形态<br>sequential deterministic algorithms —— 顺序确定性算法<br>asynchronous evolutionary algorithms ——非同步演化算法<br>approximation algorithms —— 近似算法<br>online/incremental algorithms —— 在线/增量算法<br>Complementary Metal-Oxide-Semiconductor —— CMOS —— 互补金属氧化物半导体<br>Dynamic Random-Access Memory —— DRAM —— 动态随机存取存储器</p></blockquote><h4 id="资源管理和调度"><a href="#资源管理和调度" class="headerlink" title="资源管理和调度"></a>资源管理和调度</h4><ul><li>大规模服务中的自动扩展和资源控制</li><li>多云操作和负载平衡</li><li>专门的多重控制循环设计</li><li>工作负载特征错误的敏感性</li><li>安全和资源管理的相互作用</li></ul><p>云数据中心有多达几十万的计算和存储设备，因此需要高效的资源管理和调度策略。当前的<strong>IaaS</strong>主要依赖两种<strong>虚拟机配置策略</strong>：<strong>静态</strong>和<strong>动态</strong>。静态策略使用<strong>装箱算法</strong>将固定数量的物理资源分配给虚拟机；动态则通过虚拟机<strong>实时迁移</strong>和其他负载平衡技术来处理负载的变化。这些策略可以是<strong>提前预测分配</strong>，也可以是<strong>监测后重新分配</strong>，但不管如何，都需要知道虚拟机资源的需求，可以是用户指定，也可以是通过监控数据进行预测</p><p>对于<strong>PaaS</strong>、<strong>SaaS</strong>供应商来说，资源管理方法可以帮助管理分配给分布式应用、容器、网络服务、微服务的资源的种类和数量。相关的策略有：1<strong>.自动扩展技术</strong>（基于当前和预测的负载动态扩展或收缩）2<strong>.资源节流技术</strong>（处理瞬时自动扩展中的工作负载突发、平滑和变化，和控制可抢占VM的使用）3.<strong>准入控制方法</strong>（处理高峰负载和高价值客户的负载优先级）4.<strong>服务编排和工作流调度</strong>（整理和编排工作负载，可能专门为特定领域设计，如科学领域中对成本和任务需求有限制的工作流，<a href="https://manuscript.elsevier.com/S0167739X15000059/pdf/S0167739X15000059.pdf" target="_blank" rel="noopener">参考文献</a>）5.<strong>多云的负载平衡</strong>（将应用的负载分布到多个云数据中心）。</p><p>其中的一个挑战是，当前的资源管理策略<strong>不适用</strong>于<strong>不精确的资管需求预测</strong>，因此需要新的权衡方法，在工作负载信息不精确的情况下，对策略<strong>最优性</strong>和<strong>稳健性</strong>之间进行权衡。当前的需求估计和工作负载预测方法在未来可能不适用，而机器学习和人工智能能否胜任有待研究。</p><p>另一个常见的问题是，资源管理策略<strong>专注于优化特定的度量指标和资源</strong>，缺少一个能在<strong>相同多重控制循环环境中共存</strong>的系统方法，使用户能公平的访问资源，以及对云堆栈各层在整体上实现最佳化（<a href="https://ieeexplore.ieee.org/abstract/document/6809354" target="_blank" rel="noopener">参考文献</a>）</p><p>当前的研究功能工作还缺少安全和资源管理之间的相互作用的风险问题</p><blockquote><p>provisioning policies —— 配置策略<br>bin-packing algorithms —— 装箱算法<br>resource throttling methods —— 资源节流技术<br>preemptible —— 抢占式的<br>service orchestration —— 服务编排<br>multiple control loops —— 多重控制循环</p></blockquote><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul><li>导致大规模服务中断的故障关联</li><li>缺少整体服务可靠性模型</li><li>缺少自动的可靠性感知的服务管理机制</li><li>缺少故障感知的配置策略</li></ul><p>云数据中心的系统是高度相互关联和相互依赖的。由于云计算系统的规模、复杂性和相互依赖性，它们需要面对可靠性相关挑战，比如硬件故障、资源缺失故障、溢出故障、网络故障、超时故障、和环境改变引发的软件缺陷。有些故障会影响系统操作，连锁故障甚至会应发大规模服务中断。企业组织通常会采用严格的可靠性保证和还原能力。需要新的云服务供应方式，来保障性能和<strong>从能各种故障中恢复的能力</strong>。另一个挑战是云系统的<strong>可靠性</strong>和<strong>能耗</strong>之间的相互影响的研究。</p><p>云计算是<strong>面向服务</strong>的而不是面向资源的，所以分布式计算中保障可靠性的模型（如容错）不适和直接用于云计算系统。</p><p>云计算中相互关联的特征的范围，比如巨大的规模、服务共享模型、广域网络、软/硬件组件异质性，导致难以分析云计算系统的规模和可靠性的<strong>期望值</strong>。</p><p>现有许多研究对故障进行单独分析和解决，但都忽略了<strong>故障之间的相互影响</strong>。现存对的云计算环境中也缺少可靠性模型、自动的可靠性感知的服务管理机制，和故障感知配置策略</p><h4 id="可持续性"><a href="#可持续性" class="headerlink" title="可持续性"></a>可持续性</h4><ul><li>云数据中心的能源需求</li><li>虚拟机整合以最小化服务器的能耗</li><li>服务器之间数据流的最佳调度策略</li><li>基于机器学习的任务分配</li><li>能源与服务质量的权衡</li></ul><p>2017年世界上大约有850万云数据中心，它们每年的耗电量比大多数国家都多（除了美、中、俄、日）。ICT设施的耗电量接近世界总体耗电量的10%。但云和网络也有助于节能，比如智慧城市，或最大程度优化可再生和不可再生能源的混合使用。考<strong>虑能</strong>耗的同时还要考虑<strong>服务质量</strong>，比如在搜救领域就不能降低服务质量来减少能耗。</p><p>当前的主要工作是整合虚拟机（涉及资源管理）以减少能耗。但其他的基础设施，比如制冷系统（接近35%能耗）、网络等也需要适合的调度算法。</p><p>多核结构，新型的基于硬件的休眠启动控件、时钟速度管理技术，让服务器的能耗取决于瞬时工作负载。因此新的基于机器学习的方法能够动态<strong>分配</strong>任务到（云或雾的）多个服务器中，从而最少的违反SLA。整体技术也需要解决网络的服务质量，比如包延迟、远程访问云数据中心的网络能源效率问题。这些技术的目的都是为了提供一个能<strong>在线自动调整</strong>或自治的方法，使云系统的能耗和服务质量作为一个整体得到解决。</p><p>当前的实验研究表明，<strong>深度学习和神经网络</strong>能够按照规定的执行延迟、响应时间、系统吞吐量、和能耗对任务进行分配（<a href="https://spiral.imperial.ac.uk:8443/bitstream/10044/1/59726/2/ServerstateDetection.pdf" target="_blank" rel="noopener">参考文献</a>）。另一种方式涉及<strong>均衡能源供应</strong>，云数据中心可以调节自身能耗并以服务质量作为响应，根据供应的能源动态的修改处理器的可变时钟速率（<a href="https://ieeexplore.ieee.org/document/6903096" target="_blank" rel="noopener">参考文献</a>）。也有人建议使用混合使用可再生和不可再生能源</p><blockquote><p>Information and Communications Technology, ICT —— 信息通信技术<br>sleep-start controls —— 休眠启动控件<br>Holistic techniques —— 整体技术<br>rationing the energy supply —— 均衡能源供应</p></blockquote><h4 id="异质性"><a href="#异质性" class="headerlink" title="异质性"></a>异质性</h4><ul><li>虚拟机级别、供应商级别、硬件结构级别的异质性</li><li>虚拟机放置、供应配置和调度‘</li><li>采用供应商指定语言进行硬件加速</li></ul><p>因为云供应商需要不断更新硬件以满足用户需求，以及提高性能和效率，因此出现了云内在的异质性，反映在三个层面。</p><p><strong>虚拟机</strong>层面，原因是能够以<strong>多种方式和配置方法</strong>对同质的资源进行组织（或者接近同质的，比如相同的处理器族），比如N核的同质硬件处理器可以被组织为有任意核的虚拟机。<strong>供应商</strong>层面，原因是可以从<strong>多个云供应商</strong>中利用资源，不同的云供应商有不同的虚拟机监控程序和软件套件（通常出现在多重云环境中）。<strong>硬件结构</strong>层面，原因是<strong>同时利用</strong>CPUs和硬件加速器（如GPUs、FPGAs）。</p><p>第一重挑战是<strong>异质环境中的资源和工作负载管理</strong>。资源管理专注于以静态和动态的方式对虚拟机进行安置，综合考虑网络参数和能耗的本地调度或全局调度技术。工作负载管理则通过基准技术优化工作负载的安置的调度。基准技术的实践在虚拟机层面已经足够成熟，在供应商层面也正在发展（<a href="https://link.springer.com/article/10.1007/s10922-014-9307-7" target="_blank" rel="noopener">参考文献1</a> &amp; <a href="https://pureadmin.qub.ac.uk/ws/files/74475124/Varghese_IEEETCC.pdf" target="_blank" rel="noopener">参考文献2</a>），但在<strong>硬件结构层面对工作负载的性能预测</strong>还缺少研究。除此之外 ，当前对异质资源的资源管理和工作负载管理的研究也是分别进行的。当前还缺少对3个层面的异质性进行整合和管理的通用云平台。</p><p>第二重挑战关于<strong>应用软件的开发，使之兼容异质资源</strong>。当前大部分的加速器需要不同的编程语言（比如CUDA和OpenCL需要对GPU编程），导致云程序很难采用加速器。在IaaS中，开发者只能直接面对硬件环境进行编程，而SaaS、PaaS中，可以在中间件对硬件进行抽象。但在中间件提供对加速器硬件的抽象，则会减少优化性能的可能性。因此需要对性能和易用性进行权衡。在这方面的开放性挑战是开发与底层硬件无关的软件，并且可以基于可用硬件进行适应（<a href="https://ieeexplore.ieee.org/document/7495121" target="_blank" rel="noopener">参考文献</a>）</p><blockquote><p>homogeneous —— 同质的，同类的<br>heterogeneous —— 异质的<br>vendor —— 供应商<br>Hypervisor —— 虚拟机监控程序<br>Software suits —— 软件套件<br>Field Programmable Gate Arrays (FPGAs) —— 现场可编程门阵列<br>benchmarking techniques —— 基准技术</p></blockquote><h4 id="相互关联的云"><a href="#相互关联的云" class="headerlink" title="相互关联的云"></a>相互关联的云</h4><ul><li>云的相互操作性</li><li>安全性和服务质量的常见规则和标准</li><li>跨站点的虚拟网络</li><li>服务的最小公分母背后的相互操作性</li></ul><p>云供应商都各自把工作局限于自己的服务。云的相互操作性是各种类型的云和系统（如公有云、私有云）彼此相互了解的一种能力，了解的信息包括：系统接口、配置、验证和授权格式、数据格式、程序的初始化和定制化。</p><p>从更宽泛的角度来说，互连云有许多用于方法，用于整合不同的云供应商和数据中心的服务和功能。这些技术取决于互连云的参与者、它的目标、和提供给用户的服务整合的透明度（<a href="Interconnected Cloud Computing Environments: Challenges, Taxonomy, and Survey">参考文献</a>）</p><p>现有的云供应商虽然有专门的互操作机制，但并<strong>没有统一的标准和开源</strong>，因此有很大的局限性。当前的标准化工作有：OGF的OCCI、SNIA的CDMI、DMTF的CIMI和OVF、IEEE的互连云、NIST的联合云。但<strong>现存云服务的接口并没有被标准化，且很多云服务的提供商都使用不同的接口、格式和上下文配置机制</strong>。</p><p>广义上，如果各种云之间的互连是由供应商发起和管理的，这些方式可以被归为联合的云计算。<strong>联合云计算</strong>可以被看做是云计算发展的下一步，也是<strong>整合雾计算和边缘计算</strong>结构的下一步。联合云模型的好处有：资源优化、节约成本、敏捷资源交付、可扩展性、高可用性、商业连续性、地理分布</p><p>共享云之间的资源有2个原因，一是公司企业希望现有的内部基础设施能够<strong>最大程度的被使用</strong>，因此公司的私有云需要与公有云无缝集成；二是公司把的大部分的程序（没有隐私要求的）转移到公有云上，以此将程序的<strong>工作负载转移</strong>到云上，或放宽资源需求的限制。</p><p>最新的项目Aneka开发了中间件和库来整个不同的资源（如VM、数据库等），但也导致非最优的云程序或者只支持特定的服务模型</p><p>互操作性和便携性在不同的组件上有不同的考虑，包括接口规范、可移动的数据格式和应用、国际公认的服务质量和安全标准。如何以高效、透明的方式，通过跨站虚拟网络将本地云和外部供应商资源进行互连，实现云资源的供应、管理和配置，是普及该技术的重要挑战。</p><p>互连云服务的最小公分母是一个限制，如何突破这个限制，从而支持更丰富的云程序是其中的一个挑战。其他挑战还有：如何在多个供应商之间的授权、访问、账单方面进行协调；如何将互连云应用到雾计算等新兴趋势中。</p><blockquote><p>InterCloud —— interconnected Cloud —— 互连云<br>minimum common denominator —— 最小公分母</p><ul><li>Open Grid Forum’s (OGF) Open Cloud Computing Interface (OCCI)</li><li>Storage Networking Industry Association’s (SNIA) Cloud Data Management Interface (CDMI)</li><li>Distributed Management Task Force’s (DMTF) Cloud Infrastructure Man- agement Interface (CIMI)</li><li>DMTF’s Open Virtualization Format (OVF)</li><li>IEEE’s InterCloud</li><li>National Institute of Standards and Technology’s (NIST) Federated Cloud</li></ul></blockquote><h4 id="强化资源受限设备的自主权"><a href="#强化资源受限设备的自主权" class="headerlink" title="强化资源受限设备的自主权"></a>强化资源受限设备的自主权</h4><ul><li>移动云绑定模型——任务委托和代码分流</li><li>移动云的适应性问题</li><li>云中心的物联网</li><li>雾计算</li></ul><p>智能手机等移动设备，它们的电池、CPU、内存、存储等跟台式设备比是受限的，但可以通过外部的云资源减少这些限制。因此出现了移动云的概念。</p><p>在移动云上的主要研究包括<strong>任务委托</strong>和<strong>移动代码负担转移</strong>。任务委托是指，从多个云供应商中移动调用网络服务，因此涉及互操作性问题，解决方案是中间件。代码负担转移，则对应用程序进行配置和分区，并将资源密集型的方法函数转移到云实例的代理上（如Cloudlets/swarmlets）。相关的研究挑战有：如何开发理想的负担转移方式、如何识别资源密集型方法、如何学习合理的决策机制——兼顾设备上下文（如电池级别、网络连通性）和云上下文（如云代理的当前负载）</p><p>物联网演变为工业4.0和互联网4.0+，而云计算能够帮助存储和分布式处理物联网节点的数据。<strong>网络延迟</strong>是以云为中心的物联网模型的挑战之一。除此之外还有<strong>能耗</strong>问题，虽然可以通过可再生能源缓解，但却又引发了<strong>服务质量</strong>问题。</p><p><strong>雾计算</strong>是一个新兴的解决方案，它的优点包括边缘设备的安全、位置识别、敏捷开发、低延迟、成本和性能上的效率，但同时也是关键的挑战。</p><blockquote><p>task delegation —— 任务委托<br>mobile code offloading —— 移动代码负担转移<br>Cloudlet —— 小云<br>swarmlets —— 小集群</p></blockquote><h4 id="安全性和隐私"><a href="#安全性和隐私" class="headerlink" title="安全性和隐私"></a>安全性和隐私</h4><ul><li>基于编码的数据保护</li><li>选择性的信息共享</li><li>细粒度的访问</li><li>查询的机密性和完整性</li><li>基于安全性的云供应商原则</li></ul><p>涉及机密性、完整性、可用性。</p><p>在机密性方面，通常是在储存前在云供应商外部对数据进行编码，但这限制了云供应商的查询评估。解决方案之一是<strong>索引</strong>，使部分查询评估不需要对数据进行解码。索引是保存了部分数据属性的元数据，对索引的定义需要在精确性和隐私性方面取得平衡，<strong>精确的索引能提高查询性能，但会暴露数据信息</strong>。某些编码技术也支持直接对数据进行操作和评估，不需要解码。比如<strong>OPE</strong>和<strong>同态加密</strong>。一些加密的数据库系统支持<strong>对加密数据进行SQL查询</strong>。</p><p>一些基于云的程序（比如健康管理、社交服务等）会从多个数据源获得数据，而一些数据挖掘工具会因此挖掘到比预期更多的隐私数据，如何保护隐私性是一个挑战。对此的研究挑战是如何设计隐私保护的理论模型和实践机制。当前的研究趋势是<strong>采用机器学习分析大数据</strong>，包括威胁分析、攻击智能、病毒传播、数据关联等。</p><p>常用的保护措施是，隐私数据仅对通过加密登录的用户本身开放，但有时候需要选择性的公开一些数据给其他用户，常用的方法是：<strong>选择性加密</strong>和<strong>基于属性加密ABE</strong>。但选择性共享数据还要考虑到第三方合作共享和分布式计算的场景可能出现的问题。</p><p>有时候数据之间的关联比数据本身更加敏感，可以将数据拆分成不同部分并储存在不同的服务器中，但这会导致查询复杂度增加。</p><p>虽然<strong>选择性访问</strong>的问题已经被解决，但却会受到利用访问频率侵犯数据和用户隐私的攻击。解决方案是<strong>私有信息检索RIP技术</strong>，它涉及隐私保护索引技术：比如Oblivious RAM、B-tree结构、二分搜索树（<a href="https://ieeexplore.ieee.org/abstract/document/7830709" target="_blank" rel="noopener">参考文献</a>）。但该领域的实践性解决方案仍然是一个挑战。</p><p>关于完整性的技术有：数字签名、PDP、POR、将探测到的数据未授权修改存储在云供应商外部等。验证授权用户的数据的<strong>完整性</strong>只是其中一个方面。还有，由多用户共享数据的改变和查询引起的问题。相关的方法有确定性方法（使用认证的数据结构）和概率方法（完整性检查插入）（<a href="http://pdfs.semanticscholar.org/8cc0/0323e1907a0cf19561827fe4fa8047334e6f.pdf" target="_blank" rel="noopener">参考文献</a>），都可以代表有希望的方向，但所提供的适用性和完整性保证受到限制。</p><p>关于可用性，是如何让用户能够选择到满足其安全性需求的云供应商（云供应商的行为通常在SLAs中声明）。最近的研究有关于不同云服务特征的可能依赖的探索，但这只是第一步。</p><p>基于硬件的技术也可以保护云中的数据，最著名的是ARM TrustZone和 Intel SGX 技术。简单来说就是创建安全的执行环境。</p><p>高级持久性威胁APTs是一类新的网络攻击，特点是面向目标，高度针对性，组织合理，资金充裕，技术先进，隐秘且持久。目前缺乏足够的防御手段，以及减少损失的措施，如技术驱动或原则驱动的解决方案。</p><blockquote><p>Order Preserving Encryption —— OPE<br>fully (or partial) homomorphic encryption —— 全、半同态加密<br>selective encryption —— 选择性加密<br>attribute-based encryption (ABE) ——基于属性的加密<br>Private Information Retrieval (PIR) —— 私有信息检索<br>privacy-preserving indexing techniques —— 隐私保护索引技术<br>Oblivious RAM<br>Provable Data Possession —— PDP<br>Proof Of Retrievability —— POR<br>Software Guard Extensions —— SGX<br>Advanced Persistent Threats (APTs) —— 高级持久性威胁</p></blockquote><h4 id="云计算的经济"><a href="#云计算的经济" class="headerlink" title="云计算的经济"></a>云计算的经济</h4><ul><li>服务级别协议和策略管理</li><li>将内部的基础设施迁移到公有云供应商</li><li>选择合适的云供应商</li><li>云的许可模型</li></ul><p>近年来，云经济学的研究主题集中在许多关键方面：1.云服务的定价；2.代理机制（搜索符合用户预算的资源）；3.监视以确定是否满足用户要求（涉及SLAs），比如WS-Agreement之类的规范的实现。</p><p>云经济学涉及SLA，而SLA管理又与<u>计算资源、实例和服务</u>的供应和需求有关，在这方面有许多关于<u>基于原则的方法</u>和相关的<u>最优化策略</u>的研究（因为缺少资源适用场景）</p><p>另一个相关的方面是如何迁移公司内部的基础设施和IT部门到云供应商。比如迁移服务需要考虑服务后续如何使用，对业务能力的影响；迁移系统需要考虑是否会影响保留在企业内部的系统功能。其中IT部门应该起到中介者的角色。</p><p>上述背景引起了新技术的出现，比如基于容器的部署（无服务计算），使亚秒级计费成为可能，例如 Google “functions”，AWS Lambda。</p><p>使用许可是另一个问题，包括年度许可和永久许可。独立的软件供应商正在研究更适合云的许可模式，如<u>BYOL</u>，<u>完全按需</u>等。</p><p>选择合适的云供应商是另一个挑战。比较不同的云供应商十分耗时，并且难以比较。有人提出，专门平台对各个云平台进行比较，帮助用户进行选择；还有关于市场模型的研究</p><blockquote><p>BYOL (bring your own license)<br>marketplace models —— 市场模型</p></blockquote><h4 id="应用部署和交付"><a href="#应用部署和交付" class="headerlink" title="应用部署和交付"></a>应用部署和交付</h4><ul><li>资源的可编程性</li><li>持续传递</li><li>敏捷传递带来的技术债务积累</li></ul><p>资源的可编程性，是开发者能够对基础设施和平台进行编程控制，带来的好处比如让程序能够自动扩展，使程序能够在运行时自动修复、优化等。关键的好处是能够加速产品更新的交付。实现的关键是敏捷交付工具和基于模型的编排语言（比如 Terraform，OASIS TOSCA）。这些工具有助于自动化生命周期管理，包括持续交付和持续集成，应用程序和平台配置以及测试。</p><p>平台可编程性，开发云上的程序时，可以帮助减少软件开发的复杂度。比如用户专注于Map、Reduce任务，由中间件负责容错、任务分配的工作。当前正在研究的编程模型，关注如何处理<strong>云平台的异质性</strong>，比如将程序分布于边缘计算中的各个异质节点。当前缺乏交付框架和编程模型，将程序部署在CDC和边缘节点。因而无法在云应用中使用异构硬件，也无法使用互连云操作。</p><p>另一个挑战是应用程序的发展，加速产品更新交付会影响程序的质量。当前缺少云软件工程的研究，将传统开发和敏捷开发的优点结合。比如记录云程序的所有发行版本的性能和可靠性数据，以便更好地指导产品更新，以及自动识别违反设计模式的行为，并在测试新功能期间探索假设场景</p><blockquote><p>CDC —— 云数据中心</p></blockquote><h4 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h4><ul><li>服务在管理元数据上的局限性</li><li>数据管理策略和规范</li><li>管理对延迟敏感的数据流</li><li>整合流和批量数据</li></ul><p>大数据平台有多种类型，如用于互联网和企业工作负载，采用批处理+NoSQL，如Apache Hadoop；用于物联网，处理分布式数据流，如Apache Storm。</p><p><u>处理元数据（定位和使用数据）的服务</u>对<u>存储数据的服务</u>的支持不够。数据的隐私问题。广域网的延迟较高，从而影响物联网设备对低延迟处理的需求（出现边缘计算和雾计算）。数据中心里各个虚拟机之间的带宽和网络延迟，也会导致瓶颈和影响延迟敏感的数据流的处理。需要的解决方案包括，<strong>软件定义网络</strong>SDN，和<strong>网络功能虚拟化</strong>NFV。</p><p>还需要对Lambda结构的研究，以便在休息和运行时都能处理数据。Apache Flink和Spark Streaming 提供了一些早期方案。大数据系统对在弹性云上自动扩展和收缩的支持不够。</p><blockquote><p>Software Defined Networking (SDN)<br>Network Functions Virtualization (NFV)</p></blockquote><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li>高能耗和缺少能源的对称性</li><li>缺少对服务质量的保证</li><li>多重租赁和可扩展性问题</li></ul><p>近年关于云网络的研究有：SDN和NFV，用于构建敏捷、灵活的可编程计算机网络，减少运营支出。还有关于扩展限制、平面空间地址、和服务的过度订阅等问题的研究，促进了一些网络结构的产生，比如VL2, PortLand, and BCube。</p><p>关于网络的挑战之一是如何使<strong>能耗与负载成比例</strong>。大多数网络组件，比如交换机、路由器等硬件本身不支持节能的功能，比如没有通信时休眠，低流量时段的链路速率调整等。</p><p>另一个挑战则关于服务质量的保证。因为没有实现<strong>性能隔离</strong>的机制，导致SLAs没有对比如带宽和延迟的保证。当前的研究有通过网络抽象层VDC<strong>对虚拟机带宽的保证</strong>（<a href="https://dl.acm.org/doi/abs/10.1145/1921168.1921188" target="_blank" rel="noopener">参考文献</a>），但没有<strong>对延迟的保证</strong>。</p><p>在<strong>混合云环境中</strong>部署虚拟集群时，虽然可以通过虚拟化技术解决资源的网络连接问题，但云提供商无法像在其自己的数据中心中那样获得对核心Internet设备的特权访问。因此，云提供商在路由和流量工程方面的灵活性在很大程度上受到限制，<strong>网络性能缺少保证</strong>。</p><p>此外，与专用的数据中心网络相比，诸如Internet之类的公用网络的性能更加不可预测和易变，这使得更难以提供有保证的性能要求。传统的WAN方法，例如用于此类网络中流量工程的多协议标签交换MPLS，由于缺乏网络全局视图，因此在带宽使用和处理对延迟敏感的流量方面也效率不高（<a href="https://dl.acm.org/doi/abs/10.1145/2486001.2486012" target="_blank" rel="noopener">参考文献</a>）。 </p><p>由于现代云数据中心的网络规模很大，因此它也同样面临着和互联网相似的问题，比如VLAN的限制，VXLAN在多播种的限制，IPV4的限制等。</p><blockquote><p>Multi-Protocol Label Switching (MPLS) —— 多协议标签转换</p></blockquote><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><ul><li>HCI和分布式系统社区的差距</li><li>基础设施和服务的封装</li><li>生产力工具</li></ul><p>可用性是降低组织探索云服务和基础架构成本的关键因素，因为用户可以拥有更好的服务质量并提高生产力，从而减少人工支出。</p><p>云的可用性被NIST的可用性框架中突出为5个方面：能力、个人、可靠、安全、价值（<a href="https://link.springer.com/chapter/10.1007/978-3-319-20376-8_59" target="_blank" rel="noopener">参考文献</a>）。能力，与满足云消费者对云服务功能的期望有关。 个人，是允许用户和组织更改用户界面的外观和风格并自定义服务功能。 可靠，安全和价值，是与使系统在状态条件下安全、受保护地执行其功能，并分别将价值（结果）返回给用户。</p><p>对于可用性，当前的工作主要集中在将复杂的服务封装到API中，以方便用户使用，比如HPC云，研究者一直在创建服务来公开HPC应用程序，以简化其使用。</p><p>另一个方向是DevOps，它的目标是将开发（Dev）和操作（Ops）集成在一起，从而帮助更快地交付软件。在云环境中创建和部署解决方案时，DevOps提高了开发人员和运营商的生产力。 不仅要在云中构建新的解决方案，而且要简化从内部部署环境到多租户弹性云服务的旧软件迁移。</p><blockquote><p>capable, personal, reliable, secure, and valuable<br>High Performance Computing (HPC) —— 高性能计算</p></blockquote><h3 id="新兴的趋势和影响范围"><a href="#新兴的趋势和影响范围" class="headerlink" title="新兴的趋势和影响范围"></a>新兴的趋势和影响范围</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>Docker的诞生引起了各界对容器技术的关注。</p><p>容器依赖于现代Linux的内核设施，比如 cgroups, LXC (Linux containers) and libcontainer。Docker使用Linux核心的cgroups和命名空间来运行独立的容器。cgroups提供资源的隔离（如CPU、内存、网络、block I/O）。命名空间从程序的角度隔离操作环境（包括进程树、网络、用户ID、挂载文件系统）。libcontainer库作为<u>容器引用实现</u>。并将程序和相关依赖打包到容器镜像中。</p><p>容器技术在行业中的普及，促进了对容器即服务（CaaS）的需求，比如UberCloud。</p><p>容器的两大特点，一是启动速度快，甚至能低于1秒；二是容器对内存的占用量很小，消耗的资源很少。</p><p>容器的缺点是由于共享内核，因此隔离和安全比VM差（这是其中一个研究热点）。解决该问题的可能方案之一是<strong>硬件支持</strong>，比如Intel SGX的受信执行支持；二是使用Unikernel，是一种库操作系统。</p><p>容器技术的挑战是如何最优化容器性能，比如<strong>Slack技术</strong>对存储驱动最佳化，来加速容器启动。还有基于用户服务质量需求的容器集群管理，比如容器集群管理系统，Kubernetes，Mesos 和 Swarm。</p><blockquote><p>mounted file systems —— 挂载文件系统<br>container reference implementation —— 容器引用实现<br>trusted execution support of Intel SGX</p></blockquote><h4 id="雾计算"><a href="#雾计算" class="headerlink" title="雾计算"></a>雾计算</h4><p>雾计算是传统云计算模型的扩展。雾计算包括3个方面，一是使路由节点（如移动基站、网关、路由器等）执行通用目的计算；二是为路由节点添加计算能力，对传输数据进行处理；三是结合前2者。</p><p>好处之一是<strong>减少延迟</strong>，改进流式应用和实时应用的服务质量。二是<strong>无缝支持移动性</strong>，可以启用用户设备和计算服务器之间的无线访问，并可以组织可伸缩的控制系统。这些好处都适用于IoT应用。</p><p>雾计算和边缘计算的不同在于，<strong>边缘计算</strong>将计算能力提供给了IoT设备本身，而<strong>雾计算</strong>的计算节点（Dockers、VMs）则是靠近数据源。<strong>边缘计算需要IoT设备有执行代码和通信的能力，问题在于这样的接口并没有被所有的IoT设备采用</strong>。因此，雾计算似乎是迄今为止唯一可行/通用的解决方案。</p><p>雾计算尽管不能完全作为CDC，但也提供完整的IaaS，PaaS和SaaS资源堆栈。它的主要好处在于能减少延迟，预计每个城市只需要少数几个雾数据中心。从商业角度，还能使用私有云或独立的雾供应商的基础设施作为雾节点。对于<strong>移动边缘计算</strong>，它基于移动蜂窝网络，而不经过传统雾计算的路由节点</p><p>雾计算的优点包括，应用在不同计算层之间的<strong>垂直扩展性</strong>。它允许对<strong>传输数据进行提前处理</strong>，从而只有必要的流量会被发送到云数据中心。<strong>工作负载</strong>也可从云中分解下发到雾节点上，或者从边缘节点向上迁移到雾节点。在雾节点中可以使用更轻量的<strong>容器</strong>代替虚拟机。</p><h4 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h4><h4 id="无服务计算"><a href="#无服务计算" class="headerlink" title="无服务计算"></a>无服务计算</h4><h4 id="软件定义的云计算"><a href="#软件定义的云计算" class="headerlink" title="软件定义的云计算"></a>软件定义的云计算</h4><h4 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h4><h4 id="机器学习和深度学习"><a href="#机器学习和深度学习" class="headerlink" title="机器学习和深度学习"></a>机器学习和深度学习</h4><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><p>&gt;</p><blockquote><p>non-volatile technologies —— 非易失性技术<br>Ad-hoc —— 特设的<br>offloading —— 分流<br>proportionality —— 对称性</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算大纲</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/00%20%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%A7%E7%BA%B2/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/00%20%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<ol><li>分布式系统模型和支持技术</li><li>云计算–体系结构，服务，模型，用例</li><li>公共云和私有云。 资源管理</li><li>集群和数据中心的虚拟机和虚拟化</li><li>虚拟基础架构管理：OpenNebula和Openstack</li><li>云调度</li><li>容器化和Kubernetes</li><li>云编程和软件环境</li><li>云中间件和配置管理</li><li>大数据。 Mapreduce和Hadoop</li><li>服务水平协议</li><li>云经济</li><li>能源效率</li><li>安全与信任</li><li>无处不在的云和物联网</li><li>云支持：边缘计算，虚拟化/单核，工业4.0，无服务器架构</li></ol>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算的新方向1</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/17%20IoT%E7%89%A9%E8%81%94%E7%BD%91/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/17%20IoT%E7%89%A9%E8%81%94%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>云计算、物联网、社交网络影响着整个服务行业，也因此关系着未来互联网的演变和全球的经济。</p><p>云的生态系统需要普适性、高效性、安全性、用户接受性和值得信赖。</p><p>云是塑造未来互联网的关键：物联网和社交网络正参与着商业、政府、教育、娱乐等的各个方面</p><p><strong>《BIG SWITCH》描述了21世纪初出现的转变：</strong></p><p>更强大的电脑；无限的存储；高带宽的网络和普遍的连接（TB级的网络、宽带无线移动）；行业竞相建立大型数据中心（容量）；虚拟化有助于实现规模经济</p><p><strong>未来的网络开发存在以下技术挑战：</strong></p><p>可编程的网络结构；合并互联网、移动网络、和TV网络；基于TCP/IP的实名数据网络；智能路由和内容分布；加强安全和隐私保护</p><a id="more"></a><h4 id="云在未来互联网和社交网络中的角色"><a href="#云在未来互联网和社交网络中的角色" class="headerlink" title="云在未来互联网和社交网络中的角色"></a>云在未来互联网和社交网络中的角色</h4><p>在未来，云将会是提供网络服务的基础。未来的互联网不仅包含人和机器，还包括任何的对象或物体（物联网）</p><p>物联网的兴起：物理网应用程序必须最大化使用云，以便动态的处理和存储大规模的数据</p><p>云、物联网和社交网络正在重塑人类之间的关系，影响我们的日常生活，并且影响着全球的经济、政治系统</p><h4 id="物联网究竟意味着什么"><a href="#物联网究竟意味着什么" class="headerlink" title="物联网究竟意味着什么"></a>物联网究竟意味着什么</h4><p>Kevin Ashton将“物联网”描述为一个系统，它通过无处不在的传感器将物理世界和互联网联系在一起</p><blockquote><p>无处不在的传感器：手机、汽车、房间、门、床、椅子、建筑等任何物体</p></blockquote><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p>所有的传感器和控制端都在不断产生数据。通常这些数据是有用且私密的。因此需要一个系统来使这些设备相互沟通、管理数据，并加强适当的访问控制</p><p>而所有的通信、管理、访问控制技术，都是应用在大规模的设备网络上，因此必须是<u>可大规模扩展的</u></p><h4 id="开放协议"><a href="#开放协议" class="headerlink" title="开放协议"></a>开放协议</h4><p>当前的互联网和软件的解决方案有：</p><ul><li>接口 API：高度模块化</li><li>云：高度的分布式</li><li>面向服务的体系结构 SOA：高度解耦</li></ul><h4 id="物联网的维度"><a href="#物联网的维度" class="headerlink" title="物联网的维度"></a>物联网的维度</h4><p>任何时间相连：移动时、户内户外、白天晚上</p><p>任何地点相连：移动时、户外、户内（不在电脑上）、电脑上</p><p>任何物体相连：电脑之间、人与人（不使用电脑）、人与物（使用通用设备）、物与物</p><h4 id="无线传感器的角色"><a href="#无线传感器的角色" class="headerlink" title="无线传感器的角色"></a>无线传感器的角色</h4><p>无处不在的计算将促进各种各样的无线应用程序，包括监控宠物和家里的植物、控制程序、追踪书籍和单车等</p><h4 id="物联网的结构"><a href="#物联网的结构" class="headerlink" title="物联网的结构"></a>物联网的结构</h4><p>应用层：商品追踪、环境保护、智能搜索、远程医疗、智能交通、智能家居</p><p>网络层：云计算平台 —— 移动电信网、物联网、信息网</p><p>服务层：射频识别技术（射频标签）、传感器网络（节点）、GPS（公路地图）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd900m538xj311e0l80x3.jpg" alt="截屏2020-03-27 下午5.27.30" style="zoom:50%;" /></p><h4 id="概念图：基于云的物联网"><a href="#概念图：基于云的物联网" class="headerlink" title="概念图：基于云的物联网"></a>概念图：基于云的物联网</h4><p>无缝连接/无处不在的访问 —— 云计算 —— 基于云的物联网</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd9098ew80j30og0ie0vt.jpg" alt="截屏2020-03-27 下午5.35.49" style="zoom:50%;" /></p><h4 id="本地的分布式云"><a href="#本地的分布式云" class="headerlink" title="本地的分布式云"></a>本地的分布式云</h4><p>公有云：公开资源管理、服务质量管理、服务创新、准入控制</p><p>网络：地点管理、服务呈现、计费、身份管理、服务支持功能</p><p>本地云：本地资源管理、公有云交互</p><p>物体：资源请求、资源呈现</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd90e2iwt8j30kq0j8tds.jpg" alt="截屏2020-03-27 下午5.40.26" style="zoom:50%;" /></p><h4 id="射频识别技术-RFID"><a href="#射频识别技术-RFID" class="headerlink" title="射频识别技术 RFID"></a>射频识别技术 RFID</h4><blockquote><p><a href="https://baike.baidu.com/item/%E5%B0%84%E9%A2%91%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/9524139" target="_blank" rel="noopener">百度百科</a>：无线射频识别技术通过<a href="https://baike.baidu.com/item/无线电波/942435" target="_blank" rel="noopener">无线电波</a>不接触快速信息交换和存储技术，通过无线通信结合数据访问技术，然后连接数据库系统，加以实现非接触式的双向通信，从而达到了识别的目的，用于数据交换，串联起一个极其复杂的系统。在识别系统中，通过电磁波实现电子标签的读写与通信。根据通信距离，可分为近场和远场，为此读/写设备和电子标签之间的数据交换方式也对应地被分为负载<a href="https://baike.baidu.com/item/调制/4803375" target="_blank" rel="noopener">调制</a>和反向散射调制。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd90svv6dzj311y0j8dlx.jpg" alt="截屏2020-03-27 下午5.54.38" style="zoom:50%;" /></p><h5 id="应用场景：物流分配中心"><a href="#应用场景：物流分配中心" class="headerlink" title="应用场景：物流分配中心"></a>应用场景：物流分配中心</h5><ol><li>通过RFID指示包裹的输送方向</li><li>通过RFID读取仓库中的库存或在运输中的包裹，同步到系统上，从而与供应链同步</li><li>通过RFID识别集装箱内的包裹，更新库存</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd914qqp3tj30zw0k8qp8.jpg" alt="截屏2020-03-27 下午6.06.03" style="zoom:50%;" /></p><h4 id="无线网络——支持普适计算"><a href="#无线网络——支持普适计算" class="headerlink" title="无线网络——支持普适计算"></a>无线网络——支持普适计算</h4><blockquote><p><a href="https://baike.baidu.com/item/%E6%99%AE%E9%80%82%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">百度百科</a>：<strong>普适计算</strong>（Ubiquitous computing（ubicomp）、pervasive computing），又称<strong>普存计算</strong>、<strong>普及计算</strong>、<strong>遍布式计算</strong>、<strong>泛在计算</strong>，是一个强调和环境融为一体的计算概念，而<a href="https://baike.baidu.com/item/计算机/140338" target="_blank" rel="noopener">计算机</a>本身则从人们的视线里消失。在普适计算的模式下，人们能够在任何时间、任何地点、以任何方式进行信息的获取与处理。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd91bg1jhpj310y0fw12e.jpg" alt="截屏2020-03-27 下午6.12.32"></p><h4 id="ZigBee-结构"><a href="#ZigBee-结构" class="headerlink" title="ZigBee 结构"></a>ZigBee 结构</h4><p>目的：监控和控制；电池：3个月-3年；网络数量：无限 ；带宽：20-150KB；范围：1-100+米；系统资源：4-32K</p><ul><li>全功能设备 FFD —— <ul><li>协调器 (ZigBee Coordinator, ZC)：<ul><li>一个ZB网络只需要1个协调器，发起网络</li><li>作为 802.15.4 2003 协议的协调器</li><li>当网络成型后，也能作为路由器</li></ul></li><li>路由器 (ZigBee Router, ZR)<ul><li>可选的组件，辅助ZC，对消息进行多跳路由</li></ul></li></ul></li><li>缩减功能设备 RFD<ul><li>终端设备 (ZigBee End Device, ZED)<ul><li>可选的网络组件</li><li>不参与路由</li></ul></li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd91m4qv31j30o60gwwjc.jpg" alt="截屏2020-03-27 下午6.22.47" style="zoom:50%;" /></p><h4 id="物联网中的云和大数据，5C-5ANY"><a href="#物联网中的云和大数据，5C-5ANY" class="headerlink" title="物联网中的云和大数据，5C+5ANY"></a>物联网中的云和大数据，5C+5ANY</h4><p>数据：存储在云中，跟随着用户和用户的设备，可随时随地访问，可被其他人共享</p><p>5C：Convergence、Contents、Computing、Communication、Connectivity</p><p>5Any：Any Time、Any Where、Any Service、Any Network、Any Object</p><h4 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h4><blockquote><p>Telecom —— 电信<br>RFID: Radio Frequency Identification Technology —— 射频识别技术<br>Antenna —— 天线</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算的新方向2</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/18%20%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%96%B0%E6%96%B9%E5%90%91/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/18%20%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%96%B0%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>概述：</p><ol><li>回顾在物联网环境下，云计算的发展方向</li><li>为了阻止来自物联网的数据泛滥，在远程设备上采用智能本地数据处理成为关键：雾计算、边缘计算</li><li>本地数据处理中的虚拟化问题：以微服务和unikernels为例</li><li>工业4.0和智能工程</li></ol><a id="more"></a><h4 id="物联网家具：设备的发展前景"><a href="#物联网家具：设备的发展前景" class="headerlink" title="物联网家具：设备的发展前景"></a>物联网家具：设备的发展前景</h4><p>灯泡、冰箱、摄像头、手表、音响、显示器、扫地机器人等</p><h4 id="物联与智能产品：飞利浦照明"><a href="#物联与智能产品：飞利浦照明" class="headerlink" title="物联与智能产品：飞利浦照明"></a>物联与智能产品：飞利浦照明</h4><p>用户可以通过手机调节灯泡的亮度，调节开关；通过编程让它们：当发现进入者时闪烁，到晚上时变得昏暗</p><h3 id="雾计算"><a href="#雾计算" class="headerlink" title="雾计算"></a>雾计算</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>物联网应用和设备在持续激增，而旧的数据仓库模型：无法跟上物联网设备创建数据的速度和体积，也无法满足用户对低延迟响应时间的要求。但将数据发送到云上进行分析同样会带来风险：比如数据拥堵，安全问题等。网络数据传输的增长会导致数据拥堵的问题，而新的商业模型要求数据分析的时间少于1分钟（在某些情况下甚至要少与1秒）</p><h4 id="雾计算——思科架构"><a href="#雾计算——思科架构" class="headerlink" title="雾计算——思科架构"></a>雾计算——思科架构</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeq44w8ybj30tq0ca7cv.jpg" alt="截屏2020-04-01 下午5.18.16" style="zoom:50%;" /></p><p>雾平台：在网络边缘布置的密集型计算结构</p><p>特点：低延迟、位置感知、可通过无线访问使用</p><p>优点：实时分析、优化安全性</p><p>例子：</p><ol><li>智能交通信号灯系统，可基于当前的交通监控状况改变它的信号</li><li>数据可以发送到云端，用于长期分析</li></ol><p>在许多行业中，术语<u>边缘计算</u>和<u>雾计算</u>是可交互使用的，它们都涉及将<u>智能（计算处理数据的能力）</u>下发到离数据源更近的地方（泵、传感器、发动机、继电器），它们的根本区别在于<u>智能</u>到底安置在哪：</p><ul><li>雾：将<u>智能</u>发送到网络结构中的<u>局域网级别</u>，在雾节点或物联网网关中处理数据</li><li>边缘：将<u>智能、处理能力、通信能力</u>发送到边缘网关，或直接应用在设备本身（如可编程的自动化控制器 PACs）</li></ul><h3 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h3><p>在该结构中，数据可被处理，包括监控、分析、去重、缓存。</p><p>在该结构中，还需要考虑4个问题：1. 带宽，2. 网络能源，3.吞吐量，4. 数据存储；其他的开放新问题包括：</p><ol><li>便携性</li><li>能源效率</li><li>硬件结构的异构性</li><li>安全性虚</li><li>虚拟化</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeqp0e6pzj30no0ni7b8.jpg" alt="截屏2020-04-01 下午5.38.22" style="zoom:50%;" /></p><h4 id="1-可移动的边缘计算-Mobile-Edge-Computing-MEC"><a href="#1-可移动的边缘计算-Mobile-Edge-Computing-MEC" class="headerlink" title="1. 可移动的边缘计算 Mobile Edge Computing, MEC"></a>1. 可移动的边缘计算 Mobile Edge Computing, MEC</h4><p>在蜂窝网络或任何网络的边缘，启用云计算能力和通信技术服务环境的，一种网络结构。它的基本思想是与边缘计算和雾计算类似，即在接近蜂窝用户的地方运行程序和处理相关任务，从而缓解网络拥堵，提高性能。云不直接接收用户的数据，而是接收经过MEC节点处理后的少量数据。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gder2aip6dj30ts0l2dt4.jpg" alt="截屏2020-04-01 下午5.51.06" style="zoom:50%;" /></p><h4 id="2-低能耗计算案例"><a href="#2-低能耗计算案例" class="headerlink" title="2. 低能耗计算案例"></a>2. 低能耗计算案例</h4><p>该技术的关键在于如何使<u>本地处理数据的智能设备</u>使用最少的能源。目前，<u>低功耗和低能耗</u>仍然是物联网连接的智能对象的挑战。</p><p><u>性能</u>的表现由，除了速度之外的，非功能性部分组成，比如：能耗、可靠性、时间需求等</p><p>能源效率应该从三个方面考虑：</p><ol><li>系统级别：比如使用本地计算，而不是将数据传输到外部；通信是能源浪费的主要因素</li><li>设备级别：考虑到设备的异质性，使用在节能的结构</li><li>语言级别：避免数据通信，确保数据的本地性</li></ol><h4 id="3-硬件结构的异质性"><a href="#3-硬件结构的异质性" class="headerlink" title="3. 硬件结构的异质性"></a>3. 硬件结构的异质性</h4><p><u>异质的并行化结构</u>已经收到了相当大的关注，它的好处在于能够高效的运行程序和传递服务，并且在一个系统中组合了不同种类的处理器，从而优化了绝对性能和降低能耗</p><p>于是出现了新的平台，它们将多核CPUs、多核GPUs，和一系列的附加设备合并为一个单独的解决方案。它们的特点是高度的多样化，在混合的环境中操作，以及使用环境十分广泛（从超级计算机到个人智能手机）</p><h4 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4.安全问题"></a>4.安全问题</h4><p>将物理网设备中的敏感数据（医疗数据、个人跟踪数据、视频、财务数据等）从数据源（家庭、企业等）中发送出去，可能会导致隐私泄露、声誉受损、数据盗窃等问题。除此之外还需要考虑传输成本，如带宽消耗、处理成本、存储成本。</p><p>解决方案应该专注于保护设备、网络和使用时的安全：物理层的安全性、设备保护、密码保险、泄露预防、基础设备的安全性、数据传输时的安全性、平台安全性</p><h4 id="5-虚拟化：以微服务为例"><a href="#5-虚拟化：以微服务为例" class="headerlink" title="5. 虚拟化：以微服务为例"></a>5. 虚拟化：以微服务为例</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdes9a0hvfj30wq0g8acv.jpg" alt="截屏2020-04-01 下午6.32.26" style="zoom:50%;" /></p><p>微服务是一个结构模型，它以服务为粒度，将其拆分为多个分布的单元（小的服务），多个自治的服务相互合作，各个服务之间相互解耦，并且通过接口和协议（如HTTP）进行访问</p><h5 id="部署选项"><a href="#部署选项" class="headerlink" title="部署选项"></a>部署选项</h5><p>微服务可以是从<u>需要专用硬件</u>到<u>仅仅是软件包</u>。其中部署在容器上（如Docker）是在效率和管理方面都比较理想的选择（包含虚拟机的大部分优点，但比虚拟机的损耗更低）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdesj02pl5j30eg0m2di1.jpg" alt="截屏2020-04-01 下午6.41.48" style="zoom:33%;" /></p><h5 id="以-Unikernels-独立核心为例"><a href="#以-Unikernels-独立核心为例" class="headerlink" title="以 Unikernels 独立核心为例"></a>以 <a href="http://dockone.io/article/855" target="_blank" rel="noopener">Unikernels</a> 独立核心为例</h5><p>Unikernel简单来说就是<strong>删除应用与硬件中间多余的部分，只保留运行程序所需的最小依赖的库和栈模块的操作系统镜像</strong>。</p><p>由于Unikernel只实现了传统操作系统中的最低限度功能，因此极度轻量，允许在日常硬件上实现高密度部署。Unikernel还可以运行自己的<u>服务</u>，这些服务在需求出现时诞生，并在需求消失后立即消失，其中一些短暂的<u>微服务</u>的寿命可能以秒为单位，甚至是几分之一秒。Unikernel是即时计算服务，仅在有工作要做时存在，因此可以最大限度地利用计算基础架构。</p><p>但是当应用和配置需要更新，我们需要重新编译你的源码来生成新的Unikernel并部署新版本。如果是新的安全升级，也同样需要重新编译和部署。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdet1tpmvmj30tu0fggts.jpg" alt="截屏2020-04-01 下午6.59.54" style="zoom:50%;" /></p><h3 id="工业4-0"><a href="#工业4-0" class="headerlink" title="工业4.0"></a>工业4.0</h3><p>在工业4.0中，各个行业中的计算机和自动化将以全新的方式融合在一起，比如机器人远程连接到具备机器学习算法的计算机系统，而机器学习算法只需很少的人工操作即可学习和控制机器人。</p><p>工业4.0引入了<u>智能工厂</u>的概念，其中,<u>网络物理系统</u>监视工厂的物理上处理，并做出非中心化的决策</p><p>物理系统成为物联网，通过无线网络，实时地，在系统间相互通信，并与人类进行协作。</p><h4 id="工业4-0的六大设计原则"><a href="#工业4-0的六大设计原则" class="headerlink" title="工业4.0的六大设计原则"></a>工业4.0的六大设计原则</h4><ul><li><p>互操作性：<u>网络物理系统</u>（即工件载体，装配站和产品）、人类和智能工厂通过物联网相互连接和通信的能力</p></li><li><p>虚拟化：通过将传感器数据（来自监视物理上的处理过程）与虚拟工厂模型和仿真模型进行连接，以此创建的<u>智能工厂的虚拟副本</u></p></li><li><p>去中心化：智能工厂内的<u>网络物理系统</u>有自行决策的能力</p></li><li><p>实时功能：具有收集和分析数据并立即提供见解的能力</p></li><li><p>服务导向：通过<u>Internet of Services</u>提供（网络物理系统、人类和智能工厂的）服务</p></li><li><p>模块化：当对模块的需求发生改变时，智能工厂可以灵活地适应。</p></li></ul><h3 id="相关数据"><a href="#相关数据" class="headerlink" title="相关数据"></a>相关数据</h3><blockquote><p>pump——泵<br>motor——发动机<br>relay——继电器<br>energy efficient——节能<br>data-in-transit——传输中的数据<br>overhead——损耗<br>Cyber-Physical Systems —— 网络物理系统</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> 无处不在的云 </tag>
            
            <tag> 雾计算 </tag>
            
            <tag> MEC </tag>
            
            <tag> 微服务的虚拟化 unikernels </tag>
            
            <tag> 工业4.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形数据库 Neo4J</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%9B%BE%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4J/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%9B%BE%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4J/</url>
      
        <content type="html"><![CDATA[<p>NoSQL可以被分成4类：键值对存储（MapReduce）、面向列的数据库（如Google Big Table）、文档数据库（MongoDB）、图形数据库（如Neo4J）</p><p>图形数据库主要用于存储具有更多关联的数据，而传统的RDBMS对大量数据的遍历性能不佳</p><p>图形数据库适合数据元素之间的关系与数据本身同样重要的项目</p><blockquote><p>由Neo4j，Inc.开发的图形数据库管理系统。它的开发人员将Neo4j描述为具有本机图形存储和处理的ACID兼容事务数据库，根据DB-Engines排名，Neo4j是最受欢迎的图形数据库，并且总体上是第22位最受欢迎的数据库。</p></blockquote><a id="more"></a><h4 id="NoSQL的种类"><a href="#NoSQL的种类" class="headerlink" title="NoSQL的种类"></a>NoSQL的种类</h4><p>NoSQL可以被分成4类：键值对存储（MySQL）、面向列的数据库（如Google Big Table）、文档数据库、图形数据库（如Neo4J）</p><h4 id="图-树结构的数据库"><a href="#图-树结构的数据库" class="headerlink" title="图/树结构的数据库"></a>图/树结构的数据库</h4><p>图包括2个元素：</p><ul><li><p>节点node：表示实体</p></li><li><p>关系relationship：表示2个节点之间是如何联系在一起的</p></li></ul><blockquote><p>2019年Twitter的每月活跃用户数量为3.21亿，通过图形数据库关联在一起</p></blockquote><h4 id="图形数据库-VS-传统的关系数据库管理系统RDBMS"><a href="#图形数据库-VS-传统的关系数据库管理系统RDBMS" class="headerlink" title="图形数据库 VS 传统的关系数据库管理系统RDBMS"></a>图形数据库 VS 传统的关系数据库管理系统RDBMS</h4><p>图形数据库主要用于存储更多连接的数据，而传统的RDBMS对大量数据的遍历(traverse)性能不佳</p><p>图形数据库适合：数据元素之间的关系与数据本身同样重要的项目</p><div class="table-container"><table><thead><tr><th>RDBMS</th><th>Graph DataBase</th></tr></thead><tbody><tr><td>表</td><td>图</td></tr><tr><td>行</td><td>节点</td></tr><tr><td>列和数据</td><td>属性和值</td></tr><tr><td>约束</td><td>关系</td></tr><tr><td>Joins</td><td>Traversal 遍历</td></tr></tbody></table></div><p>属性是用来表示数据的键值对</p><h3 id="Neo4J"><a href="#Neo4J" class="headerlink" title="Neo4J"></a>Neo4J</h3><p>是服从ACID的事务性数据库，提供自带的(native)图存储和处理</p><p>由Java编写，其他语言可以通过Cypher Query Language (CQL) 进行访问</p><blockquote><p>Cypher是一种声明性图形查询语言，它允许在属性图形中进行有表现力且有效的数据查询。</p></blockquote><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>以CQL作为查询语言，类似于SQL的查询语言</p><p>遵循属性图数据模型 Property Graph Data Model</p><p>包含可执行CQL命令的用户接口（Neo4J数据浏览器）</p><p>尽管是NoSQL，但其他大多数图像界面一样，服从ACID</p><p>提供REST和JavaScript接口</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>能够简单快速对<u>连接的数据</u>进行表示和获取</p><p>CQL的设计是人类可读的，并且易于学习</p><p>不需要复杂的Joins来获取连接的数据</p><h4 id="属性图数据模型"><a href="#属性图数据模型" class="headerlink" title="属性图数据模型"></a>属性图数据模型</h4><p>Neo4J使用属性图数据模型对数据进行存储和管理，Neo4J使用自带的图处理引擎GPE，对以这个格式存储的数据进行处理。该模型简单，只有少量的基本元素：</p><ul><li>数据由节点、关系和属性表示</li><li>节点和关系都包含属性</li><li>关系连接节点</li><li>属性是键值对</li><li><p>每个关系都包含“起始节点”和“结束节点”</p></li><li><p><strong>标签</strong>：将一系列的节点或关系用一个常用的名字管理起来。一个节点或关系可以有多个标签</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd12m5xkukj30qw0bk0vr.jpg" alt="截屏2020-03-20下午8.52.53"></p><h4 id="可视化——Neo4J-数据浏览器"><a href="#可视化——Neo4J-数据浏览器" class="headerlink" title="可视化——Neo4J 数据浏览器"></a>可视化——Neo4J 数据浏览器</h4><p>Neo4J 2.0版开始自带。能够快速简单的图形数据库进行可视化和编辑</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd12sg645oj312g0faafz.jpg" alt="截屏2020-03-20下午8.58.59"></p><h4 id="Cypher查询语言"><a href="#Cypher查询语言" class="headerlink" title="Cypher查询语言"></a>Cypher查询语言</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd12xhqnq2j311i0g2djr.jpg" alt="截屏2020-03-20下午9.03.50"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建emp节点，标签名为Employee</span><br><span class="line">CREATE (emp:Employee)</span><br><span class="line">&#x2F;&#x2F; 创建包含属性的节点</span><br><span class="line">CREATE (emp:Employee &#123;employeeNumber:10, name&#x3D;“Paul”, location&#x3D;“Leeds”&#125; ) ;</span><br><span class="line">&#x2F;&#x2F; 获取数据</span><br><span class="line">MATCH (myresults: Employee)</span><br><span class="line">RETURN myresults.name, myresults.location</span><br></pre></td></tr></table></figure><h4 id="与Java整合"><a href="#与Java整合" class="headerlink" title="与Java整合"></a>与Java整合</h4><p>Neo4J有自带接口和Cypher接口与Java整合，Cypher接口能让用户通过Java接口直接执行CQL命令</p><h3 id="Neo4J-VS-MySQL"><a href="#Neo4J-VS-MySQL" class="headerlink" title="Neo4J VS MySQL"></a>Neo4J VS MySQL</h3><p>对于MySQL来说，表中的每个元素都有一组提前定义好的属性（列）</p><p>在Neo4J中，每个节点node等价于MySQL中的一行记录</p><ul><li>Label能将相似的数据归为同一组，比如用户组。相当于MySQL中的表，但同一组数据并不会真正的存储在一起，只是语义上的划分</li></ul><h4 id="图形数据库-VS-传统的RDBMS——以用户-餐厅为例"><a href="#图形数据库-VS-传统的RDBMS——以用户-餐厅为例" class="headerlink" title="图形数据库 VS 传统的RDBMS——以用户/餐厅为例"></a>图形数据库 VS 传统的RDBMS——以用户/餐厅为例</h4><p>传统数据库需要3张表分别表示用户、餐厅和关系：</p><ul><li><p>存储：<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd167p6tmfj30em086q6v.jpg" alt="截屏2020-03-20下午10.57.26" style="zoom: 33%;" /></p></li><li><p>查询：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user.*, restaurant.* </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>, restaurant, joinTable </span><br><span class="line"><span class="keyword">WHERE</span> user.firstName = ‘Paul’ <span class="keyword">AND</span> user.id = joinTable.userId <span class="keyword">AND</span> restaurant.id = joinTable.restaurantId <span class="keyword">AND</span> joinTable.rating = ‘LOVED’</span><br></pre></td></tr></table></figure><p>图形数据库通过<u>节点</u>表示用户和餐厅，<u>关系</u>表示节点之间的关联信息，比如当用户写的评论可以直接储存在<u>关系</u>中</p><ul><li><p>存储：<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd16bcna2jj30gu0cgwf3.jpg" alt="截屏2020-03-20下午11.00.43" style="zoom:33%;" /></p></li><li><p>查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Neo4J会忽略不匹配该模式的所有值</span><br><span class="line">&#x2F;&#x2F; 通过提供的变量名，可以使用name.property与所有匹配的节点或关系进行交互</span><br><span class="line">MATCH (u:User &#123;firstName:‘Paul&#39;&#125;)-[rel:LOVED]-&gt;(res:Restaurant) RETURN res</span><br><span class="line">MATCH (u:User)-[rel]-&gt;(res:Restaurant &#123;name:&#39;French Laundry&#39;&#125;) RETURN u</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Neo4J </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云编程的现状</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/11%20Cloud%20Programming%20Landscape%20%E4%BA%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/11%20Cloud%20Programming%20Landscape%20%E4%BA%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="11-Cloud-Programming-Landscape-云编程"><a href="#11-Cloud-Programming-Landscape-云编程" class="headerlink" title="11 Cloud Programming Landscape 云编程"></a>11 Cloud Programming Landscape 云编程</h2><p>主要内容：</p><p>云编程的前景</p><p>在云中的执行应用程序和服务的框架</p><p>云服务生命周期</p><p>常用的编程框架和模型：MPI、MapReduce / Hadoop 、亚马逊、微软 Azure</p><a id="more"></a><h4 id="云产品的现状"><a href="#云产品的现状" class="headerlink" title="云产品的现状"></a>云产品的现状</h4><p>云产品可应用于以下领域：科学/技术（无人驾驶汽车）、商务（电商、消费者关系管理CRM、会计、企业资源规划ERP）、消费者/社交（FB、Gmail、Twitter）</p><h3 id="产品和服务的编程"><a href="#产品和服务的编程" class="headerlink" title="产品和服务的编程"></a>产品和服务的编程</h3><p>现有的框架支持对应用程序和服务进行编程，并在云中执行：</p><ol><li>新的接口用以开发程序：比如Azure、Google App Engine</li><li>基于服务的工作流程的图形（Web服务业务流程执行语言）</li><li>高性能计算：MPI，OpenMP</li><li>非通用编程模型：MapReduce，Aneka（用于在云上开发分布式应用的平台和框架）</li></ol><h3 id="云服务的生命周期"><a href="#云服务的生命周期" class="headerlink" title="云服务的生命周期"></a>云服务的生命周期</h3><p>编程模型/构造服务：</p><ul><li>编程模型——用于开发产品</li><li>应用包装器——用于创建服务清单</li><li>虚拟机镜像构造器——用于产生镜像</li></ul><p>部署服务</p><ul><li>产品管理器——经服务部署到云基础设施上</li><li>虚拟机上下文工具contextualiser——将服务的软件依赖嵌入到虚拟机镜像中，并支持运行时配置</li><li>产品监控器——在操作是监控服务</li></ul><p>操作服务：</p><ul><li>虚拟机管理器——将虚拟机部署到物理节点</li><li>虚拟机基础设施管理器——管理虚拟机</li><li>基础设施监控器——监控云资源 </li></ul><h3 id="构造云服务"><a href="#构造云服务" class="headerlink" title="构造云服务"></a>构造云服务</h3><p>云服务是专门为了在云基础设施上部署而开发、策划和配置的</p><p>需执行的活动有：</p><ol><li>服务开发：开发应用程序，为用户提供功能服务<ul><li>使用编程模型简化服务开发：MapReduce、MPI、COMP Superscalar</li></ul></li><li>准备好虚拟机，等服务开发完成后，将服务部署在虚拟机上</li><li><p>指定和配置服务需求，描述参数（功能性和非功能性）</p><ul><li>容量需求、位置限制、能源效率限制</li></ul><p>针对云量身定制的编程语言：GO——针对云项目Docker的编程语言，提供并发操作</p></li></ol><h4 id="例1：消息传递接口MPI"><a href="#例1：消息传递接口MPI" class="headerlink" title="例1：消息传递接口MPI"></a>例1：消息传递接口MPI</h4><p>高性能多重计算机的出现；需要面向消息的<u>原语Primitives</u>以轻松编写高效的应用程序</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd04xhtyu7j30ys0i8tbv.jpg" alt="截屏2020-03-20上午1.27.08" style="zoom: 33%;" /></p><p>问题：大多数内部交互网络和高性能多重计算机都自带专有的通信库——需要硬件独立的通信库</p><p>解决方案：MPI</p><ul><li>为并行产品设计</li><li>使用底层网络</li><li>假设通信发生在已知的进程组</li></ul><h5 id="消息传递模型"><a href="#消息传递模型" class="headerlink" title="消息传递模型"></a>消息传递模型</h5><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd04om93dyj30ou0lw418.jpg" alt="截屏2020-03-20上午1.18.52" style="zoom:33%;" /></p><p>消息同步传输：</p><ul><li><p>需要发送者与接受者配合，但“配合”并不总是反映在代码上。</p></li><li><p>比较一对一通信和集体通信</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd04u6rjjuj30yg0aodgp.jpg" alt="截屏2020-03-20上午1.24.17"></p><h5 id="进程执行：裸机与虚拟环境的对比"><a href="#进程执行：裸机与虚拟环境的对比" class="headerlink" title="进程执行：裸机与虚拟环境的对比"></a>进程执行：裸机与虚拟环境的对比</h5><p>对消息传递的方式对进程来说没有区别，区别在于进程是位于裸机中还是虚拟机中</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd0503wa9hj30xu0nen3p.jpg" alt="截屏2020-03-20上午1.29.58" style="zoom:33%;" /></p><h4 id="例2：MapReduce——在大型集群上的可扩展数据处理"><a href="#例2：MapReduce——在大型集群上的可扩展数据处理" class="headerlink" title="例2：MapReduce——在大型集群上的可扩展数据处理"></a>例2：MapReduce——在大型集群上的可扩展数据处理</h4><ul><li>用于快速处理大规模数据集的编程模型</li><li>适用于网络规模的搜索和云计算产品</li><li>用户编写的<ul><li>map函数用于生成中间操作的键值对</li><li>reduce函数将键值对按键合并</li></ul></li></ul><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><p>由雅虎开发的软件平台，让用户编写和运行基于大规模分布式数据的产品</p><p>特点：</p><ul><li>可扩展：可以轻松的在网络空间上扩展，存储和处理PB级的数据</li><li>经济的：开源框架，能够最小化过量的任务滋生和大规模数据通信</li><li>高效的：通过大量的简单节点，进行高度并行的数据处理</li><li>可靠的：自动维护多个数据备份，当发送故障时能够重新部署计算任务</li></ul><h3 id="部署云服务"><a href="#部署云服务" class="headerlink" title="部署云服务"></a>部署云服务</h3><p>成果：服务能够在云基础设施资源上运行</p><p>执行的活动有：</p><ul><li>选择最合适的基础设施来部署服务</li><li>当服务被部署后，确保服务按照其约束进行<ul><li>约束指的是在性能、成本、能耗等方面达成一致</li></ul></li><li>上下文（配置）信息的传递，当服务被部署后，上下文信息用于初始化服务</li></ul><h3 id="操作云服务"><a href="#操作云服务" class="headerlink" title="操作云服务"></a>操作云服务</h3><p>服务运行在云基础设之上</p><p>执行的活动有：</p><ul><li>满足服务需求的管理操作（比如服务质量）</li><li>资源分配机制（包括数据放置）</li><li>（被虚拟机、容器使用的）基础设施用量的监控机制</li><li>根据基础设备用量、历史模式、预测未来用量的变化的报告机制</li></ul><h3 id="在AWS上的并行编程"><a href="#在AWS上的并行编程" class="headerlink" title="在AWS上的并行编程"></a>在AWS上的并行编程</h3><p>部分亚马逊平台上提供的服务</p><ul><li><p>EC2 亚马逊弹性云服务：提供可重新调整计算能力的Web服务，为开发者设计，简化网络规模的云计算</p></li><li><p>S3 简单存储服务：为用户提供安全、可容忍、可高度扩展的对象存储，通过简单的网络服务接口，从网络的任何地方，对任何数量的数据进行存储和获取</p></li><li><p>EBS 弹性块存储：基于EC2实例，支持<u>块级别</u>存储大小的持久化</p></li><li><p>SimpleDB：高度可用和灵活的非关系数据存储，减少开发者对数据库管理的工作。开发者只要通过网络服务请求对数据进行查询和存储，SimpleDB负责其余的工作</p></li></ul><h4 id="EC2——AMI-亚马逊虚拟机镜像"><a href="#EC2——AMI-亚马逊虚拟机镜像" class="headerlink" title="EC2——AMI 亚马逊虚拟机镜像"></a>EC2——AMI 亚马逊虚拟机镜像</h4><p>AMI是虚拟机实例的模板，AMI是预装了软件Linux系统，部署在EC2上。</p><p>AMI的类型包括私有（个人创建和使用），公开（由用户创建，并在AWS社区发布，任何人都能使用），付费（由个人创建，其他用户可以付费使用）</p><h4 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h4><p>特点：</p><ul><li><p>基于对象的存储服务，对象是最基础的数据单元，每个对象的大小为1Byte-5GB</p><ul><li>使用Bucket来存储对象，用Key来获取数据对象</li><li>对象包括：键、值、元数据、访问控制</li></ul></li><li><p>通过地理分散实现冗余，99.99%的可用性目标，共有或私有，每个对象都有专门的URL，支持比特流BitTorrent</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Apache Spark</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/16%20APACHE%20SPARK/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/16%20APACHE%20SPARK/</url>
      
        <content type="html"><![CDATA[<p><strong>MapReduce的限制</strong></p><ol><li>MapReduce编程对许多人来说都是有难度的</li><li>性能通常会遇到瓶颈（因为批处理不适合所需的用例）</li></ol><p>这导致MapReduce不适用于大型应用程序。因此出现了多种专业系统的发展。</p><p> 因此Spark面世——将所有的专业系统整合到一起</p><a id="more"></a><h2 id="Apache-Spark"><a href="#Apache-Spark" class="headerlink" title="Apache Spark"></a>Apache Spark</h2><p>是一个通用目的数据处理引擎，为不同的需求设计，</p><ul><li>更快的批处理</li><li>应用需要交互式查询处理</li><li>处理流数据</li><li>系统需要迭代算法</li></ul><p>特征：</p><ul><li>是in-memory的计算引擎（充分利用内存）</li><li>用磁盘时比Hadoop快10倍，用内存时比Hadoop快100倍</li></ul><h4 id="Spark-结构"><a href="#Spark-结构" class="headerlink" title="Spark 结构"></a>Spark 结构</h4><p>Spark不提供任何类似HDFS的存储或者资源管理能力，它是一个以几乎实时的方式，处理大量数据的，统一的框架</p><p>三个主要的分层：</p><ol><li>生态层：基于核心层执行操作的库<ul><li>Spark SQL， Spark Streaming， BlinkDB， Spark ML， GraphX， Tachyon</li></ul></li><li>核心层：框架的通用层，它定义了所有的基础功能，其他功能和扩展都是基于这一层创建的<ul><li>Spark Core，Spark DataFrame API</li></ul></li><li>资源管理层：Spark以独立模式（单节点群集设置）管理自己的资源。 但是对于分布式集群模式，它可以与YARN之类的资源管理模块集成在一起。<ul><li>Standalone，YARN，Mesos</li></ul></li></ol><p>结构：</p><ul><li>Spark应用程序在集群上作为独立的进程集运行，由SparkContext对象（也称为驱动程序）协调。<ul><li>每个应用程序都有其自己的执行程序进程，这些进程在整个应用程序期间保持不变，并在多个线程中运行任务。</li><li>这具有将应用程序彼此<strong>隔离</strong>的好处——每个驱动程序调度自己的任务，并且来自不同应用程序的任务在不同的JVM中运行。</li><li>但是，这也意味着，如果不将数据写入外部存储系统，则无法在不同的Spark应用程序（SparkContext实例）之间共享数据。</li></ul></li><li>SparkContext负责将应用程序代码（JAR或Python文件）和任务发送给执行程序。</li><li>每个驱动程序都有一个Web UI，通常在端口4040上，该Web UI显示有关正在运行的任务，执行程序和存储使用情况的信息。</li></ul><h4 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h4><p>提供了Java、Scala、Python的high-level APIs</p><p>提供了优化引擎支持：产生执行图，结构化数据处理的高级工具</p><h3 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h3><p>处理：</p><ul><li>内存管理和容错</li><li><p>对集群上的任务jobs进行调度，分配，监控</p></li><li><p>与存储系统进行交互</p></li></ul><p>它也实现了弹性分布式数据库（RDDs）的关键概念。</p><ul><li>RDD是对象的不可变容错分布式集合，可以并行操作。</li><li>RDD可以包含任何类型的对象，并且可以通过加载外部数据集或从驱动程序分配集合来创建</li><li>RDD是分布在整个集群中的数据集的表示。</li></ul><h4 id="弹性分布式数据库-RESILIENT-DISTRIBUTED-DATABASES（RDDs）"><a href="#弹性分布式数据库-RESILIENT-DISTRIBUTED-DATABASES（RDDs）" class="headerlink" title="弹性分布式数据库 RESILIENT DISTRIBUTED DATABASES（RDDs）"></a>弹性分布式数据库 RESILIENT DISTRIBUTED DATABASES（RDDs）</h4><ul><li>RDDs可以被存储在内存或磁盘中，主要的性能来自于将数据存在内存中<ul><li>诸如MapReduce之类的当前框架提供了许多用于<u>访问集群的计算资源的接口</u>，但是缺乏<u>利用分布式内存的接口。</u></li></ul></li><li>Spark的优势：<ul><li>数据重用在许多迭代ML算法中很常见，例如K-means聚类。另一个示例是当用户对同一数据子集运行多个临时查询时。</li></ul></li><li>在Hadoop（和其他框架）中，在不同作业之间<u>重用数据的唯一方法</u>是将其写入外部存储系统（例如HDFS）。使用内存中的RDD，可以更快地处理数据。可以存储在分布式内存中的数据大小仅受群集大小限制。</li></ul><h4 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h4><ul><li>Transformations 转换：在RDD上执行并产生包含结果的新RDD的操作（例如，映射，过滤器，联接，联合等）</li><li>Actions 行动：在RDD上运行计算后返回值的操作（例如reduce，count，first等）。</li></ul><p>Spark上的转换操作是lazy的，并不会立即执行。只有当行动被调用时，转换才会执行。执行的结果将返回给驱动程序。该设计能提高Spark的运行效率</p><h4 id="Lazy-（Transformations）评估"><a href="#Lazy-（Transformations）评估" class="headerlink" title="Lazy （Transformations）评估"></a>Lazy （Transformations）评估</h4><p>转换是对数据的操纵。 它们从一个RDD转换到下一个。</p><p>比如：一个Action查询数据集中有多少数据，Spark在收到查询后，才会进行Transformations，再将结果返回给Action</p><h4 id="RDD用例"><a href="#RDD用例" class="headerlink" title="RDD用例"></a>RDD用例</h4><p>假设我们必须在大量的Web服务器访问日志中查找错误代码。</p><p>我们可以使用MapReduce，Storm或我们喜欢的任何框架来读取文件集，查找特定的错误代码，并将带有该代码的所有行放入存储设备（例如HDFS）</p><p>然后，当我们分析这些结果数据时，我们可能希望将错误与其他用户活动进行交叉引用cross-reference。 这将要求我们再次获取文件，处理并提供结果等。</p><p>对于传统方式需要重复对磁盘进行查询，而RDD是将数据存储在内存中，并提供了重新查询所用子集的功能。 </p><p>内存中数据存储非常适合许多迭代和交互式算法</p><h4 id="RDD容错"><a href="#RDD容错" class="headerlink" title="RDD容错"></a>RDD容错</h4><p>设计RDD的主要挑战是定义一个可提供有效容错能力的编程接口。</p><ul><li>故障是系统中的缺陷defect。</li><li>错误error是系统边界内观察到的行为与系统的指定行为之间的<strong>差异</strong></li><li>故障failure是系统当时<u>显示的行为</u>与<u>规范相反</u>的<strong>实例</strong></li></ul><p>现有解决方案提供基于<strong>细粒度更新</strong>的容错接口。</p><ul><li><p>使用这样的系统，获得容错的唯一方法，是<u>跨计算机复制数据</u>或<u>跨计算机记录更新</u>。</p></li><li><p>这些方法是数据密集型的——<strong>高带宽</strong>用于在群集网络上移动数据。</p></li></ul><p>RDD提供了基于粗粒度转换的接口（例如，映射，过滤器，联接）。 这些转换将相同的操作应用于许多数据项。</p><ul><li><p>这允许通过记录用于构建数据库的转换而不是实际数据本身来有效地应用容错。</p></li><li><p>如果RDD的分区丢失，则RDD具有有关如何从其他RDDS派生出来的足够信息，以便仅重新计算该分区。</p></li></ul><h4 id="RDD的限制"><a href="#RDD的限制" class="headerlink" title="RDD的限制"></a>RDD的限制</h4><p>不适合非迭代应用程序，因为Spark的主要性能提升是内存数据的迭代。</p><p>RDD也不太适合对共享状态进行异步细粒度更新的应用程序，例如Web应用程序的存储系统或增量Web爬虫。批量转换对于小的更新是浪费的。</p><h4 id="传统的流处理管道"><a href="#传统的流处理管道" class="headerlink" title="传统的流处理管道"></a>传统的流处理管道</h4><ol><li>从数据源接收流数据</li><li>在集群上并行处理流数据</li><li>将数据输出到下游的系统</li></ol><p>大多数传统的流处理器使用连续操作器（continuous operator）模型进行数据处理</p><ul><li>一组工作节点，每个工作节点运行一个或多个连续操作器</li><li>每个连续的操作器一次处理流数据一个记录，然后将记录转发给管道中的其他操作器。</li><li>有源操作器用于从采集系统接收数据，而下沉操作器则输出到下游系统。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcwbap19kxj30o80e4wii.jpg" alt="截屏2020-03-16下午6.05.24"></p><p>比如Apache Storm；这是一个非常优雅的解决方案，但是随着系统变得越来越大以及大数据分析的复杂性增加，使用此模型面临着越来越多的挑战。</p><h4 id="传统流数据处理系统的问题"><a href="#传统流数据处理系统的问题" class="headerlink" title="传统流数据处理系统的问题"></a>传统流数据处理系统的问题</h4><p><strong>故障和任务被卡主（straggling）：</strong></p><ul><li><p>随着规模扩大，集群节点故障或者无法预测的变慢（比如stragglers，掉队者）的可能性会增加</p></li><li><p>系统需要能自动从故障和卡住的任务（stragglers）中恢复，以实时提供结果</p></li><li>将<u>连续操作器</u>静态分配给工作节点，会使传统系统很难从故障和卡住的任务（stragglers）中快速恢复。</li></ul><p><strong>负载平衡：</strong></p><ul><li>Workers之间的处理负载分配不均，会导致连续操作器系统出现瓶颈。</li><li>这在大型集群和动态变化的工作负载中更可能发生。</li><li>系统需要能够根据工作负载动态调整资源分配。</li></ul><p><strong>流、批处理、交互式工作负载的统一：</strong></p><ul><li>在许多使用案例中，以交互方式查询流数据或将其与静态数据集（例如，预先计算的模型）结合起来很有吸引力。</li><li>在连续的操作器系统中，这很难做到，因为它们并非旨在动态地为临时查询引入新的运算器</li><li>这需要一个可以结合批处理，流式处理和交互式查询的引擎。</li></ul><p><strong>高级分析：</strong></p><ul><li><p>复杂的工作负载需要连续的学习和更新数据模型，甚至是用sql查询最新的流数据视图</p></li><li><p>使这些分析任务具有通用抽象（API），能让开发人员的工作更加轻松</p></li></ul><h4 id="离散流-Discretized-Streams-——-解决方案"><a href="#离散流-Discretized-Streams-——-解决方案" class="headerlink" title="离散流 Discretized Streams —— 解决方案"></a>离散流 Discretized Streams —— 解决方案</h4><p>为了解决这些问题，Spark Streaming组件使用称为离散化流的新架构，该架构直接利用了Spark引擎的库和容错能力。</p><ul><li>Spark Streaming接收器不会一次读取单个数据记录，而是将数据流离散化为亚秒级的微小批量（RDDs）。（即接收者并行接受数据并将其缓冲在Spark worker节点的内存中）。然后，Spark引擎运行简短的任务（数十毫秒）以处理批处理并将结果输出到其他系统。</li></ul><p>与连续操作器模型不同，Spark任务根据数据的位置和可用资源动态分配给工作人员。这是为了实现更好的负载平衡和更快的故障恢复。</p><ul><li>每个数据的batches都是一个RDD。这允许使用任何Spark代码或库来处理流数据。</li></ul><h4 id="DSP好处：动态负载平衡"><a href="#DSP好处：动态负载平衡" class="headerlink" title="DSP好处：动态负载平衡"></a>DSP好处：动态负载平衡</h4><p>将数据划分为多个微批，可以将计算能力以细粒度的方式分配给资源。</p><p>以字数统计为例：分区不均衡的流会导致某个节点过载，达到瓶颈；而将数据离散Discretized 后，可以根据节点的负载对任务进行分配和调度。</p><h4 id="DSP好处：从故障和卡住的任务中快速恢复"><a href="#DSP好处：从故障和卡住的任务中快速恢复" class="headerlink" title="DSP好处：从故障和卡住的任务中快速恢复"></a>DSP好处：从故障和卡住的任务中快速恢复</h4><p>传统流：</p><ul><li>万一发生节点故障，传统系统必须在另一个节点上重新启动发生故障的连续运算器，并重播数据流的某些部分以重新计算丢失的信息。（请注意，在重播后新节点赶上之前，管道无法继续进行。）</li></ul><p>Spark流（离散流）</p><ul><li><p>可以在集群中的所有其他节点上并行重新启动失败的任务，从而将所有重新计算均匀地分布在多个节点上，从而从故障中恢复。</p><p><u>计算已经离散化为可以在任何地方运行而不会影响正确性的任务。</u></p></li></ul><h4 id="DSP好处：流、批处理、交互的统一"><a href="#DSP好处：流、批处理、交互的统一" class="headerlink" title="DSP好处：流、批处理、交互的统一"></a>DSP好处：流、批处理、交互的统一</h4><p>Spark Streaming中的关键编程接口是DStream或分布式流。 每一批流数据都由RDD表示，因此DStream只是一系列RDD。</p><p>因此，我们可以使用任何Spark函数处理DStream。例如，我们可以将DStream与预先计算的静态数据集（已加载到另一个RDD中）结合在一起</p><p>数据批存储在workers的内存中，因此可以按需交互查询。<br>批处理，流和交互式工作负载的这种统一在Spark中非常简单，但是在没有<u>工作负载的通用接口</u>的系统中很难实现</p><h4 id="DSP好处：高级分析"><a href="#DSP好处：高级分析" class="headerlink" title="DSP好处：高级分析"></a>DSP好处：高级分析</h4><p>DStreams生成的RDD可以转换为DataFrames并使用SQL查询</p><p>例如，使用Spark的JDBC驱动程序，可以公开流的状态，并支持SQL语句进行查询。</p><p>然后，通过JDBC服务器，就能够以交互方式（比如SQL命令、GUI）查询持续更新的表。</p><h4 id="Spark流：性能"><a href="#Spark流：性能" class="headerlink" title="Spark流：性能"></a>Spark流：性能</h4><p>实际上，Spark Streaming具有批处理数据和利用Spark引擎的能力，可以使吞吐量与其他流系统相当或更高。</p><ul><li>Spark Streaming可以实现低至几百毫秒的延迟。</li></ul><p>开发人员有时会问微批处理是否会固有地增加过多的延迟。</p><ul><li>实际上，批处理延迟仅是端到端管道延迟的一小部分。</li></ul><ul><li>例如，许多应用程序在滑动窗口上计算结果，甚至在COS中，该窗口也仅定期更新（例如，每2秒滑动20秒的窗口）。</li></ul><ul><li>许多管道等待很短的时间来处理延迟或乱序的数据。</li></ul><ul><li>最后，任何自动触发算法都倾向于等待一段时间才能触发。</li></ul><p>同样，DStreams带来的吞吐量提高通常意味着您需要更少的计算机来处理相同的工作负载。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> RDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算/10 云中间件，配置管理，PaaS</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/10%20%E4%BA%91%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%EF%BC%8CPaaS/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/10%20%E4%BA%91%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%EF%BC%8CPaaS/</url>
      
        <content type="html"><![CDATA[<h2 id="10-云中间件，配置管理，PaaS"><a href="#10-云中间件，配置管理，PaaS" class="headerlink" title="10 云中间件，配置管理，PaaS"></a>10 云中间件，配置管理，PaaS</h2><h4 id="云计算的好处"><a href="#云计算的好处" class="headerlink" title="云计算的好处"></a>云计算的好处</h4><ul><li>弹性资源：自治的资源按需供应（通过实用的模型）</li><li><p>多重租赁：多个用户并发使用相同资源</p></li><li><p>工作负载整合：将利用不足的资源释放，把工作负载低的虚拟机整合到同一个物理机器上。</p></li></ul><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>位于网络中分布式计算系统每一侧的操作系统和应用程序之间的软件层：</p><ul><li>连接不同的软件组件</li><li>是在系统和分布式软件之间的软件层</li><li><p>隐藏了分布式系统的复杂性和多样性 heterogeneity</p></li><li><p>连接了低层次的OS通信（系统级别的通信实现）和编程语言抽象（通信的接口）的间隔</p></li><li><p>为分布式应用提供了常用的编程接口和基础设施</p></li><li>促进资源服务的使用</li><li>将应用与基础设施连接</li></ul><h4 id="Platform-as-a-Service-PaaS"><a href="#Platform-as-a-Service-PaaS" class="headerlink" title="Platform as a Service (PaaS)"></a>Platform as a Service (PaaS)</h4><p>定义：“向消费者提供的功能是将使用提供商提供的编程语言，库，服务和工具创建的，由消费者创建或获取的应用程序部署到云基础架构上。 使用者不管理或控制包括网络，服务器，操作系统或存储在内的底层云基础架构，但可以控制已部署的应用程序以及应用程序托管环境的配置设置。</p><p>简单的定义：在基本虚拟资源（即虚拟机，块存储）管理之外提供的任何服务。</p><p>是什么：是一种云中间件；提供<u>软件解决方案堆栈</u>即服务；可以聚合其他PaaS和IaaS供应商服务；通常由工具和/或库(APIs)组成</p><p>用处：通过抽象简化应用开发；通过简化管理促进应用部署</p><h4 id="PaaS例子"><a href="#PaaS例子" class="headerlink" title="PaaS例子"></a>PaaS例子</h4><ul><li>• Google App Engine</li><li>• Amazon Web Services<ul><li>– Amazon RDS (Relational Database Service) </li><li>– Amazon Elastic Transcoder</li></ul></li><li>• Hadoop Project<ul><li>– MapReduce</li><li>– Hbase: Bigtable-like capabilities on top of Hadoop and HDFS</li></ul></li></ul><h4 id="云服务的生命周期"><a href="#云服务的生命周期" class="headerlink" title="云服务的生命周期"></a>云服务的生命周期</h4><ol><li>construction：开发、组合、配置</li><li>deployment：选择供应商、部署、上下文化</li><li>operation：调度、优化、执行、重新上下文化</li></ol><h4 id="配置管理-Configuration-Management-CM"><a href="#配置管理-Configuration-Management-CM" class="headerlink" title="配置管理 Configuration Management (CM)"></a>配置管理 Configuration Management (CM)</h4><p>用于：在构造阶段后（但不是在部署和操作阶段），在大规模机器上（10k）配置应用和中间件</p><p>例子：puppet、chef</p><h4 id="Puppet"><a href="#Puppet" class="headerlink" title="Puppet"></a>Puppet</h4><p>提供基于图像的和模型驱动的方式；通过人类可读的DSL（Domain Specific Language）实现；资源是存储在“清单”中的配置单位；可以将资源编译到定义依赖项的目录中（作为有向非循环图）；目录已应用于系统以对其进行配置；在许多计时器步骤中，配置更改是不确定的（最终应用）</p><h4 id="Chef"><a href="#Chef" class="headerlink" title="Chef"></a>Chef</h4><p>是Puppet的一个受欢迎的分支；</p><p>主要区别：天生就是确定性的 Deterministic</p><p>强调启动一个新的服务（适合虚拟机和云）</p><p>按顺序应用配置，且用户可知</p><p>使用烹饪的类比：<br>•创建配方（安装步骤或脚本的预算）<br>•使用刀（用于管理的命令行工具）<br>•存储在服务器内的食谱中</p><h4 id="Chef的结构"><a href="#Chef的结构" class="headerlink" title="Chef的结构"></a>Chef的结构</h4><p>Client-Server架构</p><p>服务器推送配置变更</p><p>客户端在机器上实施配置变更</p><h4 id="配置管理在Cloud上的问题"><a href="#配置管理在Cloud上的问题" class="headerlink" title="配置管理在Cloud上的问题"></a>配置管理在Cloud上的问题</h4><ol><li>云环境天生就是动态的：CM工具并不是用于处理有弹性的资源集合（AWS Elastic Beanstalk 是Chef的云生命周期可感知版）；因为云的生命周期，导致云应用和普通应用不一样（Useful in Construction，What about: Deployment, Operation?）</li><li>遗留软件如何迁移到云：如何使遗留软件和他们的中间件适应云的动态特征（如何将云的dynamic nature提取走）</li><li>如何构建可内部交互的云应用</li></ol><h4 id="Contextualization-上下文化"><a href="#Contextualization-上下文化" class="headerlink" title="Contextualization 上下文化"></a>Contextualization 上下文化</h4><p>定义：上下文是在部署到特定环境期间自主配置应用程序的各个组件并支持软件堆栈的过程。</p><p>通过在整个生命周期内通过PaaS组件配置SaaS和PaaS，启用弹性云软件堆栈。<br>通过通用配置机制支持旧式中间件<br>通过recontextualization 实现IaaS提供程序的互操作性</p><p>上下文化机制的两个阶段：</p><ul><li>Deployment：从环境中（在PaaS层）采集动态生成的配置数据</li><li>Operation：由VM boot触发，使用上述数据的软件配置</li></ul><p>被OpenNebula和OpenStack采用，用于使软件使用Iaas供应商的环境，例如：</p><ul><li>配置基础网络（静态和动态）</li><li>配置虚拟机秘钥识别（SSH VPN）</li><li>连接基于网络的存储</li></ul><h4 id="Operation阶段的上下文化"><a href="#Operation阶段的上下文化" class="headerlink" title="Operation阶段的上下文化"></a>Operation阶段的上下文化</h4><ul><li>配置数据是如何传递到虚拟机的（见图）</li><li>在boot阶段安装ISO光盘镜像（ISO CD image）：上下文数据通过网络脚本传递到虚拟机内部的脚本上，由脚本创建软件专门的配置文件和域数据</li><li>配置文件和数据用于设置云环境中，软件依赖和中间件服务的上下文，</li></ul><h4 id="Recontextualization-重新上下文化"><a href="#Recontextualization-重新上下文化" class="headerlink" title="Recontextualization 重新上下文化"></a>Recontextualization 重新上下文化</h4><p>在Operation阶段（runtime）改变配置数据</p><blockquote><p>The recontextualizer is responsible for triggering the creation and association of new infrastructure class context data when applicable domains are migrated to the infrastructure.</p></blockquote><p>触发：虚拟机实时迁移Live Migration，比如本地环境变量更改，但无需重启reboot，因此需要触发机制，而不是有规律的执行</p><p>在重新上下文化的过程中，虚拟机将会持续运行，自动的，且更改对应用是透明的</p><h4 id="Contextualizer-结构"><a href="#Contextualizer-结构" class="headerlink" title="Contextualizer 结构"></a>Contextualizer 结构</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcsnmpoczxj31c00g2dlv.jpg" alt="截屏2020-03-13下午2.09.51"></p><blockquote><p>Figure 3 also includes the order in which components are called. From the figure it can be seen that the Contextualizer component is invoked by the VM Manger during application deployment (step 1) to create ISO images (steps 2, 3), create VM images (steps 4, 5) and/or manip- ulate VM images (steps 6, 7). After images have been created and/or manipulated, they are stored in a local data repository (step 8) for deployment by the VM Manager. During operation, if an event from the underlying hypervisor indicates that a VM has been stopped, started or migrated (step 9), alterations to the existing ISO images are made (steps 10, 11) and reinserted into the VM’s virtual device (step 12).</p></blockquote><p>从图中可以看出，在应用程序部署期间，VM管理器调用了Contextuizer组件（步骤1）以创建ISO映像（步骤2、3），创建VM映像（步骤4、5）和/或操作 -确定VM映像（步骤6、7）。 创建和/或操作映像后，它们将存储在本地数据存储库中（步骤8），以供VM Manager进行部署。 在操作过程中，如果来自底层管理程序的事件指示VM已停止，启动或迁移（步骤9），则对现有ISO映像进行更改（步骤10、11），然后将其重新插入VM的虚拟设备中（ 第12步）。</p><h4 id="Recontextualization-例子"><a href="#Recontextualization-例子" class="headerlink" title="Recontextualization 例子"></a>Recontextualization 例子</h4><p>由于先前的设置，分布式文件系统的操作性能可能会在实时迁移后降低</p><p>客户端数据与远程服务节点交互，而不是附近的节点</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/19 Serverless Architectures</title>
      <link href="/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/19%20Serverless%20Architectures/"/>
      <url>/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/19%20Serverless%20Architectures/</url>
      
        <content type="html"><![CDATA[<h2 id="19-Serverless-Architectures"><a href="#19-Serverless-Architectures" class="headerlink" title="19 Serverless Architectures"></a>19 Serverless Architectures</h2><h4 id="无服务计算"><a href="#无服务计算" class="headerlink" title="无服务计算"></a>无服务计算</h4><p>开发者不需要配置或者管理服务器或容器，如AWS Lambda，只需要将业务代码上传至平台即可。</p><p>在无服务计算的模型中，服务器的存在对开发者是隐藏的。</p><ul><li>无服务结构和功能即服务 Function-as-a-Service(FaaS) 平台的优点：简单、快速、灵活</li><li><strong>无服务</strong>指的是软件结构，<strong>功能即服务</strong>是其中的关键的机制，通过这种机制，开发者在该软件结构中实现业务逻辑</li></ul><h4 id="IaaS-PaaS-SaaS-FaaS的区别"><a href="#IaaS-PaaS-SaaS-FaaS的区别" class="headerlink" title="IaaS, PaaS, SaaS, FaaS的区别"></a>IaaS, PaaS, SaaS, FaaS的区别</h4><h4 id="无服务计算执行模型"><a href="#无服务计算执行模型" class="headerlink" title="无服务计算执行模型"></a>无服务计算执行模型</h4><p>如果该功能不存在与现有的服务器中，则平台从数据库中读取功能，并部署到服务器上，再返回功能的执行结果给用户</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>无需管理服务器，可连续扩展，动态分配资源，避免资源过度分配（管理资源分配，平衡资源分配），按使用付费</p><p>从生产角度From a productivity standpoint，可以不考虑代码存储和执行环境管理的细节</p><p>基于execution metrics，无服务计算十分划算priced，so there is a financial advantage as well.</p><h4 id="无服务功能-Serverless-Functions"><a href="#无服务功能-Serverless-Functions" class="headerlink" title="无服务功能 Serverless Functions"></a>无服务功能 Serverless Functions</h4><p>从 monoliths 到 microservices 到 functions</p><p><strong>微服务</strong>的特点：Smaller-grained services 粒度小的服务，专属、具体的功能</p><p><strong>微服务</strong>的结构：事件处理器 Event handler，无服务后端，数据处理</p><p><strong>无服务功能</strong>的特点：FaaS的指导原则，开发者无需关注被抽象化的服务器，按照功能的使用服务而不是服务器实例的大小，提供的服务是事件驱动的且能够立即扩展</p><h4 id="透明的应用部署"><a href="#透明的应用部署" class="headerlink" title="透明的应用部署"></a>透明的应用部署</h4><p>PaaS：用于基于用户需求和约束的服务发现</p><p><strong>无服务结构</strong>和<strong>微服务</strong>可以掩盖“运行过程中软件和数据的灵活组合/拆分和可交互性”</p><p><strong>容器</strong>或<strong>技术</strong>用于桥接云和边缘计算之间的间隔：Unikernels 提供解决“软件定义的基础架构”的基础功能</p><h4 id="无服务计算——其他好处"><a href="#无服务计算——其他好处" class="headerlink" title="无服务计算——其他好处"></a>无服务计算——其他好处</h4><p>简化部署和打包，消除系统管理的要求</p><p>敏捷开发，使开发者集中于代码，并快速发布deliver</p><p>扩展的成本更低：扩展（用户访问量）不需要开发者通过代码实现，管理者也不用更新服务器或添加新的服务器</p><p>更小的开发成本和经营成本 operational costs</p><p>更快发布软件 software release，减少到市场的时间 Decreased time to market</p><h4 id="无服务架构的解决方案和结构细节"><a href="#无服务架构的解决方案和结构细节" class="headerlink" title="无服务架构的解决方案和结构细节"></a>无服务架构的解决方案和结构细节</h4><ul><li>Amazon Lambda</li><li>Apache Openwhisk</li><li>IBM Openwhisk</li><li>Google cloud functions</li><li>Microsoft Azure functions Other: Iron.io, Fission</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向列的数据库</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20NOSQL-%E8%B0%B7%E6%AD%8CBigTable/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20NOSQL-%E8%B0%B7%E6%AD%8CBigTable/</url>
      
        <content type="html"><![CDATA[<p>大数据系统的规模对数据库空间的要求有很大挑战</p><p>传统的关系数据库管理系统（Relational Database Management System：<em>RDBMS</em>）无法扩展为适应真正的massive级别数据：ACID原则不适合大规模的数据，CAP定理中描述的问题</p><a id="more"></a><h4 id="CAP定理："><a href="#CAP定理：" class="headerlink" title="CAP定理："></a>CAP定理：</h4><ul><li>一致性：所有客户都能看到最新的数据，不管执行过什么操作（比如更新或删除）</li><li>可用性：即使某些节点发送错误，系统也需要继续客户的操作</li><li>分区容错：即使网络或消息发送错误，系统也需要继续执行可续操作（比如一个节点向另一个节点发送的消息，允许发送错误并被丢弃）</li></ul><h4 id="ACID-和-BASE"><a href="#ACID-和-BASE" class="headerlink" title="ACID 和 BASE"></a>ACID 和 BASE</h4><p>ACID：</p><ul><li>Atomic 原子性：事务的所有操作都成功，不然就回滚</li><li>Consistent 一致性：事务不能使数据库的最终状态出现不一致</li><li>Isolated 隔离性：事务使独立的，不能影响其他事务</li><li>Durable 容忍性：即使服务器重新启动等，已完成的事务也会保留。</li></ul><p>BASE</p><ul><li><strong>B</strong>asic <strong>A</strong>vailability 基础可用性：系统在CAP定理方面，保证系统的可用性</li><li><strong>S</strong>oft-state 软状态：系统的状态会随时间改变，即使没有输入（因为要确保最终一致性）</li><li><strong>E</strong>ventual consistency 最终一致性：只要数据库最终变得一致，在每个事务之后就不需要一致性。</li></ul><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><p>可以被分成4类：Key-value stores、Column-oriented databases、Document databases、Graph databases</p><h3 id="Google-BigTable-HBASE"><a href="#Google-BigTable-HBASE" class="headerlink" title="Google BigTable (HBASE)"></a>Google BigTable (HBASE)</h3><p>BigTable是第一个（也是影响力最大的）面向列的NoSQL数据库之一。于2006年发布。它旨在可靠地扩展到数千台计算机上的PB级数据。</p><p>在60多种Google产品中使用，包括Google Earth，Google Analytics（分析）和Youtube。</p><p>BigTable具有极大的影响力，它催生了一个非常受欢迎的开源克隆：HBase。</p><p>设计为与MapReduce BigTable兼容并互补，可为MapReduce提供基于键的快速查找</p><h4 id="关键特征"><a href="#关键特征" class="headerlink" title="关键特征"></a>关键特征</h4><ul><li>BigTable是一个简单的概念 —- 映射两个任意字符串值（行键和列键）以及时间戳，并将其放入关联的任意字节数组中：（行：字符串，列：字符串，时间：int64）-&gt;字符串</li><li>在NoSQL分类中，BigTable是面向列的数据库。<br>它是高度分布式的，没有可用的连接，并且假定“一次写入多次读取”。</li><li>数据模型是“稀疏，分布式，持久的多维排序图”<br>a sparse, distributed, persistent multi-dimensional sorted map”</li><li>实际上，这意味着您可以通过提供行ID，列名和时间戳来访问BigTable中的任何单元（用于版本控制–您保留同一单元的过去版本）。<br>提供这些参数，BigTable会很快将结果返回给您。</li></ul><h4 id="Tablets"><a href="#Tablets" class="headerlink" title="Tablets"></a>Tablets</h4><ul><li>单元的每个新版本都会增加时间戳。 这允许您设置策略，例如“仅保留最新的n个版本”或“仅保留自时间t开始存储的版本”。</li><li>数据按行排序，以行的Key按字典顺序排序，并且表的行范围是动态分区的。 每行范围称为一个Tablets。</li><li>Tablets是分配和负载平衡的单位——如果发生不平衡，则Tablets可以在服务器之间移动。<br>Tablets的大小大约在200MB</li></ul><p>例如 ：如果关键范围是{January，February，March}，并且从March开始有很多数据进入，则它将拆分为多个Tablets，并在服务器之间移动以平衡系统。</p><p>因此，少量row范围的读取是高效的，并且通常仅需要与少量机器通信。</p><h4 id="Tablet-管理"><a href="#Tablet-管理" class="headerlink" title="Tablet 管理"></a>Tablet 管理</h4><p>BigTable使用3层模型对tablet进行管理</p><ol><li>第一层包含存储在Chubby（用于访问控制的分布式锁定服务）中的文件，该文件包含根Tablet的位置。</li><li>根tablet包含系统中所有tablets的位置。 它经过特殊处理，并且与其他tablet不同，它永远不会被分割——确保层次结构永远不会超过3个级别。</li><li>根tablet中的每一行都在内存中使用大约1k的数据。 假设每块tablet有128MB的限制，则3级层次结构可以处理$2^{34}$（〜170亿）个tablets。</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5s2zivqsj30o60b2whu.jpg" alt="截屏2020-03-24下午10.36.12" style="zoom:50%;" /></p><h4 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h4><p>Head node：分配tablets到tablet服务器上</p><p>Tablet server：管理对tablets的读写操作；客户端直接与tablet服务器通信；tablet服务器将太大的tablets拆分</p><p>SSTable：Sorted String Tables 包含真实数据</p><h4 id="读写组织"><a href="#读写组织" class="headerlink" title="读写组织"></a>读写组织</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcvbq1kcy8j30sg0e8dhf.jpg" alt="截屏2020-03-15下午9.34.38"></p><p>内存中有一个表（memTable）用于存储发生的一系列的更新</p><p>一个写操作会将记录添加到memTable中，并且同时会写入日志（为了容错）</p><p>通过读取SSTable文件以及通过动态应用memTable的更新来提供读操作。 换句话说：“这里是价值所在，以及需要应用到该价值以获得真正价值的更新流”</p><h4 id="次要压缩-Minor-Compactions"><a href="#次要压缩-Minor-Compactions" class="headerlink" title="次要压缩 Minor Compactions"></a>次要压缩 Minor Compactions</h4><p>随着写操作执行，memTable的大小也会增大。当memTable的大小达到阈值，该memTable会被冻结，并创建一个新的memTable。被冻结的memTable被转化为SSTable并被写成文件。</p><p> 这部分操作被认为次要压缩，该压缩的两个目标：</p><ol><li>减少tablet服务器的内存使用量</li><li>减少数据恢复时，必须从提交日志中读取的数据量。</li></ol><p>发生压缩时，传入的读/写操作可以继续。</p><h4 id="主要压缩-Major-Compactions"><a href="#主要压缩-Major-Compactions" class="headerlink" title="主要压缩 Major Compactions"></a>主要压缩 Major Compactions</h4><p>每个次要压缩都会产生一个新的SSTable，如果该操作不断进行，读操作需要从大量的SSTables中合并更新。</p><p>为了防止这种情况，我们会在后台定期执行合并压缩。这样的压缩读取了几个SSTables和memTable的内容，并写出了一个新的SSTable。 完成后，可以丢弃之前的SSTables和memTable。</p><p><strong>将所有SSTables重写为一个SSTable的合并压缩称为主要压缩</strong>。 请记住，单个SSTable本身可能会拆分为多个文件。</p><h4 id="关键特征-1"><a href="#关键特征-1" class="headerlink" title="关键特征"></a>关键特征</h4><p>调整压缩格式</p><ul><li><p>客户端可以控制是否压缩地区组的SSTable，以及如果压缩，则使用哪种压缩格式。</p><p>用户指定的压缩格式将应用于每个SSTable块（大小可通过特定于位置组的调整参数来控制）。</p><p>分别压缩每个块时，会损失一些空间，但是我们的好处是，可以读取SSTable的一小部分而无需解压缩整个文件。</p></li></ul><p>布隆过滤器</p><ul><li><p>读取操作必须从组成tablet状态的所有SSTable中读取。 如果这些SSTable不在内存中，我们可能最终会进行许多磁盘访问。</p><p>BigTable可以使用Bloom Filters减少此类访问的次数。 布隆过滤器允许我们询问SSTable是否可能包含指定行/列/对的任何数据。</p><p>对于某些应用程序，将少量tablet服务器内存分配给<u>布隆过滤器</u>，能够大大减少读取操作所需的磁盘搜索次数。</p></li></ul><p>使SSTables不可变</p><ul><li><p>使用BigTable改善性能的另一种方法是使SSTables不可变。</p><p>这意味着SSTables不会直接写入，因为唯一可写入的数据结构是memTable，这使得并发控制相对简单。</p><p>结果，由于具有不可变性，仅在发生重大压缩时才创建SSTables。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google BigTable </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异构硬件</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20%E5%BC%82%E6%9E%84%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20%E5%BC%82%E6%9E%84%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Cyber-Physical Systems (CPS)，the Internet of Things (IoT)， and the Smart Anything Everywhere Initiative</p><p>从长远来看，随着大规模采用，物联网转型影响预计将显着增加：千万级数量的物品互联，非常大的经济价值</p><p>关键驱动因素：物联网收集的数据，复杂的应用程序开发平台，应用于事物的分析以及<strong>异构硬件体系结构 heterogeneous hardware architectures</strong>，能够促进新业务模型</p><a id="more"></a><h4 id="云计算-大数据"><a href="#云计算-大数据" class="headerlink" title="云计算+大数据"></a>云计算+大数据</h4><p>实时流、实时处理</p><p>数据可视化</p><p>实时结构化数据库、交互式分析、批量处理</p><p>结构化和非结构化数据</p><p>云基础设施</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Cyber-Physical Systems (CPS)，the Internet of Things (IoT)， and the Smart Anything Everywhere Initiative</p><p>从长远来看，随着大规模采用，物联网转型影响预计将显着增加：千万级数量的物品互联，非常大的经济价值</p><p>关键驱动因素：物联网收集的数据，复杂的应用程序开发平台，应用于事物的分析以及<strong>异构硬件体系结构 heterogeneous hardware architectures</strong>，能够促进新业务模型</p><h3 id="异构硬件体系结构-Heterogeneous-hardware-architectures"><a href="#异构硬件体系结构-Heterogeneous-hardware-architectures" class="headerlink" title="异构硬件体系结构 Heterogeneous hardware architectures"></a>异构硬件体系结构 Heterogeneous hardware architectures</h3><p>是运行产品和提供服务的一种高效方法；将不同的处理器类型组合到一个系统中，以此提高绝对性能，最小化能耗和成本。</p><p>引入新的平台：合并多核CPUs，多核GPUs，和许多附加设备作为一个单独解决方案。出现在从超级计算机到个人智能手机的各种环境中.</p><p>因为产品的种类不断增长，因此需要设计<strong>更灵活的软件抽象software abstractions</strong>，以及改进系统结构，以探索异构平台的好处</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>数据巨大且复杂，传统处理方法效率不足：</p><ul><li>Too large to fit reasonably in fast RAM 数据太大无法合理的放入fast RAM中</li><li>Random access intensive, making prefetching and caching ineffective 随机访问密集，使预取和缓存无效</li></ul><p>数据经常被存在多机集群中的二号存储节点中</p><ul><li>存储系统和网络性能成为 first-order concerns</li></ul><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>大数据系统带来新的需求：新的编程模型和工具</p><p>大数据系统需要实现：高性能和高效率</p><h4 id="关于异质性方面"><a href="#关于异质性方面" class="headerlink" title="关于异质性方面"></a>关于异质性方面</h4><p>异质性是并行结构中最深奥和最有挑战的特征</p><p>宏观方面：分布式计算机（云）的网络，由不同的节点结构（单核，多核）组成，通过可能的异质网络进行内部交互；即网络的异质性和，网络上的机器的异质性</p><p>微观方面：底层的内存结构（main、cache、disk storage、tertiary storage）和不同的accelerator结构（固定的、可编程的，比如GPUs；可配置的：FPGAs）</p><h3 id="电脑结构"><a href="#电脑结构" class="headerlink" title="电脑结构"></a>电脑结构</h3><p>需要进行分类：根据目的进行分类</p><h4 id="通用处理器-General-Purpose-Processors（GPP）"><a href="#通用处理器-General-Purpose-Processors（GPP）" class="headerlink" title="通用处理器 General Purpose Processors（GPP）"></a>通用处理器 <strong>General Purpose Processors</strong>（GPP）</h4><ul><li>通用微处理器（通用电脑）：比如PCs，workstations，Laptops，notepads，用于执行多种应用和任务</li><li>微控制器：嵌入式系统<ul><li>专门为嵌入式系统中指定任务而设计</li><li>有面向控制的外围设备</li><li>具有片上CPU，固定数量的RAM，ROM，I / O端口</li><li>低成本、低能耗、低性能、比微处理器更小</li><li>适合对成本、空间、能耗要求严格的应用</li></ul></li></ul><h4 id="应用专用处理器"><a href="#应用专用处理器" class="headerlink" title="应用专用处理器"></a>应用专用处理器</h4><p>通用处理器对不同的软件都能表现出较好的性能，但专用处理器在特定任务上的表现更好</p><p>应用专用处理器出现的目的：更高的性能，更低的消耗，更低的成本</p><p>比如：TVs、mobile phone（不是智能手机）、GPSs</p><p>被分为：</p><ol><li>Digital Signal Processor (DSPs) 数字信号处理器</li><li>Application Specific Instruction Set Processors (ASIPs) 应用专用命令集处理器</li><li>Application Specific Integrated Circuit (ASICs) 应用专用集成电路<ul><li>指定市场、更少编程、难以构建</li></ul></li></ol><h4 id="Accelerators-Coprocessors-加速器-协处理器"><a href="#Accelerators-Coprocessors-加速器-协处理器" class="headerlink" title="Accelerators - Coprocessors 加速器-协处理器"></a><strong>Accelerators - Coprocessors</strong> 加速器-协处理器</h4><p>加速器-协处理器对某些功能的处理性能比CPU更高效more efficiently ：更快、更低能耗，但更难编程，比如：</p><ol><li>Graphics Processing Unit (GPU)<ul><li>Single Instruction Multiple Thread (SIMT) model 单指令多线程模型 – CUDA code</li><li>高效：数据并行应用；吞吐量密集型应用——算法需要处理大量数据元素</li></ul></li><li>FPGA (Field Programmable Gate Array) 现场可编程门阵列<ul><li>是逻辑门阵列，可以进行硬件编程以完成用户指定的任务</li><li>软件的一部分可以直接由硬件实现</li><li>比软件更有效率，但比ASIC更贵</li></ul></li></ol><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>Intel CPU -&gt; DSP -&gt; MultiCore -&gt; ManyCore -&gt; GPU -&gt; FPGA -&gt; ASIC</p><p>灵活性、可编程、 ——&gt; 性能、特定领域、能源使用率高 power efficiency</p><h4 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h4><p>Host memory 主存：CPU的内存</p><p>Device memory 显存：GPU的内存</p><p><strong>处理流程：</strong></p><ol><li>从CPU中将输入数据拷贝到GPU中</li><li>加载GPU程序并执行，将数据缓存到芯片chip上提高性能</li><li>将执行结果从GPU内存中拷贝回CPU内存</li></ol><h4 id="GPU——数据处理"><a href="#GPU——数据处理" class="headerlink" title="GPU——数据处理"></a>GPU——数据处理</h4><p>擅长处理并行 data-parallel processing</p><ul><li>在多个数据元素上并行执行相同的计算——低控制流开销和高SP浮点运算强度 high SP floating point arithmetic intensity</li><li>每个内存访问有许多计算</li></ul><p>高浮点运算强度和许多数据元素意味着可以通过计算而不是大数据缓存来隐藏内存访问延迟</p><ul><li>需要避免带宽饱和</li></ul><h4 id="FPGA-现场可编程门阵列"><a href="#FPGA-现场可编程门阵列" class="headerlink" title="FPGA 现场可编程门阵列"></a>FPGA 现场可编程门阵列</h4><p>可配置逻辑块，内部通信网络，I/O信号</p><h4 id="FPGA——数据处理"><a href="#FPGA——数据处理" class="headerlink" title="FPGA——数据处理"></a>FPGA——数据处理</h4><ul><li>用于数据采集和原始数据预处理以进行事件过滤</li><li>需要掌握基于FPGA的硬件描述语言（HDL）的编程模型。<ul><li>– VHDL和Verilog是设计FPGA系统的传统方法</li><li>–描述执行计算的基础设计的基础硬件</li><li>–这与诸如C和C ++的编程语言形成对比，后者描述了在固定不变体系结构上执行的指令</li><li>–这使得FPGA既可以在其上实现的方面极为灵活，又在不充分了解其编程模型的情况下也很难设计。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异构硬件 </tag>
            
            <tag> GPU </tag>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据仓库、数据去重</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%8E%BB%E9%87%8D%E5%92%8C%E4%BB%93%E5%BA%93/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%8E%BB%E9%87%8D%E5%92%8C%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>数据去重是一个逐渐流行起来的方法</p><p>重复数据删除有许多用途，但其主要用途是减少系统所需存储空间的潜力。</p><p>去重可以是文件file级别，块block级别，字节byte级别</p><a id="more"></a><h4 id="数据仓库-data-warehouse"><a href="#数据仓库-data-warehouse" class="headerlink" title="数据仓库 data warehouse"></a>数据仓库 data warehouse</h4><p>假设一个大公司：有许多数据库database、许多站点sites，和不同的schemas。</p><p>求是：•支持决策<br>•在全公司范围内查看高质量信息的集成视图（来自不同的数据库）<br>•分离运营系统和信息系统</p><p>运营系统和信息系统的比较</p><div class="table-container"><table><thead><tr><th>特征</th><th>运营系统</th><th>信息系统</th></tr></thead><tbody><tr><td>主要目的</td><td>在当前基础上用于商业运营</td><td>帮助制定决策</td></tr><tr><td>数据类型</td><td>当前商业运营状况的展示</td><td>历史数据和预测数据</td></tr><tr><td>主要用户</td><td>柜员、销售、管理员</td><td>管理者、商业分析师、客户</td></tr><tr><td>使用范围</td><td>狭窄的、有计划的和简单的<u>更新和查找</u></td><td>宽泛的、复杂的<u>查询和分析</u></td></tr><tr><td>设计目标</td><td>性能：吞吐量、可用性</td><td>灵活访问和使用</td></tr><tr><td>大小</td><td>对一个和少数几个表的大量更新和查询</td><td>周期性的批量更新，对大量或所有行的查询</td></tr></tbody></table></div><p>数据仓库包括：元数据，原始数据-&gt;轻度总结数据-&gt;高度总结数据，数据库管理系统；其他还有：负载管理、查询管理、数据仓库管理</p><p>数据仓库的使用者：联机分析处理OLIP工具，报告、查询、应用开发、EIS工具，数据挖掘工具，和终端用户end-user访问工具</p><p>数据仓库的来源：<strong>运营数据源Operational data source</strong>，运营数据库Operational data store</p><h4 id="数据仓库的定义"><a href="#数据仓库的定义" class="headerlink" title="数据仓库的定义"></a>数据仓库的定义</h4><p>“数据仓库是面向主题的，集成的，随时间变化且非易失性的数据收集，以支持管理层的决策过程。”</p><p><strong>Subject-oriented</strong>：</p><ul><li>面向重要的主题，而不是交易transactions：比如销售、市场、金融、分销distribution；</li><li>简洁的视图，仅提供有用的数据以供决策</li></ul><p><strong>Integrated</strong>：</p><ul><li><p>来自于多个数据源的数据遵循一致的命名习惯Consistent naming conventions、格式、编码结构</p></li><li><p>对缺失数据，噪声数据，不一致数据进行清洗cleaning和预处理pre-processing</p></li></ul><p><strong>Time-varinat</strong>：</p><ul><li>只读，周期性刷新</li><li>提供历史historical值和可能的预测projected值</li></ul><p><strong>Non-volatile</strong>：</p><ul><li>在物理上分别存储</li><li>非在线更新</li><li>从不移除数据，因此没有并发问题</li></ul><h4 id="运营数据-Operational-data"><a href="#运营数据-Operational-data" class="headerlink" title="运营数据 Operational data"></a>运营数据 Operational data</h4><ul><li>transient 短暂的（not historical）</li><li>not normalised非标准化的（指的是数据库的范式）（可能为了性能而去规范化）</li><li>约束在一定范围内（非全面的 not comprehensive）</li><li>有时候质量不佳（出现不一致和错误）</li></ul><p><strong>经过提取/转换/加载 E(xtract)T(ransform)L(oad)后：</strong></p><ul><li>详细的Detailed（但还没被总结summarized）</li><li>历史的（周期性的periodic）</li><li>标准化（第三范式3rd  normal form或更高）</li><li>全面的：以公司为角度</li><li>时效的：数据足够支持目前的决策制定</li><li>质量受控的：数据精确且准确</li></ul><h4 id="删除重复数据-Data-Deduplication"><a href="#删除重复数据-Data-Deduplication" class="headerlink" title="删除重复数据 Data Deduplication"></a>删除重复数据 Data Deduplication</h4><p>数据去重是一个逐渐流行起来的方法</p><p>重复数据删除有许多用途，但其主要用途是减少系统所需存储空间的潜力。</p><p>去重可以是文件file级别，块block级别，字节byte级别</p><h4 id="文件级别去重"><a href="#文件级别去重" class="headerlink" title="文件级别去重"></a>文件级别去重</h4><p>对单文件去重，常被认为“单实例存储”，它的主要思想就是：不管有多少文件实例被使用，只保留一个文件备份</p><p>该技术被用于Amazon S3，并报告出能够减少存储和带宽的成本为1/10</p><h4 id="块级别去重"><a href="#块级别去重" class="headerlink" title="块级别去重"></a>块级别去重</h4><p>将文件拆分成块blocks（或chunks）：核心思想是，经过两个文件不同，但他们可能包括相同的元素（比如两个不同的ppt可能包含同一张图片）</p><h4 id="字节级别去重"><a href="#字节级别去重" class="headerlink" title="字节级别去重"></a>字节级别去重</h4><p>在许多方面，字节级去重是块级去重的一种特殊情况。它比较数据流中的每个单独字节，而不是块。</p><p>字节级别去重是通常是“内容感知”的——比如，卖方对数据流的组成有一定的了解，因此知道要处理的数据流的特定部分。</p><p>该方法通常是“后处理”的，即先存储所有的流，再进行处理</p><h4 id="去重处理"><a href="#去重处理" class="headerlink" title="去重处理"></a>去重处理</h4><p>我们需要一种方法来检查数据是否已经被存储在我们的系统中：对文件、块、字节进行哈希计算，然后在我们的去重数据库DDB中查询该哈希值。如果该值存在，则该数据存在，如果值不存在，则存储该数据和对应的哈希值。</p><h4 id="Source-based-和-Target-based"><a href="#Source-based-和-Target-based" class="headerlink" title="Source-based 和 Target-based"></a>Source-based 和 Target-based</h4><p><strong>Source-based</strong>：</p><ul><li>之间在文件系统（或靠近数据的地方）中进行去重</li><li>对用户和应用透明</li><li>可以由文件系统本身或主机的操作系统执行</li><li>通常一个文件系统会扫描新文件并和现存的文件比较哈希值</li><li>通常需要中心化的管理（文件系统和备份服务器要在一起）</li><li>需要更多的用户资源，而不是带宽</li></ul><p>Target-based</p><ul><li>发生在备份服务器（第二/归档archive数据库）</li><li>重复数据从创建数据的位置删除</li><li>不损耗数据源的资源</li><li>不需要中心化的管理</li><li>需要更多的带宽</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h4 id="去重的权衡"><a href="#去重的权衡" class="headerlink" title="去重的权衡"></a>去重的权衡</h4><p><strong>Granularity 粒度</strong>：影响存储的效率和性能（存储空间和处理效率的权衡）</p><p>将文件拆分得越小（比如chunck-block-byte），就能找到更多的重复数据，但同样的，去重的处理速度也就越慢</p><p>另一个考虑是是容错：只留一个去重数据的副本copy是否足够</p><p>多个副本的优缺点？容错；数据分散靠近用户的cluster中，有利于提高响应时间；占用存储空间，增加成本</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>Operational System —— 运营系统<br>ad hoc —— 常用来形容一些特殊的、不能用于其它方面的，为一个特定的问题、任务而专门设定的解决方案<br>throughput —— 吞吐量</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据去重 </tag>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP定理</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12_%20CAP%E5%AE%9A%E7%90%86/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12_%20CAP%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在<a href="https://zh.wikipedia.org/wiki/理论计算机科学" target="_blank" rel="noopener">理论计算机科学</a>中，<strong>CAP定理</strong>（CAP theorem），又被称作<strong>布鲁尔定理</strong>（Brewer’s theorem），它指出对于一个<a href="https://zh.wikipedia.org/wiki/分布式计算" target="_blank" rel="noopener">分布式计算系统</a>来说，不可能同时满足以下三点：<a href="https: //zh.wikipedia.org/wiki/CAP定理#cite_note-Lynch-1">[1]</a><a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-2" target="_blank" rel="noopener">[2]</a></p><ul><li>一致性（<strong>C</strong>onsistency） （等同于所有节点访问同一份最新的数据副本）</li><li><a href="https://zh.wikipedia.org/wiki/可用性" target="_blank" rel="noopener">可用性</a>（<strong>A</strong>vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li><li><a href="https://zh.wikipedia.org/w/index.php?title=网络分区&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">分区容错性</a>（<strong>P</strong>artition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择<a href="https: //zh.wikipedia.org/wiki/CAP定理#cite_note-3">[3]</a>。）</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-4" target="_blank" rel="noopener">[4]</a>。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p></blockquote><a id="more"></a><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>客户端将值写入任何服务器并获得响应后，它期望从其读取的任何服务器取回该值（或更新鲜的值）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcv3kjxahwj319q0lygnv.jpg" alt="截屏2020-03-15下午4.52.25"></p><p>为了保证该特性，客户端在向其中一个服务器写入后，该服务器需要与其他服务器同步，在同步完成后，才会通知客户端已成功写入。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcv3kxx6tij318w0lqwh7.jpg" alt="截屏2020-03-15下午4.52.58"></p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><blockquote><p>系统中非故障节点收到的每个请求都必须导致响应</p><p>every request received by a non-failing node in the system must result in a response</p></blockquote><p>在可用的系统中，如果我们的客户端向服务器发送请求并且服务器没有崩溃，则服务器最终必须响应客户端。不允许服务器忽略客户端的请求。</p><h3 id="分区容错"><a href="#分区容错" class="headerlink" title="分区容错"></a>分区容错</h3><blockquote><p>网络将被允许任意丢失从一个节点发送到另一节点的许多消息</p><p>the network will be allowed to lose arbitrarily many messages sent from one node to another</p></blockquote><p>即一个节点向另外一个节点发送的消息丢失是可接受的，下图展示当所有消息都丢失的情况：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcv3sa21zej30yo08k752.jpg" alt="截屏2020-03-15下午4.59.59"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop和MapReduce的发展</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/11%20Hadoop%E5%92%8CMapReduce%E7%9A%84%E5%8F%91%E5%B1%95/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/11%20Hadoop%E5%92%8CMapReduce%E7%9A%84%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>Hadoop 1 的局限、Hadoop 2：HDFS Federation、YARN</p><a id="more"></a><h3 id="Hadoop-1"><a href="#Hadoop-1" class="headerlink" title="Hadoop 1"></a>Hadoop 1</h3><h4 id="Hadoop1中的MapReduce"><a href="#Hadoop1中的MapReduce" class="headerlink" title="Hadoop1中的MapReduce"></a>Hadoop1中的MapReduce</h4><ol><li>客户端提交MapReduce任务到<u>工作追踪器 Job Tracker</u>上</li><li>工作追踪器询问<u>主节点 NameNode</u>：哪些<u>数据节点 Data Node</u>有文件块</li><li>工作追踪器然后将<u>任务追踪器 Task Tracker</u>和<u>执行Map计算的Java代码</u>提供给那些节点。计算任务将在拥有本地数据的节点执行</li><li>任务追踪器将启动Map任务，并监控进程。它将返回心跳和任务状态给工作追踪器</li><li>每一个Map任务完成后，该节点将临时存储结果（中间数据），当所有Map任务都完成后，数据将通过网络发送给执行Reduce任务的节点</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd17f7ua3oj30kq0gkdje.jpg" alt="截屏2020-03-20下午11.39.15" style="zoom:50%;" /></p><h4 id="Hadoop-1-的局限"><a href="#Hadoop-1-的局限" class="headerlink" title="Hadoop 1 的局限"></a>Hadoop 1 的局限</h4><p>集群资源管理和MapReduce是紧密耦合的</p><ul><li>Hadoop 1中的工作追踪器只在一个机器上运行<ol><li>可扩展性有限，但实际中可能需要许多数据节点</li><li>可用性只存在于单点，如果工作追踪器发生故障，那么所有工作 Jobs 都要重启</li></ol></li></ul><blockquote><p>雅虎估计该设计的上限是5000个节点和40000个并发任务</p></blockquote><p>在资源使用上同样存在问题</p><ul><li>Hadoop 1对map和reduce的插槽(slots)数量是提前定义好的，因此可能出现map插槽满了而reduce插槽还是空的情况（反之亦然）</li><li>文件的数量也十分有限。主节点在内存中持有元数据，因此每个集群通常限制为5千万-1亿个文件</li></ul><p>在Hadoop1上运行非MapReduce应用也存在限制</p><ul><li>MapReduce工作基于<u>批处理驱动的分析</u>，但是，人们通常希望在Hadoop集群中运行其他计算范例</li><li>为什么要运行非MapReduce应用？<ul><li>实时分析存在困难。 MapReduce是批处理驱动的； 当需要实时结果时，Apache Storm之类的引擎可以更好地工作。</li><li>消息传递方法在MapReduce中是不可能的（没有相互依赖性）。</li></ul></li></ul><p><strong>这些问题都在Hadoop2中得到解决</strong></p><h4 id="长尾现象"><a href="#长尾现象" class="headerlink" title="长尾现象"></a>长尾现象</h4><p>谷歌与2013年将其识别为长尾现象：<u>个别拖后腿的任务task stragglers</u>大大减慢了应用程序的完成速度（执行阈值比作业平均值高50％），由操作系统抖动 OS jitter，数据偏斜 data skew,，守护进程，能源等引起</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd18i1hjspj311y0e677y.jpg" alt="截屏2020-03-21上午12.16.14"></p><h3 id="Hadoop-2"><a href="#Hadoop-2" class="headerlink" title="Hadoop 2"></a>Hadoop 2</h3><p>Hadoop 2从受限的<u>面向批处理的模型</u>转变为更具交互性和专用性的处理模型</p><p>主要变化有：HDFS联盟，YARN，高度可用的NameNode，容器的概念</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd18nu9h66j30tg0cctcc.jpg" alt="截屏2020-03-21上午12.22.08"></p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是一个抽象概念，但本质上是一种资源分配。</p><p>容器授予应用程序使用特定主机上特定数量资源（cpu，内存，磁盘）的权限。</p><p>容器类似于虚拟机，但是在现有操作系统之上运行，而不是在<u>虚拟机管理程序Hypervisor</u>上运行。换句话说，容器能在应用级别对用户进行隔离（虚拟机是操作系统级别的隔离）。容器之间是相互独立的，但公用操作系统、bins和库</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd18ujrh6zj30lu0ditbg.jpg" alt="截屏2020-03-21上午12.28.35" style="zoom:50%;" /></p><h4 id="高可用性主节点"><a href="#高可用性主节点" class="headerlink" title="高可用性主节点"></a>高可用性主节点</h4><p>解决Hadoop1中主节点的单点问题：它提供在同一群集中运行两个冗余NameNode的选项，可以主动或被动配置，使备用节点<u>热待命 hot standby</u></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1955bwhfj30uq08owgr.jpg" alt="截屏2020-03-21上午12.38.46"></p><h4 id="HDFS水平可扩展性"><a href="#HDFS水平可扩展性" class="headerlink" title="HDFS水平可扩展性"></a>HDFS水平可扩展性</h4><p>由上图可以看出，即使通过备份让主节点获得高可用性，但2个单独的主节点并不能提供水平可扩展性</p><ul><li>垂直可扩展性：更多的RAM，更高效的内存使用，将部分命名空间放到内存中，主类归档（tar/zip）</li><li>水平可扩展性的好处：规模、隔离性、稳定性、可用性、灵活性、实现其他主节点或非HDFS 命名空间</li></ul><h4 id="解决方案：HDFS-Federation"><a href="#解决方案：HDFS-Federation" class="headerlink" title="解决方案：HDFS Federation"></a>解决方案：HDFS Federation</h4><p>解决方式是联合多个独立的主节点</p><ul><li>联合的主节点是独立的，不需要协调。</li><li>数据节点被所有主节点共用，作为块的存储。</li><li>每个数据节点向群集中的所有主节点注册。</li><li>DataNode发送心跳给所有主节点，并接受块报告和处理命令。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd19lu5mjej30jk0bstbq.jpg" alt="截屏2020-03-21上午12.54.48" style="zoom:50%;" /></p><p>主要概念：</p><ul><li><u>块池 Block Pool</u>是一个<u>命名空间 namespace</u>中的一系列块</li><li><p>数据节点存储集群中的所有块</p></li><li><p>块池是独立管理的。因此每个命名空间都可以生成块ID，而不需要与其他命名空间进行达成一致</p></li><li>一个主节点故障不会影响数据节点对其他主节点的服务</li><li>一个命名空间和它对应的块池统称为<u>命名空间卷 Namespace Volumes</u>，如果一个命名空间被删除，它对于的块池也会被删除</li></ul><h4 id="HDFS-Federation的好处"><a href="#HDFS-Federation的好处" class="headerlink" title="HDFS Federation的好处"></a>HDFS Federation的好处</h4><p>命名空间的可扩展性：HDFS群集存储（数据节点）可以水平扩展，但命名空间不能。 当使用大量文件部署时，可通过向群集添加更多主节点的而达成水平扩展的目的</p><p>性能：文件系统操作吞吐量不再局限于单个主节点的</p><p>隔离：单个主节点的在多用户环境中不提供隔离。 现在，我们可以将不同类别的应用程序放入不同的主节点中（例如，实验性应用程序减慢主节点的运行速度不会影响其余集群）</p><h4 id="Yet-Another-Resource-Negotiation-YARN"><a href="#Yet-Another-Resource-Negotiation-YARN" class="headerlink" title="Yet Another Resource Negotiation (YARN)"></a>Yet Another Resource Negotiation (YARN)</h4><p>YARN的基础思想是：将Hadoop资源管理和工作调度拆分为不同的进程（后台进程）</p><p>不同种类的应用程序都能被提交给YARN（比如MapReduce，Giraph等），应用程序可以是单个作业，也可以是作业的<u>有向无环图Directed Acyclic Graph（DAG）</u>。</p><p>这样可以并行运行更多作业，并且可扩展性得到显着提高</p><ul><li><u>资源管理器ResourceManager</u>代替<u>工作追踪器JobTracker</u>，负责在所有应用程序之间仲裁资源的使用权限。<ul><li>持续追踪：维护在集群上运行的所有程序，以及所有在线的节点管理器的可用资源</li><li>分配资源：决定下一个使用集群资源的程序（即下个一程序应该分配到哪个数据节点上）</li><li>监控<u>程序主节点</u></li></ul></li><li><p><u>节点管理器NodeManager</u>是一个基于机器的框架，负责管理容器、监视资源使用情况并向资源管理器报告。 集群中的每台计算机都是一个节点管理器和一个数据节点。 </p><ul><li>以容器的形式提供计算资源</li><li>管理容器内运行的进程</li><li>负责监视资源（容器）。 它没有固定数量的Map和Reduce插槽，但是可以动态创建和管理<u>资源容器</u>。 它就像Hadoop 1中JobTracker的通用版本。</li></ul></li><li><p><u>ApplicationMaster的任务是与资源管理器协商资源，并与各个节点管理器一起执行和监视任务。</p><ul><li>协调执行程序的内所有任务</li><li>请求合适的资源容器来执行任务</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1cz80dvaj30zk0hq118.jpg" alt="截屏2020-03-21上午2.51.28"></p><blockquote><p>ApplicationMaster负责单个应用程序的执行。它从资源调度程序（资源管理器）中请求容器，并在获得的容器上执行特定的程序（例如，Java类的主程序）。 Application Master知道程序逻辑，因此每个框架都需要自己编写ApplicationMaster。 MapReduce框架提供了自己的应用ApplicationMaster。</p><p>应用程序管理器ApplicationManager负责维护已提交的应用程序列表。在客户端提交应用程序后，应用程序管理器首先验证是否满足其ApplicationMaster的资源需求。如果有足够的资源，则将程序转发给调度器，否则将拒绝。还要确保没有其他具有相同应用程序ID的应用程序提交。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5f0alzhqj30ni0b2dgh.jpg" alt="image"></p><h4 id="提交应用到YARN中"><a href="#提交应用到YARN中" class="headerlink" title="提交应用到YARN中"></a>提交应用到YARN中</h4><ol><li>客户端将需要执行的程序发送给<u>资源管理器ResourceManager</u>（如MapReduce）</li><li>资源管理器，在容器内启动一个<u>程序管理器ApplicationMaster</u>，并将要执行的程序发送过去</li><li><u>程序管理器</u>与<u>资源管理器</u>协商资源。<ul><li>它负责应用程序的整个生命周期。</li><li>资源请求只是请求分配多个容器，表示为magabytes和CPU份额（当前）。</li></ul></li><li>然后，<u>ApplicationMaster</u>与<u>节点管理器</u>联系，以在容器中启动任务<ul><li>它监视这些任务的进度，重启失败的任务，推测性地运行速度较慢的任务，并计算应用程序计数器的总值。</li><li>它的整个生命周期用于与容器协商，来启动完成程序所需的所有任务</li></ul></li><li><u>资源管理器</u>不会监视程序中的任务——但它会检查<u>ApplicationMaster</u>的运行状况<ul><li>如果<u>ApplicationMaster</u>失败，则<u>资源管理器</u>可以在新容器中重新启动它。</li><li><u>资源管理器</u>负责<u>ApplicationMaster</u>，而<u>ApplicationMaster</u>负责<u>任务</u></li></ul></li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5fujv1klj317o0r6arg.jpg" alt="截屏2020-03-24下午3.31.42" style="zoom:50%;" /></p><h4 id="YARN可以运行任何分布式程序"><a href="#YARN可以运行任何分布式程序" class="headerlink" title="YARN可以运行任何分布式程序"></a>YARN可以运行任何分布式程序</h4><p>ResourceManager，NodeManager和Container不关心它们要运行的任务或应用程序的类型。只要实现了适当的ApplicationMaster，任何应用程序都可以运行。</p><p>好处：</p><ul><li>更高的集群利用率（一个框架不使用的资源可以被另一个框架使用）</li><li>更低的运营成本（仅需要管理和调整一种类型的集群）</li><li>数据移动减少（无需在YARN和其他系统之间移动数据）</li></ul><p>管理单个群集，还能够减少数据中心空间的使用，从而降低的运营成本，功耗，发热等。</p><h4 id="YARN的其他特征"><a href="#YARN的其他特征" class="headerlink" title="YARN的其他特征"></a>YARN的其他特征</h4><ul><li>如果作业足够小，则可以直接在ApplicationMaster的容器中运行MapReduce作业的所有任务。 这避免了从ResourceManager请求容器并要求NodeManager启动（据说很小）任务的开销。（见上图）</li><li>YARN提供简化的用户日志管理和访问。 与旧的Hadoop 1 MapReduce不同，日志不会保留在单个从节点上，而是移至中央存储（例如HDFS）。 后续可用于调试，性能分析等。</li><li>在重启资源管理器后恢复程序(YARN-128)——使资源管理器可以重建应用程序的状态，并仅重新运行未完成的任务。</li><li>高可用性的资源管理器体系结构（YARN-149）——发送故障后，支持资源管理器从一个实例到另一个实例（可能在另一台计算机上）。 它涉及领导者竞选，权限转移，客户端重定向。</li></ul><h4 id="Hadoop-2总结"><a href="#Hadoop-2总结" class="headerlink" title="Hadoop 2总结"></a>Hadoop 2总结</h4><p>HDFS2——高可用性和用于水平扩展的联合主节点</p><p>YARN——超越了Hadoop 1的批处理，并提高了效率</p><p>工具和程序的完整生态系统</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1dm0m0pfj30wy0be0wi.jpg" alt="截屏2020-03-21上午3.13.22"></p><h4 id="Hadoop不平衡集群"><a href="#Hadoop不平衡集群" class="headerlink" title="Hadoop不平衡集群"></a>Hadoop不平衡集群</h4><p>问题：</p><ul><li>将新服务器和机架添加到Hadoop群集可能会导致其变得不平衡。 现有数据保留在原处，新服务器处于空闲状态。</li><li>如果现有节点繁忙，则<u>工作追踪器JobTracker</u>可能不得不将Map任务分配给新服务器。</li><li>如果发生这种情况，新服务器将需要通过网络复制对应的数据块。 这导致更多的网络流量和较慢的作业完成时间。</li></ul><p>解决：为了解决不平衡的情况，Hadoop包含一个称为平衡器的实用程序。</p><ul><li>它检查节点之间的可用空间的差异，并尝试平衡到阈值。</li><li>当检测到具有大量磁盘空间的节点时，数据块将从空间较小的节点复制过去。 </li><li>平衡器是手动运行的，并在管理员关闭其终端时停止。 </li><li>平衡器的默认设置为1MB / s网络流量，可更改。</li></ul><p>理想情况下，平衡器应在所有群集上定期运行以进行良好管理。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop1 </tag>
            
            <tag> Hadoop2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bloom filters 布隆过滤器</title>
      <link href="/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20Bloom%20filters%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20Bloom%20filters%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>布隆过滤器</strong>（英語：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><a id="more"></a><p>will trigger: false positive —- possibly in the set</p><p>will no trigger: false negative —- definitely not in the set</p><h4 id="demo-amp-介绍"><a href="#demo-amp-介绍" class="headerlink" title="demo &amp; 介绍"></a>demo &amp; 介绍</h4><p><a href="https://llimllib.github.io/bloomfilter-tutorial/" target="_blank" rel="noopener">https://llimllib.github.io/bloomfilter-tutorial/</a></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>布隆过滤器</strong>（英語：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。<a href="https://zh.wikipedia.org/wiki/链表" target="_blank" rel="noopener">链表</a>、<a href="https://zh.wikipedia.org/wiki/树_(数据结构" target="_blank" rel="noopener">树</a>)、<a href="https://zh.wikipedia.org/wiki/散列表" target="_blank" rel="noopener">散列表</a>（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/db50673c67c6e72b7342ca1383def18cdead21b6" alt="{\displaystyle O(https://wikimedia.org/api/rest_v1/media/math/render/svg/db50673c67c6e72b7342ca1383def18cdead21b6),O(\log n),O(1)}">。</p><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个<a href="https://zh.wikipedia.org/wiki/散列函数" target="_blank" rel="noopener">散列函数</a>将这个元素映射成一个位<a href="https://zh.wikipedia.org/wiki/数组" target="_blank" rel="noopener">数组</a>中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ec39041121b14e8c2b1a986c9b04547b223e3c" alt="O(https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ec39041121b14e8c2b1a986c9b04547b223e3c)">。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p><p>布隆过滤器可以表示全集，其它任何数据结构都不能；</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" alt="k">和<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0a07d98bb302f3856cbabc47b2b9016692e3f7bc" alt="m">相同，使用同一组散列函数的两个布隆过滤器的交并<a href="https://zh.wikipedia.org/wiki/Wikipedia:列明来源" target="_blank" rel="noopener">[來源請求]</a>运算可以使用位操作进行。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率false positive随之增加。但是如果元素数量太少，则使用散列表足矣。</p><p>另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><p>在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p><p>optimal number of hash functions $k=\frac{m}{n}ln2,k=-\frac{lnp}{ln2}$</p><p>估计要添加的元素数量</p><p>bollm过滤器的大小</p><p>计算最佳的哈希函数数量</p><p>计算false positive的可能性</p><p>trade-off</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布隆过滤器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN图像分类</title>
      <link href="/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/CNN%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
      <url>/2020/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/CNN%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>实验步骤和分析</p><a id="more"></a><h3 id="Clarification"><a href="#Clarification" class="headerlink" title="Clarification"></a>Clarification</h3><ul><li><p>This coursework is running and testing on Google Colab. </p></li><li><p>Because the test set is extracted randomly from the dataset, the accuracy on the test set cannot precisely represent the performance of model. But it is still a reasonable approach for evaluating the performance of model.</p></li><li><p>The evaluation on the test set is using the model at final epoch in task 1-3 using the model with lowest loss on validation set in task 4.</p></li></ul><h3 id="Task-1-Experiments"><a href="#Task-1-Experiments" class="headerlink" title="Task 1: Experiments"></a><strong>Task 1: Experiments</strong></h3><h4 id="Subtask-1-1-How-does-the-number-of-layers-affect-the-training-process-and-test-performance-Try-between-2-and-5-layers"><a href="#Subtask-1-1-How-does-the-number-of-layers-affect-the-training-process-and-test-performance-Try-between-2-and-5-layers" class="headerlink" title="Subtask 1-1: How does the number of layers affect the training process and test performance? Try between 2 and 5 layers."></a><strong>Subtask 1-1: How does the number of layers affect the training process and test performance? Try between 2 and 5 layers.</strong></h4><p>Firstly, to clarify the architecture of 4 CNNs for the experiments, I assume the layer 4 and 5 are following the pattern of given layer 1-3 —— the output channels of each layer are added by 8 from its input channels. The parameters of each layer are listed in table 1. Each convolutional layer is followed by the same ReLU, max-pooling and dropout (see table 2). After the last convolutional layer, there are 2 fully connected layers (see table 3). Other relevant parameters are shown in table 4.</p><p>In short, the control variable is only the number of layers and its parameters, everything else, even the increasing pattern of the layer’s parameters, keep the same as possible.</p><p>Table 1: Parameters of each convolutional layer.</p><div class="table-container"><table><thead><tr><th>Layer 1</th><th>Input channels = 3, output channels = 16,  kernel size = 3</th></tr></thead><tbody><tr><td>Layer 2</td><td>Input channels = 16, output channels = 24,  kernel size = 4</td></tr><tr><td>Layer 3</td><td>Input channels = 24, output channels = 32,  kernel size = 4</td></tr><tr><td>Layer 4</td><td>Input channels = 32, output channels = 40,  kernel size = 4</td></tr><tr><td>Layer 5</td><td>Input channels = 40, output channels = 48, kernel  size = 4</td></tr></tbody></table></div><p>Table 2: Functional layers followed by each layer, and relevant parameters.</p><div class="table-container"><table><thead><tr><th>ReLU</th><th></th></tr></thead><tbody><tr><td>Max-pooling</td><td>Kernel size = 2</td></tr><tr><td>Dropout</td><td>Rate = 0.3</td></tr></tbody></table></div><p>Table 3: Fully connected layer, and relevant parameters.</p><div class="table-container"><table><thead><tr><th>Fully connected layer 1</th><th>Input = (flattened output of last  convolutional layer), output = 512</th></tr></thead><tbody><tr><td>Fully connected layer 2</td><td>Input = 512, output = 10</td></tr></tbody></table></div><p>Table 4: Other relevant parameters and methods.</p><div class="table-container"><table><thead><tr><th>Other relevant parameters and methods.</th></tr></thead><tbody><tr><td>Learning  rate = 0.001, Batch size = 16, momentum=0.9  Optimizer = SGD, Loss function = CrossEntropyLoss</td></tr></tbody></table></div><p>In the subtask 1-1, table 5 compares the accuracy of CNNs with a different number of maximal layers, visualizing their confusion matrixes and Loss curves. For each CNNs, the training will stop when the model converges (pre-train the model to find out the most suitable training epochs —— the point when loss curve start increasing, which means overfitting and losing generalization on unseen data). For example, 2-layer CNN will converge at 4th epoch and achieve 49.89% accuracy on the test set, and 5-layer CNN can achieve 63.17% of accuracy on the test set, and this 5-layer CNN will converge at 40th epoch.</p><p>Table 5. Range of accuracy on the test set, after 3 times execution for each architectures (different number of maximal layers).</p><div class="table-container"><table><thead><tr><th>Maximal  layer</th><th>The highest  accuracy (%)</th><th>The lowest  accuracy (%)</th><th>Number of  Epochs when converge</th></tr></thead><tbody><tr><td>Layer 2</td><td>49.89</td><td>45.06</td><td>4</td></tr><tr><td>Layer 3</td><td>53.22</td><td>53.11</td><td>10</td></tr><tr><td>Layer 4</td><td>57.17</td><td>55.94</td><td>15</td></tr><tr><td>Layer 5</td><td>63.17</td><td>59.00</td><td>40</td></tr></tbody></table></div><p>Convolution layer is used to abstract feature and simplify the complexity of the network. A different number of filters and layers can have different performance. The results shown in table 5 indicate that with the increment of layers mentioned above, the accuracy of the model on the test set also increased. It is reasonable in this case because more layer will output more feature map to represent the original image and for classifying</p><p>In figure 1, we can have a clearer understanding of how the models with different layer perform when predicting the class on the test set. On confusion matrix (a) (b) (c) (d), the percentages of a misclassified image are decreasing when the CNN go deeper (seeing the light cells excluding diagonal getting dark from (a) to (b)). The loss curves (e) (f) (g) (h) in which the lines tend to be flat are used to detect converge.</p><p>The best performance is given by 5-layer CNN, achieving 63.17% accuracy on the test set at 40th epochs. The parameters are listed in Table 1-5. This 5-layer CNN will be used in task 2 &amp; 3, called CNN-5L.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduxi6uxvsj31320ioe5h.jpg" alt="截屏2020-04-15 下午5.43.01"></p><p>Figure 1. Confusion matrix and loss curves of CNNs at 1st execution —— (a) (e) 2-layer, (b) (f) 3-layer, (c) (g) 4-layer, (d) (h) 5-layer</p><h4 id="Subtask-2-Choose-one-more-architectural-element-to-test"><a href="#Subtask-2-Choose-one-more-architectural-element-to-test" class="headerlink" title="Subtask 2: Choose one more architectural element to test"></a><strong>Subtask 2: Choose one more architectural element to test</strong></h4><p>In subtask2, the report will test with 3 different elements. The first experiment is to test the performance of different batch size in 3-layer CNN. The second experiment is to increase the number of fully connected layers in 5-layer CNN. The third experiment is to increase the parameters for each convolutional layer.</p><ol><li><p>The first experiment is based on 3-layer convolutional neural, keeping other parameters same as mentioned above, and train the model with different batch size (see table 6). The model will be pre-trained to find out the number of epoch to converge before the evaluation of accuracy on the test set.</p><p>Intuitively, a larger batch size means the number of iterations required to run an epoch is reduced and therefore speed up the processing. If the batch size is within an ideal range, a larger the batch size will take more points into account, and therefore can make the gradient direction more accurate with less fluctuation. However, based on the result, to achieve similar accuracy, it needs more epochs to run.</p></li></ol><p>Table 6 Comparison of accuracy and converge epochs for different batch size</p><div class="table-container"><table><thead><tr><th>Batch size</th><th>Converge epochs</th><th>Accuracy</th></tr></thead><tbody><tr><td>8</td><td>7</td><td>49.44</td></tr><tr><td>16</td><td>10</td><td>53.22</td></tr><tr><td>32</td><td>13</td><td>51.28</td></tr></tbody></table></div><p>Figure 2: Confusion matrixes of 8 batches CNN (a), 16 batches CNN (b) and 32 batches CNN (c).</p><ol><li>The result of 5-layer architecture seems good. In this experiment, based on the previous 5-layer network, a new CNN with one more fully connected layer with the same 512 input and output channels is tested (see table 7.).  The accuracy of this model on the test set is 59.22% for the first time and 59.59% for the second time. It seems that the performance does not have much difference comparing with CNN-5L (the original 5-layer CNN).</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduxixih8lj311m0d6qoo.jpg" alt="截屏2020-04-15 下午5.43.29"></p><p>Table 7. Parameters of 3 fully connected layers</p><div class="table-container"><table><thead><tr><th>Fully connected layer 1</th><th>Input = (flattened output of last  convolutional layer), output = 512</th></tr></thead><tbody><tr><td>Fully connected layer 2</td><td>Input = 512, output = 512</td></tr><tr><td>Fully connected layer 3</td><td>Input = 512, output = 10</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy0gqk30j30um0ec49z.jpg" alt="截屏2020-04-15 下午6.00.33"></p><p>Figure 3. Confusion matrix (a) and loss curve (b) in experiment 2 (with 59.22% ACC on the test set).</p><ol><li>The third experiment is to increase the parameters for each convolutional layer —— multiply by 4 (see table 8). Larger channels values normally mean that the model can extract more features from an image. After pre-trained the CNN, the loss curve shows the model will converge at around 23rd epoch. Running 23rd epoch again, the model got 61.22% accuracy on the test set. It seems slightly better than the model in experiment 2 but still stays in the potential accuracy range of CNN-5L.</li></ol><p>Table 8. Parameters of each layer in the 5-layer CNN</p><div class="table-container"><table><thead><tr><th>Layer 1</th><th>Input channels = 3, output channels = 64,  kernel size = 3</th></tr></thead><tbody><tr><td>Layer 2</td><td>Input channels = 64, output channels = 96,  kernel size = 4</td></tr><tr><td>Layer 3</td><td>Input channels = 96, output channels = 128,  kernel size = 4</td></tr><tr><td>Layer 4</td><td>Input channels = 128, output channels = 160,  kernel size = 4</td></tr><tr><td>Layer 5</td><td>Input channels = 160, output channels = 196,  kernel size = 4</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy110xrwj30uw0e0n8i.jpg" alt="截屏2020-04-15 下午6.01.09"></p><p>Figure 4: Confusion matrix (a) and loss curve (b) in experiment 3.</p><h3 id="Task-2-Filter-visualization"><a href="#Task-2-Filter-visualization" class="headerlink" title="Task 2: Filter visualization"></a><strong>Task 2: Filter visualization</strong></h3><p>The filters before training are initialized randomly (see figure 5-a). During the training process, the filters will be updated by gradient descent and backpropagation. In figure 5, there are significant differences between the filters before training (5-a) and halfway training (5-b), which means the model change a lot during the process. However, comparing with the filters in halfway training and after training, there only slight differences, which means that the filters of the first layer of this specific model are close to the optimal values (but possibility local optimum instead of global optimum). This phenomenon can also be observed on loss and accuracy curve (see figure 6). It is clear that the differences between 0 and 20th epochs are significant but much smaller between 20th and 40th epochs (e.g. compare the gaps between 3 lines in figure 6-a).</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy1ia24zj311s0dw7jy.jpg" alt="截屏2020-04-15 下午6.01.39"></p><p>Figure 5: Filters before training (a), halfway training (b) and after training (c), outputting from Conv2d without ReLU.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy2hyckcj311y0euakn.jpg" alt="截屏2020-04-15 下午6.02.35"></p><p>Figure 6: Loss (a) and accuracy (b) curve in CNN-5L.</p><h3 id="Task-3-Feature-map-visualization"><a href="#Task-3-Feature-map-visualization" class="headerlink" title="Task 3: Feature map visualization"></a><strong>Task 3: Feature map visualization</strong></h3><p>The number of feature maps equals to that of output channels, each filter will extract a type of feature map. With the network goes deeper, feature maps will become smaller and blurrier, but also means being more representative than the previous layer. For example, figure 7 (a) is showing the image of a banana. It is obvious that the feature maps at 6th row are smaller and more abstractive than the 2nd row. Loot at the graffiti on the banana peel in the original image. The information of these graffiti which is unrelated for identifying and classifying is gradually removed from the feature maps as the network goes deeper.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy3hpsi1j30u00u6b29.jpg" alt="截屏2020-04-15 下午6.03.21"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy3qjgaoj313e0eejuh.jpg" alt="截屏2020-04-15 下午6.03.40"></p><p>Figure 7: Original and normalized image (1), feature maps after each CONV layer without ReLU (2-6), and feature map before fully connected layer (7), banana (a) and mug (b)</p><h3 id="Task-4-Improving-network-performance"><a href="#Task-4-Improving-network-performance" class="headerlink" title="Task 4: Improving network performance"></a><strong>Task 4: Improving network performance</strong></h3><p>In this task, inspired by AlexNet, this improved model (call CNN-task4) can achieve 69.11% accuracy on the test set. The relevant structure and parameters are listed below (see table 9). Noticed that the accuracy on the test set is evaluated by the model achieving the lowest loss on validation set during training (save the model at that epoch and reload it in evaluation).</p><p>Table 9: Structure and parameters of CNN-task4</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy4h8ikej31240pgaej.jpg" alt="截屏2020-04-15 下午6.04.27"></p><p>One of the adjustments is using another optimizer Adam, which support adaptive learning rate, updating the learning rate during learning. The reason behind is that adaptive learning rate will slow down the stride of gradient descent during the training. Giving a small stride can help reduce the possibility of missing and fluctuating around the (local or global) optimal solution. From figure 8, we can notice that CNN-task4 with 0.0001 initial learning rate can give a better loss curve than the others.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy4s62maj310c09swh3.jpg" alt="截屏2020-04-15 下午6.04.48"></p><p>Figure 8: Loss curve of original 5-layer CNN with 0.01 LR (a)，CNN-task4 with 0.001 initial LR (b)，CNN-task4 with 0.0001 initial LR (c)</p><p>Another adjustment is to move the dropout layer from convolution layers to fully connected layers. One reason is that the parameters in the convolution layer are quite few but highly relative. The pixels within a certain area of an image in convolutional layers are sharing the same information, which means that the discarded information may still be retained by nearby pixels. Using dropout layer in convolution layer may only help control the noise of the input images but not improving the generalization on unseen data (see figure 9 (d)). On the other hand, if the feature maps between 2 layers are highly abstracted when passing forward such as convolution operation with large kernel size or stride, or max-pooling operation, using dropout will, on the contrary, cause the feature maps to lose important information for classifying. And therefore, the performance of the model will decline, especially causing a significant decrease of accuracy on the test set and fluctuation of loss curve on the validation set (see figure 9 (c)).</p><p>Table 10 is comparing the accuracy on the test set of 4 different dropout layer placing strategies. The 2nd and 4th row are showing that adding dropout after convolution layer 3 &amp; 4, which have small kernel and stride, having similar performance. However, once the dropout layers are placed after max-pooling layer (see 3rd row). The accuracy of the model on the test set will decline from around 65% to 50%.</p><p>Table 10, Position of dropout layer (based on the CNN-task4 in table 9) and the highest accuracy on the test set after 30 epochs training</p><div class="table-container"><table><thead><tr><th>Dropout(0.5)  Before FC1&amp;2</th><th>69.11%</th><th>Figure 9 (a)</th></tr></thead><tbody><tr><td>No dropout</td><td>66.17%</td><td>Figure 9 (b)</td></tr><tr><td>Dropout(0.3)  after max-pooling layer 1&amp;2&amp;3</td><td>50.22%</td><td>Figure 9 (c)</td></tr><tr><td>Dropout(0.3)  after CONV 3&amp;4</td><td>64.94%</td><td>Figure 9 (d)</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gduy5ahtb9j311608o76i.jpg" alt="截屏2020-04-15 下午6.05.16"></p><p>Figure 9: Loss curve of CNN-task4, with dropout before FC1&amp;2 (original) (a), without dropout (b)，with 0.3 dropout after max-pooling (c)，with 0.3 dropout after CONV 3&amp;4 (d).</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像分类 </tag>
            
            <tag> CNN </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库和存储</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/10%20DATABASES%20AND%20STORAGE/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/10%20DATABASES%20AND%20STORAGE/</url>
      
        <content type="html"><![CDATA[<p>大数据系统需要存储大量的数据，并且需要花费大量的金钱对存储的数据进行获取和维护。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3phyt1uoj30tw0hgaf0.jpg" alt="截屏2020-03-23上午3.35.43"  /></p><a id="more"></a><h3 id="数据库的结构"><a href="#数据库的结构" class="headerlink" title="数据库的结构"></a>数据库的结构</h3><p>以下类型的数据可以被归类为：关系型数据库，或非关系型数据库（后4种）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3pmrg1u5j30r20fwn8e.jpg" alt="截屏2020-03-23上午3.40.17"></p><p><img src="../../../Library/Application Support/typora-user-images/截屏2020-03-23上午3.42.55.png" alt="截屏2020-03-23上午3.42.55"></p><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>关键特征：</p><ul><li><p>Edgar Codd’s 12 rules <a href="https://baike.baidu.com/item/%E7%A7%91%E5%BE%B7%E5%8D%81%E4%BA%8C%E5%AE%9A%E5%BE%8B/10138377?fr=aladdin" target="_blank" rel="noopener">科德十二定律</a></p></li><li><p>使用<u>表</u>储存<u>结构化数据</u></p></li><li><p>支持ACID事务的一致性</p><blockquote><p>Atomic 原子性：事务中的所有操作全部成功或者全部回滚</p><p>Consistent 一致性：事务不能让数据库处于不一致的状态</p><p>Isolated 隔离性：事务之间不能相互影响</p><p>Durable 耐用性：对完成的事务进行持久化，即使服务器重启</p></blockquote></li><li><p>通常使用SQL进行查询</p></li><li><p>通过主键和外键管理关系</p></li><li><p>使用SQL和关系来执行<u>关联joins</u></p><blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3pu209rij30xc0owjyl.jpg" alt="截屏2020-03-23上午3.47.23" style="zoom:50%;" /></p></blockquote></li></ul><h3 id="大数据系统中数据库的挑战"><a href="#大数据系统中数据库的挑战" class="headerlink" title="大数据系统中数据库的挑战"></a>大数据系统中数据库的挑战</h3><ul><li>大数据的规模，对数据库空间的要求是很大的挑战</li><li>传统的RDBMS无法扩展到真正”大数据“的级别</li><li>ACID原则不一定适用于大规模</li><li>CAP定理提出了一个问题</li></ul><h4 id="CAP定理："><a href="#CAP定理：" class="headerlink" title="CAP定理："></a>CAP定理：</h4><p>是Eric Brewer在1998年提出的一个假设，由Gilbert和Lynch在2002年证明。</p><p>它指出，分布式系统不可能同时确保<u>一致性</u>，<u>可用性</u>和<u>分区容错性</u>。</p><ul><li>一致性：所有客户都能看到最新的数据，不管执行过什么操作（比如更新或删除）</li><li>可用性：即使某些节点发送错误，系统也需要继续客户的操作</li><li>分区容错：即使网络或消息发送错误，系统也需要继续执行可续操作（比如一个节点向另一个节点发送的消息，允许发送错误并被丢弃）</li></ul><h4 id="ACID-和-BASE"><a href="#ACID-和-BASE" class="headerlink" title="ACID 和 BASE"></a>ACID 和 BASE</h4><p>ACID：</p><ul><li>Atomic 原子性：事务的所有操作都成功，不然就回滚</li><li>Consistent 一致性：事务不能使数据库的最终状态出现不一致</li><li>Isolated 隔离性：事务使独立的，不能影响其他事务</li><li>Durable 耐用性：即使服务器重新启动等，已完成的事务也会保留。</li></ul><p>BASE</p><ul><li><strong>B</strong>asic <strong>A</strong>vailability 基础可用性：系统在CAP定理方面，保证系统的可用性</li><li><strong>S</strong>oft-state 软状态：系统的状态会随时间改变，即使没有输入（因为要确保最终一致性）</li><li><strong>E</strong>ventual consistency 最终一致性：只要数据库最终变得一致，在每个事务之后就不需要一致性。</li></ul><h3 id="NoSQL-——-Not-only-SQL"><a href="#NoSQL-——-Not-only-SQL" class="headerlink" title="NoSQL —— Not only SQL"></a>NoSQL —— Not only SQL</h3><p><strong>严格的一致性</strong>会在大规模的系统中带来巨大的性能和能源开销。</p><p>妥协方案是<strong>最终一致性</strong>：给定足够长的时间不发送任何更改，可以期望所有更新都将通过系统进行传播，且所有副本都将最终保持一致。</p><p>NoSQL数据库比传统的数据库采用<u>更宽松的一致性模型</u>，它是非关系的数据库，没有固定的schema，也没有joins。NoSQL描述为克服RDBMS的可扩展性限制而开发的许多非关系数据库。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3qpwtjf1j310m0l2tsl.jpg" alt="截屏2020-03-23上午4.18.00" style="zoom:33%;" /></p><h4 id="NoSQL的好处"><a href="#NoSQL的好处" class="headerlink" title="NoSQL的好处"></a>NoSQL的好处</h4><ul><li>适合处理大量的数据</li><li>NoSQL数据库针对<u>检索</u>和<u>添加</u>操作进行了高度优化，并且通常除了记录存储之外几乎没有其他功能（尽管有时它们确实可以有）</li><li>当实时性能比一致性更重要时，可以采用NoSQL</li><li>例子：对大量文档进行索引、在高流量网站上提供页面、传递流媒体</li></ul><h4 id="NoSQL的种类"><a href="#NoSQL的种类" class="headerlink" title="NoSQL的种类"></a>NoSQL的种类</h4><p>键值对存储、面向列的数据库、文档型数据库、图数据库</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3qxs5kfej30r20fwgnj.jpg" alt="截屏2020-03-23上午3.40.17"></p><h4 id="类型1：键值对存储"><a href="#类型1：键值对存储" class="headerlink" title="类型1：键值对存储"></a>类型1：键值对存储</h4><ul><li>是最简单的NoSQL类型，且易于实现，比如MapReduce。</li><li>它允许数据以<u>无shcema</u>和<u>无固定数据模型</u>的方式存储。</li><li>Key可以用简单的值表示。</li><li>当它仅用于查询或对部分数据进行更新时，效率很低</li></ul><div class="table-container"><table><thead><tr><th>例子</th><th>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</th></tr></thead><tbody><tr><td>经典的应用</td><td>内容缓存（专注于向大量的数据进行扩展，为处理大量负载而设计），日志等</td></tr><tr><td>数据模型</td><td>一系列的键值对</td></tr><tr><td>优点</td><td>快速查询</td></tr><tr><td>缺点</td><td>存储的数据没有schema</td></tr><tr><td>适合</td><td>存储会话session信息、用户资料、偏好、购物车信息</td></tr><tr><td>不适合</td><td>查询信息、存储的数据之间有关系、同时操作多个Key</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3r8esu5ej310k0hy0zc.jpg" alt="截屏2020-03-23上午4.35.48" style="zoom:33%;" /></p><h4 id="面向列的数据库"><a href="#面向列的数据库" class="headerlink" title="面向列的数据库"></a>面向列的数据库</h4><p>数据库的常用查询需要对数据集进行聚合处理，以面向列的方式存储数据，能使需要对大规模数据进行聚合的查询更高效</p><p>面向列的数据库还可以处理非常大的数据，因为数据是按列组织的，并且可以轻松分区（称为分片）。在这种情况下，列会按列族（也称为组）进行组织，以将相关列保持在一起（如用于客户地址的列组等）</p><div class="table-container"><table><thead><tr><th>例子</th><th>Cassandra, HBase, Riak</th></tr></thead><tbody><tr><td>经典的应用</td><td>分布式文件系统</td></tr><tr><td>数据模型</td><td>列 -&gt; 族</td></tr><tr><td>优点</td><td>快速查询、分布式的数据存储</td></tr><tr><td>缺点</td><td>低级别的接口</td></tr><tr><td>适合</td><td>内容管理系统、博客平台、大量写入（日志聚合）、maintaining counters、expiring usage</td></tr><tr><td>不适合</td><td>早期开发、变化的查询模式</td></tr></tbody></table></div><h4 id="面向文档的数据库"><a href="#面向文档的数据库" class="headerlink" title="面向文档的数据库"></a>面向文档的数据库</h4><ul><li>面向文档的数据库类似于键值存储，不同之处在于，值指向标准格式/编码的文档（入XML，JSON等）</li><li>文档数据库将这些文档理解为字段的集合，除了通过键进行检索之外，还可以直接进行查询和更新。</li><li>文档数据库实质上是键值存储的下一个级别，允许与每个键与嵌套的值关联。 它们支持更有效的查询。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3sg7kp29j30ku0gymzg.jpg" alt="截屏2020-03-23上午5.17.51" style="zoom:25%;" /></p><div class="table-container"><table><thead><tr><th>例子</th><th>CouchDB, MongoDb</th></tr></thead><tbody><tr><td>经典的应用</td><td>网络应用</td></tr><tr><td>数据模型</td><td>列 -&gt; 族</td></tr><tr><td>优点</td><td>快速查询、分布式的数据存储</td></tr><tr><td>缺点</td><td>查询性能、没有标准的查询语法</td></tr><tr><td>适合</td><td>内容管理系统、博客平台、网络分析、实时分析、电商应用</td></tr><tr><td>不适合</td><td>跨多个业务的复杂事务、针对不同聚合结构的查询</td></tr></tbody></table></div><h4 id="图-树结构数据库"><a href="#图-树结构数据库" class="headerlink" title="图/树结构数据库"></a>图/树结构数据库</h4><p>图数据库使用灵活的图模型，代替行列式表和硬性结构（如SQL），它可以跨多台计算机进行扩展。目标是性能和灵活性。</p><p>图包括<u>节点</u>和<u>关系</u>两个元素，每个<u>节点</u>代表一个 实体（如人、地点等），每个<u>关系</u>代表两个节点之间的联系。Twitter是图数据库的例子之一</p><ul><li>图的存储：有些图数据库使用，专门为存储和管理图而设计的，自带存储方式，；其他的则使用<u>关系数据库</u>或<u>对象数据库</u></li><li>图的处理引擎：本地图处理（也称为“无索引邻接”）是处理图数据的最有效方法，因为连接的节点在数据库中彼此物理“指向”。非本机图处理使用其他方式来处理CRUD操作。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3sqmtdb2j30ku0f40ze.jpg" alt="截屏2020-03-23上午5.27.55" style="zoom:50%;" /></p><p>性能：</p><ul><li>数据之间的连接（关系）数量比数据量增长得更快。</li><li>随着关系的数量和深度的增加，传统的数据库将变得混乱。 图数据库的性能可以更好地解决这一问题。</li></ul><p>灵活性：</p><ul><li>图的结构和方案可以随着解决方案/行业的变化而灵活变化。</li><li>无需对域进行详尽的建模。 可以在现有结构上进行添加，而不必担心当前的功能。</li></ul><div class="table-container"><table><thead><tr><th>例子</th><th>Neo4J, InfoGrid, Infinite Graph</th></tr></thead><tbody><tr><td>经典的应用</td><td>社交网络、推荐系统（专注于对数据结构建模 - 内部联系性）</td></tr><tr><td>数据模型</td><td>属性图 - 节点</td></tr><tr><td>优点</td><td>图算法：如最短路径、连通性、n度关系等</td></tr><tr><td>缺点</td><td>必须遍历整个图形才能获得确定的答案。不容易集群。</td></tr><tr><td>适合</td><td>关联数据的问题空间：社交网络、空间数据、货物和金钱的路由信息（物流）、推荐引擎</td></tr></tbody></table></div><h4 id="更多NoSQL的例子"><a href="#更多NoSQL的例子" class="headerlink" title="更多NoSQL的例子"></a>更多NoSQL的例子</h4><p>外部数据集成：</p><ul><li>许多公司需要集成来自业务合作伙伴的数据。 即使双方进行了大量的讨论和谈判，企业也几乎无法控制数据格式</li></ul><ul><li>同样，在许多情况下，由于业务需求等的变化，这些格式会非常频繁地更改。</li></ul><p>前端订单处理系统：</p><ul><li>每当最终用户从世界任何地方进行交易时，系统都需要不被中断的接受请求。</li><li>之后，协调系统通常会将其更新到后端系统，并更新最终用户的订单状态。</li></ul><p>企业内容管理服务：</p><ul><li>现在，内容管理已在公司的不同职能部门（例如HR或Sales）中使用。</li><li>挑战是，将使用不同元数据结构的部门，一起合并到公共内容管理服务中</li></ul><h4 id="NoSQL-VS-RDBMS"><a href="#NoSQL-VS-RDBMS" class="headerlink" title="NoSQL VS RDBMS"></a>NoSQL VS RDBMS</h4><p>NoSQL：</p><ul><li>存储应该能够处理非常高的负载，能够在存储上执行许多写操作</li><li>支持水平可扩展的存储</li><li>简单，因为使用非常简单的查询语言（无联接）</li></ul><p>RDBMS：</p><ul><li>存储应该是高负载的，但主要由读取操作组成</li><li>希望在复杂的数据结构中得到性能</li><li>需要强大的SQL查询语言</li></ul><p>NewSQL</p><ul><li>使用SQL查询（虽然不完全支持）</li><li>关系型</li><li>保持ACID事务的一致性</li><li>像NoSQL一样扩展</li></ul><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><blockquote><p>RDBMS —— Relational Database Management System —— 关系型数据库管理系统<br>column families —— 族</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非关系型数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> ACID </tag>
            
            <tag> BASE </tag>
            
            <tag> CAP定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云(1)</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/08%20CLOUD%20%E2%80%93%20PART%201/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/08%20CLOUD%20%E2%80%93%20PART%201/</url>
      
        <content type="html"><![CDATA[<p>实用计算：使<u>计算资源</u>像水电这样按表计量的服务一样按需使用；按需动态提供资源的能力</p><p>云计算：是一种模型，用于支持对可配置计算资源（例如，网络，服务器，存储，应用程序和服务）共享池的普遍，方便，按需的网络访问，这些资源可通过最少的管理工作或与服务提供商的交互，快速地进行配置和发布。（美国国家标准技术研究院（NIST））</p><a id="more"></a><h4 id="数据的类型"><a href="#数据的类型" class="headerlink" title="数据的类型"></a>数据的类型</h4><p>关系型数据（表、事务）、文本数据、半结构化数据（XML）、图类数据（社交网络）、流数据（只能被扫描一次）</p><h4 id="数据与生俱来的特点"><a href="#数据与生俱来的特点" class="headerlink" title="数据与生俱来的特点"></a>数据与生俱来的特点</h4><p>复杂、大量、半结构化</p><h4 id="大数据与云计算的关联"><a href="#大数据与云计算的关联" class="headerlink" title="大数据与云计算的关联"></a>大数据与云计算的关联</h4><ol><li>数据可视化</li><li>实时数据流、实时处理</li><li>实时的结构化数据库、交互式分析、批量处理</li><li>结构化和非结构化数据（HDFS、S3）</li><li>云基础设施</li><li>存储、网络、计算资源</li></ol><h4 id="例子：百事可乐和阿里巴巴"><a href="#例子：百事可乐和阿里巴巴" class="headerlink" title="例子：百事可乐和阿里巴巴"></a>例子：百事可乐和阿里巴巴</h4><p>百事可乐公司与阿里巴巴达成战略协议，以利用后者的数据来增强其客户体验并推动其在中国的发展。这是阿里巴巴达成的第二笔此类交易，允许公司利用其数据和见解为客户提供更好的服务。阿里巴巴是中国最大的电子商务平台。公司可以使用这些数据更好地了解消费者的偏好，并相应地修改其产品。 除了为外国企业提供进入中国市场的电子商务平台外，阿里巴巴现在还希望成为数据和见解提供。通过利用阿里巴巴客户数据产生的见解，百事可乐可以从事产品开发、创新和品牌建设，从而带动中国的增长。 据阿里巴巴称，此次合作“引领了中国食品饮料行业不断发展的数字化转型”（2017.05.16 Forbe）</p><h4 id="实用计算-Utility-Computing"><a href="#实用计算-Utility-Computing" class="headerlink" title="实用计算 Utility Computing"></a>实用计算 Utility Computing</h4><p>“到目前为止，计算机网络仍处于起步阶段，但是随着它们的成长和日趋成熟，我们可能会看到<u>计算机设施 computer utilities</u>的普及，像现在的电力和电话这类实用设施一样，它将为整个国家的家庭和办公室提供服务”（1969 – Leonard Kleinrock, ARPANET project）</p><p>什么是实用计算：使<u>计算资源</u>像水电这样按表计量的服务一样按需使用；按需动态提供资源的能力</p><p>为什么：成本（购买设备 VS 操作付费），可扩展性，弹性（按需扩展或收缩）</p><h4 id="云计算的定义"><a href="#云计算的定义" class="headerlink" title="云计算的定义"></a>云计算的定义</h4><p>个人设备可以通过网络获得各种各样的计算服务（不需要安装在本地）</p><p>云计算是一种模型，用于支持对可配置计算资源（例如，网络，服务器，存储，应用程序和服务）共享池的普遍，方便，按需的网络访问，这些资源可通过最少的管理工作或与服务提供商的交互，快速地进行配置和发布。（美国国家标准技术研究院（NIST））</p><p>主要特征： 1. 按需的自助服务 2. 广泛的网络访问 3. 资源池 4. 快速的弹性变化或扩展 5. 测量服务</p><p>三种服务模型：1. 软件 2. 平台 3. 基础设施</p><p>四种部署模型：1. 私有 2. 社区 3. 公开 4. 混合</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>成本和管理（经济的扩展方式，将资源管理外包）</li><li>减少部署时间（大部分工作由服务提供商完成）</li><li>可扩展性（按需使用，按需付费）</li><li>可靠性（大量的、冗余的、共享的资源）</li><li>可持续性（不需要自己购买设备）</li></ul><h4 id="虚拟化的基础设施"><a href="#虚拟化的基础设施" class="headerlink" title="虚拟化的基础设施"></a>虚拟化的基础设施</h4><p>整合服务器系统、降低成本、降低复杂性、简化管理、按使用付费</p><p>是一个新兴的计算范例，数据和服务位于大规模的数据中心，并且可以被任何联网设备访问</p><h4 id="云"><a href="#云" class="headerlink" title="云"></a>云</h4><p>当今互联网应用的历史根源：搜索、Email、社交网络、文件存储（Dropbox等）</p><p>Cloud infrastructure提供了一个框架，管理对应用程序的可扩展的、可靠的、按需的访问</p><p>对于终端的移动应用来说，云是不可见的</p><h4 id="云数据中心"><a href="#云数据中心" class="headerlink" title="云数据中心"></a>云数据中心</h4><p>10-100k的主机，通常紧密靠近以及紧密耦合。比如亚马逊的电商，YouTube、Apple、微软的内容服务器，Google的搜索引擎、数据挖掘</p><p>挑战：多应用，每个应用都要服务于大量的客户端；管理/负载平衡、处理、网络、数据管理（动态负载平衡）</p><h4 id="云结构的分层"><a href="#云结构的分层" class="headerlink" title="云结构的分层"></a>云结构的分层</h4><div class="table-container"><table><thead><tr><th>用户层、服务层、虚拟化层、物理层</th><th>用户级、用户级的中间件、核心中间件、系统级</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3eoih37ij312a0k87a2.jpg" alt="截屏2020-03-22下午9.21.28" style="zoom:33%;" /></td><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3enjxli1j31160nan5m.jpg" alt="截屏2020-03-22下午9.20.34" style="zoom: 33%;" /></td></tr></tbody></table></div><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>cloud infrastructure —— 云基础设施</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云(2)</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/09%20CLOUD%20PART%202/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/09%20CLOUD%20PART%202/</url>
      
        <content type="html"><![CDATA[<p>云数据中心——物理层（系统级）：存储、网络</p><p>虚拟机——虚拟化层（核心中间件）：Hypervisor、Infrastructure</p><p>编程模型 —— 结构层（用户级中间件）：MapReduce、Hadoop</p><a id="more"></a><h3 id="云计算的好处"><a href="#云计算的好处" class="headerlink" title="云计算的好处"></a>云计算的好处</h3><ol><li>用户似乎可以按需使用无限的计算资源，从而消除了云用户为资源调配而提前计划的需求</li><li>消除了云用户的前期投入，公司可以从小做起，并在将来需要时再增加硬件资源。</li><li>根据需要，在短期内购买计算资源，并在完成后释放它们，从而可以节约资源和成本（例如，按小时计算的处理器和按天存储的处理器，在服务使用的高峰期扩展服务器）。</li></ol><h3 id="云的三种服务模型"><a href="#云的三种服务模型" class="headerlink" title="云的三种服务模型"></a>云的三种服务模型</h3><p>服务可以在三层中的任何一层公开，较低的层对用户是透明的</p><ol><li>SaaS 软件即服务：是本地运行程序的代替方案，即远程运行程序。如Google Apps</li><li>PaaS 平台即服务：也是本地运行程序的代替方案。通过软件堆栈促进应用程序的部署。如微软Azure</li><li>IaaS 基础设施即服务：通过虚拟化，基础设施提供商可以拆分、分配和动态管理服务提供商，服务提供商将在这些系统上部署运行其服务的软件堆栈。 Amazon EC2</li></ol><div class="table-container"><table><thead><tr><th>服务模型</th><th>服务模型与典型软件结构</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3fespzsmj30gm0eedgi.jpg" alt="截屏2020-03-22下午9.46.47" style="zoom:33%;" /></td><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3gursrjoj30mq0k47ax.jpg" alt="截屏2020-03-22下午10.36.43" style="zoom:50%;" /></td></tr></tbody></table></div><h4 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h4><ul><li>通过互联网构建</li><li>任何为该服务付费的用户都可以访问</li><li>由服务提供商拥有</li><li>可通过订阅访问</li></ul><h4 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h4><ul><li>在单个组织拥有的Intranet域内构建</li><li>客户拥有和管理</li><li>访问仅限于拥有客户及其合作伙伴</li><li>可能影响云标准化，同时保留更大的自定义和组织控制权。</li></ul><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><ul><li>多个云协同工作，包括公共云和私有云</li><li>混合云可以由<u>联合的云提供商</u>交付，该供应商将其自身的资源与其他提供商的资源相结合</li></ul><h2 id="云数据中心——物理层（系统级）"><a href="#云数据中心——物理层（系统级）" class="headerlink" title="云数据中心——物理层（系统级）"></a>云数据中心——物理层（系统级）</h2><p>大规模：10万-100万的服务器，大约是足球场的11.5倍</p><p>小服务器集群：大约1000台服务器，通过 Ethernet switch 以太网交换机相连，放置在仓库或容器环境中</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>存储选项：</p><ul><li>使用服务器内部的磁盘，或通过无限带宽的网络附加存储（NAS）</li><li>WSCs 通常依赖于本地磁盘</li><li>Google文件系统（GFS）使用本地磁盘，并至少维护三个副本</li></ul><p>连接多个机架的交换机</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>包含：边界路由器，访问路由器、负载均衡器、一层交换机、二层交换机、架顶交换机、服务器机架</p><p>负载均衡器：应用层路由</p><ul><li>接收外部客户请求</li><li>在数据中心内分配工作负载</li><li>将结果返回给外部客户端（隐藏数据中心的内部细节）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3fssnn4hj30ya0m444x.jpg" alt="截屏2020-03-22下午10.00.01" style="zoom:50%;" /></p><h2 id="虚拟机——虚拟化层（核心中间件）"><a href="#虚拟机——虚拟化层（核心中间件）" class="headerlink" title="虚拟机——虚拟化层（核心中间件）"></a>虚拟机——虚拟化层（核心中间件）</h2><p>虚拟化层相当于底层硬件和虚拟机的中间件</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3gdgnmdpj31100hqq9d.jpg" alt="截屏2020-03-22下午10.20.05" style="zoom: 40%;" /></p><h4 id="虚拟化的定义"><a href="#虚拟化的定义" class="headerlink" title="虚拟化的定义"></a>虚拟化的定义</h4><ul><li><p>不同的虚拟机（VM）可以在同一台物理计算机上运行不同的操作系统（OS）和多个应用程序。</p></li><li><p>支持虚拟化的主要技术是虚拟机监控程序Hypervisor</p><ul><li>VMM通过仿真或硬件辅助虚拟化，以透明的方式对物理主机进行划分</li><li>提供了完整的硬件环境模拟</li></ul><blockquote><p>虚拟机：真实机器通过软件，提供操作环境，运行 Guest OS</p><p>Guest OS：运行在虚拟机环境中的，或直接运行在物理机器上的（不同于Host OS），操作系统</p></blockquote></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>更好的利用资源；最大化硬件利用，降低硬件成本；改进容错；扩容；能耗</p></li><li><p>自由选择操作系统（即测试环境）</p></li><li>整合服务器和基础架构</li><li>节省时间和金钱</li><li>使管理和保护桌面环境更加容易</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>GuestOS对硬件的要求更高（主机需要更多的内存，磁盘空间等）</li><li>可能需要培训才能操作</li></ul><h3 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h3><p>VMware、ESXi（原Elastic Sky X）、Xen、KVM</p><h4 id="VMware-ESX-Server-——-Type-1-Hypervisor（裸机）"><a href="#VMware-ESX-Server-——-Type-1-Hypervisor（裸机）" class="headerlink" title="VMware ESX Server —— Type-1 Hypervisor（裸机）"></a>VMware ESX Server —— Type-1 Hypervisor（裸机）</h4><ul><li>企业数据中心的商用VMM</li><li>支持<u>全虚拟化</u>和<u>混合虚拟化技术</u></li><li>基于x86和x86-64结构的Linux和Widows的变体</li><li>GuestOS最高支持：32个虚拟CPU和1TB内存</li><li>每个主机最高支持：160个CPU，2TB内存，512个虚拟机</li><li>其他商业版：VMware Workstation and Server 是 Type-2 Hypervisor（有HostOS）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2g2esvvdj30l20d678f.jpg" alt="截屏2020-03-22上午1.23.51" style="zoom:50%;" /></p><h4 id="XEN-——-Type-1-Hypervisor（裸机）"><a href="#XEN-——-Type-1-Hypervisor（裸机）" class="headerlink" title="XEN —— Type-1 Hypervisor（裸机）"></a>XEN —— Type-1 Hypervisor（裸机）</h4><ul><li>例子：剑桥大学、Citrix System思杰系统</li><li>微核、</li><li>Domain 0（特权Guest）负责控制和I/O、其他Domain负责用户的程序</li><li>轻量（&lt;150k 代码行），高可扩展性，大于255个物理CPU</li><li>可以分配最高128个虚拟CPU和1TB内存给虚拟机</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2ftu1du4j30ya0d6tcl.jpg" alt="截屏2020-03-22上午1.15.39" style="zoom:50%;" /></p><h4 id="KVM-——-Type-2-Hypervisor（HostOS）"><a href="#KVM-——-Type-2-Hypervisor（HostOS）" class="headerlink" title="KVM —— Type 2 Hypervisor（HostOS）"></a>KVM —— Type 2 Hypervisor（HostOS）</h4><ul><li>由 Red Hat 支持</li><li>支持硬件辅助虚拟化、混合虚拟化</li><li>主要是X86和X86-64</li><li>移植到PowerPC和IA-64（Itanium）</li><li>通过kernel模块，将Linux内核转化为Hypervisor</li><li>通过QEMU进行设备模拟</li><li>支持多种GuestOS</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2gdbcx79j30iy0h8dpv.jpg" alt="截屏2020-03-22上午1.34.22" style="zoom:50%;" /></p><h3 id="云的结构"><a href="#云的结构" class="headerlink" title="云的结构"></a>云的结构</h3><ol><li>Hypervisor 虚拟机监控程序：创建、执行、管理同一台物理机上的多个虚拟机</li><li>虚拟基础设施管理者: 将虚拟机组织到分区组中</li><li>虚拟机群集：一组具有嵌入式软件的虚拟机，充当正在运行的应用程序的中间件</li><li>分布式应用程序：旨在在多台计算机上运行以执行特定任务的软件</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3gursrjoj30mq0k47ax.jpg" alt="截屏2020-03-22下午10.36.43" style="zoom:50%;" /></p><h4 id="云基础设施管理者-——-OpenNebula"><a href="#云基础设施管理者-——-OpenNebula" class="headerlink" title="云基础设施管理者 —— OpenNebula"></a>云基础设施管理者 —— OpenNebula</h4><p>代表终端用户，用于提供虚拟资源；具有庞大的用户群，和各种Linux发行版</p><p>功能：</p><ul><li>通过云插件支持多站点资源池</li><li>与Hypervisor无关</li><li>广泛采用云接口</li><li>简单的用户管理</li></ul><h4 id="云基础设施管理者-——-OpenStack"><a href="#云基础设施管理者-——-OpenStack" class="headerlink" title="云基础设施管理者 —— OpenStack"></a>云基础设施管理者 —— OpenStack</h4><p>用于生产出无处不在的开源云计算平台，无论规模大小，它都能满足公共云和私有云的需求，易于实现和可大规模扩展。（目标是称为云中的Linux）</p><p>功能：</p><ul><li>管理层增加了自动化和控制</li><li>有效分配资源</li><li>通过服务门户授权管理员和用户</li><li>开发人员能够通过API，能够使应用程序具有云感知能力</li><li>启用云联合</li></ul><h2 id="编程模型-——-结构层（用户级中间件）"><a href="#编程模型-——-结构层（用户级中间件）" class="headerlink" title="编程模型 —— 结构层（用户级中间件）"></a>编程模型 —— 结构层（用户级中间件）</h2><p>包括各种框架，允许对云中以及存在的服务和应用，进行编程和执行，包含一些分类：</p><ol><li>用于开发应用程序的新API：Microsoft Azure, Google App Engine</li><li>高性能计算：Message Passing Interface (MPI)</li><li>非通用目的编程模型：MapReduce、Aneka（用于在云上开发分布式应用的平台和框架）</li></ol><h4 id="MapReduce：可在大规模集群上扩展的数据处理模型"><a href="#MapReduce：可在大规模集群上扩展的数据处理模型" class="headerlink" title="MapReduce：可在大规模集群上扩展的数据处理模型"></a>MapReduce：可在大规模集群上扩展的数据处理模型</h4><ul><li>用于快速粗粒大数据集的编程模型</li><li>用于网络规模的搜索和云计算应用</li><li>用户编写map函数，生成键值对</li><li>用户编写的reduce函数，将键值对按照key合并</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3hllltgqj311y0e6ab7.jpg" alt="截屏2020-03-22下午11.02.22" style="zoom:50%;" /></p><h4 id="Hadoop：遵循MapReduce模型的分布式平台"><a href="#Hadoop：遵循MapReduce模型的分布式平台" class="headerlink" title="Hadoop：遵循MapReduce模型的分布式平台"></a>Hadoop：遵循MapReduce模型的分布式平台</h4><p>通过Hadoop，用户编写和执行程序，处理大规模的分布式数据</p><p>特点</p><ul><li>可扩展：扩展以存储和处理Web空间中的PB级数据</li><li>经济的：开源MapReduce最大限度地减少了任务生成和海量数据通信中的开销。</li><li>高效的：在大量的节点上以高度并行性处理数据</li><li>可轻松：自动维护数据的多个备份，以便于故障时重新部署计算任务</li></ul><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><blockquote><p>Hypervisor —— Virtual Machine Manager (VMM)  —— 虚拟机监控程序</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> Hypervisor </tag>
            
            <tag> 云计算的三种服务模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算/07 OpenNebula - A Cloud Virtual Infrastructure Manager</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/07%20OpenNebula%20-%20A%20Cloud%20Virtual%20Infrastructure%20Manager/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/07%20OpenNebula%20-%20A%20Cloud%20Virtual%20Infrastructure%20Manager/</url>
      
        <content type="html"><![CDATA[<h2 id="07-OpenNebula-A-Cloud-Virtual-Infrastructure-Manager"><a href="#07-OpenNebula-A-Cloud-Virtual-Infrastructure-Manager" class="headerlink" title="07 OpenNebula - A Cloud Virtual Infrastructure Manager"></a>07 OpenNebula - A Cloud Virtual Infrastructure Manager</h2><h4 id="OpenNebula的主要特征"><a href="#OpenNebula的主要特征" class="headerlink" title="OpenNebula的主要特征"></a>OpenNebula的主要特征</h4><p>内部接口、调度（任务、负载）、虚拟化管理、镜像管理、网络管理、服务管理和语境化、安全、容错、可扩展性Scalability、安装、灵活且可扩展Extensibility</p><h4 id="OpenNebula结构——核心Core"><a href="#OpenNebula结构——核心Core" class="headerlink" title="OpenNebula结构——核心Core"></a>OpenNebula结构——核心Core</h4><p>请求管理：提供XML-RPC接口，用于管理和获取实体信息</p><h4 id="OpenNebula结构——工具层"><a href="#OpenNebula结构——工具层" class="headerlink" title="OpenNebula结构——工具层"></a>OpenNebula结构——工具层</h4><p>调度器</p><p>命令行接口</p><h4 id="OpenNebula结构——驱动层"><a href="#OpenNebula结构——驱动层" class="headerlink" title="OpenNebula结构——驱动层"></a>OpenNebula结构——驱动层</h4><p>传输Transfer驱动：负责镜像的管理，如克隆、删除、创建swap交换镜像</p><p>虚拟机驱动：</p><p>信息驱动：</p><h4 id="进程拆分"><a href="#进程拆分" class="headerlink" title="进程拆分"></a>进程拆分</h4><h4 id="构造私有云：存储"><a href="#构造私有云：存储" class="headerlink" title="构造私有云：存储"></a>构造私有云：存储</h4><h4 id="构造私有云：网络"><a href="#构造私有云：网络" class="headerlink" title="构造私有云：网络"></a>构造私有云：网络</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动设备虚拟化</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/07%20Introduction%20to%20Mobile%20Device%20Virtualization/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/07%20Introduction%20to%20Mobile%20Device%20Virtualization/</url>
      
        <content type="html"><![CDATA[<p>大规模的物联网设备及其数据需要有效利用云资源，但随之而来的是隐私和性能问题</p><p>解决方案：物联网设备的虚拟化</p><a id="more"></a><h4 id="动机：为什么"><a href="#动机：为什么" class="headerlink" title="动机：为什么"></a>动机：为什么</h4><p>大规模的物联网设备及其数据需要有效利用云资源，但随之而来的是隐私和性能问题</p><p>解决方案：使物联网设备的虚拟化</p><h4 id="移动设备的虚拟化"><a href="#移动设备的虚拟化" class="headerlink" title="移动设备的虚拟化"></a>移动设备的虚拟化</h4><p>虚拟化：在多个操作系统之间，高效的共享物理资源</p><p>混合关键性Mixed criticality设置：通用操作系统（实时OS，安全OS，遗留的旧版OS）</p><blockquote><p>混合关键性系统是包含计算机硬件和软件的系统，可以执行多个具有不同关键性的应用程序，例如安全性关键性和非安全性关键性或不同的安全完整性级别。不同关键性应用程序的设计具有不同的保证级别，高关键性应用程序的设计和验证成本最高。这些类型的系统通常嵌入在必须确保安全性的机器（例如飞机）中。</p><p>传统的安全关键系统必须进行完整的测试和认证，以表明它们可以安全使用。然而，许多这样的系统由安全关键部分和非关键部分的混合物组成，例如，当飞机包含与安全关键飞行系统隔离的乘客娱乐系统时。混合关键系统中要解决的一些问题包括实时行为，内存隔离，数据和控制耦合。</p></blockquote><p>减少软件移植费用和硬件成本</p><p>虚拟化的主要的组件：硬件设备、Hypervisor（虚拟机监控程序 Virtual Machine Monitor）、GuestOS（虚拟机 ）</p><p>移动设备的高效虚拟化：通过同时执行多个操作系统，不会损害<u>虚拟硬件</u>的<strong>实时特性</strong></p><h4 id="服务器虚拟化-VS-移动虚拟化"><a href="#服务器虚拟化-VS-移动虚拟化" class="headerlink" title="服务器虚拟化 VS 移动虚拟化"></a>服务器虚拟化 VS 移动虚拟化</h4><div class="table-container"><table><thead><tr><th>问题/特征</th><th>服务器虚拟化</th><th>移动设备虚拟化</th></tr></thead><tbody><tr><td>设备能源</td><td>高</td><td>低</td></tr><tr><td>资源限制</td><td>无</td><td>有</td></tr><tr><td>用例</td><td>异构操作系统</td><td>异构操作系统</td></tr><tr><td>硬实时能力</td><td>无</td><td>有</td></tr><tr><td>硬件支持</td><td>2005年起</td><td>2012年起</td></tr><tr><td>主要硬件ISA</td><td>Intel</td><td>ARM</td></tr></tbody></table></div><h4 id="移动虚拟化：硬件创新"><a href="#移动虚拟化：硬件创新" class="headerlink" title="移动虚拟化：硬件创新"></a>移动虚拟化：硬件创新</h4><p>早期阻碍：</p><ul><li>资源的限制（CPU、内存、电池）</li><li>额外的性能开销，因此会降低响应速度</li></ul><p>当前的推动：</p><ul><li><p>各种需要资源的应用设备。如游戏，多媒体</p></li><li><p>CPU的发展：从MHz的单核CPU，到限制GHz的多核CPU</p></li><li><p>内存容量的扩展：GB级别</p></li><li>多处理器的单片系统（System-on-Chip）设计</li></ul><blockquote><p>单片系统或片上系统是一个将电脑或其他电子系统集成到单一芯片的集成电路。单片系统可以处理数字信号、模拟信号、混合信号甚至更高频率的信号。单片系统常常应用在嵌入式系统中。单片系统的集成规模很大，一般达到几百万门到几千万门。</p></blockquote><h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><p>共存的异构操作系统：企业为了节约成本，让员工使用自己的设备，因此员工的个人资料和企业资料共存于员工的个人设备中。（采用虚拟化将企业与个人资料分开）</p><p>多核管理：与对称/非对称多处理相比，资源分配灵活</p><p>安全：同时执行不同安全级别的任务，比如同时执行用户程序和安全至上security-critical的程序</p><h4 id="移动虚拟技术的分类"><a href="#移动虚拟技术的分类" class="headerlink" title="移动虚拟技术的分类"></a>移动虚拟技术的分类</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2apgkp80j31240jg7ao.jpg" alt="截屏2020-03-21下午10.18.29"></p><h5 id="虚拟化的类型"><a href="#虚拟化的类型" class="headerlink" title="虚拟化的类型"></a>虚拟化的类型</h5><ul><li>Type-1：之间在硬件上部署虚拟机guest OS</li><li>Type-2：在主操作系统host OS 上部署虚拟机guest OS</li></ul><h5 id="硬件平台"><a href="#硬件平台" class="headerlink" title="硬件平台"></a>硬件平台</h5><p>移动设备&amp;手机领域：ARM</p><p>笔记本、网络设备、游戏机领域：Intel Atom、MIPS、PowerPC</p><h5 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h5><p>虚拟化技术可捕获ARM ISA中敏感的非特权指令</p><p>CPU虚拟化模型：二进制翻译 Binary translation、半虚拟化Paravirtualization、硬件辅助Hardware assisted</p><h5 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h5><p>内存保护模型：固定分区Fixed partitions、域访问控制标记Domain Access Control Tagging、VMID标记 VMID tagging</p><h5 id="中断虚拟化"><a href="#中断虚拟化" class="headerlink" title="中断虚拟化"></a>中断虚拟化</h5><p>陷阱和模拟程序：Emulated interrupt controller</p><p>由中断控制器配置：Virtual interrupt interfaces</p><h5 id="I-O虚拟化"><a href="#I-O虚拟化" class="headerlink" title="I/O虚拟化"></a>I/O虚拟化</h5><p>I/O访问模型：专用的dedicated（基于优先权）、共享的shared（在所有虚拟机之间）</p><h5 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h5><p>网络虚拟化模型：半虚拟的Paravirtual（基于超级调用的接口）、陷阱和模拟 Trap and emulate（用于网络接口访问）、硬件辅助Hardware assisted（多接口访问虚拟机）、悬挂和恢复Suspend and resume（路由）</p><blockquote><p>在计算和操作系统中，陷阱Trap（也称为异常或错误）通常是由异常情况（例如，断点，零除，无效的内存访问）引起的一种同步中断。 陷阱通常会导致切换到内核模式，其中操作系统在将控制权返回到原始进程之前执行某些操作。内核进程中的陷阱比用户进程中的陷阱更严重，并且在某些系统中是致命的。在某些用法中，陷阱一词特指旨在启动上下文切换到监视程序或调试器的中断。</p></blockquote><h4 id="移动虚拟化技术：Type1-amp-2"><a href="#移动虚拟化技术：Type1-amp-2" class="headerlink" title="移动虚拟化技术：Type1 &amp; 2"></a>移动虚拟化技术：Type1 &amp; 2</h4><p>Type-1：</p><ul><li>全虚拟化 Full virtualization：不需要修改虚拟机操作系统，本地代码的执行效率高</li><li>半虚拟化 Para-virtualization：修改虚拟机操作系统，支持超级调用 Hypercall()，能够获得更多的性能，但代价是更多的开发成本和不支持开源</li><li>动态二进制翻译 Dynamic Binary Translation (DBT)：有更多的内存空间</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2ce723bwj30p40eiaf3.jpg" alt="截屏2020-03-21下午11.16.49" style="zoom: 67%;" /></p><p>Type-2：对虚拟机操作系统进行轻量级的修改，以及基于自动化脚本的翻译。相比Type-1，多了一层host OS</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2cn7q4fej30920eamyq.jpg" alt="截屏2020-03-21下午11.25.30" style="zoom:50%;" /></p><h4 id="全虚拟化和半虚拟化"><a href="#全虚拟化和半虚拟化" class="headerlink" title="全虚拟化和半虚拟化"></a>全虚拟化和半虚拟化</h4><div class="table-container"><table><thead><tr><th>虚拟化技术</th><th>分类</th><th>原则</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>全虚拟化</td><td>硬件辅助</td><td>利用Hypervisor模式和虚拟化扩展</td><td>更低的Hypervisor复杂度；不需要修改GuestOS</td><td>敏感的非优先的ISA指令；频繁的陷入导致昂贵的上下文切换</td></tr><tr><td></td><td>动态二进制翻译</td><td>动态翻译敏感的非优先的指令</td><td>可应用于不可虚拟化的平台；可以不修改GuestOS</td><td>更高的Hypervisor复杂度（因为要扫描所有指令）；陷阱和仿真进程的过度消耗；需要内存空间来存储指令</td></tr><tr><td>半虚拟化</td><td>纯半虚拟化</td><td>修改GuestOS，用精确的hypercall代替敏感非优先的指令</td><td>在硬件的数量和OS平台方面具有可扩展性</td><td>要对GuestOS进行内核级的修改（补丁）；每次更新GuestOS都要同步更新补丁；没有标准的Hypervisor接口；无法使用不开源的GuestOS</td></tr><tr><td></td><td>轻量级半虚拟化</td><td>基于脚本识别和替换敏感非优先的指令</td><td>需要更少的汇编代码（以脚本代替）</td><td>每个GuestOS需要不同的脚本</td></tr><tr><td></td><td>基于微核的半虚拟化</td><td>将操作系统服务移动到用户空间中，减少内核的大小</td><td>更小的内核，因此获得更高的安全性和效率</td><td><u>用户-内核空间通道</u>需要高效的通信补丁（IPC）</td></tr></tbody></table></div><blockquote><p>在任何操作系统中，都必须具有双模式操作，以确保系统受到未经授权或错误用户的保护和安全。此双重模式将用户模式与系统模式或内核模式分开。</p><p>优先指令（内核模式）：I/O指令、暂停指令、上下切换、清除内存、从内存中移除进程等</p><p>非优先指令（用户模式）：读取处理器状态、读取系统时间、生成任何陷阱指令、发送打印机的最终打印结果</p></blockquote><h4 id="各版本Hypervisor比较"><a href="#各版本Hypervisor比较" class="headerlink" title="各版本Hypervisor比较"></a>各版本Hypervisor比较</h4><div class="table-container"><table><thead><tr><th>Hypervisor</th><th>VT</th><th>RT</th><th>Sc-M-OS</th><th>Sc-M-C</th><th>VE</th><th>PA</th><th>Se</th><th>MP</th><th>In</th><th>VM-M</th></tr></thead><tbody><tr><td>虚拟机监控程序</td><td>虚拟化技术</td><td>实时能力</td><td>可扩展性——多操作系统</td><td>可扩展性——多核</td><td>虚拟化扩展</td><td>处理器结构</td><td>安全性</td><td>内存保护</td><td>入侵性</td><td>虚拟器迁移</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2duy8usjj30xo0j846m.jpg" alt="截屏2020-03-22上午12.07.27"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2duda4u1j30xs0j4qat.jpg" alt="截屏2020-03-22上午12.06.40"></p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>Heterogeneous OS —— 异构操作系统<br>Host OS —— 主机操作系统<br>Guest OS —— 虚拟机操作系统<br>Hypervisor —— 虚拟机监控程序<br>Hypercall —— 超级调用<br>Assembly code —— 汇编代码</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
            <tag> 移动设备虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘和文本分析/08 Information Extraction</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/08%20Information%20Extraction/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/08%20Information%20Extraction/</url>
      
        <content type="html"><![CDATA[<h2 id="08-Information-Extraction"><a href="#08-Information-Extraction" class="headerlink" title="08 Information Extraction"></a>08 Information Extraction</h2><p><strong>Information Retrieval</strong>，从大的本文集中（通常是网站），根据关键字或查询，获取文档documents。用于分析文档。（如搜索引擎）</p><ul><li>返回的文档可能包含需求相关的信息（不一定）</li></ul><p><strong>Information Extraction</strong>，从大的文本集的内容中，获取事实facts，和结构化的信息。用于分析事实</p><ul><li><p>IE返回结构化的信息</p></li><li><p>比IR返回的knowledge更加深入</p></li><li><p>通过IE构建数据库，并与文档关联，可以形成另一种形式的搜索工具。</p><ul><li>即使结果不够精确，人们也可以从关联的原始文档中查找。（相当于另一种形式的IR）</li></ul></li><li><p>使用场景：</p><ul><li>新闻：分辨主要的关系 major relations，和事件种类 event types；</li><li>科学报告：分辨关系relations和涉及的科学领域subfield</li></ul></li></ul><h4 id="例子：HASIE、KIM、Threat-tracker"><a href="#例子：HASIE、KIM、Threat-tracker" class="headerlink" title="例子：HASIE、KIM、Threat tracker"></a>例子：HASIE、KIM、Threat tracker</h4><p><strong>HaSIE</strong>，IE系统，自动找出公司对健康和安全问题的报告，自动识别文档的每个部分，从中提取出关于健康和安全问题的句子，并存入数据库。</p><p><strong>KIM</strong>，简化的数据库查询页面</p><p><strong>Threat tracker</strong>：识别文章中出现的实体（名词）</p><h4 id="如何识别命名实体-Named-Entity-NE-Recognition"><a href="#如何识别命名实体-Named-Entity-NE-Recognition" class="headerlink" title="如何识别命名实体 Named Entity (NE) Recognition"></a>如何识别命名实体 Named Entity (NE) Recognition</h4><p>识别文字中的命名实体，并将他们分类到提前定义好的类别中</p><p>命名实体包括：人、组织、地点、日期、其他</p><p>是构建复杂IE系统的基础</p><p>命名实体之间的关系可以用于追踪tracking、信息本体论ontological information、情景构建scenario building</p><blockquote><p>本体就是一种特殊类型的<a href="https://zh.wikipedia.org/wiki/术语集" target="_blank" rel="noopener">术语集</a>，具有结构化的特点，且更加适合于在<a href="https://zh.wikipedia.org/wiki/信息系统" target="_blank" rel="noopener">计算机系统</a>之中使用；或者说，本体实际上就是「对特定<a href="https://zh.wikipedia.org/wiki/论域" target="_blank" rel="noopener">领域</a>之中某套<a href="https://zh.wikipedia.org/wiki/概念" target="_blank" rel="noopener">概念</a>及其相互之间<a href="https://zh.wikipedia.org/wiki/关系_(数学" target="_blank" rel="noopener">关系</a>)的形式化表达（formal representation）」</p></blockquote><h4 id="两种途径"><a href="#两种途径" class="headerlink" title="两种途径"></a>两种途径</h4><p><strong>知识工程Knowledge Engineering</strong>：基于规则、由有经验的语言学工程师开发、采用人类的直觉、开发周期长、有些变化很难适应</p><p><strong>学习系统Learning System</strong>：采用统计学或机器学习、开发者不需要语言学专业技能、需要大量的带注解的训练数据annotated training data、有些更改可能需要重新标注整个训练语料库</p><h4 id="NE命名实体中的问题"><a href="#NE命名实体中的问题" class="headerlink" title="NE命名实体中的问题"></a>NE命名实体中的问题</h4><p>实体的多样性：John Smith / Mr Smith, John</p><p>实体种类的不确定性：John Smith 人或公司</p><p>常用词的一词多义：may</p><h4 id="MUSE-–-MUlti-Source-Entity-Recognition"><a href="#MUSE-–-MUlti-Source-Entity-Recognition" class="headerlink" title="MUSE – MUlti-Source Entity Recognition"></a>MUSE – MUlti-Source Entity Recognition</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/06_ Service Level Agreement</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/06_%20Service%20Level%20Agreement/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/06_%20Service%20Level%20Agreement/</url>
      
        <content type="html"><![CDATA[<h2 id="06-Service-Level-Agreement"><a href="#06-Service-Level-Agreement" class="headerlink" title="06_ Service Level Agreement"></a>06_ Service Level Agreement</h2><p>A service-level agreement is an agreement between two or more parties, where one is the customer and the others are service providers. This can be a legally binding formal or an informal “contract” (for example, internal department relationships). The agreement may involve separate organizations, or different teams within one organization. Contracts between the service provider and other third parties are often (incorrectly) called SLAs – because the level of service has been set by the (principal) customer, there can be no “agreement” between third parties; these agreements are simply “contracts.” Operational-level agreements or OLAs, however, may be used by internal groups to support SLAs. If some aspect of a service has not been agreed with the customer, it is not an “SLA”.</p><p>SLAs commonly include many components, from a definition of services to the termination of agreement. To ensure that SLAs are consistently met, these agreements are often designed with specific lines of demarcation and the parties involved are required to meet regularly to create an open forum for communication. Rewards and penalties applying to the provider are often specified. Most SLAs also leave room for periodic (annual) revisitation to make changes.</p><p>Since late 1980s SLAs have been used by fixed line telecom operators. SLAs are so widely used these days that larger organizations have many different SLAs existing within the company itself. Two different units in an organization script a SLA with one unit being the customer and another being the service provider. This practice helps to maintain the same quality of service amongst different units in the organization and also across multiple locations of the organization. This internal scripting of SLA also helps to compare the quality of service between an in-house department and an external service provider.</p><p>The output received by the customer as a result of the service provided is the main focus of the service level agreement.</p><p>Service level agreements are also defined at different levels:</p><ul><li><p><strong>Customer-based SLA</strong>: An agreement with an individual customer group, covering all the services they use. For example, an SLA between a supplier (IT service provider) and the finance department of a large organization for the services such as finance system, payroll system, billing system, procurement/purchase system, etc.</p></li><li><p>Service-based SLA: An agreement for all customers using the services being delivered by the service provider</p><p>For example:</p><ul><li>A mobile service provider offers a routine service to all the customers and offers certain maintenance as a part of an offer with the universal charging.</li><li>An email system for the entire organization. There are chances of difficulties arising in this type of SLA as level of the services being offered may vary for different customers (for example, head office staff may use high-speed <a href="https://en.wikipedia.org/wiki/Local_area_network" target="_blank" rel="noopener">LAN</a> connections while local offices may have to use a lower speed leased line).</li></ul></li><li><p>Multilevel SLA: The SLA is split into the different levels, each addressing different set of customers for the same services, in the same SLA.</p><ul><li><strong>Corporate-level SLA</strong>: Covering all the generic <a href="https://en.wikipedia.org/wiki/Service_level_management#Service_level_management" target="_blank" rel="noopener">service level management</a> (often abbreviated as SLM) issues appropriate to every customer throughout the organization. These issues are likely to be less volatile and so updates (SLA reviews) are less frequently required.</li><li><strong>Customer-level SLA</strong>: covering all SLM issues relevant to the particular customer group, regardless of the services being used.</li><li>Service-level SLA: covering all SLM issue relevant to the specific services, in relation to this specific customer group.</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/06 Cloud Resource Management and Scheduling</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/06%20Cloud%20Resource%20Management%20and%20Scheduling/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/06%20Cloud%20Resource%20Management%20and%20Scheduling/</url>
      
        <content type="html"><![CDATA[<h2 id="06-Cloud-Resource-Management-and-Scheduling"><a href="#06-Cloud-Resource-Management-and-Scheduling" class="headerlink" title="06 Cloud Resource Management and Scheduling"></a>06 Cloud Resource Management and Scheduling</h2><h4 id="资源管理和调度"><a href="#资源管理和调度" class="headerlink" title="资源管理和调度"></a>资源管理和调度</h4><p>是任何“人造”系统的的关键功能；对系统的评估包括3个基本准则：功能性、性能、成本</p><p>计算机系统的调度：如何分配系统的资源：如CPU cycles，内存，次级存储空间，I/O，网络带宽，用户事件和任务</p><p>资源调度的策略和机制：Policy：指导决策的原则；机制：如何实现policies</p><h4 id="虚拟机资源管理"><a href="#虚拟机资源管理" class="headerlink" title="虚拟机资源管理"></a>虚拟机资源管理</h4><p><strong>服务级别协议(Service Level Agreement, SLA)</strong>和<strong>资源分配</strong>：</p><ul><li>服务请求检查<strong>Service Request Examiner</strong> 和准入控制<strong>Admission Control</strong>，包括：消费者驱动服务管理、计算风险管理、自动化资源管理</li></ul><blockquote><p>A service-level agreement (SLA) is a commitment between a service provider and a client. Particular aspects of the service quality, availability, responsibilities are agreed between the service provider and the service user.</p><p>服务级别协议（英語：service-level agreement，缩写SLA）也称服务等级协议、服务水平协议，是服务提供商与客户之间定义的正式承诺。服务提供商与受服务用户之间具体达成了承诺的服务指标——质量、可用性，责任。</p><p>The most common component of an SLA is that the services should be provided to the customer as agreed upon in the contract. As an example, Internet service providers and telcos will commonly include service level agreements within the terms of their contracts with customers to define the level(s) of service being sold in plain language terms. In this case the SLA will typically have a technical definition in mean time between failures (MTBF), mean time to repair or mean time to recovery (MTTR); identifying which party is responsible for reporting faults or paying fees; responsibility for various data rates; throughput; jitter; or similar measurable details.</p><p>SLA最常见的组成部分是以合同约定向客户提供的服务。例如，互联网服务供应商（ISP）和電訊公司通常在与客户的合同条款内包含简单定义的服务级别协议。在此事例下，SLA通常定义有平均故障間隔（MTBF）、平均修复时间或平均修復時間（MTTR）；哪一方负责报告错误与支付费用；吞吐量；抖动；或类似的可衡量细节。</p><p>服务级别协议是一种两方或多方间协议，其中一方为客户，另一方为服务提供商。这可以是具有法律约束力的正式合同或非正式合约。协议有可能涉及单独的组织，也可以是同一个组织内的不同团队。服务提供商与其他第三方之间的合同经常被误称为SLA——由于服务级别是由出资客户要求，与第三方之间则不是“协议”，而只是“合约”。</p><p>服务级别协议通常包含许多部分，从服务的定义到协议的终止。</p></blockquote><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>云资源管理的问题：</p><ul><li><p>对于multi-objective optimization，需要复杂的策略和决策</p><blockquote><p>Multi-objective optimization多目标优化: 需要在权衡的情况下做出最佳决策在两个或多个相互矛盾的目标之间。比如：load balance, energe, cost, fault tolerance, security</p></blockquote></li><li><p>挑战性：由于系统的复杂性，获取精确的全局状态信息是不可能的</p></li><li><p>与（系统）环境的交互是不可预测的，因此会受到影响：如系统故障、受攻击</p></li><li><p>云服务的提供商需要面对，巨大的负载波动，对云的弹性（可伸缩性）的影响</p></li></ul><h4 id="资源管理策略-Policies"><a href="#资源管理策略-Policies" class="headerlink" title="资源管理策略 Policies"></a>资源管理策略 Policies</h4><ul><li>准入控制 Admission control：防止系统违反高层系统策略接受工作负载</li><li>容量分配 Capacity allocation：分配资源以单独激活服务</li><li>负载平衡 Load balancing：在服务器之间平均分配工作负载</li><li>能源优化 Energy optimization：能源消耗最小化</li><li>服务质量（QoS）保证 Quality of service guarantees：能够满足服务级协议(SLA)规定的时间或其他条件。</li></ul><h4 id="Admission-control-准入控制"><a href="#Admission-control-准入控制" class="headerlink" title="Admission control 准入控制"></a>Admission control 准入控制</h4><blockquote><p><strong>Admission control</strong> is a validation process in communication systems where a check is performed before a connection is established to see if current resources are sufficient for the proposed connection.</p><p>是通信系统中的一种验证过程，在建立连接之前先进行检查，以查看当前资源是否足以用于建议的连接。</p><p>For example：</p><p>For some applications, dedicated resources (such as a wavelength across an optical network) may be needed in which case admission control has to verify availability of such resources before a request can be admitted.</p><p>对于某些应用，可能需要专用资源（例如，整个光网络中的波长），在这种情况下，准入控制必须在可以接受请求之前验证此类资源的可用性。</p><p>For more elastic applications, a total volume of resources may be needed prior to some deadline in order to satisfy a new request, in which case admission control needs to verify availability of resources at the time and perform scheduling to guarantee satisfaction of an admitted request.</p><p>对于更具弹性的应用程序，在某个截止日期之前可能需要总量的资源才能满足新的请求，在这种情况下，准入控制需要验证当时的资源可用性并执行调度以保证满足所接纳的请求。</p></blockquote><p>比如：is about look at the resource that i have, can i fulfil the customers request, if i dont have enough resources, i will find resources for the customer from other resource providers, if i have agreement with them. if i can provide anyway, the access will be denied.</p><h4 id="云的调度-Scheduling"><a href="#云的调度-Scheduling" class="headerlink" title="云的调度 Scheduling"></a>云的调度 Scheduling</h4><p>什么是调度：负责多个级别的资源共享：</p><ul><li>物理主机可以在多个虚拟机之间共享</li><li>虚拟机可以支持多个应用程序</li><li>一个应用程序可能包含多个线程</li></ul><blockquote><p>调度在计算机中是分配工作所需资源的方法。资源可以指虚拟的计算资源，如线程、进程或数据流；也可以指硬件资源，如处理器、网络连接或扩展卡。</p><p>进行调度工作的程序叫做调度器。调度器通常的实现使得所有计算资源都处于忙碌状态（在负载均衡中），允许多位用户有效地同时共享系统资源，或达到指定的服务质量。调度是计算自身的基础，同时也是编程语言计算模型固有的部分。调度器使得在单处理器上通过多任务处理，从而让执行多个进程成为可能。</p></blockquote><p>调度程序的目标：</p><ul><li>批处理系统：最大吞吐量和最小周转时间</li><li>实时系统：按时完成并具有可预测性</li></ul><blockquote><p>调度器可能会针对不同的目标设计，例如：吞吐率最大化、响应时间最小化、最低延迟[1]、或最大化公平。在实践中，这些目标通常是互相冲突的，因此，调度器会实现一个权衡利弊的折中方案，而侧重点则可能是前文提到的任何一种，这取决于用户的需求和目的。</p><p>在实时环境，例如工业上用于自动控制（如机器人）的嵌入式系统，调度器必须保证进程的调度不能超过最后期限 —— 这是保持系统稳定运行的关键因素。调度也可能是通过一个管理性的后端进行，而任务是通过网络发配到若干远程设备上的。</p></blockquote><p>常见算法：</p><ul><li>Round-Robin(RR)</li><li>First-Come-First Serve (FCFS)</li><li>Shortest-Job-First (SJF)</li><li>Priority Algorithms</li></ul><h4 id="OpenNebula的虚拟机调度"><a href="#OpenNebula的虚拟机调度" class="headerlink" title="OpenNebula的虚拟机调度"></a>OpenNebula的虚拟机调度</h4><ul><li>调度器算法：match making，将“挂起的虚拟机 pending VM”分配给“已知的主机 known Hosts” （匹配VM的需求和硬件层正好有的资源）</li><li>策略：Rank Scheduling Policy，该策略的目标是优先考虑那些更适合VM的资源。</li></ul><h4 id="虚拟机调度方式：例子"><a href="#虚拟机调度方式：例子" class="headerlink" title="虚拟机调度方式：例子"></a>虚拟机调度方式：例子</h4><ul><li>Power-aware：重点是如何最大程度地减少物理主机消耗的能源（比如电），从而最大程度地提高云提供商的收入；比如将多个VMs迁移到同一个节点上，降低总的能耗。</li><li>Performance-aware: 通过动态布局机制，重点在于保持服务级别，同时提高资源利用率（如Real-time system）</li><li>Network-aware: 重点是如何最大程度地减少虚拟机实例和数据存储之间的数据传输时间的影响（如Big data system，Hadoop distributed file system）</li><li>Heuristics 启发式的: 包括先到先得（FCFS），贪婪和循环机制。 例如，FCFS使用First Fit（FF）启发式方法，将VM分配给可以容纳它的第一台物理主机。</li></ul><h4 id="虚拟机管理：例子"><a href="#虚拟机管理：例子" class="headerlink" title="虚拟机管理：例子"></a>虚拟机管理：例子</h4><ol><li>监控云的使用和负载</li><li>服务器整合 server consolidation：当负载降低时，实时转移虚拟机，到负载更高的节点上；不使用的节点关闭</li><li>当负载增加时：启动待机节点；对新的虚拟机和新的节点进行调度</li></ol><h4 id="能源感知算法"><a href="#能源感知算法" class="headerlink" title="能源感知算法"></a>能源感知算法</h4><p>主机过载检测：MAD，LR</p><p>主机underload（低负载）检测算法：Migrate the VMs from the least utilised host；如Power-aware场景</p><p>虚拟机选择算法：MMT，RS</p><p>虚拟机放置算法：Power-Aware Best Fit</p><h4 id="虚拟机转移"><a href="#虚拟机转移" class="headerlink" title="虚拟机转移"></a>虚拟机转移</h4><p>转移的发生是透明的</p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>何时迁移：Host overload detection algorithms、Host underload detection algorithms，</p><p>迁移哪个：VM selection algorithms</p><p>迁移到哪：VM placement algorithms</p><h4 id="需要考虑：内存、网络、存储"><a href="#需要考虑：内存、网络、存储" class="headerlink" title="需要考虑：内存、网络、存储"></a>需要考虑：内存、网络、存储</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟化</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/07%20Virtualization/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/07%20Virtualization/</url>
      
        <content type="html"><![CDATA[<p>虚拟机监控程序：Type 1 &amp; 2<br>虚拟化技术：全虚拟化、硬件辅助虚拟化、半虚拟化等<br>流行的几种虚拟机技术产品</p><a id="more"></a><h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h2><p>虚拟化可以广义地定义为：概念性资源或服务与提供它的物理方式的（有益）分离</p><p>创建虚拟资源：硬件平台，操作系统，存储设备，计算机网络资源</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>虚拟机：真实机器的一种表示，使用软件模拟操作环境</p><p>Guest Operating System：运行在虚拟机里的操作系统</p><p>Host OS：运行虚拟机的操作系统</p><p>Hypervisor/VMM 虚拟机监控程序：将资源虚拟化的中间件；位于基础资源和虚拟机之间</p><h4 id="虚拟化的好处"><a href="#虚拟化的好处" class="headerlink" title="虚拟化的好处"></a>虚拟化的好处</h4><p>原因：资源利用不足；数据中心空间不足；环保；管理成本上升</p><p>特点：Sharing、Aggregation，Emulation，Isolation</p><p>好处：随意选择操作系统（比如测试环境）；合并服务器和基础设施；节约时间和金钱；简化管理，保护桌面环境：比如将不安全的程序隔离进虚拟机中，可以将虚拟机复制到其他机器中，相同的操作系统/软件可以快速安装。</p><p>缺点：Guest OS对硬件要求更高；需要学习如何使用；不够精确；硬件问题：比如Intel IA-32</p><h3 id="虚拟机监控程序-Hypervisor"><a href="#虚拟机监控程序-Hypervisor" class="headerlink" title="虚拟机监控程序 Hypervisor"></a>虚拟机监控程序 Hypervisor</h3><p>Qemu, VMware Player, Microsoft Virtual PC etc，Sometimes called Emulation, e.g. x86 Emulation</p><h4 id="Hypervisor的分类"><a href="#Hypervisor的分类" class="headerlink" title="Hypervisor的分类"></a>Hypervisor的分类</h4><p><strong>裸机模式 Bare Metal: Type 1 hypervisor</strong></p><p>位于裸机计算机硬件上，例如CPU，内存等；所有GuestOS都在Hypervisor之上；Hypervisor是硬件之上的第一层。如：Microsoft Hyper-V</p><p><strong>托管模式 Hosted Approach：Type 2 Hypervisor</strong></p><p>在主操作系统上运行；Hypervisor是硬件之上的第二层；Guest OS在hypervisor上的一层运行</p><p>比如：VMWare Workstations、Microsoft Virtual PC、FreeBSD</p><h4 id="Hypervisor的主要属性"><a href="#Hypervisor的主要属性" class="headerlink" title="Hypervisor的主要属性"></a>Hypervisor的主要属性</h4><p><strong>Equivalence 等价性</strong>：程序应该表现的像是直接在同样的硬件上执行</p><p><strong>Resource control 资源控制</strong> ：Hypervisor对虚拟资源有完整的控制</p><p><strong>Efficiency 效率</strong>：必须在无Hypervisor的干预下执行绝大部分机器指令machine instruction</p><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>全虚拟化，硬件辅助虚拟化，部分虚拟化：半虚拟化、混合、OS Level</p><h3 id="全虚拟化"><a href="#全虚拟化" class="headerlink" title="全虚拟化"></a>全虚拟化</h3><p>在全虚拟化技术中，Guest OS并不知道自己处于虚拟的环境，以Guest OS的角度，它直接与硬件进行通信（实际上是虚拟的硬件）</p><ul><li>主机系统模拟硬件，使Guest OS无需任何修改即可运行</li><li>不同的架构可以独立运行</li><li>因为GuestOS与仿真硬件通信（due to the overhead associated with emulating hardware at the transistor level），导致相当大的性能损失</li></ul><h3 id="硬件辅助虚拟化"><a href="#硬件辅助虚拟化" class="headerlink" title="硬件辅助虚拟化"></a>硬件辅助虚拟化</h3><p>是全虚拟化的一种，其中的微处理器架构有特殊的指令，可以协助硬件的虚拟化（而不是完全靠主机操作系统模拟硬件）。这种方式以“Virtual Machine Extensions”的形式，充分利用了硬件的能力，如Intel VT和AMD V</p><p><strong>促进虚拟机的性能</strong>：可以直接与主机的处理器通信，而不需要由Hypervisor进行翻译和隔离；要求GuestOS与主机使用一样的命令集</p><p><strong>完整的硬件协助虚拟化</strong>（如I/O和内存管理），还没有在任何VMM中完整实现</p><h3 id="部分虚拟化"><a href="#部分虚拟化" class="headerlink" title="部分虚拟化"></a>部分虚拟化</h3><p>只模拟主机的大部分硬件，而非全部；支持资源共享，但不保证GuestOS实例被隔离</p><p>比如：半虚拟化、混合虚拟化、操作系统级别虚拟化</p><h4 id="半虚拟化"><a href="#半虚拟化" class="headerlink" title="半虚拟化"></a>半虚拟化</h4><p>在半虚拟化中，GuestOS知道自己的身份，并且直接与HostOS通信（而不是与模拟的硬件通信）</p><ul><li>GuestOS需要进行修改</li><li>提供定义好的“钩子“，在GuestOS和HostOS中执行特定的任务</li><li>在半虚拟的平台中，虚拟机监控程序更简单，因为重要的任务都从VMM中移交给了操作系统<ul><li>优点：虚拟化开销减少，因此性能提高</li></ul></li><li>缺点：兼容性和可移植性降低（因为修改了操作系统）、维护成本增加（因为对操作系统的深度修改）</li><li>例子：KVM (Kernel-based VM)</li></ul><h4 id="比较：半虚拟化和全虚拟化"><a href="#比较：半虚拟化和全虚拟化" class="headerlink" title="比较：半虚拟化和全虚拟化"></a>比较：半虚拟化和全虚拟化</h4><div class="table-container"><table><thead><tr><th>全虚拟化</th><th>半虚拟化</th></tr></thead><tbody><tr><td>不需要修改OS</td><td>需要修改OS</td></tr><tr><td>通过二进制翻译，由软件模拟关键的指令</td><td>用Hypercall代替不可虚拟化的指令，GuestOS直接与VMM通信</td></tr><tr><td><strong>二进制翻译会降低性能</strong></td><td>减少开销</td></tr><tr><td></td><td>维护半虚拟化的GuestOS成本很高（修改、更新系统补丁）</td></tr><tr><td>如：VMware</td><td>如：Xen，VMware ESX (Elastic Sky X)</td></tr></tbody></table></div><h4 id="混合虚拟化"><a href="#混合虚拟化" class="headerlink" title="混合虚拟化"></a>混合虚拟化</h4><p>组合<u>半虚拟化</u>和<u>硬件辅助虚拟化</u>，为创建新的基于云的系统奠定了良好的基础，减少了高峰需求所需的物理机数量，从而减少了硬件运行和设置成本</p><p>优点：能够在GuestOS上获得接近本机的性能</p><p>缺点：包含双方的缺点，如可移植性低、兼容性低、开发维护成本增加</p><ul><li>大多数VMM支持多种类型的虚拟化，因此可以略微减轻这些缺点</li></ul><h4 id="操作系统级的虚拟化"><a href="#操作系统级的虚拟化" class="headerlink" title="操作系统级的虚拟化"></a>操作系统级的虚拟化</h4><p>对多个用户空间的实例进行隔离，GuestOS需要与HostOS一致</p><p>优点：GuestOS上的执行能够达到本机的性能</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2fphsuk8j30m60gq0xe.jpg" alt="截屏2020-03-22上午1.11.29" style="zoom:33%;" /></p><h2 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h2><h4 id="XEN-——-Type-1-Hypervisor（裸机）"><a href="#XEN-——-Type-1-Hypervisor（裸机）" class="headerlink" title="XEN —— Type-1 Hypervisor（裸机）"></a>XEN —— Type-1 Hypervisor（裸机）</h4><ul><li>例子：剑桥大学、Citrix System思杰系统</li><li>微核、</li><li>Domain 0（特权Guest）负责控制和I/O、其他Domain负责用户的程序</li><li>轻量（&lt;150k 代码行），高可扩展性，大于255个物理CPU</li><li>可以分配最高128个虚拟CPU和1TB内存给虚拟机</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2ftu1du4j30ya0d6tcl.jpg" alt="截屏2020-03-22上午1.15.39" style="zoom:50%;" /></p><h4 id="VMware-ESX-Server-——-Type-1-Hypervisor（裸机）"><a href="#VMware-ESX-Server-——-Type-1-Hypervisor（裸机）" class="headerlink" title="VMware ESX Server —— Type-1 Hypervisor（裸机）"></a>VMware ESX Server —— Type-1 Hypervisor（裸机）</h4><ul><li>企业数据中心的商用VMM</li><li>支持<u>全虚拟化</u>和<u>混合虚拟化技术</u></li><li>基于x86和x86-64结构的Linux和Widows的变体</li><li>GuestOS最高支持：32个虚拟CPU和1TB内存</li><li>每个主机最高支持：160个CPU，2TB内存，512个虚拟机</li><li>其他商业版：VMware Workstation and Server 是 Type-2 Hypervisor（有HostOS）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2g2esvvdj30l20d678f.jpg" alt="截屏2020-03-22上午1.23.51" style="zoom:50%;" /></p><h4 id="KVM-——-Type-2-Hypervisor（HostOS）"><a href="#KVM-——-Type-2-Hypervisor（HostOS）" class="headerlink" title="KVM —— Type 2 Hypervisor（HostOS）"></a>KVM —— Type 2 Hypervisor（HostOS）</h4><ul><li>由 Red Hat 支持</li><li>支持硬件辅助虚拟化、混合虚拟化</li><li>主要是X86和X86-64</li><li>移植到PowerPC和IA-64（Itanium）</li><li>通过kernel模块，将Linux内核转化为Hypervisor</li><li>通过QEMU进行设备模拟</li><li>支持多种GuestOS</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2gdbcx79j30iy0h8dpv.jpg" alt="截屏2020-03-22上午1.34.22" style="zoom:50%;" /></p><h4 id="VirtualBox-——-Type-2-Hypervisor（HostOS）"><a href="#VirtualBox-——-Type-2-Hypervisor（HostOS）" class="headerlink" title="VirtualBox —— Type 2 Hypervisor（HostOS）"></a>VirtualBox —— Type 2 Hypervisor（HostOS）</h4><ul><li>由Oracle支持，是一个桌面的虚拟机监控程序</li><li>支持混合虚拟化</li><li>开源</li><li>不开源的免费版本扩展包，用于支持远程桌面协议（RDP）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2giho173j30fq0jm0z9.jpg" alt="截屏2020-03-22上午1.39.20" style="zoom:50%;" /></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2gnooutkj30zw0juki9.jpg" alt="截屏2020-03-22上午1.44.18" style="zoom:50%;" /></p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><blockquote><p>Host OS —— 主机操作系统<br>Guest OS —— 虚拟机操作系统<br>Hypervisor —— Virtual Machine Monitor (VMM)—— 虚拟机监控程序<br>Para-Virtualization —— 半虚拟化<br>Hybrid Virtualization —— 混合虚拟化<br>Bare Metal —— 裸机<br>Overhead —— 开销<br>Portability —— 可移植性<br>Hypercall —— 超级调用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
            <tag> Hypervisor </tag>
            
            <tag> 全虚拟化 </tag>
            
            <tag> 半虚拟化 </tag>
            
            <tag> 硬件辅助虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算/05 Virtualization 2</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/05%20Virtualization%202/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/05%20Virtualization%202/</url>
      
        <content type="html"><![CDATA[<h2 id="05-Virtualization-2"><a href="#05-Virtualization-2" class="headerlink" title="05 Virtualization 2"></a>05 Virtualization 2</h2><p>容器技术，VM和Containers，Docker</p><h4 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h4><p>虚拟层被认为是Hypervisor或虚拟机监视器 Virtual Machine Monitor</p><h4 id="虚拟机-vs-容器"><a href="#虚拟机-vs-容器" class="headerlink" title="虚拟机 vs 容器"></a>虚拟机 vs 容器</h4><p>容器虚拟化操作系统，而不是硬件</p><p>使用单核来运行多个操作系统的实例，每个实例都在完全隔离的环境中运行，保证了安全性</p><p>比传统的Hypervisor在效率和性能上更好</p><blockquote><p>我们用的传统虚拟机如 <code>VMware</code> ， <code>VisualBox</code> 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><p>而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p></blockquote><h4 id="容器和虚拟机的不同"><a href="#容器和虚拟机的不同" class="headerlink" title="容器和虚拟机的不同"></a>容器和虚拟机的不同</h4><p>容器的更加轻量，性能更好：</p><ul><li>便携性Portability：VM（GB级）Container（MB级），虚拟机受限于Hypervisor和硬件</li><li>性能：容器可以在几秒内启动和重启，虚拟机则需要几分钟；没有Hypervisor和GuestOS，因此减少了容器对的CPU和内存损耗</li><li>管理成本：每个虚拟机实例需要完整的操作系统，因此需要额外的管理</li></ul><p>适合用容器的场景：DevOps运维，批量计算 Batch Computing，微服务 Microservices</p><blockquote><p>DevOps是一种重视“软件开发人员”和“IT运维技术人员”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p></blockquote><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ul><li>容器内部是一个单独的可执行服务，该服务是一个应用的一小部分：微服务</li><li>微服务通过单独一小段可执行代码，提供一个简单的功能</li><li>应用由一系列的微服务组成，每个微服务提供应用整体的一小部分</li><li>单个微服务的多个副本可以在许多容器中运行，并且这些容器通过消息队列或负载平衡链接在一起。</li><li>应用程序本身是为了处理单个容器的故障而构建的，并且每个容器都有自己的微服务软件代码实例。</li><li>相同的微服务的容器运行相同的代码。</li></ul><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>分解为小的部分；松耦合；更容易扩展；易于隔离故障；每个服务可以单独开发和部署；将长周期的开发转为解决一个个技术问题</p><h4 id="容器管理平台"><a href="#容器管理平台" class="headerlink" title="容器管理平台"></a>容器管理平台</h4><p>也称为容器管理者container managers，container orchestration 容器编排 engines (COEs)/platforms，或containers-as-a-service (CaaS) platforms</p><p>用于帮助企业解决部署容器的问题；帮助管理者监控、管理、保护secure、扩展容器，就像是维护虚拟机和服务器一样（doing the same thing as virtualization）</p><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>Docker Engine：轻量级的运行和工具，用于管理容器，镜像，构建物；</p><p>组成包括：</p><ul><li>Docker Daemon 守护线程：在主机上运行；负责执行命令；构建，运行和分发容器；</li><li>Docker Client 客户端：是Docker的终端用户，与用户接口和进行通信，传达终端用户的指令到Docker Daemon；Docker客户端也可以在主机上运行，但是不需要。</li><li>REST API：与Docker线程远程交互</li><li>Dockerfile：由终端用户写命令，以构建Docker镜像</li><li>Docker Images 镜像：是最终用户根据Dockerfile中编写的一组指令构建的只读模板；镜像定义了终端用户打包的应用和相关依赖有哪些，以及当应用启动时需要运行哪些进程</li></ul><h4 id="Docker技术"><a href="#Docker技术" class="headerlink" title="Docker技术"></a>Docker技术</h4><ul><li>Docker容器将应用程序的软件包装到一个看不见的盒子中，其中包含应用程序需要运行的所有内容：包括操作系统，应用程序代码，运行时，系统工具，系统库</li><li>由于映像是只读的，因此Docker在映像的只读文件系统之上添加了一个读写文件系统，以创建一个容器。</li><li>Docker创建一个网络接口，以便容器可以与本地主机通信，将IP地址附加到容器，并执行在定义映像时指定运行应用程序的过程。</li></ul><p><strong>Singularity更安全</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘和文本分析/07 Unsupervised ML Association Rules, Clustering</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/07%20Unsupervised%20ML%20Association%20Rules,%20Clustering/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/07%20Unsupervised%20ML%20Association%20Rules,%20Clustering/</url>
      
        <content type="html"><![CDATA[<h2 id="07-Unsupervised-ML-Association-Rules-Clustering"><a href="#07-Unsupervised-ML-Association-Rules-Clustering" class="headerlink" title="07 Unsupervised ML: Association Rules, Clustering"></a>07 Unsupervised ML: Association Rules, Clustering</h2><h4 id="关联规则-Assoication-Rules"><a href="#关联规则-Assoication-Rules" class="headerlink" title="关联规则 Assoication Rules"></a>关联规则 Assoication Rules</h4><p>基本算法：</p><ul><li>生成覆盖范围大于某些指定的最小覆盖范围的所有规则；</li><li>仅从这些规则中选择精度高于某些指定的最低精度（例如100％！）的规则。</li></ul><p><strong>$n$-item sets</strong> (with minimum coverage = $m$)：任意n个属性，且满足attr-val对的实例数量超过m个</p><p>Minimun coverage = $m$</p><p>Rules from : attr1=val1, attr2=val2, … </p><p>If …[Case]… then …</p><p><strong>Coverage</strong>：满足“attr=val”的所有实例</p><p><strong>Accuracy</strong> = Coverage / Cases</p><h4 id="聚类算法：K-means"><a href="#聚类算法：K-means" class="headerlink" title="聚类算法：K-means"></a>聚类算法：K-means</h4><p>计算欧几里得距离</p><p>将属性从nominal转化为numerical：可以是一维向量，或者N维数组</p><h4 id="聚类算法：增量聚类-Incremental-Clustering"><a href="#聚类算法：增量聚类-Incremental-Clustering" class="headerlink" title="聚类算法：增量聚类 Incremental Clustering"></a>聚类算法：增量聚类 Incremental Clustering</h4><p>算法：根据category utility，把每一个实例添加到当前的树中最合适的位置。</p><ul><li>一次添加一个实例，建立树状图</li><li>通过<strong>category utility</strong>，对与每一个新的实例，决定该实例应该划分到哪个簇cluster，或划分为一个新的簇</li><li><strong>category utility</strong>是一个测量方法，用于判断一个簇的好坏，它不需要属性值为数字</li></ul><h4 id="比较Kmeans和增量聚类"><a href="#比较Kmeans和增量聚类" class="headerlink" title="比较Kmeans和增量聚类"></a>比较Kmeans和增量聚类</h4><p>两者都无法保证全局最优</p><p>Kmeans的效果取决于聚类的数量和聚类中心的初始位置</p><p>增量聚类生成可以检查和推理的层次结构</p><p>增量聚类的效果取决于实例被添加的顺序</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据通信和存储层（Hadoop分布式文件系统）</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/06%20MESSAGING%20AND%20STORAGE%20LAYER/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/06%20MESSAGING%20AND%20STORAGE%20LAYER/</url>
      
        <content type="html"><![CDATA[<p>介绍Hadoop分布式文件系统的特点和行为</p><a id="more"></a><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><p>Hadoop是包括多个不同产品的完整生态系统，由Apache软件基金会负责</p><p>是开源框架，实现MapReduce，用于处理、存储和分析数据</p><p>最初用于10亿级的网页搜索引擎</p><p>基本原则是将一个大块的数据拆分成多个小块，然后把多个小块分散存储</p><h4 id="Hadoop的基本结构"><a href="#Hadoop的基本结构" class="headerlink" title="Hadoop的基本结构"></a>Hadoop的基本结构</h4><p>Hadoop包括两个方面：</p><ul><li><p>HDFS：Hadoop分布式文件系统</p></li><li><p>MapReduce：集群资源管理和批数据处理</p></li></ul><h4 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h4><blockquote><p>HDFS采用了主从（Master/Slave）结构模型，一个HDFS集群是由一个NameNode和若干个DataNode组成的。其中NameNode作为主服务器，管理文件系统的命名空间和客户端对文件的访问操作；集群中的DataNode管理存储的数据。</p></blockquote><p>HDFS公开文件系统的命名空间，并允许用户数据储存在文件中。HDFS由Java编写，因此只要能运行Java的机器，就能成为NameNode或DataNode</p><p>在内部，一个文件被拆分成1个或多个块blocks，并且这些块被存储在一系列的DataNodes中</p><p>HDFS包括一个NameNode和多个DataNodes：</p><ul><li><p>NameNode：作为主服务器，管理文件系统的命名空间和客户端对文件的访问操作；</p><p>执行文件系统操作，例如打开，关闭和重命名文件/目录。 它确定Block到DataNode的映射（找到所需的Block在哪些DataNodes中）。</p></li><li><p>DataNodes：通常，集群中的每个节点都有一个DataNode，DataNode运行在该节点之上，并管理该节点的存储</p><p>DataNode处理来自文件系统客户端的读写请求。 它们根据NameNode的指令执行块创建，删除和复制。</p></li></ul><p>根据系统偏好设置，DataNode中的块将跨多个节点复制，因此，如果一个DataNode发生故障，则包含所需数据的另一个DataNode会自动联机。</p><h4 id="HDFS-File-Writes"><a href="#HDFS-File-Writes" class="headerlink" title="HDFS File Writes"></a>HDFS File Writes</h4><ol><li>HDFS客户端把一个文件File.txt分成了多个块BlockA B C，</li><li>HDFS客户端发送写文件请求给NameNode，NameNode分配DataNodes，并返回DataNodes的地址</li><li>HDFS客户端直接将文件块写入被分配好的DataNodes</li><li>DataNode会复制数据块到其他DataNode中</li><li>下一个DataNode重复该复制操作</li></ol><p>一个文件被拆分的块blocks越多，那么在并行处理数据时，就有越多的机器可以参与进来</p><p>对于容错，每个块将在被写入时复制。Hadoop的标准是在一个集群中，每个block至少有3个copies（可配置）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u5a70f7j30rs0do77l.jpg" alt="截屏2020-03-24上午3.01.58" style="zoom:50%;" /></p><h4 id="Hadoop-Rack-Awareness-机架感知"><a href="#Hadoop-Rack-Awareness-机架感知" class="headerlink" title="Hadoop Rack Awareness 机架感知"></a>Hadoop Rack Awareness 机架感知</h4><p>机架感知确保每个块Block至少被储存在2个以上的机架Rack中（至少有一个block的备份在不同的机架中）。通过机架感知，我们可以确保数据不会因为整个机架崩溃failure而丢失</p><p>机架感知还可以尽可能让大数据在机架中流动（flows in-rack）：我们认为机架内in-rack有更高的带宽和更低的延迟</p><p>每个从属数据节点DataNode的机架号需要手动定义</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u5wn3soj30t60ciafe.jpg" alt="截屏2020-03-24上午3.02.46" style="zoom:50%;" /></p><h4 id="HDFS-Pipeline-Write-管道写"><a href="#HDFS-Pipeline-Write-管道写" class="headerlink" title="HDFS Pipeline Write 管道写"></a>HDFS Pipeline Write 管道写</h4><ol><li>在HDFS将一个块block写入集群cluster之前，它会确认是否所有需要保存块备份的DataNode都准备好了</li><li>客户端首先连接DataNode1，DN1会询问DN2，DN2会询问DN3（至少有一个DataNode在另一个机架中，不同机架的DataNode需要通过交换机Switch进行连接，同一个机架上的DataNode则通过架顶交换机TOR Switch进行连接）</li><li>如果所有DataNode都准备好了，那么DataNode1会通知客户端</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u7g7td3j30um0lwafy.jpg" alt="截屏2020-03-24上午3.03.57" style="zoom:50%;" /></p><ol><li>每个块被写入集群后，都会创建一个复制管道replication pipeline。<ul><li>意思是，当一个DataNode接受到了block数据，它会同时将block的备份推送到管道的下一个节点中</li><li><strong>机架感知</strong>会在这部分有所体现（机架内intra-rack通信速度更快）</li></ul></li><li>各个管道的初始节点都是不一样的（即两个管道的初始节点不会是同一个）</li><li>Hadoop根据配置的复制因素，使用大量的带宽和存储</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u8rk18ij31qg0j21ak.jpg" alt="截屏2020-03-24上午3.05.27"></p><h4 id="File-Spread-文件传播"><a href="#File-Spread-文件传播" class="headerlink" title="File Spread 文件传播"></a>File Spread 文件传播</h4><ul><li>理想情况下，文件最终应散布在整个机器集群中</li><li>组成文件的块blocks越多，数据可传播到的机器越多，并行处理能力越强，结果越快。</li><li>当群集扩展时，我们的网络需要适当地扩展。 </li><li>提高性能的另一种方法：pre-process some data in the edge</li></ul><h4 id="NameNode监控DataNode"><a href="#NameNode监控DataNode" class="headerlink" title="NameNode监控DataNode"></a>NameNode监控DataNode</h4><ul><li>除了持有文件系统的所有元数据，NameNode还监控DataNodes的运行状况，并协调数据访问</li><li>每3秒，通过TCP，DataNodes发送“心跳heartbeat”消息给NameNode；<ul><li>第10次心跳的消息是block report。这允许NameNode构建其元数据，并确保Block的备份数量是足够的</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4u9s5nbuj30qi0aggoi.jpg" alt="截屏2020-03-24上午3.06.30" style="zoom:50%;" /></p><ul><li>如果NameNode没有收到DataNode的心跳消息，那么就会假设DataNode出故障了。</li><li>基于NameNode之前收到的block report，它知道故障的数据节点持有哪个block，因此可以重新备份将该block到其他DataNode中<ul><li>这里再次涉及到<strong>机架感知</strong>（备份在不同的机架上）</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4uawzzyjj30sw0bqaen.jpg" alt="截屏2020-03-24上午3.07.31" style="zoom:50%;" /></p><h4 id="Secondary-NameNode-辅助节点"><a href="#Secondary-NameNode-辅助节点" class="headerlink" title="Secondary NameNode 辅助节点"></a>Secondary NameNode 辅助节点</h4><p>该辅助NameNode定时与主NameNode进行连接（默认是1小时），辅助主节点的元数据（基于内存和基于文件）</p><p>辅助NameNode合并（检查点）上述信息，并将其传递回NameNode，同时为其自身维护副本。</p><p>如果NameNode死亡，则可以使用Secondary NameNode恢复。</p><p>在繁忙的群集中，管理员可以将整理工作设置得更加频繁。</p><h4 id="HDFS客户端读文件"><a href="#HDFS客户端读文件" class="headerlink" title="HDFS客户端读文件"></a>HDFS客户端读文件</h4><p>要读取文件，客户端会查询NameNode并询问文件的块位置。</p><p>对于每个块，NameNode会返回包含该块的DataNode的列表。</p><p>客户端从每个block列表中选择一个DataNode，并使用TCP一次读取一个块。 </p><p>在前一个块完成之前，它不会进行到下一个块。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4ucqx0msj30nm0c6n0e.jpg" alt="截屏2020-03-24上午3.09.21" style="zoom:50%;" /></p><p>有时候DataNode本身也需要从HDFS中读取数据块（比如它需要处理自身没有的数据时）。这时将再次涉及<strong>机架感知</strong>，它将告诉DN最优的网络路由来从其他DN获取数据</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4uhghtkjj30vo0dudks.jpg" alt="截屏2020-03-24上午3.13.52" style="zoom:50%;" /></p><h4 id="DataNode读文件"><a href="#DataNode读文件" class="headerlink" title="DataNode读文件"></a>DataNode读文件</h4><p>有时，DataNode自身可能需要从HDFS中读取一个数据块：比如该节点被要求处理非本地数据。</p><p>该节点的机架感知Rack Awareness 可以提供最优的网络方案（比如优先选择同一机架内节点的block）</p><h4 id="HDFS的特点"><a href="#HDFS的特点" class="headerlink" title="HDFS的特点"></a>HDFS的特点</h4><p><strong>硬件故障 Hardware Failure</strong>：故障检测和快速自动恢复是HDFS的核心架构目标。</p><p><strong>可移植性 Portability</strong>：HDFS被设计为可从一个平台轻松移植到另一个平台。</p><p><strong>大数据集 Large Data Sets</strong>：典型文件的大小应为GB，TB或PB，因此HDFS已调整为支持大文件。 它可以在单个实例中支持数千万个文件。</p><p><strong>流数据访问 Streaming Data Access</strong>：HDFS设计用于批处理，而不是用户交互使用。 重点在于数据的高吞吐量而不是数据访问的低延迟。</p><p><strong>简单一致性模型 Simple Coherency Model</strong>：文件通常只创建和写入一次，不需要更改。 该假设简化了数据一致性问题。 有计划在将来支持对文件的追加写入。</p><p><strong>计算应移至数据 Move Computing To Data</strong>：如果在要处理的数据附近执行计算，效率会大大提高，尤其是在数据量很大时。 HDFS为应用程序提供了使自己更接近数据的接口。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算/04 Virtualisation</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/04%20Virtualisation/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/04%20Virtualisation/</url>
      
        <content type="html"><![CDATA[<h2 id="04-Virtualisation-1"><a href="#04-Virtualisation-1" class="headerlink" title="04 Virtualisation 1"></a>04 Virtualisation 1</h2><p>虚拟化的实现级别，机器设备级别的虚拟化，基于虚拟机监视器的虚拟化：全虚拟化、超虚拟化、硬件辅助，操作系统级的虚拟化</p><h4 id="传统电脑和虚拟机的区别"><a href="#传统电脑和虚拟机的区别" class="headerlink" title="传统电脑和虚拟机的区别"></a>传统电脑和虚拟机的区别</h4><p>对于传统电脑来说，应用安装在电脑的操作系统上，操作系统管理和使用电脑的硬件资源；对于虚拟机来说，虚拟层安装在电脑的主操作系统上，虚拟层能够模拟硬件资源，管理多个虚拟操作系统，而不同客户的软件可以分别安装在不同的虚拟操作系统上。</p><h4 id="虚拟化的定义"><a href="#虚拟化的定义" class="headerlink" title="虚拟化的定义"></a>虚拟化的定义</h4><p>不同的虚拟机VM可以在同一个物理电脑上运行不同的操作系统OS和多个软件</p><p>Hyperviosr虚拟机监视器是主要的虚拟化技术：完全模拟硬件环境</p><ul><li>虚拟机管理者通过仿真（emulation）或者硬件辅助虚拟化（hardware-assisted virtualisation），以透明的方式，分隔物理服务器主机</li></ul><p>虚拟层是底层硬件和系统的虚拟机之间的中间件</p><h4 id="虚拟机的好处——用户角度："><a href="#虚拟机的好处——用户角度：" class="headerlink" title="虚拟机的好处——用户角度："></a>虚拟机的好处——用户角度：</h4><p>更好的利用资源；减少硬件成本；改进容错；扩展容量</p><h4 id="虚拟化的实现级别"><a href="#虚拟化的实现级别" class="headerlink" title="虚拟化的实现级别"></a>虚拟化的实现级别</h4><ul><li>应用程序：将应用程序虚拟化为VM；处理级别的虚拟化；比如.NET JVM CLR</li><li>库（用户级API）：API作为虚拟化的参与者；通过API hooks控制“应用程序与系统其余部分之间”的通信链接；比如：WINE，vCURD</li><li>操作系统：在单个物理服务器和操作系统实例上创建隔离的容器，来使用硬件和软件。比如：OpenVZ</li><li>硬件抽象层HAL（Hardware Abstraction Layer，虚拟化硬件）通过虚拟化管理硬件（进程、内存、输入输出设备）：VMware、XEN</li><li>指令集结构ISA （Instruction Set Architecture）：通过主机的指令集模拟特定的指令；可以在新的主机上运行过时的二进制 legacy code 代码。比如：QEMU</li></ul><h4 id="机器级别的虚拟化"><a href="#机器级别的虚拟化" class="headerlink" title="机器级别的虚拟化"></a>机器级别的虚拟化</h4><p>2种不同的技术：托管 hosted；裸机 bare metal</p><p>技术的不同取决于所使用的Hypervisor的类型</p><p>目标是创建一个平台，使多个虚拟机可以共享相同的系统资源</p><h4 id="托管模式-Hosted-Approach：Type-2-Hypervisor"><a href="#托管模式-Hosted-Approach：Type-2-Hypervisor" class="headerlink" title="托管模式 Hosted Approach：Type 2 Hypervisor"></a>托管模式 Hosted Approach：Type 2 Hypervisor</h4><p>在主操作系统上运行；Hypervisor是硬件之上的第二层；Guest OS在hypervisor上的一层运行</p><p>比如：VMWare Workstations、Microsoft Virtual PC</p><blockquote><p>Unlike the bare-metal virtualization hypervisor, a hosted hypervisor requires you to first install an OS. These hypervisors are basically like applications that install on a guest OS. </p><p>与裸机虚拟化管理程序不同，托管管理程序要求您首先安装操作系统。 这些虚拟机管理程序基本上类似于安装在来宾OS上的应用程序。</p></blockquote><h4 id="裸机模式-Bare-Metal-Type-1-hypervisor"><a href="#裸机模式-Bare-Metal-Type-1-hypervisor" class="headerlink" title="裸机模式 Bare Metal: Type 1 hypervisor"></a>裸机模式 Bare Metal: Type 1 hypervisor</h4><p>位于裸机计算机硬件上，例如CPU，内存等；所有来宾操作系统都在Hypervisor之上；Hypervisor是硬件之上的第一层</p><blockquote><p>A bare-metal virtualization hypervisor does not require admins to install a server operating system first. Bare-metal virtualization means the hypervisor has direct access to hardware resources, which results in better performance, scalability and stability. </p><p>裸机虚拟化管理程序不需要管理员首先安装服务器操作系统。裸机虚拟化意味着管理程序可以直接访问硬件资源，从而获得更好的性能，可伸缩性和稳定性。</p></blockquote><h4 id="Hypervisor-虚拟监控程序"><a href="#Hypervisor-虚拟监控程序" class="headerlink" title="Hypervisor 虚拟监控程序"></a>Hypervisor 虚拟监控程序</h4><p>Hyperviosr在客户系统之前展示了一个虚拟的操作平台；监控和管理客户系统和虚拟机的执行；基于Hypervisor的虚拟化技术可以被分为3类</p><h4 id="全虚拟化-Full-Virtualisation"><a href="#全虚拟化-Full-Virtualisation" class="headerlink" title="全虚拟化 Full Virtualisation"></a>全虚拟化 Full Virtualisation</h4><p>通过Hypervisor，使用普通的操作系统（如Windows，Linux，即不需要专门定制）作为来宾OS运行：灵活性！</p><p>Hypervisor完全模拟或仿真基础硬件：处理所有Guest OS的硬件呼叫</p><p>关键指令由软件通过使用二进制翻译来模拟</p><p>这种二进制翻译方法会降低性能：VMWare、Microsoft Virtual Server</p><h4 id="半虚拟化-Para-Virtualisation"><a href="#半虚拟化-Para-Virtualisation" class="headerlink" title="半虚拟化 Para-Virtualisation"></a>半虚拟化 Para-Virtualisation</h4><p>将一部分虚拟化管理任务从Hypervisor中移交给了Guest OS</p><ul><li><p>需要修改Guest OS以实现以下功能：porting移植</p></li><li><p>Guest OS已显式支持（ported for）Para-Application Program Interface（API）</p><p>需要事先知道：</p><ul><li>将在虚拟平台上运行</li><li>将在哪个特定的Hypervisor上运行</li></ul></li><li><p>在安装到VM之前，要重新编译Guest OS</p></li><li><p>Guest OS与虚拟机的接口，和Guest OS与基础硬件的接口，可以不同</p><ul><li>提供专门定义的“挂钩hooks”以在主机和来宾操作系统中执行某些任务</li></ul></li><li><p>半虚拟化平台中的Hypervisor更简单，因为关键任务现在在操作系统中执行，而不是由Hypervisor执行</p><ul><li>由于虚拟化开销减少，因此性能提高。</li></ul></li><li><p>缺点：</p><ul><li>由于修改了操作系统，降低了兼容性和可移植性；</li><li>由于OS的深层修改，维护成本很高。</li></ul></li></ul><h4 id="硬件辅助虚拟化-Hardware-Assisted-Virtualisation"><a href="#硬件辅助虚拟化-Hardware-Assisted-Virtualisation" class="headerlink" title="硬件辅助虚拟化 Hardware-Assisted Virtualisation"></a>硬件辅助虚拟化 <strong>Hardware-Assisted Virtualisation</strong></h4><p>不需要Hypervisor，虚拟客户操作系统直接与硬件交互</p><ul><li>硬件商专门为支持虚拟化定制的硬件</li><li>处理器中包含虚拟化特性</li><li>允许来Guest OS中的某些特权CPU调用直接由CPU处理：不需要通过Hypervisor对这些调用进行翻译</li><li>比如：AMD虚拟化（AMD-V）、英特尔-虚拟化技术（Intel-VT）</li></ul><h4 id="操作系统级别的虚拟化"><a href="#操作系统级别的虚拟化" class="headerlink" title="操作系统级别的虚拟化"></a>操作系统级别的虚拟化</h4><p>虚拟服务器：由操作系统的共享内核启用；与父系统具有相同的操作系统</p><p>如：FeeBSD jail，Linux Vserver，OpenVZ</p><p>优点：更轻量级</p><h4 id="Hypervisor的定义"><a href="#Hypervisor的定义" class="headerlink" title="Hypervisor的定义"></a>Hypervisor的定义</h4><p>是一个软件层，用于裸机硬件的虚拟化。该层可以被实现为操作系统的微型内核（micro-kernel）。它将物理设备转化为虚拟资源，使用户软件可以运行在虚拟机上</p><h4 id="XEN架构"><a href="#XEN架构" class="headerlink" title="XEN架构"></a>XEN架构</h4><p>特殊的Domain 0用于控制和I/O，其他Guest Domain用于用户的应用</p><h4 id="传统物理机器-vs-3种虚拟机结构"><a href="#传统物理机器-vs-3种虚拟机结构" class="headerlink" title="传统物理机器 vs 3种虚拟机结构"></a>传统物理机器 vs 3种虚拟机结构</h4><ul><li>Physical Machine 物理机器：操作系统以特权模式执行</li><li>Native VM 本地虚拟机：VMM在特权模式下运行</li><li>Hosted VM 托管虚拟机：受信任的主机OS在托管的VM系统中以特权模式执行。来宾操作系统驻留在VM中，并以较低的特权级别运行</li><li>Dual-mode VM 双模虚拟机：VMM的某些部分在特权模式下运行。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/04_ hosted and bare-metal virtualization</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/04_%20hosted%20and%20bare-metal%20virtualization/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/04_%20hosted%20and%20bare-metal%20virtualization/</url>
      
        <content type="html"><![CDATA[<h2 id="hosted-and-bare-metal-virtualization"><a href="#hosted-and-bare-metal-virtualization" class="headerlink" title="hosted and bare-metal virtualization"></a>hosted and bare-metal virtualization</h2><p>When choosing a <a href="https://searchservervirtualization.techtarget.com/definition/hypervisor" target="_blank" rel="noopener">virtualization hypervisor</a>, you have to consider both <a href="https://searchservervirtualization.techtarget.com/tip/Virtualization-hypervisor-comparison-Type-1-vs-Type-2-hypervisors" target="_blank" rel="noopener">hypervisor types</a>.</p><p>A virtualization hypervisor comes in one of two forms: a bare-metal hypervisor, also known as Type 1; or a hosted hypervisor, also known as Type 2. There are important differences between a hosted and bare-metal virtualization hypervisor, and each has pretty specific use cases.</p><p><strong>Bare-metal virtualization hypervisors</strong></p><p>A bare-metal virtualization hypervisor does not require admins to install a server operating system first. Bare-metal virtualization means the hypervisor has direct access to hardware resources, which results in better performance, scalability and stability. One disadvantage of a bare-metal virtualization hypervisor, however, is that hardware support is typically more limited, because the hypervisor usually has limited device drivers built into it.</p><p>Bare-metal virtualization  is well suited for enterprise data centers, because it usually comes with advanced features for resource management, high availability and security. Admins can centrally manage this kind of virtualization hypervisor, which is critical when you have many hosts in your virtual infrastructure. The most popular bare-metal virtualization hypervisors are:</p><ul><li>VMware ESX and ESXi</li><li><a href="https://searchservervirtualization.techtarget.com/tip/How-the-Hyper-V-architecture-differs-from-VMware-ESXi" target="_blank" rel="noopener">Microsoft Hyper-V</a></li><li>Citrix Systems XenServer</li></ul><h3 id="Hosted-virtualization-hypervisors"><a href="#Hosted-virtualization-hypervisors" class="headerlink" title="Hosted virtualization hypervisors"></a><strong>Hosted virtualization hypervisors</strong></h3><p>Unlike the bare-metal virtualization hypervisor, a hosted hypervisor requires you to first install an OS. These hypervisors are basically like applications that install on a guest OS. This approach provides better hardware compatibility than bare-metal virtualization, because the OS is responsible for the hardware drivers instead of the hypervisor.</p><p>But, as with the bare-metal hypervisor, there are disadvantages. A hosted virtualization hypervisor does not have direct access to hardware and must go through the OS, which increases resource overhead and can degrade virtual machine (VM) performance. Also, because there are typically many services and applications running on the <a href="https://searchvmware.techtarget.com/definition/host-operating-system" target="_blank" rel="noopener">host OS</a>, the hypervisor often steals resources from the VMs running on it.</p><p>Hosted hypervisors are common for desktops, because they allow you to run multiple OSes. These virtualization hypervisor types are also popular for developers, to maintain application compatibility on modern OSes. The most popular hosted virtualization hypervisors are:</p><ul><li>VMware Workstation, Server, Player and Fusion</li><li>Oracle VM VirtualBox</li><li>Microsoft Virtual PC</li><li>Parallels Desktop</li></ul><p>Once you understand the differences between a hosted and bare-metal virtualization hypervisor — and the best use cases for each — it’s time to consider hypervisor vendors, cost and features.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘和文本分析/06 Supervised ML to learn Classifiers Decision Trees and Classification Rules</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/06%20Supervised%20ML%20to%20learn%20Classifiers%20Decision%20Trees%20and%20Classification%20Rules/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/06%20Supervised%20ML%20to%20learn%20Classifiers%20Decision%20Trees%20and%20Classification%20Rules/</url>
      
        <content type="html"><![CDATA[<h2 id="06-Supervised-ML-to-learn-Classifiers-Decision-Trees-and-Classification-Rules"><a href="#06-Supervised-ML-to-learn-Classifiers-Decision-Trees-and-Classification-Rules" class="headerlink" title="06 Supervised ML to learn Classifiers: Decision Trees and Classification Rules"></a>06 Supervised ML to learn Classifiers: Decision Trees and Classification Rules</h2><h4 id="数据挖掘的目标"><a href="#数据挖掘的目标" class="headerlink" title="数据挖掘的目标"></a>数据挖掘的目标</h4><p>发现数据中有用的模式，因此我们需要数据挖掘技术、算法、工具（如Weka），和用于采集数据，应用算法的方法学框架（CRISP-DM）</p><p>机器学习中的监督学习：训练集已经被分类</p><h4 id="概念-Concept"><a href="#概念-Concept" class="headerlink" title="概念 Concept"></a>概念 Concept</h4><p>Concept 的定义：</p><ul><li>数据集间的关键区别：比如某区域不同年份的销售额sales的区别</li><li>簇clusters 或自然分隔partitions：根据用户的购物习惯对用户进行分类</li><li><p>分类的规则：Adj+X+Verb =&gt; X=Noun</p></li><li><p>通用的关联：高频词一般是语法性的，而不是有含义的</p></li><li>数字的预测：找到预测数值的规则，比如根据成绩预测毕业生的工资</li></ul><h4 id="决策树的构建方法"><a href="#决策树的构建方法" class="headerlink" title="决策树的构建方法"></a>决策树的构建方法</h4><p>建立决策树</p><p>决定用哪个属性划分节点：基于entropy熵</p><p>避免过度拟合：决策树太复杂，能够精确的描述训练集，但不适合用于预测</p><p>异常点</p><h4 id="建立决策树"><a href="#建立决策树" class="headerlink" title="建立决策树"></a>建立决策树</h4><p>算法是递归的</p><p>节点表示在该属性值上进行分类（测试），分支表示分类（测试）的输出</p><p>决策树算法会选择information gain最高的属性进行划分</p><p>目标：更小更紧凑的树（节点数量少），和更低的错误率（错误划分）；如果精确度相同，那么优先选择更小的树</p><h4 id="Entropy-熵"><a href="#Entropy-熵" class="headerlink" title="Entropy 熵"></a>Entropy 熵</h4><p>$H=E(I)=\sum_i(-p_ilog_2p_i)$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Information_Gain &#x3D; Entropy_before - Entropy_after</span><br></pre></td></tr></table></figure><p>ID3会选择information gain最高的属性进行划分</p><p>划分后的熵越低，最后得到的Information gain越高</p><p>该属性中，如果多个分类的数量都一样，那么熵最高；如果只有一个分类，那么熵最低</p><p>所以，如果对一个属性划分后，只有一个种类，那么决策树就会选择该属性进行划分</p><h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><p>混淆矩阵</p><p>如果决策树算法已“过度拟合”数据，则基于训练集的错误率将远小于基于测试集的错误率。</p><p>10-fold cross-validation：将数据集随机分成10组（subsets），9组用于训练，1组用于测试，然后循环10次。</p><h4 id="决策树-gt-规则-Rules"><a href="#决策树-gt-规则-Rules" class="headerlink" title="决策树 =&gt; 规则 Rules"></a>决策树 =&gt; 规则 Rules</h4><p>决策树可能不容易解释</p><ul><li>与较低节点相关的测试（属性），不得不在树的更远端中读取</li><li>有时可能会将“子概念”分解并分发到树的不同部分</li><li>计算机科学家可能更喜欢“If…then…”规则！</li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>决策树可用于预测或解释。<ul><li>预测：将未分类的实例与树进行比较，并预测其属于哪个类（带有错误估计）</li><li>解释：检查树并尝试了解实例为何最终归入它们所在的类。</li></ul></li><li>规则集通常更易于解释</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘和文本分析/04 Data Mining and Knowledge Management</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/04%20Data%20Mining%20and%20Knowledge%20Management/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/04%20Data%20Mining%20and%20Knowledge%20Management/</url>
      
        <content type="html"><![CDATA[<h2 id="04-Data-Mining-and-Knowledge-Management"><a href="#04-Data-Mining-and-Knowledge-Management" class="headerlink" title="04 Data Mining and Knowledge Management"></a>04 Data Mining and Knowledge Management</h2><p>数据挖掘利用机器学习从数据中提取/发现知识，用于知识管理。</p><p>什么是知识？管理/发现知识是什么意思？信息技术有什么用？</p><h4 id="柯林斯英语词典中的定义"><a href="#柯林斯英语词典中的定义" class="headerlink" title="柯林斯英语词典中的定义"></a>柯林斯英语词典中的定义</h4><p>一个人或一群人知道的事实、感觉、经验；知道的状态；通过经验或学习所获得的感知、意识、熟悉感；博学或知情的学习；关于某主题的特定信息</p><h4 id="朗文当代英语词典中的定义"><a href="#朗文当代英语词典中的定义" class="headerlink" title="朗文当代英语词典中的定义"></a>朗文当代英语词典中的定义</h4><p>一个人或一群人知道的事实、感觉、经验；知道某事发生过或者是真的；你所知道的关于特定的情况、事件的信息；</p><h4 id="“知识管理”中的知识"><a href="#“知识管理”中的知识" class="headerlink" title="“知识管理”中的知识"></a>“知识管理”中的知识</h4><p>三种含义：</p><ul><li>知道或熟悉或熟悉的状态（知道是什么）</li><li>行动能力（知道怎么做）</li><li>整理，记录，积累事实，方法，原理，技术</li></ul><h4 id="“知识库”中的的知识"><a href="#“知识库”中的的知识" class="headerlink" title="“知识库”中的的知识"></a>“知识库”中的的知识</h4><p>除了示例，没有对“知识库”的定义。<br>Knowledge based：推论新事实的事实和逻辑规则，例如：如果（sun = yes）和（湿度= low）然后play = yes …而且还有信息检索，语言/语音/图像</p><h4 id="Explicit-Knowledge-显性知识"><a href="#Explicit-Knowledge-显性知识" class="headerlink" title="Explicit Knowledge 显性知识"></a>Explicit Knowledge 显性知识</h4><p><strong>以文本形式记录下be articulated（清晰表达）的知识</strong>：产品规格、科学公式、电脑程序、专利、记录的最佳实践、手册。</p><p>可以储存于可以存储在知识库中（如果我们可以解决数据捕获/转换的问题，…）</p><h4 id="Tacit-Knowledge-隐性知识"><a href="#Tacit-Knowledge-隐性知识" class="headerlink" title="Tacit Knowledge 隐性知识"></a>Tacit Knowledge 隐性知识</h4><p><strong>无法以文本形式记录下来（无法清晰表达）的知识</strong>：如何骑单车、如何识别脸、如何理解句子、如何创造艺术</p><p>AI试图将隐性知识改写为显性知识，例如处理英语句子的规则</p><h4 id="Implicit-Knowledge-内含知识"><a href="#Implicit-Knowledge-内含知识" class="headerlink" title="Implicit Knowledge 内含知识"></a>Implicit Knowledge 内含知识</h4><p><strong>可以表达但尚未表达的知识</strong>：培训知识工程师和系统分析员，以识别隐性知识并帮助专家表达其知识。</p><p>可以储存于可以存储在知识库中（如果我们可以解决数据捕获/转换的问题，…）</p><h4 id="Cultural-Knowledge-文化知识"><a href="#Cultural-Knowledge-文化知识" class="headerlink" title="Cultural Knowledge 文化知识"></a>Cultural Knowledge 文化知识</h4><p><strong>（文化或环境带来的知识）</strong></p><p>一个组织对自身及其环境的了解（“元知识”？）：共同的信念，规范和价值观；组织成员在其中构筑现实的框架；需要了解和使用事实，规则和试探法；需要以与其他人相同的方式进行归纳，以便采取一致行动</p><h4 id="Terminology术语-and-Ontology本体"><a href="#Terminology术语-and-Ontology本体" class="headerlink" title="Terminology术语 and Ontology本体"></a>Terminology术语 and Ontology本体</h4><ul><li>本体Ontology：学科中的“概念”，和这些概念之间的意义关系<ul><li>“概念”大致等同于术语Terminology：学科中的专业单词和短语</li></ul></li><li>术语Terminology和本体论对学科中的知识进行编码</li></ul><h4 id="从数据到知识"><a href="#从数据到知识" class="headerlink" title="从数据到知识"></a>从数据到知识</h4><p>信号 Signals =1.=&gt; 数据 Data =2.=&gt; 信息 Information =3.=&gt; 知识 Knowledge</p><ol><li>物理 Physical 构造：感知、选择</li><li>认知 Cognitive 构造：意义、重要性</li><li>信念 Belief 构造：信念、证明</li></ol><h4 id="数据的不同角度（术语解释）"><a href="#数据的不同角度（术语解释）" class="headerlink" title="数据的不同角度（术语解释）"></a>数据的不同角度（术语解释）</h4><p>数据挖掘：发现数据中的模式（知识）</p><p>机器学习：算法，用于发现数据中的知识</p><p>知识发现：发现（数据中的）知识</p><p>数据库：存储知识</p><p>信息管理：使用数据</p><p>知识管理：发现并使用数据中的模式，“驯服数据”</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>数据挖掘不只是关于数据库技术</p><p>数据挖掘包括：获取数据、清洗数据、从数据中提取有用的结构或知识</p><p>数据不仅仅在数据库中</p><p>网络中大多数的数据或信息，是非结构化的文本（HTML/XML标记多少有点帮助）</p><p>所以我们需要提取、清洗、格式化数据，从“网络”的格式转化为“类似于数据库”的格式，用于数据挖掘</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/03_ Differences between ASIC, ASSP, ASIP, SoC, FPGA</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20Differences%20between%20ASIC,%20ASSP,%20ASIP,%20SoC,%20FPGA/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20Differences%20between%20ASIC,%20ASSP,%20ASIP,%20SoC,%20FPGA/</url>
      
        <content type="html"><![CDATA[<h3 id="Differences-between-ASIC-ASSP-ASIP-SoC-FPGA"><a href="#Differences-between-ASIC-ASSP-ASIP-SoC-FPGA" class="headerlink" title="Differences between ASIC, ASSP, ASIP, SoC, FPGA"></a>Differences between ASIC, ASSP, ASIP, SoC, FPGA</h3><p><strong>ASIC</strong> (Application Specified Integrated Circuit) is a customized integrated circuit. It is usually used by a person or company for a very limited usage. So when it is developed, only the person or company who orders it can use it. It is not useful for other usages, for example, an IC designed for a specific line of cellular phones of a company, whereby no other products can use it except the cell phones belonging to that product line.<br>- ASIC is just built for one and only one customer.<br>- ASIC is used only in one product line<br>- Only volume production of ASICs for one product can make sense which means low unit cost for high volume products, otherwise the cost is not efficient.<br>- Can exploit parallelism to achieve high performance<br>- Low power consumption</p><p><strong>ASSP</strong> (Application Specified Standard Processor) is an integrated circuit that implements a specific function that appeals to a wide market, which means its function is specified for example a motor drive chip. But it is used widely, not limited to only one customer as ASIC does. So ASSPs are available as off-the-shelf components which means you can go to electronic shops and just buy it directly from the “shelf”. It means ASSPs have been developed well and you can just buy it without designing it from scratch.<br>- It addresses the product space between ASIC and generic processor based products<br>- Extremely useful for low to medium volume applications because it help reduce cost and design overheads.</p><p><strong>ASIP</strong> (application specific instruction processor) is usually used in SoC (System on a Chip). ASIP is an architecture including two parts which are a minimum ISA (Instruction Set Archietecture) and a configurable logic which you can use to design your own instruction set. So it provides relatively high flexibility compared to ASIC and better performance compared to FPGA (Field Programmable Gate Array). Also, it is cheaper than FPGA, but slightly more expensive than ASIC.<br>- ASIP can help build your own instruction set to meet your specific requirement.<br>- It provide a minimum ISA, which can make shorter TTM (Time to Market).</p><h4 id="How-to-choose-ASIC-or-ASSP"><a href="#How-to-choose-ASIC-or-ASSP" class="headerlink" title="How to choose ASIC or ASSP?"></a>How to choose ASIC or ASSP?</h4><p>- Whether TTM (Time-To-Marker) allows to design an ASIC<br>- Whether you have special requirement for your design which is not common in ASSPs, for example, you can exploit parallelism to achieve high performance<br>- Whether your products can have a big volume in market<br>- Power consumption requirement<br>- Whether software development tools are available<br>- How is the skill of the developers, whether they are capable for designing an ASIC<br>- Whether you can burden the technology risk for designing AISC<br>- How much is your plan for NRE (Non-Recurring Expense) cost to the project: ASIC needs relatively large NRE cost, and ASSP needs no NRE cost.</p><h4 id="There-is-a-lot-of-confusion-with-regard-to-devices-like-ASICs-ASSPs-SoCs-and-FPGAs-Is-an-SoC-an-ASIC-or-vice-versa-for-example"><a href="#There-is-a-lot-of-confusion-with-regard-to-devices-like-ASICs-ASSPs-SoCs-and-FPGAs-Is-an-SoC-an-ASIC-or-vice-versa-for-example" class="headerlink" title="There is a lot of confusion with regard to devices like ASICs, ASSPs, SoCs, and FPGAs. Is an SoC an ASIC, or vice versa, for example?"></a><strong>There is a lot of confusion with regard to devices like ASICs, ASSPs, SoCs, and FPGAs. Is an SoC an ASIC, or vice versa, for example?</strong></h4><p>I often receive questions about the differences between various types of devices, such as ASICs, ASSPs, SoCs, and FPGAs. Is an SoC an ASIC, or vice versa, for example? What’s the difference between an ASIC and an ASSP? And should a high-end FPGA be classed as a form of SoC?</p><p>There are several problems here, not the least that the technologies and terminologies have evolved over time. Keeping this in mind, the following is my highly simplified interpretation of where these terms came from and what they mean today.</p><p><strong>ASICs</strong><br>Let’s start with an application-specific integrated circuit (ASIC). As the name suggests, this is a device that is created with a specific purpose in mind. When most people hear the term ASIC, their “knee-jerk” reaction is to assume a digital device. In reality, any chip that is custom-made is an ASIC, irrespective of whether it is analog, digital, or a mix of both. For the purposes of these discussions, however, we shall assume a chip that is either wholly or predominantly digital in nature, with any analog and mixed-signal functions being along the lines of physical interfaces (PHYs) or phase-locked loops (PLLs).</p><p>ASICs are typically designed and used by a single company in a specific system. They are incredibly expensive, time-consuming, and resource-intensive to develop, but they do offer extremely high performance coupled with low power consumption.</p><p><strong>ASSPs</strong><br>Application-specific standard parts (ASSPs) are designed and implemented in exactly the same way as ASICs. This is not surprising, because they are essentially the same thing. The only difference is that an ASSP is a more general-purpose device that is intended for use by multiple system design houses. For example, a standalone USB interface chip would be classed as an ASSP.</p><p><strong>SoCs</strong><br>A System-on-Chip (SoC) is a silicon chip that contains one or more processor cores — microprocessors (MPUs) and/or microcontrollers (MCUs) and/or digital signal processors (DSPs) — along with on-chip memory, hardware accelerator functions, peripheral functions, and (potentially) all sorts of other “stuff.” One way to look at this is that if an ASIC contains one or more processor cores then it’s an SoC. Similarly, if an ASSP contains one or more processor cores then <em>it’s</em> an SoC.</p><p><img src="https://www.eetimes.com/wp-content/uploads/2019/12/asic-fpga-soc-max-0326-01.gif?resize=405%2C188" alt="img"></p><p>On this basis, we could view ASIC (and ASSP) as being the superset term because it embraces SoC, or we could regard the SoC as being the superset term because it includes everything in an ASIC (or ASSP) along with one or more processor cores. Are we having fun yet?</p><p><strong>FPGAs</strong><br>ASICs, ASSPs, and SoCs offer high-performance and low power consumption, but any algorithms they contain — apart from those that are executed in software on internal processor cores — are “frozen in silicon.” And so we come to field-programmable gate arrays (FPGAs). The architecture of early FPGA devices was relatively simple — just an array of programmable blocks linked by programmable interconnect.</p><p>The great thing about an FPGA is that we can configure its programmable fabric to implement any combination of digital functions we desire. Also, we can implement algorithms in a massively parallel fashion, which means we can perform a humongous amount of data processing very quickly and efficiently.</p><p><strong>SoC-class FPGAs</strong><br>Over time, the capabilities (capacity and performance) of FPGAs increased dramatically. For example, a modern FPGA might contain thousands of adders, multipliers, and digital signal processing (DSP) functions; megabits of on-chip memory, large numbers of high-speed serial interconnect (SERDES) transceiver blocks, and a host of other functions.</p><p>The problem is that the field-programmable gate array (FPGA) moniker no longer reflects the capabilities and functionality of today’s programmable devices. We really need to come up with some new terminology that embraces everything today’s state-of-the-art tools and technologies are capable of doing.</p><p>Of particular relevance to our discussions here is the fact that today’s FPGAs can contain one or more soft and/or hard core processors. On this basis, should we class this type of FPGA as being an SoC? Well, personally I have to say that SoC doesn’t work for me, because I equate the term “SoC” with a custom device created using ASIC technology.</p><p>Another alternative would be to call these devices Programmable SoCs, or PSoCs, but Cypress Semiconductor has already got the PSoC moniker locked down. The Cypress devices feature a hard microcontroller core augmented with some programmable analog and programmable digital fabric (the digital fabric is more CPLD than FPGA).</p><p>Altera used to call its versions of these devices — the ones that combine hard MCU cores with programmable FPGA fabric — SoC FPGAs, but they seem to have evolved to just calling them SoCs. Meanwhile, Xilinx calls its flavor of these devices “All Programmable SoCs.”</p><p>Personally, I’m undecided as to what would be the best name. I think I’d prefer to use PSoC if the folks at Cypress hadn’t already taken control of this appellation, but they have, so we can’t. Failing this, I guess I’d opt for SoC FPGA… unless you can suggest something better.</p><p>— Max Maxfield, Editor of All Things Fun &amp; Interesting</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人工智能/02 Image classification using CNNs</title>
      <link href="/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/02%20Image%20classification%20using%20CNNs/"/>
      <url>/2020/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/02%20Image%20classification%20using%20CNNs/</url>
      
        <content type="html"><![CDATA[<h2 id="02-Image-classification-using-CNNs"><a href="#02-Image-classification-using-CNNs" class="headerlink" title="02 Image classification using CNNs"></a>02 Image classification using CNNs</h2><p>经典的神经网络模型，需要读取整幅图像作为神经网络模型的输入（即全连接的方式），当图像的尺寸越大时，其连接的参数将变得很多，从而导致计算量非常大。</p><p>在图像中的空间联系中，局部范围内的像素之间联系较为紧密，而距离较远的像素则相关性较弱。因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。这种模式就是卷积神经网络中降低参数数目的重要神器：局部感受野。</p><h4 id="Convolution卷积"><a href="#Convolution卷积" class="headerlink" title="Convolution卷积"></a>Convolution卷积</h4><p>以每一个像素为中心，以一个n*n的遮罩（特征）mask为过滤器，在原图中移动，进行加权求和，并代替该像素的值。</p><h4 id="Padding-四周填充"><a href="#Padding-四周填充" class="headerlink" title="Padding 四周填充"></a>Padding 四周填充</h4><p>比如 zero padding</p><h4 id="Stride-间隔"><a href="#Stride-间隔" class="headerlink" title="Stride 间隔"></a>Stride 间隔</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblrn8qhqmj30fo0gadlf.jpg" alt="截屏2020-02-05上午11.49.29" style="zoom:33%;" /></p><h4 id="Dilation-扩大"><a href="#Dilation-扩大" class="headerlink" title="Dilation 扩大"></a>Dilation 扩大</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblrnc9y6vj30f80ho0ys.jpg" alt="截屏2020-02-05上午11.49.40" style="zoom:33%;" /></p><h4 id="Gaussian-mask（高斯模糊、高斯平滑）"><a href="#Gaussian-mask（高斯模糊、高斯平滑）" class="headerlink" title="Gaussian mask（高斯模糊、高斯平滑）"></a>Gaussian mask（高斯模糊、高斯平滑）</h4><p>从数学的角度来看，图像的高斯模糊过程就是图像与正态分布做卷积。</p><p>每个像素的值都是周围相邻像素值的加权平均。原始像素的值有最大的高斯分布值，所以有最大的权重，相邻像素随着距离原始像素越来越远，其权重也越来越小。</p><p>整个过程也被称为过滤</p><h4 id="局部对比度归一化-Local-Contrast-Normalisation"><a href="#局部对比度归一化-Local-Contrast-Normalisation" class="headerlink" title="局部对比度归一化 Local Contrast Normalisation"></a>局部对比度归一化 Local Contrast Normalisation</h4><p>用于消除整个图像强度intensity的大规模变化variations。</p><blockquote><p>它使用一个9x9的内核在通道上卷积图像，其权重为均值0，方差1的高斯函数。将图像居中后（通过从图像中减去上述输出），确定其方差。然后，找到所有像素的标准偏差的平均值。之后，将中心图像除以max（standard_deviation，mean_standard_deviation）以得到LCN_Image。</p></blockquote><h4 id="学习图像特征"><a href="#学习图像特征" class="headerlink" title="学习图像特征"></a>学习图像特征</h4><ol><li>数据采集：采样大量图像补丁patch（例如20,000个15x15补丁）</li><li>聚类：将二维向量转化为一维向量，在此向量空间中查找聚类，这些聚类定义了不同的特征</li></ol><h4 id="特征地图"><a href="#特征地图" class="headerlink" title="特征地图"></a>特征地图</h4><p>用特征图形补丁（过滤器）过滤图像，对匹配的部分进行上色</p><h4 id="单层卷积网络"><a href="#单层卷积网络" class="headerlink" title="单层卷积网络"></a>单层卷积网络</h4><h4 id="ReLU激活函数"><a href="#ReLU激活函数" class="headerlink" title="ReLU激活函数"></a>ReLU激活函数</h4><p>rectified linear activation function（ReLU），该算法的关键思想是让感知机专注于positive value</p><blockquote><p>线性整流函数（Rectified Linear Unit, ReLU），又称修正线性单元，是一种人工神经网络中常用的激活函数（activation function），通常指代以斜坡函数及其变种为代表的非线性函数：即对于输入的负值，输出全为0，对于正值，则原样输出</p></blockquote><h4 id="卷积神经网络-Convolutional-Neural-Network"><a href="#卷积神经网络-Convolutional-Neural-Network" class="headerlink" title="卷积神经网络 Convolutional Neural Network"></a>卷积神经网络 Convolutional Neural Network</h4><h4 id="Pooling-池化"><a href="#Pooling-池化" class="headerlink" title="Pooling 池化"></a>Pooling 池化</h4><p>池化就是将输入图像进行缩小，减少像素信息，只保留重要信息，能有效地减少计算量<br>池化的操作也很简单，通常情况下，池化区域是2*2大小，然后按一定规则转换成相应的值，例如取这个池化区域内的最大值（max-pooling）、平均值（mean-pooling）等，以这个值作为结果的像素值。</p><h4 id="Softmax-function"><a href="#Softmax-function" class="headerlink" title="Softmax function"></a>Softmax function</h4><p>维度归一化，且所有维度之和为1</p><p>softmax设计的初衷，是希望特征对概率的影响是乘性的。</p><p>我们希望分值大的那一项被经常取到，而分值较小的那一项也有一定的概率偶尔被取到，所以我们就应用到了soft的概念，即最后的输出是每个分类被取到的概率。</p><h4 id="conditional-probability-distribution"><a href="#conditional-probability-distribution" class="headerlink" title="conditional probability distribution"></a>conditional probability distribution</h4><p>最大化probability，以最小化loss。采用梯度下降</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/05%20MapReduce/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/05%20MapReduce/</url>
      
        <content type="html"><![CDATA[<p>大数据的挑战、MapReduce、Hadoop、例子</p><a id="more"></a><h4 id="大数据的挑战"><a href="#大数据的挑战" class="headerlink" title="大数据的挑战"></a>大数据的挑战</h4><ul><li>大量的数据：数据产生的速度和数据的种类在快速的增长</li><li>数据描述：用于描述内容的媒体数据和语义</li><li>搜索：语义嵌入的搜索引擎</li><li>存储：重建比存储更容易；有用数据和噪音的比例；公司会存储所有类型的数据</li><li>数据采集：信息和知识；质量控制</li></ul><h4 id="解决方案：并行化"><a href="#解决方案：并行化" class="headerlink" title="解决方案：并行化"></a>解决方案：并行化</h4><p>将工作分割处理Partition，然后合并Combine</p><h4 id="并行化的挑战-1"><a href="#并行化的挑战-1" class="headerlink" title="并行化的挑战 1"></a>并行化的挑战 1</h4><ul><li>Scheduling 调度：如何分配任务给不同的worker</li><li>可用性：如果工作单元work units比worker更多该怎么做</li><li>依赖 Dependencies：process 不要相互依赖（并行化的关键）；workers如何共享资源；如何确定所有works的任务都完成了</li><li>容错：如果worker在执行中出错怎么办</li><li>通信和同步：workers之间交换状态state和访问共享资源（如数据）</li></ul><h4 id="当前的工具"><a href="#当前的工具" class="headerlink" title="当前的工具"></a>当前的工具</h4><p>编程模型：共享内存、消息传递</p><p>设计模式：主从（Master-slaves）模式、生产者消费者流模式（Producer-consumer flows）：1.循环；2.工作队列</p><h4 id="并行化的挑战-2"><a href="#并行化的挑战-2" class="headerlink" title="并行化的挑战 2"></a>并行化的挑战 2</h4><p>并发 <strong>Concurrency</strong>：当考虑数据中心的规模，错误，多个服务之间的交互</p><p>负载平衡 <strong>Shifting the burden</strong>：开发人员制定需要执行的计算；处理实际执行任务的执行框架（在运行时）。</p><h4 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h4><p>是一个编程模型，用于在大规模系统中表达分布式计算；是一个用于zu</p><p>怎么把计算任务拆分，分配到不同的处理器中</p><p>Hadoop是MapReduce的开源实现之一</p><h4 id="MapReduce的步骤"><a href="#MapReduce的步骤" class="headerlink" title="MapReduce的步骤"></a>MapReduce的步骤</h4><ol><li>对大量的记录进行迭代</li><li>对每个记录提取感兴趣的信息——Map</li><li>对中间结果进行shuffle和sort</li><li>把中间结果合并为可用的格式，并产生结果——Reduce</li></ol><h4 id="MapReduce模型"><a href="#MapReduce模型" class="headerlink" title="MapReduce模型"></a>MapReduce模型</h4><p><strong>map(k,v)：</strong>Map 把原始数据转化为键值对 <key,val></p><p><strong>reduce(k*,v*)：</strong>Reduce 对键值对组<key,[val, val, ...]>进行处理</p><ul><li>All values with the same key are sent to the same Reducer.把相同Key的值封装在一起</li></ul><p>Shuffle and Sort 把按照键值排序和合并<key,[val, val, ...]>，把相同Key的键值对发送给同一个Reduce进程</p><p>执行框架Execution framework处理其他所有的工作</p><p>其他可编程的部分还有</p><p><strong>partition(k’, number of partition)</strong>：按key将任务拆分，并行处理reduce操作，相同的Key交给相同的Reducer</p><p><strong>combine(k’, v’)</strong>：迷你Reducer，在内存中运行，在map阶段后运行；用于优化，减少网络负载network traffic（减少需要传递的数据）</p><h4 id="运行时-Runtime"><a href="#运行时-Runtime" class="headerlink" title="运行时 Runtime"></a>运行时 Runtime</h4><p>处理调度：将workers分配到Map和Reduce任务中</p><p>处理“数据分布”：将processes移动到data上</p><p>处理同步：采集、排序、重组中间（过渡）数据</p><p>处理错误：检测workers的错误，并重新开始</p><h4 id="分布式文件系统-DFS"><a href="#分布式文件系统-DFS" class="headerlink" title="分布式文件系统 DFS"></a>分布式文件系统 DFS</h4><p>不要移动数据，而是移动workers：将数据存储在集群节点的本地磁盘中，启动该节点中的workers。例子：</p><ul><li><strong>Job Tracker</strong> 查看 <strong>NameNode</strong> 以了解哪些 <strong>DataNode</strong> 具有文件块。然后，<strong>Job Tracker</strong> 为”具有文件块的节点“上的 <strong>Task Tracker</strong> 提供执行Map计算所需的Java代码，让代码在节点本地计算。Job Tracker将始终尝试为Map任务选择具有本地数据的节点。</li></ul><p>原因：memory中的RAM不足以存放所有的数据；磁盘访问很慢，但磁盘的吞吐量是合理的</p><p>解决方案：分布式文件系统：GFS、HDFS</p><h4 id="MapReduce的特征"><a href="#MapReduce的特征" class="headerlink" title="MapReduce的特征"></a>MapReduce的特征</h4><p>Map的输出和Reduce的输入和输出都是<strong>键值对</strong></p><p>任务相互独立：比如不同Map的输出不会相互依赖</p><p>Reduce阶段必须等到Map完成后才会开始</p><p>MapReduce关注调度任务scheduling tasks，对他们进行监控以及对错误的任务重新执行</p><p>数据在MapReduce中是不可改变的，也就是说无法更新</p><h4 id="Hadoop例子"><a href="#Hadoop例子" class="headerlink" title="Hadoop例子"></a>Hadoop例子</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4rwj3cqtj30kk0fkjv2.jpg" alt="截屏2020-03-24上午1.44.31" style="zoom:50%;" /></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ol><li>客户端将MapReduce任务提交给 <strong>Job Tracker</strong></li><li><strong>Job Tracker</strong> 查看 <strong>NameNode</strong> 以了解哪些 <strong>DataNode</strong> 具有 file blocks文件块。</li><li>然后，<strong>Job Tracker</strong> 为”具有文件块的节点“上的 <strong>Task Tracker</strong> 提供执行Map计算所需的Java代码，让代码在节点本地计算</li><li><strong>Task Tracker</strong>启动Map任务并监视其进度。 它将心跳和任务状态返回给<strong>Job Tracker</strong>。</li><li>每个Map任务完成时，其节点将结果存储在临时存储区中（中间数据 <strong>intermediate data</strong>）。</li><li>当所有Map都完成后，它将通过网络发送到运行reduce任务的节点</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4rx2v3fmj30me0d0dip.jpg" alt="截屏2020-03-24上午1.45.02" style="zoom:50%;" /></p><ul><li>Job Tracker将始终尝试为Map任务选择具有本地数据的节点。这可能做不到（例如，具有本地数据的节点可能已经在运行许多其他任务）</li><li>在这种情况下，Job Tracker将尝试尽可能将任务分配给与数据位于同一机架中的节（使用机架感知 Rack Awareness）。</li><li>NameNode将指示节点从相关DataNode复制数据。</li></ul><h5 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h5><ol><li>Job Tracker在集群中的任何节点上启动Reduce任务</li><li>它引导Reduce任务从“所需的每个已完成的Map任务”复制中间数据<strong>intermediate data</strong>。</li><li>如果Map任务几乎立即响应，那么网络会过载。</li><li>为了解决这个问题，群集网络很重要：交换机具有良好的内部流量管理功能和缓冲区（ <strong>good internal traffic management capabilities and buffers</strong>）</li><li>Reducer任务的输出将写入HDFS（拆分为块，管道复制等）</li><li>Hadoop支持：“在需要时合并多个Reduce Task jobs”的方法</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4sboduzkj30ky0ceacw.jpg" alt="截屏2020-03-24上午1.59.06" style="zoom:50%;" /></p><h4 id="Facebook例子——共同好友"><a href="#Facebook例子——共同好友" class="headerlink" title="Facebook例子——共同好友"></a>Facebook例子——共同好友</h4><p>共同好友列表的数据改变频率不高，所以我们可以用MapReduce来计算所有人的共同好友并储存结果，每天一次</p><p>当有人访问时，就可以展示结果</p><ol><li>Map：对于一个人A的好友列表，可以通过Map转换为，A与列表中每个好友分别组成键，其好友为值</li><li>排序和重组</li><li>Reduce：相同键所包含的列表中，如果值有相同，那么说明相同的值就是他们的共同好友</li><li>最后将结果输出到HDFS（Hadoop分布式文件系统）中</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MapReduce </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算/03_ Federated Cloud 联合云</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20Federated%20Cloud%20%E8%81%94%E5%90%88%E4%BA%91/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20Federated%20Cloud%20%E8%81%94%E5%90%88%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Federated-Cloud-联合云"><a href="#Federated-Cloud-联合云" class="headerlink" title="Federated Cloud 联合云"></a>Federated Cloud 联合云</h2><p>Federated cloud usually describes joining up and managing multiple public cloud environments – but there is nothing to prohibit joining multiple public clouds to a private one (so some overlap with Hybrid).</p><p>The central idea is that you have multiple IaaS and PaaS environments in the cloud. An application or a set of services may require the joining up and managing multiple PaaS and IaaS environments.</p><p>Now there are two classic scenarios:</p><ol><li>I have my storefront in the cloud. During peak periods, I want to quickly expand my capacity. I may choose to federate my load across multiple cloud providers both from a cost or location issue (for example: I am a US-based service, but I have an European sales promotion – I should probably choose a local cloud provider to federate my load across, etc.).</li><li>I have multiple cloud services (think RDS from Amazon, a CDN from Akamai, etc.). I will (either for cost or functionality) choose to federate my application across multiple different clouds.</li></ol><p>The reasons for doing it are usually either functional, location or cost-based. You can get a lot of flexibility here, as you don’t need to rely upon a single vendor to support you, so there is less vendor lock-in. However, the flexibility you gain can be at the cost of complexity. You now have multiple different SLAs, you have to manage potentially different APIs, monitoring and management and deployment approaches.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/03_ Cloud Bursting</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20Cloud%20Bursting/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03_%20Cloud%20Bursting/</url>
      
        <content type="html"><![CDATA[<h1 id="Cloud-Brusting-云爆发"><a href="#Cloud-Brusting-云爆发" class="headerlink" title="Cloud Brusting 云爆发"></a>Cloud Brusting 云爆发</h1><h2 id="The-latest-hybrid"><a href="#The-latest-hybrid" class="headerlink" title="The latest hybrid"></a>The latest hybrid</h2><p>model could be a cost-effective way to take advantage of the cloud</p><p>Cloud bursting is a rather nebulous buzzword that sounds cool but, I’m afraid, has nothing to do with Kate Bush. Instead, it’s the term used to describe a setup where you run your business mostly on your own kit, but also have a set of cloud accounts sitting idle, ready to take on extra “bursts” of work when demand peaks.</p><h2 id="Isn’t-that-already-the-idea-behind-hybrid-cloud"><a href="#Isn’t-that-already-the-idea-behind-hybrid-cloud" class="headerlink" title="Isn’t that already the idea behind hybrid cloud?"></a>Isn’t that already the idea behind hybrid cloud?</h2><p>Yes and no. Hybrid cloud is an umbrella term for dividing up your computing resources across local and off-premises servers; cloud bursting is a specific way of using those resources.</p><p>In practice, a cloud burst setup might use containerised VMs and some form of load orchestration package to shift containers to locations where user sessions can reach them. It will probably require quite a lot of work at the database design level as well, so that this too can be replicated, multi-homed or remotely accessed. In short, cloud bursting isn’t an architecture or a computing philosophy, but a capability of your entire technology estate.</p><h2 id="Is-it-just-an-agile-implementation-of-hybrid-cloud"><a href="#Is-it-just-an-agile-implementation-of-hybrid-cloud" class="headerlink" title="Is it just an agile implementation of hybrid cloud?"></a>Is it just an agile implementation of hybrid cloud?</h2><p>That’s a question of semantics. A cloud bursting setup should quickly respond to unforeseen changes in demand, but this isn’t quite what’s conventionally meant by “agile”. Agility is about being able to retool your code quickly to adapt to changing circumstances, whereas cloud bursting requires everything to be in place well before the high-load day comes.</p><p>You need to have your cloud accounts in place and paid up, you need to be sure that your code platform will run on the cloud, and you need to make sure that it’s actually capable of meeting the demands you want to place on it. Doing this properly involves a great deal of pre-emptive development and testing. I’d be very wary of a business that went into a cloud bursting project with an “agile” mindset.</p><h2 id="Is-a-cloud-bursting-setup-is-cheaper-than-regular-cloud-hosting"><a href="#Is-a-cloud-bursting-setup-is-cheaper-than-regular-cloud-hosting" class="headerlink" title="Is a cloud bursting setup is cheaper than regular cloud hosting?"></a>Is a cloud bursting setup is cheaper than regular cloud hosting?</h2><p>It might work out that way, but the two models aren’t perfectly comparable. Hybrid cloud usually tends to imply an IAAS model, whereas cloud bursting finds most interest from heavy SAAS users.</p><p>Cloud bursting also relies on your orchestration software correctly working out when to spin up the offsite services and incur the associated charges - which involves an element of voodoo, as it’s exquisitely difficult to distinguish between blips and booms as they’re happening. A hybrid cloud setup with plenty of slack capacity may or may not work out cheaper, but it’s likely to be more dependable, and have a more predictable cost.</p><h2 id="When-is-cloud-bursting-the-right-answer"><a href="#When-is-cloud-bursting-the-right-answer" class="headerlink" title="When is cloud bursting the right answer?"></a>When is cloud bursting the right answer?</h2><p>There are some such scenarios, but they’re mostly inside the world of IT itself. For example, if you’re an antivirus developer combatting zero-day exploits, you’ll want the ability to scale your download links out into the cloud on bad virus days. Some classes of simulation can also easily parcel up workloads and hand them off to compute nodes with no regard for where those nodes are hosted. Unfortunately, this model has become controversial, since it’s currently mostly employed by Bitcoin-mining trojans.</p><h2 id="What’s-the-key-downside-of-a-cloud-bursting-approach"><a href="#What’s-the-key-downside-of-a-cloud-bursting-approach" class="headerlink" title="What’s the key downside of a cloud bursting approach?"></a>What’s the key downside of a cloud bursting approach?</h2><p>Finance directors probably aren’t going to love cloud burst projects, because (as we’ve noted) the costs are unpredictable by design. What’s more, since the whole point of cloud bursting is that you don’t use it regularly, it’s only when you really need to fire up those cloud servers that you discover that a recent update has unexpectedly broken your meticulously crafted handover routines.</p><p>These inherent risks will tend to push most businesses back in the direction of a more traditional hybrid architecture.</p><h2 id="Why-are-vendors-pushing-cloud-bursting-as-the-next-big-thing"><a href="#Why-are-vendors-pushing-cloud-bursting-as-the-next-big-thing" class="headerlink" title="Why are vendors pushing cloud bursting as the next big thing?"></a>Why are vendors pushing cloud bursting as the next big thing?</h2><p>I suspect that the vendors aren’t trying to get you specifically into cloud bursting. They want to make you think more generally about where your computing resources live.</p><p>A little research, and my own anecdotal experience, suggests that very few companies have actually committed to a full-on cloud bursting model - which probably tells you everything you need to know.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/03 Cloud Platform Architecture over Virtualized Datacenters</title>
      <link href="/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03%20Cloud%20Platform%20Architecture%20over%20Virtualized%20Datacenters/"/>
      <url>/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/03%20Cloud%20Platform%20Architecture%20over%20Virtualized%20Datacenters/</url>
      
        <content type="html"><![CDATA[<h2 id="03-Cloud-Platform-Architecture-over-Virtualized-Datacenters"><a href="#03-Cloud-Platform-Architecture-over-Virtualized-Datacenters" class="headerlink" title="03 Cloud Platform Architecture over Virtualized Datacenters"></a>03 <strong>Cloud Platform Architecture over Virtualized Datacenters</strong></h2><p>公有云，私有云，混合云；云计算；数据中心设计；仓库规模计算 Warehouse scale Computing；异质性heterogeneity</p><h4 id="Cloud-Computing在硬件方面的好处"><a href="#Cloud-Computing在硬件方面的好处" class="headerlink" title="Cloud Computing在硬件方面的好处"></a>Cloud Computing在硬件方面的好处</h4><p>计算资源可以随时按需获取，使用户不需要提前规划将来的资源使用；</p><p>消除了云用户的前期承诺，从而使公司可以从小做起，并在将来需要时增加硬件资源。</p><p>能够根据需要在短期内支付计算资源成本的能力（例如，按小时计算的处理器和按天存储的处理器），并在完成后释放它们，从而可以节约资源。</p><h4 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h4><p>建立在网络上；能够被任何购买了服务的用户访问；被服务提供商拥有；可以通过订阅访问</p><p>例子：Google App Engine、Amazon Web Services、Microsoft Azure</p><h4 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h4><p>建立在企业的内部网中；企业自己拥有并管理；访问仅限于企业本身及其合作伙伴；可能与云的标准冲突，但更能自定义和更可控</p><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><p>包含了公有云和私有云的特性；如果需要更多资源，那么可以让私有云访问公有云</p><ul><li>比如IBM Reserach Compute Cloud (RC2)：<ul><li>IBM构建的私有云</li><li>互连分布在美国，欧洲和亚洲的8个IBM研究中心的计算和IT资源</li><li>混合云提供对客户端，合作伙伴网络和第三方的访问。</li></ul></li></ul><h4 id="公有云和私有云的特征"><a href="#公有云和私有云的特征" class="headerlink" title="公有云和私有云的特征"></a>公有云和私有云的特征</h4><p><strong>技术杠杆leverage和拥有权</strong>：公有云的拥有者是服务提供者。私有云利用现有的IT基础架构和人员； 由单个组织拥有</p><blockquote><p>（技术杠杆Technology leverage作用是在资源稳定或减少的情况下创造增值的能力，同时又提高了以更快的速度发展的能力）</p></blockquote><p><strong>供应资源的管理</strong>：公有云在专门的基础设备中创建和管理虚拟实例，促进标准化、减少资金支出、增加应用的灵活性。私有云由客户（企业）管理，实现定制化和更高的效率</p><p><strong>工作负载workload分配方法和负载策略</strong>：公有云处理工作负载而没有通信依赖性，分配数据和虚拟机资源，高峰工作负载被转移到其他设备(off-loaded)。私有云动态的处理工作负载，但可以更好的平衡工作负载；分布数据和虚拟资源。</p><blockquote><p>off-load：1.卸载。2.转移到其他设备</p></blockquote><p><strong>安全和数据隐私强化</strong>：公有云通过远程接口可被公开访问。私有云的访问时受限的，提供生产前测试并执行数据隐私和安全策略</p><p><strong>例子</strong>：公有云：Google App Engine、Amazon Web Services、Microsoft Azure。私有云：IBM Reserach Compute Cloud (RC2)</p><h4 id="云计算的部署场景——Bursted-internal-cloud、Federated-clouds、Multi-clouds"><a href="#云计算的部署场景——Bursted-internal-cloud、Federated-clouds、Multi-clouds" class="headerlink" title="云计算的部署场景——Bursted internal cloud、Federated clouds、Multi-clouds"></a>云计算的部署场景——Bursted internal cloud、Federated clouds、Multi-clouds</h4><p><strong>Brusted internal cloud</strong>：比如电商平台某一小时打折，这一小时内的用户流量将会激增并超过平时的负载。根据云爆发的思想，该平台应该提前准备好一组闲置的资源（比如在Azure上租赁），能够在这一小时内应对流量高峰的情况。</p><blockquote><p>Cloud bursting is an application deployment model in which an application runs in a private cloud or data center, but also have a set of cloud accounts sitting idle, ready to bursts into a public cloud when there is a necessity to meet peak demands or computing capacity spikes. </p><p>云爆发是一种应用程序部署模型，其中应用程序在私有云或数据中心中运行，但是还有一组闲置的云帐户，并在需要满足峰值需求或计算能力高峰时爆发到公共云中。</p></blockquote><p><strong>Federated cloud</strong>：联合云是两个或更多个独立的云，它们遵循一致的策略（例如，共享身份验证，存储和计算资源），使客户可以根据他们的预算和投资计划从许多供应商中进行选择。Federated cloud is two or more independent clouds follow consistent policies (e.g. share either authentication, storage and computing resources), giving customers many vendors to choose from based on their budgets and investment plans.</p><p><strong>Multi-clouds</strong>：与联合云相反，多个云之间并不会通信或共享资源，他们是完全独立的。Broker帮助服务提供商发现适合的云（which call indermediate）；或者由Broker直接代理基础设施提供者与服务提供者通信，infrastructure providers对service provider来说透明（which call virtual infrastructure provider）</p><p>A multicloud environment aims to eliminate the reliance on any single cloud provider. There are many reasons to do so, such as cost-efficiencies, flexibility, deploy the application to the cloud closer to the user (choose clouds which in the UK instead of the US for British users), etc.</p><p>多云环境旨在消除对任何单个云提供商的依赖。 原因有很多，例如成本效益，灵活性，将应用程序部署到更靠近用户的云中（对于英国用户，选择在英国而不是美国的云）。</p><h4 id="云建于大规模数据中心之上"><a href="#云建于大规模数据中心之上" class="headerlink" title="云建于大规模数据中心之上"></a>云建于大规模数据中心之上</h4><p>规模的范围：从“边缘”设施到大规模（100K至1M服务器）</p><p>成本比较：小型中心（1K服务器），和较大的400K服务器中心成本</p><h4 id="仓库规模计算Warehouse-Scale-Computing-WSC"><a href="#仓库规模计算Warehouse-Scale-Computing-WSC" class="headerlink" title="仓库规模计算Warehouse Scale Computing (WSC)"></a>仓库规模计算Warehouse Scale Computing (WSC)</h4><p>提供互联网服务：搜索、社交网络、在线地图、视频分享、在线购物、邮件、云计算等</p><p>高性能计算集群的区别：集群有更高的处理器和网络性能；集群强化线程级并行和请求级并行</p><p>数据中心：将不同的机器和软件合并在同一个位置；强化虚拟机和硬件以服务不同的消费者</p><h4 id="仓管规模计算的设计思想"><a href="#仓管规模计算的设计思想" class="headerlink" title="仓管规模计算的设计思想"></a>仓管规模计算的设计思想</h4><p>性价比Cost-performance；能源效率：影响配电power distribution和散热cooling；通过冗余增强可靠性；网络输入和输出；交互式和批处理工作负载；运营成本计算：功耗是设计系统时的主要限制；规模、机遇、问题</p><h4 id="小规模服务器集群的结构（1000-servers）"><a href="#小规模服务器集群的结构（1000-servers）" class="headerlink" title="小规模服务器集群的结构（1000 servers）"></a>小规模服务器集群的结构（1000 servers）</h4><p>通过以太网交换机互连，并位于仓库或容器环境中</p><h4 id="存储和数组交换"><a href="#存储和数组交换" class="headerlink" title="存储和数组交换"></a>存储和数组交换</h4><p>存储选项：服务器内部的磁盘；通过无线带宽技术的网络附加存储 Network Attached Storage (NAS) through Infiniband；WSC通常依赖于本地磁盘；Google文件系统（GFS）使用本地磁盘，并至少维护三个副本</p><blockquote><p>InfiniBand是一个用于高性能计算的计算机网络通信标准，它具有极高的吞吐量和极低的延迟，用于计算机与计算机之间的数据互连。InfiniBand也用作服务器与存储系统之间的直接或交换互连，以及存储系统之间的互连。 截至2014年，它是超级计算机最常用的互连技术。</p></blockquote><h4 id="数据中心的负载平衡"><a href="#数据中心的负载平衡" class="headerlink" title="数据中心的负载平衡"></a>数据中心的负载平衡</h4><p>边界border路由器 =&gt; 访问Access路由器 =&gt; 负载平衡器 =&gt; 一层交换机 =&gt; 二层交换机 =&gt; TOR (top of the rack) 交换机 =&gt; 服务器机架</p><h4 id="数据中心的网络"><a href="#数据中心的网络" class="headerlink" title="数据中心的网络"></a>数据中心的网络</h4><p>交换机，机架之间的丰富互连（一层交换机与二层交换机之间）：增加机架之间的吞吐量（可能有多个路由路径）；通过冗余提高可靠性</p><h4 id="异质性-Heterogeneity-的方面"><a href="#异质性-Heterogeneity-的方面" class="headerlink" title="异质性 Heterogeneity 的方面"></a>异质性 Heterogeneity 的方面</h4><p>异质性Heterogeneity是并行环境中出现的最深远和最有挑战的任务之一。</p><p>层次包括：</p><ul><li><p>宏观层Macro level：分布式计算机的网络，由不同的节点结构组成（单核、多核），与潜在的异构网络互连</p></li><li><p>微观层Micro level：更深的内存层次结构（内存，高速缓存，磁盘存储，三级tertiary存储）和各种加速器体系结构（固定的，可编程的（例如GPU）和可重新配置的（例如FPGA））</p></li><li><p>其他：软件（操作系统）、中间件、工具</p></li></ul><h4 id="通用处理器-General-Purpose-Processors-（GPP）"><a href="#通用处理器-General-Purpose-Processors-（GPP）" class="headerlink" title="通用处理器 General Purpose Processors （GPP）"></a>通用处理器 General Purpose Processors （GPP）</h4><ol><li>通用微处理器 Microprocessors（通用电脑）：为一般的电脑设计，如PC、workstations、Laptops、notePads；执行多个程序和多个任务</li><li>微控制器 Microcontrollers（<strong>嵌入式系统</strong>）：为专门的任务设计；具有面向控制的外围设备；低耗、低性能、低电量、比微处理器小；适用于对成本，功率和空间有限制的应用</li></ol><p>特点：</p><ul><li>通用处理器可为所有不同的应用程序提供良好的性能，但专用处理器可为特定任务提供更好的性能</li><li>专门应用处理器方案的出现：面向高性能、低能耗、低成本</li><li>专用处理器已成为我们生活的一部分，几乎可以在我们每天使用的每台设备中找到：比如电视、手机、GPS</li><li>3种类型：<ol><li>数字信号处理器（DSP）Digital Signal Processor</li><li>专用指令集处理器（ASIP）Application Specific Instruction Set Processors</li><li>专用集成电路（ASIC）Application Specific Integrated Circuit</li></ol></li></ul><h4 id="应用专业处理器"><a href="#应用专业处理器" class="headerlink" title="应用专业处理器"></a>应用专业处理器</h4><ul><li>DSP 数字信号处理器：用于广泛的实时数学计算的可编程微处理器–它们支持乘法累加单元</li><li>ASIP 专用指令集处理器：可编程微处理器，其中硬件和指令集是为一种特殊应用而设计的<ul><li>指令集，微体系结构和/或存储系统是针对某个应用程序或一系列应用程序定制的</li><li>比GPP（通用处理器）更好的性能，更低的成本和更低的功耗</li></ul></li></ul><blockquote><p>ASIP（应用特定指令处理器）通常是在使用的SoC（片上系统）。ASIP是一种体系结构，包括两部分，它们是最小的ISA（指令集体系结构）和可配置的逻辑，您可以使用它们来设计自己的指令集。因此，与ASIC相比，它具有相对较高的灵活性，而与FPGA（现场可编程门阵列）相比，它具有更好的性能。而且，它比FPGA便宜，但比ASIC贵。</p><ul><li>ASIP可以帮助您建立自己的指令集以满足您的特定要求；它提供了最小的ISA，可以缩短TTM（上市时间）。</li></ul></blockquote><ul><li>ASIC 专用集成电路：算法完全在硬件中实现<ul><li>为公司特定生产线设计的集成电路</li><li>本质上是专有的，而不是（始终）对公众开放</li></ul></li></ul><blockquote><p>ASIC（应用指定的集成电路）是一个定制的集成电路。通常由个人或公司使用，用途非常有限。因此，在开发它时，只有订购它的人或公司才能使用它。它不适用于其他用途，例如，为公司的特定移动电话线设计的IC ，除属于该产品线的移动电话外，没有其他产品可以使用它。</p><ul><li>ASIC仅为一个客户和一个客户构建；ASIC仅在一个产品系列中使用；仅批量生产一种产品的ASIC这很有意义，这意味着大批量产品的单位成本较低，否则成本效率不高；可以利用并行性来实现高性能；低功耗</li></ul></blockquote><h4 id="加速器-协处理器-Accelerators-Coprocessors"><a href="#加速器-协处理器-Accelerators-Coprocessors" class="headerlink" title="加速器-协处理器 Accelerators - Coprocessors"></a>加速器-协处理器 <strong>Accelerators - Coprocessors</strong></h4><p><strong>加速器/协处理器</strong>用于比CPU更有效地执行某些功能：更快、低能耗、但更难编程</p><p><strong>Graphics Processing Unit (GPU)</strong>：单指令多线程（SIMT）模型– CUDA代码；高效处理数据并行应用，和吞吐量密集型应用程序（该算法将要处理大量数据元素）</p><p><strong>FPGA (Field Programmable Gate Array)</strong> 现场可编程门阵列是逻辑门阵列，可以进行硬件编程以完成用户指定的任务：部分应用程序可以完全在硬件中实现</p><blockquote><p>它是作为专用集成电路（ASIC）领域中的一种半定制电路而出现的，既解决了定制电路的不足，又克服了原有可编程器件门电路数有限的缺点。</p><p>FPGA的优点是我们可以配置其可编程结构来实现所需的数字功能的任意组合。另外，我们可以大规模并行地实现算法，这意味着我们可以非常快速，高效地执行大量数据处理。</p></blockquote><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>CPU：与市场无关的；可供许多程序员使用；灵活、便携</p><p>FPGA：限制市场；难以编程；比SW更高效；比ASIC更贵</p><p>ASIC：针对特定市场；需要更少的开发者；不灵活rIgid，可编程性差；物理上难以构建</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbmyalczj7j310a0bs47h.jpg" alt="截屏2020-02-06下午12.20.57" style="zoom: 50%;" /></p><h4 id="Google-TPU-张量处理器-（tensor-processing-unit）"><a href="#Google-TPU-张量处理器-（tensor-processing-unit）" class="headerlink" title="Google TPU 张量处理器 （tensor processing unit）"></a>Google TPU 张量处理器 （tensor processing unit）</h4><blockquote><p>张量处理器（英語：tensor processing unit，缩写：TPU）是Google为机器学习全定制的人工智能加速器专用集成电路，专为Google的深度学习框架TensorFlow而设计。</p><p>与图形处理器（GPU）相比，TPU采用低精度（8位）计算，以降低每步操作使用的晶体管数量。降低精度对于深度学习的准确度影响很小，但却可以大幅降低功耗、加快运算速度。同时，TPU使用了脉动阵列的设计，用来优化矩阵乘法与卷积运算，减少I/O操作。此外，TPU还采用了更大的片上内存，以此减少对DRAM的访问，从而更大程度地提升性能。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘和文本分析/03 What “knowledge” can Data Mining learn</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/03%20What%20%E2%80%9Cknowledge%E2%80%9D%20can%20Data%20Mining%20learn/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/03%20What%20%E2%80%9Cknowledge%E2%80%9D%20can%20Data%20Mining%20learn/</url>
      
        <content type="html"><![CDATA[<h2 id="03-Data-Mining-outputs-What-“knowledge”-can-Data-Mining-learn"><a href="#03-Data-Mining-outputs-What-“knowledge”-can-Data-Mining-learn" class="headerlink" title="03 Data Mining outputs: What “knowledge” can Data Mining learn?"></a>03 Data Mining outputs: What “knowledge” can Data Mining learn?</h2><h4 id="数据挖掘、知识发现、文本挖掘"><a href="#数据挖掘、知识发现、文本挖掘" class="headerlink" title="数据挖掘、知识发现、文本挖掘"></a>数据挖掘、知识发现、文本挖掘</h4><p>数据挖掘是关于如何发现“知识”：大数据集中的模式、关系、预测规则</p><p>因此需要数据挖掘技术、算法、工具，如Weka、MatLab、R；和指导我们采集数据和发现模型的方法学框架（指导方针）：CRISP-DM</p><p>数据挖掘最初是关于从数据库中学习模式，以及将数据结构化为记录，字段</p><p>越来越多的非结构化数据（如文本），因此文本挖掘是新的数据挖掘的子领域，专注于从非结构化的文本数据中发现知识</p><h4 id="实例-Instance"><a href="#实例-Instance" class="headerlink" title="实例 Instance"></a>实例 Instance</h4><p>每个实例是被学习或描述的概念的一个例子；实例由它自身属性的值进行描述</p><p>Instance的定义取决于分类的目标：如果分类单词，那么单词是实例，如果分类句子，那么句子是实例。</p><p>数据挖掘算法的输入就是一系列实例的集合</p><p>实例表示为一系列的特征feature或属性attribute：通常来说，在文件中，一个实例instance就是文件中的一条记录record，一个属性attribute就是记录的一个字段field（attribute-instance，record-field）</p><p>从一系列实例instances中发现模式patterns，从而形成概念concepts</p><h4 id="概念-Concept"><a href="#概念-Concept" class="headerlink" title="概念 Concept"></a>概念 Concept</h4><p>Concept 的定义：</p><ul><li>数据集间的关键区别：比如某区域不同年份的销售额sales的区别</li><li>簇clusters 或自然分隔partitions：根据用户的购物习惯对用户进行分类</li><li><p>分类的规则：Adj+X+Verb =&gt; X=Noun</p></li><li><p>通用的关联：高频词一般是语法性的，而不是有含义的</p></li><li>数字的预测：找到预测数值的规则，比如根据成绩预测毕业生的工资</li></ul><h4 id="Kmeans"><a href="#Kmeans" class="headerlink" title="Kmeans"></a>Kmeans</h4><p>cluster centroids 聚类中心</p><h4 id="聚类的例子"><a href="#聚类的例子" class="headerlink" title="聚类的例子"></a>聚类的例子</h4><p>销售数据点包含买方和购物篮的信息；我们希望对不同的用户推送不同的广告；聚类分析把用户分成不同的类别的组，每个类别有不同的特征；聚类的特征与广告的种类相关联（每个簇的用户都有不同的购买偏好）；最后对用户分类</p><h4 id="输出：聚类"><a href="#输出：聚类" class="headerlink" title="输出：聚类"></a>输出：聚类</h4><p>如果不知道有多少聚类，可以先做出树状图Dendrogram</p><ul><li>根据聚类的数量/名字，对每个实例进行分类</li><li>聚类中心点</li><li>用树状图Dendrogram对结果进行展示，可以根据需求对树状图进行切割，得到不同数量的簇</li></ul><h4 id="使用案例：比较数据集"><a href="#使用案例：比较数据集" class="headerlink" title="使用案例：比较数据集"></a>使用案例：比较数据集</h4><p>寻找US vs UK专门的术语；比较这个月和上个月的数据；和几个月前的数据比较；注意新的销售增长区域；趋势：上升、下降、循环；关键的区别可能表示聚类的簇；不同的规模；</p><h4 id="输出：数据集间的不同"><a href="#输出：数据集间的不同" class="headerlink" title="输出：数据集间的不同"></a>输出：数据集间的不同</h4><p>最明显不同的关键实例/属性；关键术语的划分：names；不同数据集的趋势；整体的差别度量</p><h4 id="分类器的使用例子"><a href="#分类器的使用例子" class="headerlink" title="分类器的使用例子"></a>分类器的使用例子</h4><p>医疗记录中的大量症状和诊断数据集是可用的；找到规则来通过病人的症状预测疾病；</p><h4 id="关于决策树"><a href="#关于决策树" class="headerlink" title="关于决策树"></a>关于决策树</h4><p>无叶子节点表示特定属性的测试；边表示测试的结果；数字属性的测试通常有二元输出；普通属性的测试，通常在领域中的每个元素都有一个结果；叶子节点表示一个分类；每条路径都表示一个“实例关联到分类”的预测</p><h4 id="关于分类规则-Classification-Rules"><a href="#关于分类规则-Classification-Rules" class="headerlink" title="关于分类规则 Classification Rules"></a>关于分类规则 Classification Rules</h4><p>是决策树的替换形式：If &lt;前因antecedent&gt; then &lt;后果consequent&gt;；结果表示一个类；通常前因是条件的结合，表现在属性值上；通常我们将规则集解释为单个规则的分离</p><p>评估，规则的准确性Accuracy：它正确预测的实例数的比例，和匹配该前因的实例总数之比。</p><p>规则的优点：比树更容易理解；更紧凑；每个规则都表示一部分知识和对应得准确性</p><h4 id="例外规则"><a href="#例外规则" class="headerlink" title="例外规则"></a>例外规则</h4><p>If A then B except if C then D；比普通规则更紧凑；心理学认为这更接近人类组织知识的方式；当新实例引入时更好扩展；</p><p>对于编程的角度来说，程序会先处理异常（例外）情况，最后处理通用规则</p><h4 id="输出：其他分类器"><a href="#输出：其他分类器" class="headerlink" title="输出：其他分类器"></a>输出：其他分类器</h4><p>ZeroR、JRIP、NaiveBayes、VotedPerceptron、IB1、Bagging；输出分类器可能难以可视化、一个可以分类新实例的黑盒</p><h4 id="输出：关联规则"><a href="#输出：关联规则" class="headerlink" title="输出：关联规则"></a>输出：关联规则</h4><p>找出销售数据点之间的依赖关系可以帮助我们发现购物行为；学习规则的过程可能并不有趣</p><h4 id="关于关联规则-Assoication-Rules"><a href="#关于关联规则-Assoication-Rules" class="headerlink" title="关于关联规则 Assoication Rules"></a>关于关联规则 Assoication Rules</h4><p>类似于分类规则，但不仅可以预测分类，还能<strong>预测属性</strong></p><p>评估，规则的覆盖面Coverage：正确预测的实例的数量</p><p>评估，规则的准确性Accuracy：它正确预测的实例数的比例，和匹配该前因的实例总数之比。</p><h4 id="输出：数字预测"><a href="#输出：数字预测" class="headerlink" title="输出：数字预测"></a>输出：数字预测</h4><p>最适合使用公式；广泛应用于数学maths和统计学statistics</p><p>例子：给出关于物理环境和作物田的数字化信息，找出帮助我们在某些新条件下预测作物田的规则</p><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><p>数据挖掘工具能够半自动化的发现数据的规则</p><p>不同工具用于发现不同的概念（差异，聚类，决策树，规则，数值预测）和提供不同的输出（提供聚类中心或者树状图的聚类算法）</p><p>根据业务目标选择合适的工具以用于工作：发现知识的用途是什么</p><h4 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h4><p>我们应该：</p><ul><li>确定哪些属性与给定的数据挖掘任务相关</li><li>确定根据业务目标定义的给定问题的适当数据挖掘技术。</li><li>确定最合适的输出形式。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据来源层</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/04%20Data%20Sources/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/04%20Data%20Sources/</url>
      
        <content type="html"><![CDATA[<p>大数据来源层 Sources layer 指的是“来自于所有渠道的，可用于分析的，所有数据”。分析的类型和来源密切相关</p><p>格式：结构化的、半结构化的、非结构化的</p><p>Velocity和Volume：数据传入(arrives)的速度，以及数据传递速率(rate)根据数据源而不同</p><p>采集点：实时或分批采集数据的来源（直接采集或者源自数据提供者）。数据可以来自主要或次要来源。</p><p>数据源的地点：数据源可以在企业内部或外部。 <u>需要标识限制访问的数据，因为对数据的访问会影响可用于分析的数据范围</u></p><a id="more"></a><h4 id="来源层-Sources-layer"><a href="#来源层-Sources-layer" class="headerlink" title="来源层 Sources layer"></a>来源层 Sources layer</h4><p>指的是“来自于所有渠道的，可用于分析的，所有数据”。分析的类型和来源密切相关</p><p>格式：结构化的、半结构化的、非结构化的</p><p>Velocity和Volume：数据传入(arrives)的速度，以及数据传递速率(rate)根据数据源而不同</p><p>采集点：实时或分批采集数据的来源（直接采集或者源自数据提供者）。数据可以来自主要或次要来源。</p><p>数据源的地点：数据源可以在企业内部或外部。 <u>需要标识限制访问的数据，因为对数据的访问会影响可用于分析的数据范围</u></p><h4 id="第四次工业革命"><a href="#第四次工业革命" class="headerlink" title="第四次工业革命"></a>第四次工业革命</h4><p>2000年开始：IoT，数字整合，大数据，AI等</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4exgwmtkj31160ekjwo.jpg" alt="截屏2020-03-23下午6.15.40"></p><h4 id="IoT和IIoT"><a href="#IoT和IIoT" class="headerlink" title="IoT和IIoT"></a>IoT和IIoT</h4><p>IoT：基于消费者；低成本端点设备</p><p>Industrial IoT：以企业为重点；高成本工业资产</p><h4 id="从Cloud到Edge"><a href="#从Cloud到Edge" class="headerlink" title="从Cloud到Edge"></a>从Cloud到Edge</h4><p>Cloud 云计算：基于数据中心，TCP/IP访问，使用虚拟化基础架构可大规模扩展</p><p>Edge 边缘计算：地理位置本地化的服务器，将计算向终端设备靠近</p><p>Fog 雾计算：联合Cloud和Edge，在Could和Edge之间的去中心化计算</p><h4 id="云计算、边缘计算、雾计算"><a href="#云计算、边缘计算、雾计算" class="headerlink" title="云计算、边缘计算、雾计算"></a>云计算、边缘计算、雾计算</h4><p><strong>云计算</strong>是把大量数据放到“云”里去计算或存储，解决诸如电脑或手机存储量不够，或者是运算速度不够快的问题</p><p><strong>雾计算</strong>是定义边缘计算应如何工作的标准，它促进了终端设备与云计算数据中心之间的计算，存储和网络服务的运行。此外，许多人将雾作为边缘计算的起点。</p><p><strong>边缘计算</strong>使处理靠近数据源，不需要将其发送到远程云或其他集中式系统进行处理。通过消除将数据发送到集中式源所需的距离和时间，我们可以提高数据传输以及边缘设备和应用程序的速度和性能。</p><p>优点：以减少“云”的压力，提高了效率，也提升了传输速率，减低了时延</p><p>缺点：如果终端设备end devices（如传感器）太多，那么边缘处理器和存储平台可能不堪重负overloaded；安全性问题，分布的边缘节点edge node意味着更高的安全风险higher risk of security，比如飞机引擎被黑Imagine if a jet engine could be hacked in flight.</p><p>对于时间敏感、计算量小的任务，如紧急情况的监控和警告，应该由边缘计算负责，比如飞机引擎是否过热（such as in-flight analysis about if the engine is overheating）</p><p>对于需要计算大量数据的任务，如进行预测分析、深度数据分析或机器学习，则应该由云计算负责，比如根据过去几个月的数据预测未来的天气、找出飞机引擎过热的原因</p><h4 id="例子：无人驾驶汽车"><a href="#例子：无人驾驶汽车" class="headerlink" title="例子：无人驾驶汽车"></a>例子：无人驾驶汽车</h4><p>大量的传感器数据，要求本地数据处理能力；需要连接云端的高级数据分析工具；全新的分布式计算结构的出现，拆分不同元素间的大量工作负载（大数据分析、实时应用）；边缘计算</p><h4 id="例子：航空"><a href="#例子：航空" class="headerlink" title="例子：航空"></a>例子：航空</h4><p>对于时间敏感、计算量小的任务，如紧急情况的监控和警告，应该由边缘计算负责，比如飞机引擎是否过热（such as in-flight analysis about if the engine is overheating）</p><p>对于需要计算大量数据的任务，如进行预测分析、深度数据分析或机器学习，则应该由云计算负责，比如根据过去几个月的数据预测未来的天气、找出飞机引擎过热的原因</p><h4 id="例子：自动测试"><a href="#例子：自动测试" class="headerlink" title="例子：自动测试"></a>例子：自动测试</h4><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><p>无线连接：NFC/RFID、Bluetooth/ZigBee、WiFi、Radio、LTE、IEEE 802</p><p>通信协议：TCP/IP、HTTP/HTTPS/WebSocket、REST、SOAP、WS-*、WCF、AMQP</p><p>专用RTI：DDS、HLA(IEEE 1516.2010)</p><p>非同步消息队列：RabbitMQ、Apache kafka、ActiveMQ</p><p>特定的应用API</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据的分层结构</title>
      <link href="/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/03%20HIGH%20LEVEL%20ARCHITECTURE/"/>
      <url>/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/03%20HIGH%20LEVEL%20ARCHITECTURE/</url>
      
        <content type="html"><![CDATA[<p>针对大数据的5大特征，使用分布式资源解决大数据的存储、检索、合并、分析问题</p><a id="more"></a><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p>大数据的5大特征可以总结为4个方面：存储、检索、合并、分析</p><p>解决方案：使用分布式资源</p><h4 id="流程：原始数据到最终执行"><a href="#流程：原始数据到最终执行" class="headerlink" title="流程：原始数据到最终执行"></a>流程：原始数据到最终执行</h4><p>流程：1.数据获取 -&gt; 3.Infrastructure -&gt; 5.数据管理 -&gt; 7.分析和自动化 -&gt; 9.可视化 -&gt; 11.最终执行 (&lt;1%)</p><p>故障点：0.不可获取 -&gt; 2.不可流化或存储 -&gt; 4.不可访问 -&gt; 6.不可分析 -&gt; 8.不可通信 -&gt; 10.不可用于决策</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4damkojgj311s0i6jx2.jpg" alt="截屏2020-03-23下午5.19.07" style="zoom:50%;" /></p><h4 id="相关技术领域"><a href="#相关技术领域" class="headerlink" title="相关技术领域"></a>相关技术领域</h4><p>基础设施：Multiple nodes、CPU或GPUs、FPGAs、ASICs、Memory、Storage、Network</p><p>方法：并行化任务、并行化数据（分布数据）</p><p>应用：大规模并行 (Massive parallelism)、庞大的数据量存储、分布式数据、高速网络、高性能计算、任务和线程管理、数据挖掘和分析、数据检索、机器学习、数据可视化</p><h4 id="分层结构-Layered-architecture"><a href="#分层结构-Layered-architecture" class="headerlink" title="分层结构 Layered architecture"></a>分层结构 Layered architecture</h4><p>Layered approach最适合组织大数据系统的结构</p><p>是逻辑上的分层，而不一定要在把不同层的功能分别放在不同的机器上</p><p>按商业分层：大数据资源、数据传输和存储层、分析层、消费层</p><p>按技术分层：信息整合、大数据统治、系统管理、服务质量</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4dk6olm1j312m0cmjuy.jpg" alt="截屏2020-03-23下午5.28.15"></p><h4 id="大数据来源层-Big-Data-Sources-layer"><a href="#大数据来源层-Big-Data-Sources-layer" class="headerlink" title="大数据来源层 Big Data Sources layer"></a>大数据来源层 Big Data Sources layer</h4><p>指的是“来自于所有渠道的，可用于分析的，所有数据”。分析的类型和来源密切相关</p><ul><li><p>格式：结构化的、半结构化的、非结构化的</p></li><li><p>Velocity和Volume：数据传入(arrives)的速度，以及数据传递速率(rate)根据数据源而不同</p></li><li><p>采集点：实时或分批采集数据的来源（直接采集或者源自数据提供者）。数据可以来自主要或次要来源。</p></li><li><p>数据源的地点：数据源可以在企业内部或外部。 <u>需要标识限制访问的数据，因为对数据的访问会影响可用于分析的数据范围</u></p></li></ul><h4 id="数据通信和存储层-Data-Messaging-and-Store-Layer"><a href="#数据通信和存储层-Data-Messaging-and-Store-Layer" class="headerlink" title="数据通信和存储层 Data Messaging and Store Layer"></a>数据通信和存储层 Data Messaging and Store Layer</h4><p>Storage manager管理多个数据节点（将存储拆分）</p><p>负责从数据源获取数据——<strong>数据获取Acquisition</strong>：从数据源采集数据，然后对数据进行格式化或存储。</p><p>如果有必要，该层还能负责对数据进行格式化用于分析——<strong>数据消化Digest</strong>：简单的转化逻辑或复杂的统计算法对数据进行格式化，最大的挑战是对<strong>非结构化</strong>数据的格式化。</p><p>服从规定regulations和统治政策governance policies，为不同类型的数据提供适当的存储——<strong>分布式存储Distributed storage</strong>：负责存储数据，通常提供多种数据存储方式，比如分布式文件存储DFS、cloud、结构化数据源、NoSQL等</p><h4 id="分析层-Analysis-Layer"><a href="#分析层-Analysis-Layer" class="headerlink" title="分析层 Analysis Layer"></a>分析层 Analysis Layer</h4><p>Job manager管理多个处理节点（将分析任务拆分）</p><p>分析层的职责（如何设计分析层）：产生所需的分析；从数据中推断出观点insight；找到所需的实体；定位可以为实体提供数据的数据源；了解所需的算法和工具</p><ul><li><p>辨别实体 Entity：负责表示和填充上下文的实体；需要高效的高性能处理；定义了数据的格式；提供给分析引擎</p></li><li><p>分析引擎：使用其他组件进行分析和处理数据</p></li><li><p>模型管理：负责维护不同的统计模块，并通过不断训练确保这些模块的精确性</p></li></ul><h4 id="消费层Consumption-Layer"><a href="#消费层Consumption-Layer" class="headerlink" title="消费层Consumption Layer"></a>消费层Consumption Layer</h4><p>使用分析层的数据；消费者是以可视化软件、人、商业过程、服务；</p><p>难点在于可视化数据（可以向竞争者学习 look at what competitors in similar markets are doing）</p><p>组件：</p><ul><li>事务拦截：实时拦大量额事务，并将之转化为合适的格式给实时分析；使用不同的适配器和接口，对不同来源的数据进行整合和处理</li><li>商业过程管理进程：API，BPEL和其他流程可以使用来自分析层的Insight，从而通过自动化上下游应用程序，人员和流程的功能来推动价值。</li><li>实时监测：使用分析层的输出可以生成警告Alerts，并发送给设备或用户；实时数据可以以仪表板的形式提供。</li><li>报告引擎：生成类似于传统商业智能报告的报告至关重要。 用户可以基于来自分析层的洞察力Insight来创建临时报告，计划的报告或自我查询和分析。</li><li>推荐引擎：根据分析结果，向用户提供个性化的实时相关建议。引擎会实时处理可用信息，并根据用户的实时活动动态响应每个用户。</li><li>可视化和发现：可以在企业内部和外部的各种联合数据源之间导航数据。 数据的内容和格式可以不同，可以合并以进行可视化。</li></ul><h4 id="信息整合层-Information-Integration-Layer"><a href="#信息整合层-Information-Integration-Layer" class="headerlink" title="信息整合层 Information Integration Layer"></a>信息整合层 Information Integration Layer</h4><p>负责连接不同的数据源；需要优质的连接器和适配器（比如通信协议、API、网络服务），工业4.0平台的作用就是简化这部分</p><h4 id="大数据统治层-Big-Data-Governance-Layer"><a href="#大数据统治层-Big-Data-Governance-Layer" class="headerlink" title="大数据统治层 Big Data Governance Layer"></a>大数据统治层 Big Data Governance Layer</h4><p>核心原则：合法、公正、透明；目的限制、数据最小化、准确性、存储限制、诚信和保密、问责制Accountability</p><p>至少需要考虑：数据发现、保障措施、同意管理、数据最小化、使用情况监控、违规Breach通知</p><p>通用数据保护规则：数据控制器、数据处理器</p><h4 id="系统管理层-System-Management-Layer"><a href="#系统管理层-System-Management-Layer" class="headerlink" title="系统管理层 System Management Layer"></a>系统管理层 System Management Layer</h4><p>监视和管理整个大数据生态系统的健康状况。</p><p>包括：云消费者、云审计者 Auditor、云提供者、云中介者 Broker、云运输者 Carrier</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4e7scrruj311q0m2tb5.jpg" alt="截屏2020-03-23下午5.49.32" style="zoom:50%;" /></p><h4 id="服务质量层-QoS-Quality-of-Service-Layer"><a href="#服务质量层-QoS-Quality-of-Service-Layer" class="headerlink" title="服务质量层 (QoS) Quality of Service Layer"></a>服务质量层 (QoS) Quality of Service Layer</h4><p>定义数据质量，有关隐私和安全性的政策，数据的频率等</p><h4 id="大数据层结构总览"><a href="#大数据层结构总览" class="headerlink" title="大数据层结构总览"></a>大数据层结构总览</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4e8myag4j319l0u0kb9.jpg" alt="截屏2020-03-23下午5.51.46"></p><h4 id="传统系统-VS-大数据系统"><a href="#传统系统-VS-大数据系统" class="headerlink" title="传统系统 VS 大数据系统"></a>传统系统 VS 大数据系统</h4><p>应用开发：传统系统利用高级HPC专家开发的并行性进行优化和调整的应用程序；大数据系统简化了应用程序执行模型（分布式文件系统，编程模型，分布式数据库和调度程序）。</p><p>平台：传统系统使用高成本的大规模并行处理（MPP）计算机，利用高带宽网络和大规模I/O设备；大数据系统创建可扩展但具有弹性的虚拟化平台的创新方法。</p><p>数据管理：传统系统限于使用标准的面向行的数据布局的基于文件或RDBMS；大数据系统使用数据管理的可替换模型（通常为NoSQL），具有根据需要管理信息的多种方法。</p><p>资源：传统系统需要大量资本投资来购买要在内部安装和管理的高端硬件。大数据系统能够在虚拟平台（尤其是云）上部署系统，从而降低了进入门槛。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据分层结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘和文本分析/02 Based on Intro to Data Mining CRISP-DM</title>
      <link href="/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/02%20Based%20on%20Intro%20to%20Data%20Mining%20CRISP-DM/"/>
      <url>/2020/02/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/02%20Based%20on%20Intro%20to%20Data%20Mining%20CRISP-DM/</url>
      
        <content type="html"><![CDATA[<h2 id="02-Based-on-Intro-to-Data-Mining-CRISP-DM"><a href="#02-Based-on-Intro-to-Data-Mining-CRISP-DM" class="headerlink" title="02 Based on Intro to Data Mining: CRISP-DM"></a>02 Based on Intro to Data Mining: CRISP-DM</h2><p><strong>Cross-industry standard process for data mining</strong>, known as CRISP-DM, is an open standard process model that describes common approaches used by data mining experts. It is the most widely-used analytics model.</p><p>是一种用于数据分析的方法，而不是一种工具或者技术</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>通过定义子任务，在整个数据挖掘过程中使用可交互工具；使任何人都能进行数据挖掘工作，而不需要特别的专业技能</p><h4 id="为什么需要标准化流程"><a href="#为什么需要标准化流程" class="headerlink" title="为什么需要标准化流程"></a>为什么需要标准化流程</h4><ul><li><strong>数据挖掘工作 Data mining process</strong>，必须要可靠reliable 并且可被缺少数据挖掘背景的人重复repeatable</li><li>需要有框架记录经历experience，使项目是可复制的</li><li>协助项目的规划planning和管理</li><li>使新采纳者“感到舒适”的因素：展示数据挖掘的成熟性；减少对“明星”的依赖</li></ul><h4 id="CRISP-DM的特点"><a href="#CRISP-DM的特点" class="headerlink" title="CRISP-DM的特点"></a>CRISP-DM的特点</h4><ul><li>非专利的 Non-proprietary</li><li>行业中立的 Application/Industry neutral</li><li>中性的工具 Tool neutral</li><li>专注于商业问题和实践问题，以及技术分析</li><li>用于指导的框架</li><li>基于经验的：用于引导和分析的例子和案例学习</li></ul><h4 id="CRISP-DM的6个阶段"><a href="#CRISP-DM的6个阶段" class="headerlink" title="CRISP-DM的6个阶段"></a>CRISP-DM的6个阶段</h4><ul><li>商业理解<ul><li>理解用户（项目）的目标和需求</li><li>定义数据挖掘问题</li></ul></li><li>数据理解<ul><li>熟悉和采集原始数据</li><li>辨别数据质量问题</li><li>初始的、明显的结果</li></ul></li><li>数据准备<ul><li>记录record，和选择属性attribute</li><li>清洗数据</li></ul></li><li>建模<ul><li>运行数据分析和数据挖掘软件</li></ul></li><li>评估<ul><li>评估结果是否符合商业目标</li><li>辨别应该提前解决的商业问题</li></ul></li><li>部署<ul><li>将建立的模型应用到实践中</li><li>为数据重复采集和连续采集做好部署</li></ul></li></ul><h4 id="6个阶段的任务细节"><a href="#6个阶段的任务细节" class="headerlink" title="6个阶段的任务细节"></a>6个阶段的任务细节</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbij8b0fpbj31mx0u049s.jpg" alt="截屏2020-02-02下午4.41.12"></p><h4 id="1-商业理解"><a href="#1-商业理解" class="headerlink" title="1-商业理解"></a>1-商业理解</h4><p>关于商业目标、数据挖掘目标、和成功标准Success Criteria的陈述Statement</p><h4 id="2-数据理解"><a href="#2-数据理解" class="headerlink" title="2-数据理解"></a>2-数据理解</h4><p>采集数据、描述数据、探索数据、证实（确保）数据质量（特征和值有关联并且有意义）、辨别异常数据</p><p>Explore/verify that the features and values “<strong>seem relevant and sensible</strong>” – if not, how to transform?</p><h4 id="3-数据准备"><a href="#3-数据准备" class="headerlink" title="3-数据准备"></a>3-数据准备</h4><p>可能会占90%的时间（避免此情况）。</p><p><strong>合并Consolidation和清洗Cleaning数据</strong>：数值缺失、移除“noisy”数据（比如重复数据）、移除异常点（看情况）</p><p><strong>特征选取</strong>：选择特征、使用可视化工具</p><p><strong>转化Transformation</strong>：创建新变量、改变格式（比如拆分出训练集合测试集）</p><h4 id="4-建模"><a href="#4-建模" class="headerlink" title="4-建模"></a>4-建模</h4><p>建模方法的选择取决于数据挖掘的目标</p><p>建模可以是迭代过程</p><p>模型可能用于描述或预测（或both）</p><h4 id="5-模型评估"><a href="#5-模型评估" class="headerlink" title="5-模型评估"></a>5-模型评估</h4><p>评估模型的性能和对商业需求的达成度(how well it met)：比如是否找到并量化关键特征</p><p>方法methods和标准criteria取决于模型的种类：比如混淆矩阵用于分类模型，也满足“理解数据”的需求</p><p>说明模型Interpretation：重要性和难易程度取决于算法；不仅要展示结果，还要解释产生的可能原因</p><h4 id="6-部署"><a href="#6-部署" class="headerlink" title="6-部署"></a>6-部署</h4><p>确定结果应该如何被应用utilized，谁需要使用这些结果、以及使用的频率</p><p>如何部署数据挖掘的结果：生成报告给用户，其中包含（对商业的）改进建议；直接将结果应用在商业中</p><h4 id="为什么使用CRISP-DM"><a href="#为什么使用CRISP-DM" class="headerlink" title="为什么使用CRISP-DM"></a>为什么使用CRISP-DM</h4><p>对于指导方针guidelines和经验文件experience documentation，提供了独一无二的框架</p><p>可以灵活的考虑不同的商业/代理问题和不同的数据</p><h4 id="概念描述，Descriptive-VS-Predictive-data-mining"><a href="#概念描述，Descriptive-VS-Predictive-data-mining" class="headerlink" title="概念描述，Descriptive VS. Predictive data mining"></a>概念描述，Descriptive VS. Predictive data mining</h4><p><strong>描述性的Descriptive</strong> vs <strong>预测性的Predictive</strong>数据挖掘：</p><ul><li>描述性的数据挖掘：以简明扼要的形式描述概念或与任务相关的数据集：决策树，决策规则</li><li><p>预测性的数据挖掘：根据数据和分析，从数据集构建模型，并预测未知数据的趋势和属性：“模型”无需可视化，例如神经网络，集成</p><p><strong>概念描述 Concept description</strong>：</p></li><li><p>表征 Characterization：对给定的数据集合进行简洁明了的总结</p></li></ul><h4 id="数据挖掘-vs-可视化"><a href="#数据挖掘-vs-可视化" class="headerlink" title="数据挖掘 vs 可视化"></a>数据挖掘 vs 可视化</h4><p><strong>数据挖掘</strong>：可以处理复杂数据类型（有许多属性/特征/维度的数据）；更加自动化的过程</p><p><strong>可视化 —— OLAP Online Analytic Processing (Visualization)</strong>：限于少数尺寸和特征类型（例如，不适合文本）；由用户控制的过程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/01_ Multitenancy</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/01_%20Multitenancy/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/01_%20Multitenancy/</url>
      
        <content type="html"><![CDATA[<h1 id="Multitenancy"><a href="#Multitenancy" class="headerlink" title="Multitenancy"></a>Multitenancy</h1><p>A tenant is a group of users who share a common access with specific privileges to the software instance - including its data, configuration, user management, tenant individual functionality and non-functional properties.</p><p>Multitenancy contrasts with multi-instance architectures. Multi-instance architectures separate software instances operate on behalf of different tenants. Multitenancy provide every tenant a dedicated share of the instance but ensuring data isolation between users.</p><h2 id="Economics-of-multitenancy"><a href="#Economics-of-multitenancy" class="headerlink" title="Economics of multitenancy"></a>Economics of multitenancy</h2><h3 id="Cost-savings"><a href="#Cost-savings" class="headerlink" title="Cost savings"></a>Cost savings</h3><p>Multitenancy allows for cost savings over and above the basic economies of scale achievable from consolidating IT resources into a single operation.[6] An application instance usually incurs a certain amount of memory and processing overhead which can be substantial when multiplied by many customers, especially if the customers are small. Multitenancy reduces this overhead by spreading it over many customers. Further cost savings may come from licensing costs of the underlying software (such as operating systems and database management systems). Put crudely, if you can run everything on a single software instance, you only have to buy one software license. The cost savings can be eclipsed by the difficulty of scaling the single instance as demand grows - increasing the performance of the instance on a single server can only be done by buying faster hardware, such as fast CPUs, more memory, and faster disk systems, and typically these costs grow faster than if the load was split between multiple servers with roughly the same aggregate capacity.[citation needed] In addition, development of multitenant systems[7] is more complex, and security testing is more stringent owing to the fact that multiple customers’ data is being commingled.</p><h3 id="Data-aggregation-data-mining"><a href="#Data-aggregation-data-mining" class="headerlink" title="Data aggregation/data mining"></a>Data aggregation/data mining</h3><p>One of the most compelling reasons for vendors/ISVs to utilize multitenancy is for the inherent data aggregation benefits. Instead of collecting data from multiple data sources, with potentially different database schemas, all data for all customers is stored in a single database schema. Thus, running queries across customers, mining data, and looking for trends is much simpler. This reason is probably overhyped as one of the core multitenancy requirements is the need to prevent Service Provider access to customer (tenant) information. Further, it is common to separate the operational database from the mining database (usually because of different workload characteristics), thus weakening the argument even more.</p><h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h3><p>Because of the additional customization complexity and the need to maintain per-tenant metadata, multitenant applications require a larger development effort. Considerations such as vector-based data sequencing, encryptable algorithm infrastructure, and virtualized control interfaces, must be taken into account.[8]</p><h3 id="Release-management"><a href="#Release-management" class="headerlink" title="Release management"></a>Release management</h3><p>Multitenancy simplifies the release management process. In a traditional release management process, packages containing code and database changes are distributed to client desktop and/or server machines; in the single-instance case, this would be one server machine per customer. These packages then have to be installed on each individual machine. With the multitenant model, the package typically only needs to be installed on a single server. This greatly simplifies the release management process, and the scale is no longer dependent on the number of customers.</p><p>At the same time, multitenancy increases the risks and impacts inherent in applying a new release version. As there is a single software instance serving multiple tenants, an update on this instance may cause downtime for all tenants even if the update is requested and useful for only one tenant. Also, some bugs and issues resulted from applying the new release could manifest in other tenants’ personalized view of the application. Because of possible downtime, the moment of applying the release may be restricted depending on time usage schedule of more than one tenant.</p><h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><h3 id="Customization"><a href="#Customization" class="headerlink" title="Customization"></a>Customization</h3><p>Multitenant applications are typically required to provide a high degree of customization to support each target organization’s needs. Customization typically includes the following aspects:</p><ul><li>Branding: allowing each organization to customize the look-and-feel of the application to match their corporate branding (often referred to as a distinct “<a href="https://en.wikipedia.org/wiki/Skin_(computing" target="_blank" rel="noopener">skin</a>)”).</li><li><a href="https://en.wikipedia.org/wiki/Workflow" target="_blank" rel="noopener">Workflow</a>: accommodating differences in workflow to be used by a wide range of potential customers.</li><li>Extensions to the <a href="https://en.wikipedia.org/wiki/Data_model" target="_blank" rel="noopener">data model</a>: supporting an extensible data model to give customers the ability to customize the data elements managed by the application to meet their specific needs.</li><li><a href="https://en.wikipedia.org/wiki/Access_control" target="_blank" rel="noopener">Access control</a>: letting each client organization independently customize access rights and restrictions for each <a href="https://en.wikipedia.org/wiki/User_(computing" target="_blank" rel="noopener">user</a>).</li></ul><h3 id="Quality-of-service"><a href="#Quality-of-service" class="headerlink" title="Quality of service"></a>Quality of service</h3><p>Multitenant applications are expected to provide adequate isolation of security, robustness and performance[9] between multiple tenants which is provided by the layers below the application in case of multi-instance applications.</p><h2 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a>Virtualization</h2><p>The costs of redesigning applications for multitenancy can be significant, especially for software vendors who continue to offer an on-premises single tenant version of their product. They end up being forced to support two distinct products with all the resulting costs.</p><p>An increasingly viable alternative route to multitenancy that eliminates the need for significant architectural change is to use virtualization technology to host multiple isolated instances of an application on one or more servers. Indeed, when applications are repackaged as virtual appliances the same appliance image can be deployed in ISV hosted, on-premises or trusted-third party locations and even migrated from one deployment site to another over time.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人工智能/01 Image classification and object detection</title>
      <link href="/2020/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/01%20Image%20classification%20and%20object%20detection/"/>
      <url>/2020/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/01%20Image%20classification%20and%20object%20detection/</url>
      
        <content type="html"><![CDATA[<h2 id="01-Image-classification-and-object-detection"><a href="#01-Image-classification-and-object-detection" class="headerlink" title="01 Image classification and object detection"></a>01 Image classification and object detection</h2><h4 id="视频："><a href="#视频：" class="headerlink" title="视频："></a>视频：</h4><p>640×480 解析度，3色，颜色编码8bit，每秒25帧(25 frames per second)</p><p>Data rate：<script type="math/tex">640*480*3*8*25=184-million-bits/seconds</script></p><h4 id="Confusion-matrix-混淆矩阵"><a href="#Confusion-matrix-混淆矩阵" class="headerlink" title="Confusion matrix 混淆矩阵"></a>Confusion matrix 混淆矩阵</h4><p>对角线为正确分类</p><h4 id="特殊情况的混淆矩阵"><a href="#特殊情况的混淆矩阵" class="headerlink" title="特殊情况的混淆矩阵"></a>特殊情况的混淆矩阵</h4><p><strong>Recall</strong>：表示正确分类的比例：是否把所有猫都找出来了/ 1=目标是否全部都找到了/ 有多少目标找出来了，有多少目标没有被找出来（找错了不影响，只要找到了就行）</p><p><strong>Precision</strong>：表示正确预测的比例：正确找到了多少猫 / 1=找到的目标是否都是对的 / 找到的目标中有多少是正确的，有多少是错误的（没找到的不影响）</p><h4 id="Object-detection-物体探测"><a href="#Object-detection-物体探测" class="headerlink" title="Object detection 物体探测"></a>Object detection 物体探测</h4><h4 id="acceptable-bounding-box"><a href="#acceptable-bounding-box" class="headerlink" title="acceptable bounding-box"></a>acceptable bounding-box</h4><p>$AO=\frac{轮廓的交集}{轮廓的并集}（真实物体的轮廓和预测物体的轮廓）$</p><h4 id="Softmax-function"><a href="#Softmax-function" class="headerlink" title="Softmax function"></a>Softmax function</h4><p>维度归一化，且所有维度之和为1</p><p>softmax设计的初衷，是希望特征对概率的影响是乘性的。</p><p>我们希望分值大的那一项被经常取到，而分值较小的那一项也有一定的概率偶尔被取到，所以我们就应用到了soft的概念，即最后的输出是每个分类被取到的概率。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>一个线性方程的线性方程还是线性方程，所以线性方程的多层感知机实际上还是单层的，所以需要非线性的激活函数（激活函数的输入是上一层神经元输出的加权求和，输出是神经元的输入）</p><p>多层感知机中建立神经元的方式是一样的，但权重是不同的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人工智能/01 Introduction</title>
      <link href="/2020/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/01%20Introduction/"/>
      <url>/2020/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/01%20Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="01-Introduction"><a href="#01-Introduction" class="headerlink" title="01 Introduction"></a>01 Introduction</h2><p>关于深度学习</p><p>Reasoning with logic</p><p>Multi level Neuron processing</p><p>图像处理</p><p>文字处理</p><p>自然的智能——大脑、人</p><p>actually learning is really poor</p><p>模拟神经元</p><p>与环境交互</p><p>计算的模型作为自然智能的理论</p><p>自然智能的理论启发工业方案</p><p>预测——深度学习、机器学习</p><p>simulation</p><p>sensory input</p><p>evolutionary process</p><p>把传感器放入环境中，提取数据</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据的例子和技术前景</title>
      <link href="/2020/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/02%20EXAMPLES%20AND%20TECHNOLOGY%20LANDSCAPE/"/>
      <url>/2020/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/02%20EXAMPLES%20AND%20TECHNOLOGY%20LANDSCAPE/</url>
      
        <content type="html"><![CDATA[<p>大数据不是一个单独的科技、技术、或创新，而是一个可表征的趋势：对大量数据的收集，并从中获得收益</p><a id="more"></a><h4 id="什么是大数据"><a href="#什么是大数据" class="headerlink" title="什么是大数据"></a>什么是大数据</h4><ol><li>大量数据的收集</li><li>从中获得收益</li></ol><p>大数据不是一个单独的科技、技术、或创新，而是一个可表征的趋势</p><h4 id="大数据工具和技术"><a href="#大数据工具和技术" class="headerlink" title="大数据工具和技术"></a>大数据工具和技术</h4><ul><li>数据操控和分析：用于计算和回答明确的问题</li><li>数据挖掘：发现数据的模式(patterns)</li><li>机器学习：对缺失或未来的数据，进行预测或推断</li><li>数据可视化：把数据绘制成图像、Tableau</li><li>数据采集和准备：填充缺失数值、移除可疑的数据、格式化</li></ul><h4 id="如何理解大数据——Causation-因果关系-amp-Correlation-相关性"><a href="#如何理解大数据——Causation-因果关系-amp-Correlation-相关性" class="headerlink" title="如何理解大数据——Causation 因果关系 &amp; Correlation 相关性"></a>如何理解大数据——Causation 因果关系 &amp; Correlation 相关性</h4><p>相关性并不意味着因果关系，错误的把相关性当做是因果关系会导致经济损失等各种严重的后果</p><p>比如通过大数据发现：家里有书的孩子测试成绩更高，这几乎导致State of Illinois向州里的孩子们送书。但后来的研究发现：父母买书的家庭环境，学习是受到家长鼓励和回报的。在普通的视野里，这些是相关性而不是因果关系</p><h4 id="大数据的分类"><a href="#大数据的分类" class="headerlink" title="大数据的分类"></a>大数据的分类</h4><ul><li>分析类型：实时，分批</li><li>处理方法：预测分析，分析：社交网络分析、基于位置的分析、特征识别、文本分析、统计算法、转录(transcription)、语音分析，查询和报告，杂项(miscellaneous)：3D重建、翻译</li><li>数据频率：按需的、连续的、实时的、时间系列的；（the feeds可以是每月周日时分秒）</li><li>数据类型：媒体(Meta)数据，基准(Master)数据，历史数据、交易数据</li><li>内容格式：结构化的、非结构化的、半结构化的 —— 图像、文本、视频、文档、音频</li><li>数据来源：网页和社交媒体、机器、人类、网络数据源、交易数据、生物数据、通过数据供应商(Provider)、通过数据产生者(Originator)</li><li>数据的消费者：人、商业进程、其他企业应用、其他数据仓库</li><li>硬件：日常硬件、最新硬件</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4czdtd0rj30wi0nags9.jpg" alt="截屏2020-03-23下午5.08.16"  /></p><h4 id="场景例子"><a href="#场景例子" class="headerlink" title="场景例子"></a>场景例子</h4><p>人体佩戴设备：</p><ul><li>Volume：每个人每时每刻都会产生数据，如果所有人都佩戴，那么数据会不断积累；</li><li>Velocity：有些传感器需要实时更新数据到监控设备中，监控设备还需要即刻处理数据并反馈结果给用户；</li><li>Variety：各种各样的数据，比如Scanadu Scout测体温、心率、血压，EPOC - Emotiv 探测用户情绪，Rapid Rehab System测用户的走路模式；</li><li>Veracity：比如Asthmapolis需要精确的测量剂量dosage</li><li>Value：比如Hydration Sensor测量并分析用户的hydration level，可以提醒用户什么时候喝水，该喝多少水</li></ul><p>其他场景：智能商场，设备状况监控，汽车联网和自动驾驶，智能运输 Intelligent Transport，智能网格 Smart Grid，推荐系统，金融</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/02 Introduction to Cloud Computing</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02%20Introduction%20to%20Cloud%20Computing/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02%20Introduction%20to%20Cloud%20Computing/</url>
      
        <content type="html"><![CDATA[<h2 id="02-Introduction-to-Cloud-Computing"><a href="#02-Introduction-to-Cloud-Computing" class="headerlink" title="02 Introduction to Cloud Computing"></a>02 Introduction to Cloud Computing</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>云系统的分类、可视的基础架构管理者、云用例、云计算—开放问题</p><h4 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h4><p>“云”是一些可以自我维护和管理的虚拟计算资源，通常为一些大型服务器集群，包括计算服务器、存储服务器、宽带资源等等。云计算将所有的计算资源集中起来，并由软件实现自动管理，无需人为参与。</p><p>基本原理是将计算任务分布在云端的大量的分布式计算机上、数据也存储在云端，使得企业将有限的资源切换到需要的应用上，降低企业运行的成本。这样带来的结果是中小企业不需要购置专门的计算机系统去满足某一应用需求，只需要想云计算中心支付服务费即可获得响应服务，而云计算中心则大规模的云，以向用户提供服务。总的来说云计算具有如下的特点：超大规模云计算集群、虚拟化、高可靠性、通用性、按需服务、极其廉价。</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>分布式计算是一门计算机科学，它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多计算机进行处理，最后把这些计算结果综合起来得到最终的结果。分布式计算是利用互联网上的计算机的 CPU 的闲置处理能力来解决大型计算问题的一种计算科学。</p><p>一个分布式系统（Distributed System）是一组逻辑和物理上互联的处理单元的集合。其实质就是对资源的系统范围的分散控制，以达到应用程序的协同执行。这种系统不要求单台计算机的功能十分强大，故能降低成本。分布式系统具有快速访问、多用户使用的优点。系统中的每台计算机可以方便快捷的访问其他内部节点的信息文件，它既可以为本地用户的特殊要求服务，也可以为网络中其他用户服务，实现不同计算机之间的通信与协同工作。</p><h4 id="并行计算和分布式计算"><a href="#并行计算和分布式计算" class="headerlink" title="并行计算和分布式计算"></a>并行计算和分布式计算</h4><p>并行计算与分布式计算都是运用并行来获得更高性能，化大任务为小任务。<strong>简单说来，如果处理单元共享内存，就称为并行计算，反之就是分布式计算。</strong></p><p>但是分布式的任务包互相之间有独立性，上一个任务包的结果未返回或者是结果处理错误，对下一个任务包的处理几乎没有什么影响。因此，分布式的实时性要求不高，而且允许存在计算错误（因为每个计算任务给好几个参与者计算，上传结果到服务器后要比较结果，然后对结果差异大的进行验证。</p><h4 id="云系统的分类"><a href="#云系统的分类" class="headerlink" title="云系统的分类"></a>云系统的分类</h4><p>云的结构由3个服务层组成，服务可以在任何一层提供，更低的层对用户端隐藏</p><ol><li>Software as a Service：远程运行应用代替本地运行。比如通过浏览器运行应用程序，而不用下载安装。用户不需要管理任何东西。比如：Google Apps, Dropbox，Office365</li><li>Platform as a Service：Software stack软件堆栈促进应用程序的部署。比如提供一个平台（比如Apache）让开发者部署Web Application，开发者只需要管理和维护自己的应用(WebApp代码)和数据，运行状态、操作系统、网络等工作由平台自动管理和监控。比如：AWS Elastic Beanstalk</li><li>Infrastructure as a Service：由高度可扩展的自动化计算资源组成。 IaaS是完全自助服务，用于访问和监视计算机，网络，存储和其他服务。 IaaS允许企业按需和按需购买资源，而不必直接购买硬件。比如租一个Linux系统。用户需要管理自己的操作系统、中间件、运行状态、数据、应用。比如：Microsoft Azure</li></ol><p>Database、Function、Hardware、Sensor、Network … *  as a Service</p><h4 id="资源虚拟化"><a href="#资源虚拟化" class="headerlink" title="资源虚拟化"></a>资源虚拟化</h4><p>同一台机器上的不同的虚拟机可以运行不同的操作系统和多个应用</p><p>主要的虚拟化技术是：Hypervisor 虚拟机监控程序</p><ul><li><p>Virtual Machine Manager (VMM) 虚拟机管理者用户，通过仿真和硬件辅助虚拟化，透明地分割物理服务器主机</p></li><li><p>提供了一个全仿真的硬件环境：虚拟机、宾客操作系统</p></li></ul><p>Virtualization layer 虚拟层是一个中间层，位于硬件和系统的虚拟机之间</p><h4 id="云的结构"><a href="#云的结构" class="headerlink" title="云的结构"></a>云的结构</h4><ol><li><p>Distributed Application 分布式应用（SaaS）：被设计为 ”运行在多个机器上以执行一个特定的任务“ 的软件</p></li><li><p>Virtual Machine Cluster 虚拟机集群（PaaS）：一组包含内嵌程序的虚拟机，作为应用程序的中间层</p></li><li><p>Virtual Infrastructure Manager 虚拟基础架构管理者（IaaS）：把虚拟机分隔成组，管理上千的虚拟机</p></li><li><p>Hypervisor 虚拟机监控程序（IaaS）：在同一个机器上创建多个虚拟机的实例</p><p>如：VMware、ESX、Xen、KVM</p></li></ol><p>物理机器 -&gt; Hypervisor创建虚拟机镜像 -&gt; Virtual Infrastructure Manager管理上千的虚拟机镜像 -&gt; Virtual Machine Cluster 虚拟机镜像被上者分成不用的集群 -&gt; Distributed Application 应用分布在集群中，最后提供给用户 -&gt; User</p><h4 id="Virtual-Infrastructure-Manager-虚拟基础架构管理者"><a href="#Virtual-Infrastructure-Manager-虚拟基础架构管理者" class="headerlink" title="Virtual Infrastructure Manager 虚拟基础架构管理者"></a>Virtual Infrastructure Manager 虚拟基础架构管理者</h4><p>代表终端用户配置虚拟资源的供应。如Open Nebula </p><p>主要功能：</p><ul><li>虚拟资源调度<ul><li>镜像分段、创建、迁移、外包、终止</li></ul></li><li>虚拟和物理资源监控</li><li>用户访问控制</li></ul><h4 id="Virtual-Infrastructure-Manager和Hyperviosr的关系"><a href="#Virtual-Infrastructure-Manager和Hyperviosr的关系" class="headerlink" title="Virtual Infrastructure Manager和Hyperviosr的关系"></a>Virtual Infrastructure Manager和Hyperviosr的关系</h4><ul><li><strong>终端用户</strong>通过<strong>公开的云接口</strong>访问<strong><u>虚拟基础架构管理者</u></strong></li><li><p><strong>本地用户</strong>直接访问<strong><u>虚拟基础架构管理者</u></strong></p></li><li><p><strong><u>虚拟基础架构管理者</u></strong>通过本地的<strong><u>Hypervisor虚拟机监控程序</u></strong>访问<strong>私有本地物理资源（私有云）</strong></p></li><li><p><strong><u>虚拟基础架构管理者</u></strong>通过<strong>外包接口</strong>访问<strong>共有远程物理资源（公有云）</strong></p></li></ul><center><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbw4v6twoj30hw0hiac7.jpg" alt="截屏2020-01-27下午10.48.44" style="zoom:50%"/></center><h4 id="云结构各部分的关系"><a href="#云结构各部分的关系" class="headerlink" title="云结构各部分的关系"></a>云结构各部分的关系</h4><ol><li><u><strong>分布式应用</strong></u>部署在虚拟机集群中</li><li>通过分布式应用，<strong><u>虚拟基础设施管理者</u></strong>把<strong><u>虚拟机集群资源</u></strong>提供给用户</li><li><strong><u>基础设施管理者</u></strong>通过<u><strong>基础设施监控程序</strong></u>提供虚拟资源</li></ol><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbw3mv0voj30nk0lyqa6.jpg" alt="截屏2020-01-27下午10.48.04" style="zoom:50%;" /></p><h4 id="Virtual-Infrastructure-Manager"><a href="#Virtual-Infrastructure-Manager" class="headerlink" title="Virtual Infrastructure Manager"></a>Virtual Infrastructure Manager</h4><p><strong>Open Nebula</strong></p><p>特点：通过云插件进行多站点资源池、Hypervisor监控程序诊断、广泛采用云接口、简单的用户管理、灵活的模块化设计、成熟</p><p><strong>Openstack</strong></p><p>特点：高效地分配资源、通过服务门户授权管理员和用户、开发者通过API授权使应用具有”云感知“的能力、使”云“能够联合(cloud federation)</p><h4 id="企业-云-企业"><a href="#企业-云-企业" class="headerlink" title="企业-云-企业"></a>企业-云-企业</h4><p>重点是将资源托管在云中，以便企业间的应用程序可以相互操作</p><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><p>”混合云“可以由”federated cloud provider联合云提供商”交付，将其自身的资源与其他提供商的资源相结合</p><h4 id="Cloud-federation"><a href="#Cloud-federation" class="headerlink" title="Cloud federation"></a>Cloud federation</h4><p>different clouds can share resources：</p><ul><li><p>如果其中一个云的负载满了，那么cloud1的虚拟机可以迁移到cloud2</p></li><li><p>用户与broker（代理人/经纪人）交互，broker决定是与cloud1或2或3进行交互，但对于用户来说，cloud1 2 3是透明的。</p></li></ul><h3 id="Worksheet-1-问题"><a href="#Worksheet-1-问题" class="headerlink" title="Worksheet 1 问题"></a>Worksheet 1 问题</h3><ol><li><p><strong>Make a list of activities that you do every day in which cloud computing is used. How would your life be altered if cloud services were suddenly switched off?</strong></p><p>Office 365，Outlook，Google Cloud Platform；</p><p>云计算能够为企业提供廉价的按需付费的服务，这样企业可以专注于自己的商业目标，减少了购买和维护额外计算机资源的花费（比如租用云服务器而不是购买硬件），进而降低了成本。如果没有了云计算，那么企业的成本会增加，也会导致产品定价上涨，因此消费者需要花更多的钱的购买产品</p><p>Cloud can help companies to focus on whatever their business domain is. The total cost will decrease by the form of cloud amortization</p></li><li><p>What is meant by ”cloud” in cloud computing?</p><p>“云”是一些可以自我维护和管理的虚拟计算资源，通常为一些大型服务器集群，包括计算服务器、存储服务器、宽带资源等等。云计算将所有的计算资源集中起来，并由软件实现自动管理，无需人为参与。</p></li><li><p>Where do the clouds reside?</p><p>cloud center / data center</p></li><li><p>Which of the following is an advantage of the cloud computing approach:</p><ul><li>it is ubiquitous</li><li>enabled by pay-for-usage model </li><li>responsiveness</li><li><strong>all of these</strong></li></ul></li><li><p>What is the main advantage of utility computing (公用计算) as compared to traditional computing?</p><p><strong>Utility computing</strong> is a service provisioning model in which a service provider makes computing resources and infrastructure management available to the customer as needed. Utility computing support a pay-per-use service while traditional computing is flat rate.</p></li><li><p>Check the Amazon Web Services (AWS) cloud Web site. How would you plan a real computing application using EC2 or S3? You must specify the resources requested and figure out the costs charged by Amazon.</p><p>系统、CPU、内存、硬盘大小、带宽、数据中心位置</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/02_ Virtual Infrastructure</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02_%20Virtual%20Infrastructure/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02_%20Virtual%20Infrastructure/</url>
      
        <content type="html"><![CDATA[<h2 id="Virtual-Infrastructure"><a href="#Virtual-Infrastructure" class="headerlink" title="Virtual Infrastructure"></a>Virtual Infrastructure</h2><p>A virtual infrastructure is a software-based IT infrastructure being hosted on another physical infrastructure and meant to be distributed as a service as in cloud computing’s infrastructure as a service (IaaS) delivery model. It provides organizations, particularly smaller ones that cannot afford to build their own physical infrastructure, access to enterprise-grade technology such as servers and applications. The distribution is often done via the cloud, meaning over large networks such as the internet.</p><p>The main purpose of a virtual infrastructure is to bring enterprise-level technology to organizations that cannot afford the large capital required to pay for the hardware, software licenses, setup and continual maintenance of an actual data center infrastructure. The technology involves virtualization, which is the utilization of physical server resources to host logical or virtual servers and networking hardware in order to optimize resources and drive costs down by hosting multiple virtual servers in a single host server.</p><p>The idea is that no single server is actually taxed enough to the point that its resource limits are reached so it would be more prudent to make use of these resources by running multiple logical servers that, together, can make use of the actual capacity of the host. This lean approach allows for sharing and distributing resources, which, in turn, promotes flexibility, scalability and lower total cost of ownership.</p><p>Benefits of a virtual infrastructure:</p><ul><li>Scalable – Allows provisioning as many or as few logical servers as required, and users only pay for what they use.</li><li>Flexible – Allows for multiple server and networking configurations as compared to a hardwired physical infrastructure, which requires more capital and effort to change.</li><li>Secure – Allows more security to be layered on top of whatever security is already present in the virtual infrastructure because all traffic to the virtual infrastructure goes through the actual physical infrastructure.</li><li>Load balancing – Allows software-based servers to share workloads easily and distribute them properly so that no single logical server is taxed more than the others.</li><li>Backup and recovery – Promotes easier backups because everything can be saved somewhere, allowing for quick recovery in other hosts if a few hosts are down. This is almost impossible with physical servers, which have to be revived before services can resume.</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>介绍大数据</title>
      <link href="/2020/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/01%20INTRODUCTION,%20HISTORY,%20AND%20DEFINITIONS/"/>
      <url>/2020/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/01%20INTRODUCTION,%20HISTORY,%20AND%20DEFINITIONS/</url>
      
        <content type="html"><![CDATA[<p>大数据指的是复杂和巨大的数据集，使得传统的<u>数据库</u>或<u>数据处理</u>的软件工具无法获取、储存、管理、处理、分析。</p><p>大数据的5V： Volume Velocity Variety Veracity Value</p><a id="more"></a><h4 id="IoT-物联网"><a href="#IoT-物联网" class="headerlink" title="IoT 物联网"></a>IoT 物联网</h4><p>指环境中的人、动物、或物体具有唯一标识符，能够通过网络传输数据，而不需要人与人或人与电脑的交互。也指<u>万物互联</u></p><h4 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h4><p>复杂和巨大的数据集，使得传统的<u>数据库</u>或<u>数据处理</u>的软件工具无法获取、储存、管理、处理、分析</p><h4 id="大数据的3个特征-——-Volume-Velocity-Variety"><a href="#大数据的3个特征-——-Volume-Velocity-Variety" class="headerlink" title="大数据的3个特征 —— Volume Velocity Variety"></a>大数据的3个特征 —— Volume Velocity Variety</h4><p>Volume：就存储和访问而言，数据量十分庞大</p><p>Velocity：数据传入的速度以及处理时间</p><p>Variety：文件的种类，数据的格式和来源</p><h4 id="Volume增长的因素"><a href="#Volume增长的因素" class="headerlink" title="Volume增长的因素"></a>Volume增长的因素</h4><ol><li>基于交易的数据的不断积累</li><li>来自社交媒体的 Unstructured data streaming 非结构化数据流，结合关系数据（评论、讨论、支持投票等）</li></ol><p>其他例子：</p><ol><li><p>Facebook and Youtube have billions of users, Twitter and Instagram have hundreds of millions users. Every day, these users contribute to billions of images, posts, videos, tweets etc.</p></li><li><p>Most of the companies in the US have at least 100 Terabytes of data stored.</p></li><li><p>It’s estimated that 2.5 quintillion bytes of data are created each day.</p></li></ol><h4 id="Velocity"><a href="#Velocity" class="headerlink" title="Velocity"></a>Velocity</h4><p>数据速度，既是数据流入(stream in)的速度，也是处理数据的速度以保证数据的时效性(timeliness)</p><p>比如：</p><ol><li><p>实时处理和储存国家天气信息、即时响应高频率的股票交易和快速分析、</p></li><li><p>Tmall’s total turnover exceeded 10 billion CNY in the first 96 seconds at 11th Nov 2019</p></li><li><p>Modern cars have close to 100 sensors that monitor items such as fuel level and tire pressure</p></li></ol><h4 id="Variety"><a href="#Variety" class="headerlink" title="Variety"></a>Variety</h4><p>Variety is all about the ability to classify the incoming data into various categories.<br>多样性是指将传入数据分类为各种类别的能力。</p><p>数据有各种各样的格式，但可以被分为2种：<strong>structured 结构化</strong> 和 <strong>unstructured 非结构化</strong></p><p><strong>结构化数据</strong>：是传统数据库中的数字数据，从业务线(line-of-business)和预格式化(pre-formatted)数据中创建，随时间推移收集</p><p><strong>非结构化数据</strong>：是相关的或看似无关的数据，来自非结构化来源（社交媒体，文本文档，电子邮件，视频，音频等）</p><p>比如：</p><p>data in healthcare、data from wearable, wireless health monitors、pieces of content from Facebook and Twitter</p><h4 id="Veracity-和-Value-——-用于描述大数据的特征，而不是定义特征"><a href="#Veracity-和-Value-——-用于描述大数据的特征，而不是定义特征" class="headerlink" title="Veracity 和 Value —— 用于描述大数据的特征，而不是定义特征"></a>Veracity 和 Value —— 用于描述大数据的特征，而不是定义特征</h4><p>Veracity：数据的准确性和意义的多少</p><p>Value：从数据中可获得的价值的多少</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5Vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算/02_ SaaS, PaaS, IaaS</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02_%20SaaS,%20PaaS,%20IaaS/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/02_%20SaaS,%20PaaS,%20IaaS/</url>
      
        <content type="html"><![CDATA[<h1 id="SaaS-PaaS-IaaS"><a href="#SaaS-PaaS-IaaS" class="headerlink" title="SaaS, PaaS, IaaS"></a>SaaS, PaaS, IaaS</h1><h2 id="Summary-of-Key-Differences"><a href="#Summary-of-Key-Differences" class="headerlink" title="Summary of Key Differences"></a>Summary of Key Differences</h2><p><img src="https://blogs.bmc.com/wp-content/uploads/2017/09/iaas-paas-saas-comparison-1024x759.jpg" alt="Differences between SaaS, PaaS, &amp; IaaS"></p><h2 id="Common-Examples-of-SaaS-PaaS-amp-IaaS"><a href="#Common-Examples-of-SaaS-PaaS-amp-IaaS" class="headerlink" title="Common Examples of SaaS, PaaS, &amp; IaaS"></a>Common Examples of SaaS, PaaS, &amp; IaaS</h2><div class="table-container"><table><thead><tr><th><strong>Platform Type</strong></th><th><strong>Common Examples</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td>Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting</td></tr><tr><td><strong>PaaS</strong></td><td>AWS Elastic Beanstalk, Windows Azure, Heroku, Force.com, Google App Engine, Apache Stratos, OpenShift</td></tr><tr><td><strong>IaaS</strong></td><td>DigitalOcean, Linode, Rackspace, Amazon Web Services (AWS), Cisco Metapod, Microsoft Azure, Google Compute Engine (GCE)</td></tr></tbody></table></div><h2 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS: Software as a Service"></a>SaaS: Software as a Service</h2><p>Software as a Service, also known as cloud application services, represents the most commonly utilized option for businesses in the cloud market. SaaS utilizes the internet to deliver applications, which are managed by a third-party vendor, to its users. A majority of SaaS applications run directly through your web browser, which means they do not require any downloads or installations on the client side.</p><h3 id="SaaS-Delivery"><a href="#SaaS-Delivery" class="headerlink" title="SaaS Delivery"></a>SaaS Delivery</h3><p>Due to its web delivery model, SaaS eliminates the need to have IT staff download and install applications on each individual computer. With SaaS, vendors manage all potential technical issues, such as data, middleware, servers, and storage, resulting in streamlined maintenance and support for the business.</p><h3 id="SaaS-Advantages"><a href="#SaaS-Advantages" class="headerlink" title="SaaS Advantages"></a>SaaS Advantages</h3><p>As a reuslt, It can greatly reducing the time and money spent on tedious tasks such as installing, managing, and upgrading software. This frees up plenty of time for technical staff to spend on more pressing matters and issues within the organization.</p><h3 id="SaaS-Characteristics"><a href="#SaaS-Characteristics" class="headerlink" title="SaaS Characteristics"></a>SaaS Characteristics</h3><p>There are a few ways to help you determine when SaaS is being utilized:</p><ul><li>Managed from a central location</li><li>Hosted on a remote server</li><li>Accessible over the internet</li><li>Users not responsible for hardware or software updates</li></ul><h3 id="When-to-Use-SaaS"><a href="#When-to-Use-SaaS" class="headerlink" title="When to Use SaaS"></a>When to Use SaaS</h3><p>SaaS may be the most beneficial option in several situations, including:</p><ul><li>Startups or small companies that need to launch ecommerce quickly and don’t have time for server issues or software</li><li>Short-term projects that require quick, easy, and affordable collaboration</li><li>Applications that aren’t needed too often, such as tax software</li><li>Applications that need both web and mobile access</li></ul><h3 id="SaaS-Limitations-and-Concerns"><a href="#SaaS-Limitations-and-Concerns" class="headerlink" title="SaaS Limitations and Concerns"></a>SaaS Limitations and Concerns</h3><ul><li><strong>Interoperability.</strong> Integration with existing apps and services can be a major concern if the SaaS app is not designed to follow open standards for integration. In this case, organizations may need to design their own integration systems or reduce dependencies with SaaS services, which may not always be possible.</li><li><strong>Vendor lock-in.</strong> Vendors may make it easy to join a service and difficult to get out of it. For instance, the data may not be portable–technically or cost-effectively–across SaaS apps from other vendors without incurring significant cost or inhouse engineering rework. Not every vendor follows standard APIs, protocols, and tools, yet the features could be necessary for certain business tasks.</li><li><strong>Lack of integration support.</strong> Many organizations require deep integrations with on-premise apps, data, and services. The SaaS vendor may offer limited support in this regard, forcing organizations to invest internal resources in designing and managing integrations. The complexity of integrations can further limit how the SaaS app or other dependent services can be used.</li><li><strong>Data security.</strong> Large volumes of data may have to be exchanged to the backend data centers of SaaS apps in order to perform the necessary software functionality. Transferring sensitive business information to public-cloud based SaaS service may result in compromised security and compliance in addition to significant cost for migrating large data workloads.</li><li><strong>Customization.</strong> SaaS apps offer minimal customization capabilities. Since a one-size-fits-all solution does not exist, users may be limited to specific functionality, performance, and integrations as offered by the vendor. In contrast, on-premise solutions that come with several software development kits (SDKs) offer a high degree of customization options.</li><li><strong>Lack of control.</strong> SaaS solutions involves handing control over to the third-party service provider. These controls are not limited to the software–in terms of the version, updates, or appearance–but also the data and governance. Customers may therefore need to redefine their data security and governance models to fit the features and functionality of the SaaS service.</li><li><strong>Feature limitations.</strong> Since SaaS apps often come in a standardized form, the choice of features may be a compromising tradeoff against security, cost, performance, or other organizational policies. Furthermore, vendor lock-in, cost, or security concerns may mean it’s not viable to switch vendors or services to serve new feature requirements in the future.</li><li><strong>Performance and downtime.</strong> Because the vendor controls and manages the SaaS service, your customers now depend on vendors to maintain the service’s security and performance. Planned and unplanned maintenance, cyber-attacks, or network issues may impact the performance of the SaaS app despite adequate service level agreement (SLA) protections in place.</li></ul><h3 id="Examples-of-SaaS"><a href="#Examples-of-SaaS" class="headerlink" title="Examples of SaaS"></a>Examples of SaaS</h3><p>These are several popular examples of SaaS, including: <a href="https://gsuite.google.com/" target="_blank" rel="noopener">Google GSuite</a> (Apps), <a href="https://www.dropbox.com/" target="_blank" rel="noopener">Dropbox</a>, <a href="https://www.salesforce.com/" target="_blank" rel="noopener">Salesforce</a>, <a href="https://www.webex.com/" target="_blank" rel="noopener">Cisco WebEx</a>, <a href="https://www.concur.com/" target="_blank" rel="noopener">SAP Concur</a>, and <a href="https://www.gotomeeting.com/" target="_blank" rel="noopener">GoToMeeting</a>.</p><h2 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS: Platform as a Service"></a>PaaS: Platform as a Service</h2><p>Cloud platform services, also known as Platform as a Service (PaaS), provide cloud components to certain software while being used mainly for applications. PaaS delivers a framework for developers that they can build upon and use to create customized applications. All servers, storage, and networking can be managed by the enterprise or a third-party provider while the developers can maintain management of the applications.</p><h3 id="PaaS-Delivery"><a href="#PaaS-Delivery" class="headerlink" title="PaaS Delivery"></a>PaaS Delivery</h3><p>The delivery model of PaaS is similar to SaaS, except instead of delivering the software over the internet, PaaS provides a platform for software creation. This platform is delivered via the web, giving developers the freedom to concentrate on building the software without having to worry about operating systems, software updates, storage, or infrastructure.</p><p>PaaS allows businesses to design and create applications that are built into the PaaS with special software components. These applications, sometimes called middleware, are scalable and highly available as they take on certain cloud characteristics.</p><h3 id="PaaS-Advantages"><a href="#PaaS-Advantages" class="headerlink" title="PaaS Advantages"></a>PaaS Advantages</h3><p>No matter the size of your company, using PaaS offers numerous advantages, including:</p><ul><li>Simple, cost-effective development and deployment of apps</li><li>Scalable</li><li>Highly available</li><li>Developers can customize apps without the headache of maintaining the software</li><li>Significant reduction in the amount of coding needed</li><li>Automation of business policy</li><li>Easy migration to the hybrid model</li></ul><h3 id="PaaS-Characteristics"><a href="#PaaS-Characteristics" class="headerlink" title="PaaS Characteristics"></a>PaaS Characteristics</h3><p>PaaS has many characteristics that define it as a cloud service, including:</p><ul><li>Builds on virtualization technology, so resources can easily be scaled up or down as your business changes</li><li>Provides a variety of services to assist with the development, testing, and deployment of apps</li><li>Accessible to numerous users via the same development application</li><li>Integrates web services and databases</li></ul><h3 id="When-to-Use-PaaS"><a href="#When-to-Use-PaaS" class="headerlink" title="When to Use PaaS"></a>When to Use PaaS</h3><p>Utilizing PaaS is beneficial, sometimes even necessary, in several situations. For example, PaaS can streamline workflows when multiple developers are working on the same development project. If other vendors must be included, PaaS can provide great speed and flexibility to the entire process. PaaS is particularly beneficial if you need to create customized applications. This cloud service also can greatly reduce costs and it can simplify some challenges that come up if you are rapidly developing or deploying an app.</p><h3 id="PaaS-Limitations-and-Concerns"><a href="#PaaS-Limitations-and-Concerns" class="headerlink" title="PaaS Limitations and Concerns"></a>PaaS Limitations and Concerns</h3><ul><li><strong>Data security.</strong> Organizations can run their own apps and services using PaaS solutions, but the data residing in third-party, vendor-controlled cloud servers poses security risks and concerns. Your security options may be limited as customers may not be able to deploy services with specific hosting policies.</li><li><strong>Integrations.</strong> The complexity of connecting the data stored within an onsite data center or off-premise cloud is increased, which may affect which apps and services can be adopted with the PaaS offering. Particularly when not every component of a legacy IT system is built for the cloud, integration with existing services and infrastructure may be a challenge.</li><li><strong>Vendor lock-in.</strong> Business and technical requirements that drive decisions for a specific PaaS solution may not apply in the future. If the vendor has not provisioned convenient migration policies, switching to alternative PaaS options may not be possible without affecting the business.</li><li><strong>Customization of legacy systems.</strong> PaaS may not be a plug-and-play solution for existing legacy apps and services. Instead, several customizations and configuration changes may be necessary for legacy systems to work with the PaaS service. The resulting customization can result in a complex IT system that may limit the value of the PaaS investment altogether.</li><li><strong>Runtime issues.</strong> In addition to limitations associated with specific apps and services, PaaS solutions may not be optimized for the language and frameworks of your choice. Specific framework versions may not be available or perform optimally with the PaaS service. Customers may not be able to develop custom dependencies with the platform.</li><li><strong>Operational limitation.</strong> Customized cloud operations with management automation workflows may not apply to PaaS solutions, as the platform tends to limit operational capabilities for end users. Although this is intended to reduce the operational burden on end users, the loss of operational control may affect how PaaS solutions are managed, provisioned, and operated.</li></ul><h3 id="Examples-of-PaaS"><a href="#Examples-of-PaaS" class="headerlink" title="Examples of PaaS"></a>Examples of PaaS</h3><p>Popular examples of PaaS include <a href="https://aws.amazon.com/elasticbeanstalk/" target="_blank" rel="noopener">AWS Elastic Beanstalk</a>, <a href="https://azure.microsoft.com/en-us/free/windows-server-on-azure/" target="_blank" rel="noopener">Windows Azure</a>, <a href="https://www.heroku.com/" target="_blank" rel="noopener">Heroku</a>, <a href="https://developer.salesforce.com/platform/force.com" target="_blank" rel="noopener">Force.com</a>, <a href="https://cloud.google.com/appengine/" target="_blank" rel="noopener">Google App Engine</a>, and <a href="https://www.openshift.com/" target="_blank" rel="noopener">OpenShift</a>.</p><h2 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS: Infrastructure as a Service"></a>IaaS: Infrastructure as a Service</h2><p>Cloud infrastructure services, known as Infrastructure as a Service (IaaS), are made of highly scalable and automated compute resources. IaaS is fully <a href="https://www.bmc.com/blogs/self-service-thrives-clouds/" target="_blank" rel="noopener">self-service</a> for accessing and monitoring computers, networking, storage, and other services. IaaS allows businesses to purchase resources on-demand and as-needed instead of having to buy hardware outright.</p><h3 id="IaaS-Delivery"><a href="#IaaS-Delivery" class="headerlink" title="IaaS Delivery"></a>IaaS Delivery</h3><p>IaaS delivers cloud computing infrastructure, including servers, network, operating systems, and storage, through virtualization technology. These cloud servers are typically provided to the organization through a dashboard or an API, giving IaaS clients complete control over the entire infrastructure. IaaS provides the same technologies and capabilities as a traditional data center without having to physically maintain or manage all of it. IaaS clients can still access their servers and storage directly, but it is all outsourced through a “virtual data center” in the cloud.</p><p>As opposed to SaaS or PaaS, IaaS clients are responsible for managing aspects such as applications, runtime, OSes, middleware, and data. However, providers of the IaaS manage the servers, hard drives, networking, virtualization, and storage. Some providers even offer more services beyond the virtualization layer, such as databases or message queuing.</p><h3 id="IaaS-Advantages"><a href="#IaaS-Advantages" class="headerlink" title="IaaS Advantages"></a>IaaS Advantages</h3><p>IaaS offers many advantages, including:</p><ul><li>The most flexible cloud computing model</li><li>Easy to automate deployment of storage, networking, servers, and processing power</li><li>Hardware purchases can be based on consumption</li><li>Clients retain complete control of their infrastructure</li><li>Resources can be purchased as-needed</li><li>Highly scalable</li></ul><h3 id="IaaS-Characteristics"><a href="#IaaS-Characteristics" class="headerlink" title="IaaS Characteristics"></a>IaaS Characteristics</h3><p>Characteristics that define IaaS include:</p><ul><li>Resources are available as a service</li><li>Cost varies depending on consumption</li><li>Services are highly scalable</li><li>Multiple users on a single piece of hardware</li><li>Organization retain complete control of the infrastructure</li><li>Dynamic and flexible</li></ul><h3 id="When-to-Use-IaaS"><a href="#When-to-Use-IaaS" class="headerlink" title="When to Use IaaS"></a>When to Use IaaS</h3><p>Just as with SaaS and PaaS, there are specific situations when IaaS is most advantageous.</p><p>Startups and small companies may prefer IaaS to avoid spending time and money on purchasing and creating hardware and software. Larger companies may prefer to retain complete control over their applications and infrastructure, but they want to purchase only what they actually consume or need. Companies experiencing rapid growth like the scalability of IaaS, and they can change out specific hardware and software easily as their needs evolve. Anytime you are unsure of a new application’s demands, IaaS offers plenty of flexibility and scalability.</p><h3 id="IaaS-Limitations-and-Concerns"><a href="#IaaS-Limitations-and-Concerns" class="headerlink" title="IaaS Limitations and Concerns"></a>IaaS Limitations and Concerns</h3><p>Many limitations associated with SaaS and PaaS models – such as data security, cost overruns, vendor lock-in and customization issues – also apply to the IaaS model. Particular limitations to IaaS include:</p><ul><li><strong>Security.</strong> While the customer is in control of the apps, data, middleware, and the OS platform, security threats can still be sourced from the host or other virtual machines (VMs). Insider threat or system vulnerabilities may expose data communication between the host infrastructure and VMs to unauthorized entities.</li><li><strong>Legacy systems operating in the cloud.</strong> While customers can run legacy apps in the cloud, the infrastructure may not be designed to deliver specific controls to secure the legacy apps. Minor enhancement to legacy apps may be required before migrating them to the cloud, possibly leading to new security issues unless adequately tested for security and performance in the IaaS systems.</li><li><strong>Internal resources and training.</strong> Additional resources and training may be required for the workforce to learn how to effectively manage the infrastructure. Customers will be responsible for data security, backup, and business continuity. Due to inadequate control into the infrastructure however, monitoring and management of the resources may be difficult without adequate training and resources available inhouse.</li><li><strong>Multi-tenant security.</strong> Since the hardware resources are dynamically allocated across users as made available, the vendor is required to ensure that other customers cannot access data deposited to storage assets by previous customers. Similarly, customers must rely on the vendor to ensure that VMs are adequately isolated within the multitenant cloud architecture.</li></ul><h3 id="Examples-of-IaaS"><a href="#Examples-of-IaaS" class="headerlink" title="Examples of IaaS"></a>Examples of IaaS</h3><p>Popular examples of IaaS include <a href="https://www.digitalocean.com/" target="_blank" rel="noopener">DigitalOcean</a>, <a href="https://www.linode.com/" target="_blank" rel="noopener">Linode</a>, <a href="https://www.rackspace.com/" target="_blank" rel="noopener">Rackspace</a>, <a href="https://aws.amazon.com/" target="_blank" rel="noopener">Amazon Web Services (AWS)</a>, <a href="https://www.cisco.com/c/en/us/products/cloud-systems-management/metacloud/index.html" target="_blank" rel="noopener">Cisco Metacloud</a>, <a href="https://azure.microsoft.com/en-us/" target="_blank" rel="noopener">Microsoft Azure</a>, and <a href="https://cloud.google.com/compute/" target="_blank" rel="noopener">Google Compute Engine (GCE)</a>.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云计算/01 Introduction to Cloud Computing</title>
      <link href="/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/01%20Introduction%20to%20Cloud%20Computing/"/>
      <url>/2020/01/%E4%BA%91%E8%AE%A1%E7%AE%97/01%20Introduction%20to%20Cloud%20Computing/</url>
      
        <content type="html"><![CDATA[<h2 id="01-Introduction-to-Cloud-Computing"><a href="#01-Introduction-to-Cloud-Computing" class="headerlink" title="01 Introduction to Cloud Computing"></a>01 Introduction to Cloud Computing</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>相关技术、分布式系统的演化、云计算的定义、基础架构的可视化，概念云的结构</p><h4 id="分布式系统的演化"><a href="#分布式系统的演化" class="headerlink" title="分布式系统的演化"></a>分布式系统的演化</h4><p>Exponential growth 指数型增长</p><p>Mainframes (打孔条，做计算，给出结果) -&gt; Clusters -&gt; Grids -&gt; Clouds</p><p><strong>Cloud Computing的特点</strong>：on-demand services</p><h4 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h4><p>作用：模拟真实世界的科学问题和工程学问题</p><p><strong>Parallelisation</strong> ——好处：提供更强的计算能力和更多内存memory。——挑战：进程间的通信很慢</p><h4 id="网络-network-speed、计算机速度-computer-speed、存储容量-storage-density"><a href="#网络-network-speed、计算机速度-computer-speed、存储容量-storage-density" class="headerlink" title="网络 network speed、计算机速度 computer speed、存储容量 storage density"></a>网络 network speed、计算机速度 computer speed、存储容量 storage density</h4><p>Doubles every 9 months, doubles every 18 months, doubles every 12 months</p><h4 id="分布式计算的变化范例（Could-云计算和-Grid-网格计算的区别）"><a href="#分布式计算的变化范例（Could-云计算和-Grid-网格计算的区别）" class="headerlink" title="分布式计算的变化范例（Could 云计算和 Grid 网格计算的区别）"></a>分布式计算的变化范例（Could 云计算和 Grid 网格计算的区别）</h4><ol><li>linked all <strong>machines 机器</strong> together：Internet, TCP/IP</li><li>linked all <strong>documents 文件</strong> together：WWW, HTTP, HTML, XML</li><li>linked all <strong>applications 应用</strong> together：Web services, SOAP, WSDL, UDDI, REST</li><li>linker <strong>everything else 其他</strong> together：<ul><li><strong>Grid：分散化的基础设施 decentralised infrasturctures</strong></li><li><strong>Could：中心化的基础设施 centralised infrastructrues</strong></li></ul></li></ol><h4 id="Delivery-Network-传输网络"><a href="#Delivery-Network-传输网络" class="headerlink" title="Delivery Network 传输网络"></a>Delivery Network 传输网络</h4><p>Water Distribution Network 水网, Power Grid 电网, Gas Netwrok 煤气网, Telecom Network 电信网</p><h4 id="云计算的定义"><a href="#云计算的定义" class="headerlink" title="云计算的定义"></a>云计算的定义</h4><p>是一个模型，提供对共享的计算资源的访问；访问通过网络支持，无论何地用户都可以按需访问；共享的可配置的计算资源，能够快速提供给客户，并且对管理者的工作需求减少到最低——NIST (National Institute of Standards and Technology)</p><ol><li><p>On-demand self-service 按需自助服务</p></li><li><p>Broad network access 广泛的网络访问</p></li><li><p>Resource pooling 资源池</p></li><li><p>Rapid elasticity or expansion 快速的弹性或扩展</p></li><li><p>Measured service 测试评估服务</p><p>比如：用了多少资源（带宽）是可以计算的</p></li></ol><h4 id="虚拟的基础架构："><a href="#虚拟的基础架构：" class="headerlink" title="虚拟的基础架构："></a>虚拟的基础架构：</h4><p><strong>虚拟的服务平台</strong>的特点（好处）</p><ul><li>服务系统的整合</li><li>降低成本</li><li>降低复杂性</li><li>简化管理</li><li>按使用付费</li></ul><h4 id="云的定义"><a href="#云的定义" class="headerlink" title="云的定义"></a>云的定义</h4><p><strong>Cloud infrastructure 云架构 </strong>，提供了一个框架，用于管理对应用程序的访问，该访问可扩展、可靠、并且可以按需使用</p><p><strong>云</strong>，对于许多手机应用程序来说，是一个不可见的后端</p><h4 id="云数据中心"><a href="#云数据中心" class="headerlink" title="云数据中心"></a>云数据中心</h4><p>1~10万个主机，紧密耦合，相互紧挨着：电子商户（Amazon），内容服务器（YouTube、Apple、Microsoft），搜索引擎、数据挖掘（Google）</p><p><strong>挑战</strong>：多应用，每个应用服务于大量的客户；管理和平衡负载，处理、网络，数据管理</p><h4 id="Virtualised-Infrastructure-云架构-——-Multitenancy"><a href="#Virtualised-Infrastructure-云架构-——-Multitenancy" class="headerlink" title="Virtualised Infrastructure 云架构 —— Multitenancy"></a>Virtualised Infrastructure 云架构 —— Multitenancy</h4><p>是一个新兴的计算范例，其中数据和服务在可大规模扩展(massively scalable)的数据中心，并且通过互联网，可以被任何设备在任何地方进行访问</p><p>传统计算和云计算的比较</p><ul><li>获得：买设备/ 买服务</li><li>商业： 提前购买固定的设备和管理 / 按需购买</li><li>访问：通过内部网访问桌面/ 通过网络访问任何设备</li><li>技术：single tenant，静态的，非共享的 / <strong>multi-tenant</strong>，可扩展的，弹性的，动态</li></ul><h4 id="Multi-tenancy-model-多重租赁技术"><a href="#Multi-tenancy-model-多重租赁技术" class="headerlink" title="Multi tenancy model 多重租赁技术"></a>Multi tenancy model 多重租赁技术</h4><p>Allows a single implementation of a service to multiple customers.</p><p>A tenant (software vendor) can have many users (software customer) subscribed to its application and a user can be subscribed to different tenants’ applications, paying only for the ones that he really needs.</p><p>一个tenant的应用可以被许多用户订阅，一个用户可以订阅许多tenant的应用，并且只对需要的那个付费。</p><p>Multi-tenant 可以用在Saas, PaaS, IaaS上</p><p>影响：</p><ul><li>提高资源共享的效率(increase the efficiency of using resources - both hardware and human, achieving low priced software)，因此降低双方成本(decrease the cost)；</li><li>提高实现和管理的复杂度(comlexity of implementation and management)；</li><li>简化发布管理流程 (simplifies the release management process. For example, the central, single point updates that allow all customers to have the latest version)；</li><li>提高发布新版本带来的风险和影响（会影响所有租客/用户）;</li><li>All the code is in one place and it is much easier to maintain, update and back up,  and consequently, cheaper.</li></ul><p>特点：Multi-user environment（多个用户使用同一个软件资源）；Multi-property（把infrastructure集中在一起提供给tenant，improve the use and efficiency of underutilized resources, e.g. computer system）；</p><h4 id="云计算的好处"><a href="#云计算的好处" class="headerlink" title="云计算的好处"></a>云计算的好处</h4><p><strong>技术上</strong></p><ol><li>按需扩展资源</li><li>对按需增长的实时反应（elasticity弹性）</li><li>硬件整合，不再需要同规格homogeneity，可避免加锁</li><li>简化硬件配置</li><li>资源透明（自动化 / 容错：自动恢复机制）</li></ol><p><strong>经济上</strong></p><ol><li>服务供应链</li><li>减低维护成本</li><li>避免资金支出</li><li>降低准入门槛</li><li>减少电力和冷却成本</li></ol><h4 id="消费者和服务商的目的"><a href="#消费者和服务商的目的" class="headerlink" title="消费者和服务商的目的"></a>消费者和服务商的目的</h4><p><strong>消费者</strong>：达到服务质量，减少开支</p><p><strong>云服务提供商</strong>：吸引客户，最大化利润</p><h4 id="The-vision"><a href="#The-vision" class="headerlink" title="The vision"></a>The vision</h4><p><strong>Infrastructure provider</strong>：like Google、Amazon，提供设备、硬件、网络等</p><p><strong>Service provider</strong>：like athe middleman between infrastructure providers and the users, who provider services/applications for users</p><h4 id="云的建立基础"><a href="#云的建立基础" class="headerlink" title="云的建立基础"></a>云的建立基础</h4><p>SOA, VMs, Web 2.0 technologies</p><h4 id="Could-Architecture-——-Adaptive-management"><a href="#Could-Architecture-——-Adaptive-management" class="headerlink" title="Could Architecture —— Adaptive management"></a>Could Architecture —— Adaptive management</h4><p>is a structured, iterative process of robust decision making in the face of uncertainty, with an aim to reducing uncertainty over time via system monitoring.</p><p>是结构化的，当面对不确定性时，进行稳健决策的迭代过程，其目的是通过系统监控来逐步减少不确定性。</p><p>因为云的环境和结构是动态且复杂的，比如能够提供各种各样的服务：SaaS、PaaS、IaaS甚至everything as a service，云的不同的层也需要不同的管理方式：比如Physical Layer、Virtualization Layer、Service Layer、User Lyaer</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
