<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米达的博客</title>
  
  <subtitle>好好学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liaoooyx.com/"/>
  <updated>2020-04-01T21:56:04.824Z</updated>
  <id>https://liaoooyx.com/</id>
  
  <author>
    <name>liaoooyx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云计算中的安全性</title>
    <link href="https://liaoooyx.com/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/16%20%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>https://liaoooyx.com/2020/04/%E4%BA%91%E8%AE%A1%E7%AE%97/16%20%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/</id>
    <published>2020-03-31T23:00:00.000Z</published>
    <updated>2020-04-01T21:56:04.824Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><p>互联网最初的设计并没有太多的考虑安全问题。最初的观点是：“通过互联网联系在一起的相互信任的用户”，而互联网协议的设计者在其中充当佐料的角色。</p><p>网络安全领域包括黑客如何攻击电脑网络，我们如何对这些攻击进行防御，以及如何设计能够免疫攻击的结构。</p><p>在每一层中都应该考虑安全性问题。</p><h4 id="什么是网络安全"><a href="#什么是网络安全" class="headerlink" title="什么是网络安全"></a>什么是网络安全</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;网络安全&quot;&gt;&lt;a href=&quot;#网络安全&quot; class=&quot;headerlink&quot; title=&quot;网络安全&quot;&gt;&lt;/a&gt;网络安全&lt;/h4&gt;&lt;p&gt;互联网最初的设计并没有太多的考虑安全问题。最初的观点是：“通过互联网联系在一起的相互信任
      
    
    </summary>
    
    
      <category term="云计算" scheme="https://liaoooyx.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="安全性" scheme="https://liaoooyx.com/tags/%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>软件度量工具的使用和比较：SonarQube、</title>
    <link href="https://liaoooyx.com/2020/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AF%B9%E6%AF%94/"/>
    <id>https://liaoooyx.com/2020/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AF%B9%E6%AF%94/</id>
    <published>2020-03-31T23:00:00.000Z</published>
    <updated>2020-04-02T22:42:29.469Z</updated>
    
    <content type="html"><![CDATA[<p>软件度量是对程序本身进行数值化表示的一种方法，比如方法复杂度，代码行数，包数目等。目的是帮助开发者和管理者发现软件可能存在的缺陷、技术债务积累、代码气味等问题。</p><a id="more"></a><h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><p>MacOS Catalina 10.15.4</p><p>IntelliJ IDEA 2019.3</p><h3 id="SonarQube-8-2"><a href="#SonarQube-8-2" class="headerlink" title="SonarQube 8.2"></a>SonarQube 8.2</h3><p>提供多种安装方式，这里安装在本机：</p><p>下载压缩包并解压到对应目录后，使用命令行启动服务器，并访问<a href="http://localhost:9000/" target="_blank" rel="noopener">http://localhost:9000</a>即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../sonarqube/bin/[OS]/sonar.sh console</span><br></pre></td></tr></table></figure><p>SonarQube提供的度量方法，帮助用户了解自己是否满足代码质量的标准，好的代码质量能够减少许多代码问题和技术债务的积累。确保新写的代码是干净的，从不同的层面进行分析。</p><p>在GUI中，有相关的引导，能够轻易的将SonarQube引入项目中：基本原理是在GUI页面中为项目生成一个特定的Token，在Maven或Gradle项目的配置文件中添加SonarQube插件，最后执行提供的命令即可，命令中包含了之前生成的项目令牌。</p><p>在Measure栏，SonarQube中提供了许多实用的度量方法，包括：</p><ul><li>可靠性：Bugs、分级、补救措施</li><li>安全性：易损性、分级、补救措施</li><li>安全性审查：安全性热点、分级</li><li>可维护性（对会增加更新难度的代码进行标记）：代码气味、债务（时间）、债务比例、分级、达到A级的措施</li><li>覆盖率：覆盖率、需覆盖行、未覆盖行、已覆盖率<ul><li>单元测试数量、错误、故障、跳过、成功、执行时间</li></ul></li><li>重复率：密度、重复行、重复块、重复文件</li><li>大小（数量）：代码行、总行数、声明、函数、类、文件、注释行、注释行占比</li><li>复杂度：循环复杂度（全覆盖测试的最少测试用例）、感知复杂度（理解程序的困难程度）</li><li>问题：开放问题、重开问题、确认问题、False Positive问题，保留问题</li></ul><p>在Issues栏，SonarQube还能分析代码，检测出违反开发规范的代码，并给与提醒</p><p>在Activity栏，可以展示软件度量的变化趋势，主要包括：</p><ul><li>问题：Bugs、代码气味、易损性</li><li>覆盖率：需覆盖行和未覆盖行</li><li>重复率：代码行和重复行</li><li>定制：对任意的软件度量进行组合</li></ul><p>使用该功能，每执行一次命令行则记录一次数据日志</p><p>优点：全面</p><p>缺点：</p><ul><li>无法直接回顾以前的历史记录，需要对源码进行版本控制</li><li>不开源，研究人员/开发者无法使用自己的软件度量标准</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件度量是对程序本身进行数值化表示的一种方法，比如方法复杂度，代码行数，包数目等。目的是帮助开发者和管理者发现软件可能存在的缺陷、技术债务积累、代码气味等问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="https://liaoooyx.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件度量" scheme="https://liaoooyx.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%A6%E9%87%8F/"/>
    
      <category term="SonarQube" scheme="https://liaoooyx.com/tags/SonarQube/"/>
    
  </entry>
  
  <entry>
    <title>云计算大纲</title>
    <link href="https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/00%20%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%A7%E7%BA%B2/"/>
    <id>https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/00%20%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%A7%E7%BA%B2/</id>
    <published>2020-03-27T00:00:00.000Z</published>
    <updated>2020-03-27T16:34:07.615Z</updated>
    
    <content type="html"><![CDATA[<ol><li>分布式系统模型和支持技术</li><li>云计算–体系结构，服务，模型，用例</li><li>公共云和私有云。 资源管理</li><li>集群和数据中心的虚拟机和虚拟化</li><li>虚拟基础架构管理：OpenNebula和Openstack</li><li>云调度</li><li>容器化和Kubernetes</li><li>云编程和软件环境</li><li>云中间件和配置管理</li><li>大数据。 Mapreduce和Hadoop</li><li>服务水平协议</li><li>云经济</li><li>能源效率</li><li>安全与信任</li><li>无处不在的云和物联网</li><li>云支持：边缘计算，虚拟化/单核，工业4.0，无服务器架构</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;分布式系统模型和支持技术&lt;/li&gt;
&lt;li&gt;云计算–体系结构，服务，模型，用例&lt;/li&gt;
&lt;li&gt;公共云和私有云。 资源管理&lt;/li&gt;
&lt;li&gt;集群和数据中心的虚拟机和虚拟化&lt;/li&gt;
&lt;li&gt;虚拟基础架构管理：OpenNebula和Openstack&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="云计算" scheme="https://liaoooyx.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算的新方向1</title>
    <link href="https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/17%20IoT%E7%89%A9%E8%81%94%E7%BD%91/"/>
    <id>https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/17%20IoT%E7%89%A9%E8%81%94%E7%BD%91/</id>
    <published>2020-03-27T00:00:00.000Z</published>
    <updated>2020-04-01T15:50:31.883Z</updated>
    
    <content type="html"><![CDATA[<p>云计算、物联网、社交网络影响着整个服务行业，也因此关系着未来互联网的演变和全球的经济。</p><p>云的生态系统需要普适性、高效性、安全性、用户接受性和值得信赖。</p><p>云是塑造未来互联网的关键：物联网和社交网络正参与着商业、政府、教育、娱乐等的各个方面</p><p><strong>《BIG SWITCH》描述了21世纪初出现的转变：</strong></p><p>更强大的电脑；无限的存储；高带宽的网络和普遍的连接（TB级的网络、宽带无线移动）；行业竞相建立大型数据中心（容量）；虚拟化有助于实现规模经济</p><p><strong>未来的网络开发存在以下技术挑战：</strong></p><p>可编程的网络结构；合并互联网、移动网络、和TV网络；基于TCP/IP的实名数据网络；智能路由和内容分布；加强安全和隐私保护</p><a id="more"></a><h4 id="云在未来互联网和社交网络中的角色"><a href="#云在未来互联网和社交网络中的角色" class="headerlink" title="云在未来互联网和社交网络中的角色"></a>云在未来互联网和社交网络中的角色</h4><p>在未来，云将会是提供网络服务的基础。未来的互联网不仅包含人和机器，还包括任何的对象或物体（物联网）</p><p>物联网的兴起：物理网应用程序必须最大化使用云，以便动态的处理和存储大规模的数据</p><p>云、物联网和社交网络正在重塑人类之间的关系，影响我们的日常生活，并且影响着全球的经济、政治系统</p><h4 id="物联网究竟意味着什么"><a href="#物联网究竟意味着什么" class="headerlink" title="物联网究竟意味着什么"></a>物联网究竟意味着什么</h4><p>Kevin Ashton将“物联网”描述为一个系统，它通过无处不在的传感器将物理世界和互联网联系在一起</p><blockquote><p>无处不在的传感器：手机、汽车、房间、门、床、椅子、建筑等任何物体</p></blockquote><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p>所有的传感器和控制端都在不断产生数据。通常这些数据是有用且私密的。因此需要一个系统来使这些设备相互沟通、管理数据，并加强适当的访问控制</p><p>而所有的通信、管理、访问控制技术，都是应用在大规模的设备网络上，因此必须是<u>可大规模扩展的</u></p><h4 id="开放协议"><a href="#开放协议" class="headerlink" title="开放协议"></a>开放协议</h4><p>当前的互联网和软件的解决方案有：</p><ul><li>接口 API：高度模块化</li><li>云：高度的分布式</li><li>面向服务的体系结构 SOA：高度解耦</li></ul><h4 id="物联网的维度"><a href="#物联网的维度" class="headerlink" title="物联网的维度"></a>物联网的维度</h4><p>任何时间相连：移动时、户内户外、白天晚上</p><p>任何地点相连：移动时、户外、户内（不在电脑上）、电脑上</p><p>任何物体相连：电脑之间、人与人（不使用电脑）、人与物（使用通用设备）、物与物</p><h4 id="无线传感器的角色"><a href="#无线传感器的角色" class="headerlink" title="无线传感器的角色"></a>无线传感器的角色</h4><p>无处不在的计算将促进各种各样的无线应用程序，包括监控宠物和家里的植物、控制程序、追踪书籍和单车等</p><h4 id="物联网的结构"><a href="#物联网的结构" class="headerlink" title="物联网的结构"></a>物联网的结构</h4><p>应用层：商品追踪、环境保护、智能搜索、远程医疗、智能交通、智能家居</p><p>网络层：云计算平台 —— 移动电信网、物联网、信息网</p><p>服务层：射频识别技术（射频标签）、传感器网络（节点）、GPS（公路地图）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd900m538xj311e0l80x3.jpg" alt="截屏2020-03-27 下午5.27.30" style="zoom:50%;" /></p><h4 id="概念图：基于云的物联网"><a href="#概念图：基于云的物联网" class="headerlink" title="概念图：基于云的物联网"></a>概念图：基于云的物联网</h4><p>无缝连接/无处不在的访问 —— 云计算 —— 基于云的物联网</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd9098ew80j30og0ie0vt.jpg" alt="截屏2020-03-27 下午5.35.49" style="zoom:50%;" /></p><h4 id="本地的分布式云"><a href="#本地的分布式云" class="headerlink" title="本地的分布式云"></a>本地的分布式云</h4><p>公有云：公开资源管理、服务质量管理、服务创新、准入控制</p><p>网络：地点管理、服务呈现、计费、身份管理、服务支持功能</p><p>本地云：本地资源管理、公有云交互</p><p>物体：资源请求、资源呈现</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd90e2iwt8j30kq0j8tds.jpg" alt="截屏2020-03-27 下午5.40.26" style="zoom:50%;" /></p><h4 id="射频识别技术-RFID"><a href="#射频识别技术-RFID" class="headerlink" title="射频识别技术 RFID"></a>射频识别技术 RFID</h4><blockquote><p><a href="https://baike.baidu.com/item/%E5%B0%84%E9%A2%91%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/9524139" target="_blank" rel="noopener">百度百科</a>：无线射频识别技术通过<a href="https://baike.baidu.com/item/无线电波/942435" target="_blank" rel="noopener">无线电波</a>不接触快速信息交换和存储技术，通过无线通信结合数据访问技术，然后连接数据库系统，加以实现非接触式的双向通信，从而达到了识别的目的，用于数据交换，串联起一个极其复杂的系统。在识别系统中，通过电磁波实现电子标签的读写与通信。根据通信距离，可分为近场和远场，为此读/写设备和电子标签之间的数据交换方式也对应地被分为负载<a href="https://baike.baidu.com/item/调制/4803375" target="_blank" rel="noopener">调制</a>和反向散射调制。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd90svv6dzj311y0j8dlx.jpg" alt="截屏2020-03-27 下午5.54.38" style="zoom:50%;" /></p><h5 id="应用场景：物流分配中心"><a href="#应用场景：物流分配中心" class="headerlink" title="应用场景：物流分配中心"></a>应用场景：物流分配中心</h5><ol><li>通过RFID指示包裹的输送方向</li><li>通过RFID读取仓库中的库存或在运输中的包裹，同步到系统上，从而与供应链同步</li><li>通过RFID识别集装箱内的包裹，更新库存</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd914qqp3tj30zw0k8qp8.jpg" alt="截屏2020-03-27 下午6.06.03" style="zoom:50%;" /></p><h4 id="无线网络——支持普适计算"><a href="#无线网络——支持普适计算" class="headerlink" title="无线网络——支持普适计算"></a>无线网络——支持普适计算</h4><blockquote><p><a href="https://baike.baidu.com/item/%E6%99%AE%E9%80%82%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">百度百科</a>：<strong>普适计算</strong>（Ubiquitous computing（ubicomp）、pervasive computing），又称<strong>普存计算</strong>、<strong>普及计算</strong>、<strong>遍布式计算</strong>、<strong>泛在计算</strong>，是一个强调和环境融为一体的计算概念，而<a href="https://baike.baidu.com/item/计算机/140338" target="_blank" rel="noopener">计算机</a>本身则从人们的视线里消失。在普适计算的模式下，人们能够在任何时间、任何地点、以任何方式进行信息的获取与处理。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd91bg1jhpj310y0fw12e.jpg" alt="截屏2020-03-27 下午6.12.32"></p><h4 id="ZigBee-结构"><a href="#ZigBee-结构" class="headerlink" title="ZigBee 结构"></a>ZigBee 结构</h4><p>目的：监控和控制；电池：3个月-3年；网络数量：无限 ；带宽：20-150KB；范围：1-100+米；系统资源：4-32K</p><ul><li>全功能设备 FFD —— <ul><li>协调器 (ZigBee Coordinator, ZC)：<ul><li>一个ZB网络只需要1个协调器，发起网络</li><li>作为 802.15.4 2003 协议的协调器</li><li>当网络成型后，也能作为路由器</li></ul></li><li>路由器 (ZigBee Router, ZR)<ul><li>可选的组件，辅助ZC，对消息进行多跳路由</li></ul></li></ul></li><li>缩减功能设备 RFD<ul><li>终端设备 (ZigBee End Device, ZED)<ul><li>可选的网络组件</li><li>不参与路由</li></ul></li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd91m4qv31j30o60gwwjc.jpg" alt="截屏2020-03-27 下午6.22.47" style="zoom:50%;" /></p><h4 id="物联网中的云和大数据，5C-5ANY"><a href="#物联网中的云和大数据，5C-5ANY" class="headerlink" title="物联网中的云和大数据，5C+5ANY"></a>物联网中的云和大数据，5C+5ANY</h4><p>数据：存储在云中，跟随着用户和用户的设备，可随时随地访问，可被其他人共享</p><p>5C：Convergence、Contents、Computing、Communication、Connectivity</p><p>5Any：Any Time、Any Where、Any Service、Any Network、Any Object</p><h4 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h4><blockquote><p>Telecom —— 电信<br>RFID: Radio Frequency Identification Technology —— 射频识别技术<br>Antenna —— 天线</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;云计算、物联网、社交网络影响着整个服务行业，也因此关系着未来互联网的演变和全球的经济。&lt;/p&gt;
&lt;p&gt;云的生态系统需要普适性、高效性、安全性、用户接受性和值得信赖。&lt;/p&gt;
&lt;p&gt;云是塑造未来互联网的关键：物联网和社交网络正参与着商业、政府、教育、娱乐等的各个方面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《BIG SWITCH》描述了21世纪初出现的转变：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更强大的电脑；无限的存储；高带宽的网络和普遍的连接（TB级的网络、宽带无线移动）；行业竞相建立大型数据中心（容量）；虚拟化有助于实现规模经济&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未来的网络开发存在以下技术挑战：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可编程的网络结构；合并互联网、移动网络、和TV网络；基于TCP/IP的实名数据网络；智能路由和内容分布；加强安全和隐私保护&lt;/p&gt;
    
    </summary>
    
    
      <category term="云计算" scheme="https://liaoooyx.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="IoT" scheme="https://liaoooyx.com/tags/IoT/"/>
    
      <category term="物联网" scheme="https://liaoooyx.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>云计算的新方向2</title>
    <link href="https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/18%20%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%96%B0%E6%96%B9%E5%90%91/"/>
    <id>https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/18%20%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%96%B0%E6%96%B9%E5%90%91/</id>
    <published>2020-03-27T00:00:00.000Z</published>
    <updated>2020-04-01T18:29:40.713Z</updated>
    
    <content type="html"><![CDATA[<p>概述：</p><ol><li>回顾在物联网环境下，云计算的发展方向</li><li>为了阻止来自物联网的数据泛滥，在远程设备上采用智能本地数据处理成为关键：雾计算、边缘计算</li><li>本地数据处理中的虚拟化问题：以微服务和unikernels为例</li><li>工业4.0和智能工程</li></ol><a id="more"></a><h4 id="物联网家具：设备的发展前景"><a href="#物联网家具：设备的发展前景" class="headerlink" title="物联网家具：设备的发展前景"></a>物联网家具：设备的发展前景</h4><p>灯泡、冰箱、摄像头、手表、音响、显示器、扫地机器人等</p><h4 id="物联与智能产品：飞利浦照明"><a href="#物联与智能产品：飞利浦照明" class="headerlink" title="物联与智能产品：飞利浦照明"></a>物联与智能产品：飞利浦照明</h4><p>用户可以通过手机调节灯泡的亮度，调节开关；通过编程让它们：当发现进入者时闪烁，到晚上时变得昏暗</p><h3 id="雾计算"><a href="#雾计算" class="headerlink" title="雾计算"></a>雾计算</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>物联网应用和设备在持续激增，而旧的数据仓库模型：无法跟上物联网设备创建数据的速度和体积，也无法满足用户对低延迟响应时间的要求。但将数据发送到云上进行分析同样会带来风险：比如数据拥堵，安全问题等。网络数据传输的增长会导致数据拥堵的问题，而新的商业模型要求数据分析的时间少于1分钟（在某些情况下甚至要少与1秒）</p><h4 id="雾计算——思科架构"><a href="#雾计算——思科架构" class="headerlink" title="雾计算——思科架构"></a>雾计算——思科架构</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeq44w8ybj30tq0ca7cv.jpg" alt="截屏2020-04-01 下午5.18.16" style="zoom:50%;" /></p><p>雾平台：在网络边缘布置的密集型计算结构</p><p>特点：低延迟、位置感知、可通过无线访问使用</p><p>优点：实时分析、优化安全性</p><p>例子：</p><ol><li>智能交通信号灯系统，可基于当前的交通监控状况改变它的信号</li><li>数据可以发送到云端，用于长期分析</li></ol><p>在许多行业中，术语<u>边缘计算</u>和<u>雾计算</u>是可交互使用的，它们都涉及将<u>智能（计算处理数据的能力）</u>下发到离数据源更近的地方（泵、传感器、发动机、继电器），它们的根本区别在于<u>智能</u>到底安置在哪：</p><ul><li>雾：将<u>智能</u>发送到网络结构中的<u>局域网级别</u>，在雾节点或物联网网关中处理数据</li><li>边缘：将<u>智能、处理能力、通信能力</u>发送到边缘网关，或直接应用在设备本身（如可编程的自动化控制器 PACs）</li></ul><h3 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h3><p>在该结构中，数据可被处理，包括监控、分析、去重、缓存。</p><p>在该结构中，还需要考虑4个问题：1. 带宽，2. 网络能源，3.吞吐量，4. 数据存储；其他的开放新问题包括：</p><ol><li>便携性</li><li>能源效率</li><li>硬件结构的异构性</li><li>安全性虚</li><li>虚拟化</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeqp0e6pzj30no0ni7b8.jpg" alt="截屏2020-04-01 下午5.38.22" style="zoom:50%;" /></p><h4 id="1-可移动的边缘计算-Mobile-Edge-Computing-MEC"><a href="#1-可移动的边缘计算-Mobile-Edge-Computing-MEC" class="headerlink" title="1. 可移动的边缘计算 Mobile Edge Computing, MEC"></a>1. 可移动的边缘计算 Mobile Edge Computing, MEC</h4><p>在蜂窝网络或任何网络的边缘，启用云计算能力和通信技术服务环境的，一种网络结构。它的基本思想是与边缘计算和雾计算类似，即在接近蜂窝用户的地方运行程序和处理相关任务，从而缓解网络拥堵，提高性能。云不直接接收用户的数据，而是接收经过MEC节点处理后的少量数据。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gder2aip6dj30ts0l2dt4.jpg" alt="截屏2020-04-01 下午5.51.06" style="zoom:50%;" /></p><h4 id="2-低能耗计算案例"><a href="#2-低能耗计算案例" class="headerlink" title="2. 低能耗计算案例"></a>2. 低能耗计算案例</h4><p>该技术的关键在于如何使<u>本地处理数据的智能设备</u>使用最少的能源。目前，<u>低功耗和低能耗</u>仍然是物联网连接的智能对象的挑战。</p><p><u>性能</u>的表现由，除了速度之外的，非功能性部分组成，比如：能耗、可靠性、时间需求等</p><p>能源效率应该从三个方面考虑：</p><ol><li>系统级别：比如使用本地计算，而不是将数据传输到外部；通信是能源浪费的主要因素</li><li>设备级别：考虑到设备的异质性，使用在节能的结构</li><li>语言级别：避免数据通信，确保数据的本地性</li></ol><h4 id="3-硬件结构的异质性"><a href="#3-硬件结构的异质性" class="headerlink" title="3. 硬件结构的异质性"></a>3. 硬件结构的异质性</h4><p><u>异质的并行化结构</u>已经收到了相当大的关注，它的好处在于能够高效的运行程序和传递服务，并且在一个系统中组合了不同种类的处理器，从而优化了绝对性能和降低能耗</p><p>于是出现了新的平台，它们将多核CPUs、多核GPUs，和一系列的附加设备合并为一个单独的解决方案。它们的特点是高度的多样化，在混合的环境中操作，以及使用环境十分广泛（从超级计算机到个人智能手机）</p><h4 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4.安全问题"></a>4.安全问题</h4><p>将物理网设备中的敏感数据（医疗数据、个人跟踪数据、视频、财务数据等）从数据源（家庭、企业等）中发送出去，可能会导致隐私泄露、声誉受损、数据盗窃等问题。除此之外还需要考虑传输成本，如带宽消耗、处理成本、存储成本。</p><p>解决方案应该专注于保护设备、网络和使用时的安全：物理层的安全性、设备保护、密码保险、泄露预防、基础设备的安全性、数据传输时的安全性、平台安全性</p><h4 id="5-虚拟化：以微服务为例"><a href="#5-虚拟化：以微服务为例" class="headerlink" title="5. 虚拟化：以微服务为例"></a>5. 虚拟化：以微服务为例</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdes9a0hvfj30wq0g8acv.jpg" alt="截屏2020-04-01 下午6.32.26" style="zoom:50%;" /></p><p>微服务是一个结构模型，它以服务为粒度，将其拆分为多个分布的单元（小的服务），多个自治的服务相互合作，各个服务之间相互解耦，并且通过接口和协议（如HTTP）进行访问</p><h5 id="部署选项"><a href="#部署选项" class="headerlink" title="部署选项"></a>部署选项</h5><p>微服务可以是从<u>需要专用硬件</u>到<u>仅仅是软件包</u>。其中部署在容器上（如Docker）是在效率和管理方面都比较理想的选择（包含虚拟机的大部分优点，但比虚拟机的损耗更低）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdesj02pl5j30eg0m2di1.jpg" alt="截屏2020-04-01 下午6.41.48" style="zoom:33%;" /></p><h5 id="以-Unikernels-独立核心为例"><a href="#以-Unikernels-独立核心为例" class="headerlink" title="以 Unikernels 独立核心为例"></a>以 <a href="http://dockone.io/article/855" target="_blank" rel="noopener">Unikernels</a> 独立核心为例</h5><p>Unikernel简单来说就是<strong>删除应用与硬件中间多余的部分，只保留运行程序所需的最小依赖的库和栈模块的操作系统镜像</strong>。</p><p>由于Unikernel只实现了传统操作系统中的最低限度功能，因此极度轻量，允许在日常硬件上实现高密度部署。Unikernel还可以运行自己的<u>服务</u>，这些服务在需求出现时诞生，并在需求消失后立即消失，其中一些短暂的<u>微服务</u>的寿命可能以秒为单位，甚至是几分之一秒。Unikernel是即时计算服务，仅在有工作要做时存在，因此可以最大限度地利用计算基础架构。</p><p>但是当应用和配置需要更新，我们需要重新编译你的源码来生成新的Unikernel并部署新版本。如果是新的安全升级，也同样需要重新编译和部署。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdet1tpmvmj30tu0fggts.jpg" alt="截屏2020-04-01 下午6.59.54" style="zoom:50%;" /></p><h3 id="工业4-0"><a href="#工业4-0" class="headerlink" title="工业4.0"></a>工业4.0</h3><p>在工业4.0中，各个行业中的计算机和自动化将以全新的方式融合在一起，比如机器人远程连接到具备机器学习算法的计算机系统，而机器学习算法只需很少的人工操作即可学习和控制机器人。</p><p>工业4.0引入了<u>智能工厂</u>的概念，其中,<u>网络物理系统</u>监视工厂的物理上处理，并做出非中心化的决策</p><p>物理系统成为物联网，通过无线网络，实时地，在系统间相互通信，并与人类进行协作。</p><h4 id="工业4-0的六大设计原则"><a href="#工业4-0的六大设计原则" class="headerlink" title="工业4.0的六大设计原则"></a>工业4.0的六大设计原则</h4><ul><li><p>互操作性：<u>网络物理系统</u>（即工件载体，装配站和产品）、人类和智能工厂通过物联网相互连接和通信的能力</p></li><li><p>虚拟化：通过将传感器数据（来自监视物理上的处理过程）与虚拟工厂模型和仿真模型进行连接，以此创建的<u>智能工厂的虚拟副本</u></p></li><li><p>去中心化：智能工厂内的<u>网络物理系统</u>有自行决策的能力</p></li><li><p>实时功能：具有收集和分析数据并立即提供见解的能力</p></li><li><p>服务导向：通过<u>Internet of Services</u>提供（网络物理系统、人类和智能工厂的）服务</p></li><li><p>模块化：当对模块的需求发生改变时，智能工厂可以灵活地适应。</p></li></ul><h3 id="相关数据"><a href="#相关数据" class="headerlink" title="相关数据"></a>相关数据</h3><blockquote><p>pump——泵<br>motor——发动机<br>relay——继电器<br>energy efficient——节能<br>data-in-transit——传输中的数据<br>overhead——损耗<br>Cyber-Physical Systems —— 网络物理系统</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回顾在物联网环境下，云计算的发展方向&lt;/li&gt;
&lt;li&gt;为了阻止来自物联网的数据泛滥，在远程设备上采用智能本地数据处理成为关键：雾计算、边缘计算&lt;/li&gt;
&lt;li&gt;本地数据处理中的虚拟化问题：以微服务和unikernels为例&lt;/li&gt;
&lt;li&gt;工业4.0和智能工程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="云计算" scheme="https://liaoooyx.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="IoT" scheme="https://liaoooyx.com/tags/IoT/"/>
    
      <category term="无处不在的云" scheme="https://liaoooyx.com/tags/%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E4%BA%91/"/>
    
      <category term="雾计算" scheme="https://liaoooyx.com/tags/%E9%9B%BE%E8%AE%A1%E7%AE%97/"/>
    
      <category term="MEC" scheme="https://liaoooyx.com/tags/MEC/"/>
    
      <category term="微服务的虚拟化 unikernels" scheme="https://liaoooyx.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96-unikernels/"/>
    
      <category term="工业4.0" scheme="https://liaoooyx.com/tags/%E5%B7%A5%E4%B8%9A4-0/"/>
    
  </entry>
  
  <entry>
    <title>图形数据库 Neo4J</title>
    <link href="https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%9B%BE%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4J/"/>
    <id>https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%9B%BE%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4J/</id>
    <published>2020-03-20T20:04:14.000Z</published>
    <updated>2020-03-26T03:49:37.319Z</updated>
    
    <content type="html"><![CDATA[<p>NoSQL可以被分成4类：键值对存储（MapReduce）、面向列的数据库（如Google Big Table）、文档数据库（MongoDB）、图形数据库（如Neo4J）</p><p>图形数据库主要用于存储具有更多关联的数据，而传统的RDBMS对大量数据的遍历性能不佳</p><p>图形数据库适合数据元素之间的关系与数据本身同样重要的项目</p><blockquote><p>由Neo4j，Inc.开发的图形数据库管理系统。它的开发人员将Neo4j描述为具有本机图形存储和处理的ACID兼容事务数据库，根据DB-Engines排名，Neo4j是最受欢迎的图形数据库，并且总体上是第22位最受欢迎的数据库。</p></blockquote><a id="more"></a><h4 id="NoSQL的种类"><a href="#NoSQL的种类" class="headerlink" title="NoSQL的种类"></a>NoSQL的种类</h4><p>NoSQL可以被分成4类：键值对存储（MySQL）、面向列的数据库（如Google Big Table）、文档数据库、图形数据库（如Neo4J）</p><h4 id="图-树结构的数据库"><a href="#图-树结构的数据库" class="headerlink" title="图/树结构的数据库"></a>图/树结构的数据库</h4><p>图包括2个元素：</p><ul><li><p>节点node：表示实体</p></li><li><p>关系relationship：表示2个节点之间是如何联系在一起的</p></li></ul><blockquote><p>2019年Twitter的每月活跃用户数量为3.21亿，通过图形数据库关联在一起</p></blockquote><h4 id="图形数据库-VS-传统的关系数据库管理系统RDBMS"><a href="#图形数据库-VS-传统的关系数据库管理系统RDBMS" class="headerlink" title="图形数据库 VS 传统的关系数据库管理系统RDBMS"></a>图形数据库 VS 传统的关系数据库管理系统RDBMS</h4><p>图形数据库主要用于存储更多连接的数据，而传统的RDBMS对大量数据的遍历(traverse)性能不佳</p><p>图形数据库适合：数据元素之间的关系与数据本身同样重要的项目</p><div class="table-container"><table><thead><tr><th>RDBMS</th><th>Graph DataBase</th></tr></thead><tbody><tr><td>表</td><td>图</td></tr><tr><td>行</td><td>节点</td></tr><tr><td>列和数据</td><td>属性和值</td></tr><tr><td>约束</td><td>关系</td></tr><tr><td>Joins</td><td>Traversal 遍历</td></tr></tbody></table></div><p>属性是用来表示数据的键值对</p><h3 id="Neo4J"><a href="#Neo4J" class="headerlink" title="Neo4J"></a>Neo4J</h3><p>是服从ACID的事务性数据库，提供自带的(native)图存储和处理</p><p>由Java编写，其他语言可以通过Cypher Query Language (CQL) 进行访问</p><blockquote><p>Cypher是一种声明性图形查询语言，它允许在属性图形中进行有表现力且有效的数据查询。</p></blockquote><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>以CQL作为查询语言，类似于SQL的查询语言</p><p>遵循属性图数据模型 Property Graph Data Model</p><p>包含可执行CQL命令的用户接口（Neo4J数据浏览器）</p><p>尽管是NoSQL，但其他大多数图像界面一样，服从ACID</p><p>提供REST和JavaScript接口</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>能够简单快速对<u>连接的数据</u>进行表示和获取</p><p>CQL的设计是人类可读的，并且易于学习</p><p>不需要复杂的Joins来获取连接的数据</p><h4 id="属性图数据模型"><a href="#属性图数据模型" class="headerlink" title="属性图数据模型"></a>属性图数据模型</h4><p>Neo4J使用属性图数据模型对数据进行存储和管理，Neo4J使用自带的图处理引擎GPE，对以这个格式存储的数据进行处理。该模型简单，只有少量的基本元素：</p><ul><li>数据由节点、关系和属性表示</li><li>节点和关系都包含属性</li><li>关系连接节点</li><li>属性是键值对</li><li><p>每个关系都包含“起始节点”和“结束节点”</p></li><li><p><strong>标签</strong>：将一系列的节点或关系用一个常用的名字管理起来。一个节点或关系可以有多个标签</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd12m5xkukj30qw0bk0vr.jpg" alt="截屏2020-03-20下午8.52.53"></p><h4 id="可视化——Neo4J-数据浏览器"><a href="#可视化——Neo4J-数据浏览器" class="headerlink" title="可视化——Neo4J 数据浏览器"></a>可视化——Neo4J 数据浏览器</h4><p>Neo4J 2.0版开始自带。能够快速简单的图形数据库进行可视化和编辑</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd12sg645oj312g0faafz.jpg" alt="截屏2020-03-20下午8.58.59"></p><h4 id="Cypher查询语言"><a href="#Cypher查询语言" class="headerlink" title="Cypher查询语言"></a>Cypher查询语言</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd12xhqnq2j311i0g2djr.jpg" alt="截屏2020-03-20下午9.03.50"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建emp节点，标签名为Employee</span><br><span class="line">CREATE (emp:Employee)</span><br><span class="line">&#x2F;&#x2F; 创建包含属性的节点</span><br><span class="line">CREATE (emp:Employee &#123;employeeNumber:10, name&#x3D;“Paul”, location&#x3D;“Leeds”&#125; ) ;</span><br><span class="line">&#x2F;&#x2F; 获取数据</span><br><span class="line">MATCH (myresults: Employee)</span><br><span class="line">RETURN myresults.name, myresults.location</span><br></pre></td></tr></table></figure><h4 id="与Java整合"><a href="#与Java整合" class="headerlink" title="与Java整合"></a>与Java整合</h4><p>Neo4J有自带接口和Cypher接口与Java整合，Cypher接口能让用户通过Java接口直接执行CQL命令</p><h3 id="Neo4J-VS-MySQL"><a href="#Neo4J-VS-MySQL" class="headerlink" title="Neo4J VS MySQL"></a>Neo4J VS MySQL</h3><p>对于MySQL来说，表中的每个元素都有一组提前定义好的属性（列）</p><p>在Neo4J中，每个节点node等价于MySQL中的一行记录</p><ul><li>Label能将相似的数据归为同一组，比如用户组。相当于MySQL中的表，但同一组数据并不会真正的存储在一起，只是语义上的划分</li></ul><h4 id="图形数据库-VS-传统的RDBMS——以用户-餐厅为例"><a href="#图形数据库-VS-传统的RDBMS——以用户-餐厅为例" class="headerlink" title="图形数据库 VS 传统的RDBMS——以用户/餐厅为例"></a>图形数据库 VS 传统的RDBMS——以用户/餐厅为例</h4><p>传统数据库需要3张表分别表示用户、餐厅和关系：</p><ul><li><p>存储：<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd167p6tmfj30em086q6v.jpg" alt="截屏2020-03-20下午10.57.26" style="zoom: 33%;" /></p></li><li><p>查询：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user.*, restaurant.* </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>, restaurant, joinTable </span><br><span class="line"><span class="keyword">WHERE</span> user.firstName = ‘Paul’ <span class="keyword">AND</span> user.id = joinTable.userId <span class="keyword">AND</span> restaurant.id = joinTable.restaurantId <span class="keyword">AND</span> joinTable.rating = ‘LOVED’</span><br></pre></td></tr></table></figure><p>图形数据库通过<u>节点</u>表示用户和餐厅，<u>关系</u>表示节点之间的关联信息，比如当用户写的评论可以直接储存在<u>关系</u>中</p><ul><li><p>存储：<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd16bcna2jj30gu0cgwf3.jpg" alt="截屏2020-03-20下午11.00.43" style="zoom:33%;" /></p></li><li><p>查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Neo4J会忽略不匹配该模式的所有值</span><br><span class="line">&#x2F;&#x2F; 通过提供的变量名，可以使用name.property与所有匹配的节点或关系进行交互</span><br><span class="line">MATCH (u:User &#123;firstName:‘Paul&#39;&#125;)-[rel:LOVED]-&gt;(res:Restaurant) RETURN res</span><br><span class="line">MATCH (u:User)-[rel]-&gt;(res:Restaurant &#123;name:&#39;French Laundry&#39;&#125;) RETURN u</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NoSQL可以被分成4类：键值对存储（MapReduce）、面向列的数据库（如Google Big Table）、文档数据库（MongoDB）、图形数据库（如Neo4J）&lt;/p&gt;
&lt;p&gt;图形数据库主要用于存储具有更多关联的数据，而传统的RDBMS对大量数据的遍历性能不佳&lt;/p&gt;
&lt;p&gt;图形数据库适合数据元素之间的关系与数据本身同样重要的项目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由Neo4j，Inc.开发的图形数据库管理系统。它的开发人员将Neo4j描述为具有本机图形存储和处理的ACID兼容事务数据库，根据DB-Engines排名，Neo4j是最受欢迎的图形数据库，并且总体上是第22位最受欢迎的数据库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="NoSQL" scheme="https://liaoooyx.com/tags/NoSQL/"/>
    
      <category term="Neo4J" scheme="https://liaoooyx.com/tags/Neo4J/"/>
    
  </entry>
  
  <entry>
    <title>云编程的现状</title>
    <link href="https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/11%20Cloud%20Programming%20Landscape%20%E4%BA%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/11%20Cloud%20Programming%20Landscape%20%E4%BA%91%E7%BC%96%E7%A8%8B/</id>
    <published>2020-03-20T00:00:00.000Z</published>
    <updated>2020-03-20T15:23:56.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Cloud-Programming-Landscape-云编程"><a href="#11-Cloud-Programming-Landscape-云编程" class="headerlink" title="11 Cloud Programming Landscape 云编程"></a>11 Cloud Programming Landscape 云编程</h2><p>主要内容：</p><p>云编程的前景</p><p>在云中的执行应用程序和服务的框架</p><p>云服务生命周期</p><p>常用的编程框架和模型：MPI、MapReduce / Hadoop 、亚马逊、微软 Azure</p><a id="more"></a><h4 id="云产品的现状"><a href="#云产品的现状" class="headerlink" title="云产品的现状"></a>云产品的现状</h4><p>云产品可应用于以下领域：科学/技术（无人驾驶汽车）、商务（电商、消费者关系管理CRM、会计、企业资源规划ERP）、消费者/社交（FB、Gmail、Twitter）</p><h3 id="产品和服务的编程"><a href="#产品和服务的编程" class="headerlink" title="产品和服务的编程"></a>产品和服务的编程</h3><p>现有的框架支持对应用程序和服务进行编程，并在云中执行：</p><ol><li>新的接口用以开发程序：比如Azure、Google App Engine</li><li>基于服务的工作流程的图形（Web服务业务流程执行语言）</li><li>高性能计算：MPI，OpenMP</li><li>非通用编程模型：MapReduce，Aneka（用于在云上开发分布式应用的平台和框架）</li></ol><h3 id="云服务的生命周期"><a href="#云服务的生命周期" class="headerlink" title="云服务的生命周期"></a>云服务的生命周期</h3><p>编程模型/构造服务：</p><ul><li>编程模型——用于开发产品</li><li>应用包装器——用于创建服务清单</li><li>虚拟机镜像构造器——用于产生镜像</li></ul><p>部署服务</p><ul><li>产品管理器——经服务部署到云基础设施上</li><li>虚拟机上下文工具contextualiser——将服务的软件依赖嵌入到虚拟机镜像中，并支持运行时配置</li><li>产品监控器——在操作是监控服务</li></ul><p>操作服务：</p><ul><li>虚拟机管理器——将虚拟机部署到物理节点</li><li>虚拟机基础设施管理器——管理虚拟机</li><li>基础设施监控器——监控云资源 </li></ul><h3 id="构造云服务"><a href="#构造云服务" class="headerlink" title="构造云服务"></a>构造云服务</h3><p>云服务是专门为了在云基础设施上部署而开发、策划和配置的</p><p>需执行的活动有：</p><ol><li>服务开发：开发应用程序，为用户提供功能服务<ul><li>使用编程模型简化服务开发：MapReduce、MPI、COMP Superscalar</li></ul></li><li>准备好虚拟机，等服务开发完成后，将服务部署在虚拟机上</li><li><p>指定和配置服务需求，描述参数（功能性和非功能性）</p><ul><li>容量需求、位置限制、能源效率限制</li></ul><p>针对云量身定制的编程语言：GO——针对云项目Docker的编程语言，提供并发操作</p></li></ol><h4 id="例1：消息传递接口MPI"><a href="#例1：消息传递接口MPI" class="headerlink" title="例1：消息传递接口MPI"></a>例1：消息传递接口MPI</h4><p>高性能多重计算机的出现；需要面向消息的<u>原语Primitives</u>以轻松编写高效的应用程序</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd04xhtyu7j30ys0i8tbv.jpg" alt="截屏2020-03-20上午1.27.08" style="zoom: 33%;" /></p><p>问题：大多数内部交互网络和高性能多重计算机都自带专有的通信库——需要硬件独立的通信库</p><p>解决方案：MPI</p><ul><li>为并行产品设计</li><li>使用底层网络</li><li>假设通信发生在已知的进程组</li></ul><h5 id="消息传递模型"><a href="#消息传递模型" class="headerlink" title="消息传递模型"></a>消息传递模型</h5><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd04om93dyj30ou0lw418.jpg" alt="截屏2020-03-20上午1.18.52" style="zoom:33%;" /></p><p>消息同步传输：</p><ul><li><p>需要发送者与接受者配合，但“配合”并不总是反映在代码上。</p></li><li><p>比较一对一通信和集体通信</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd04u6rjjuj30yg0aodgp.jpg" alt="截屏2020-03-20上午1.24.17"></p><h5 id="进程执行：裸机与虚拟环境的对比"><a href="#进程执行：裸机与虚拟环境的对比" class="headerlink" title="进程执行：裸机与虚拟环境的对比"></a>进程执行：裸机与虚拟环境的对比</h5><p>对消息传递的方式对进程来说没有区别，区别在于进程是位于裸机中还是虚拟机中</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd0503wa9hj30xu0nen3p.jpg" alt="截屏2020-03-20上午1.29.58" style="zoom:33%;" /></p><h4 id="例2：MapReduce——在大型集群上的可扩展数据处理"><a href="#例2：MapReduce——在大型集群上的可扩展数据处理" class="headerlink" title="例2：MapReduce——在大型集群上的可扩展数据处理"></a>例2：MapReduce——在大型集群上的可扩展数据处理</h4><ul><li>用于快速处理大规模数据集的编程模型</li><li>适用于网络规模的搜索和云计算产品</li><li>用户编写的<ul><li>map函数用于生成中间操作的键值对</li><li>reduce函数将键值对按键合并</li></ul></li></ul><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><p>由雅虎开发的软件平台，让用户编写和运行基于大规模分布式数据的产品</p><p>特点：</p><ul><li>可扩展：可以轻松的在网络空间上扩展，存储和处理PB级的数据</li><li>经济的：开源框架，能够最小化过量的任务滋生和大规模数据通信</li><li>高效的：通过大量的简单节点，进行高度并行的数据处理</li><li>可靠的：自动维护多个数据备份，当发送故障时能够重新部署计算任务</li></ul><h3 id="部署云服务"><a href="#部署云服务" class="headerlink" title="部署云服务"></a>部署云服务</h3><p>成果：服务能够在云基础设施资源上运行</p><p>执行的活动有：</p><ul><li>选择最合适的基础设施来部署服务</li><li>当服务被部署后，确保服务按照其约束进行<ul><li>约束指的是在性能、成本、能耗等方面达成一致</li></ul></li><li>上下文（配置）信息的传递，当服务被部署后，上下文信息用于初始化服务</li></ul><h3 id="操作云服务"><a href="#操作云服务" class="headerlink" title="操作云服务"></a>操作云服务</h3><p>服务运行在云基础设之上</p><p>执行的活动有：</p><ul><li>满足服务需求的管理操作（比如服务质量）</li><li>资源分配机制（包括数据放置）</li><li>（被虚拟机、容器使用的）基础设施用量的监控机制</li><li>根据基础设备用量、历史模式、预测未来用量的变化的报告机制</li></ul><h3 id="在AWS上的并行编程"><a href="#在AWS上的并行编程" class="headerlink" title="在AWS上的并行编程"></a>在AWS上的并行编程</h3><p>部分亚马逊平台上提供的服务</p><ul><li><p>EC2 亚马逊弹性云服务：提供可重新调整计算能力的Web服务，为开发者设计，简化网络规模的云计算</p></li><li><p>S3 简单存储服务：为用户提供安全、可容忍、可高度扩展的对象存储，通过简单的网络服务接口，从网络的任何地方，对任何数量的数据进行存储和获取</p></li><li><p>EBS 弹性块存储：基于EC2实例，支持<u>块级别</u>存储大小的持久化</p></li><li><p>SimpleDB：高度可用和灵活的非关系数据存储，减少开发者对数据库管理的工作。开发者只要通过网络服务请求对数据进行查询和存储，SimpleDB负责其余的工作</p></li></ul><h4 id="EC2——AMI-亚马逊虚拟机镜像"><a href="#EC2——AMI-亚马逊虚拟机镜像" class="headerlink" title="EC2——AMI 亚马逊虚拟机镜像"></a>EC2——AMI 亚马逊虚拟机镜像</h4><p>AMI是虚拟机实例的模板，AMI是预装了软件Linux系统，部署在EC2上。</p><p>AMI的类型包括私有（个人创建和使用），公开（由用户创建，并在AWS社区发布，任何人都能使用），付费（由个人创建，其他用户可以付费使用）</p><h4 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h4><p>特点：</p><ul><li><p>基于对象的存储服务，对象是最基础的数据单元，每个对象的大小为1Byte-5GB</p><ul><li>使用Bucket来存储对象，用Key来获取数据对象</li><li>对象包括：键、值、元数据、访问控制</li></ul></li><li><p>通过地理分散实现冗余，99.99%的可用性目标，共有或私有，每个对象都有专门的URL，支持比特流BitTorrent</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;11-Cloud-Programming-Landscape-云编程&quot;&gt;&lt;a href=&quot;#11-Cloud-Programming-Landscape-云编程&quot; class=&quot;headerlink&quot; title=&quot;11 Cloud Programming Landscape 云编程&quot;&gt;&lt;/a&gt;11 Cloud Programming Landscape 云编程&lt;/h2&gt;&lt;p&gt;主要内容：&lt;/p&gt;
&lt;p&gt;云编程的前景&lt;/p&gt;
&lt;p&gt;在云中的执行应用程序和服务的框架&lt;/p&gt;
&lt;p&gt;云服务生命周期&lt;/p&gt;
&lt;p&gt;常用的编程框架和模型：MPI、MapReduce / Hadoop 、亚马逊、微软 Azure&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Apache Spark</title>
    <link href="https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/16%20APACHE%20SPARK/"/>
    <id>https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/16%20APACHE%20SPARK/</id>
    <published>2020-03-16T00:00:00.000Z</published>
    <updated>2020-03-26T03:51:15.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MapReduce的限制</strong></p><ol><li>MapReduce编程对许多人来说都是有难度的</li><li>性能通常会遇到瓶颈（因为批处理不适合所需的用例）</li></ol><p>这导致MapReduce不适用于大型应用程序。因此出现了多种专业系统的发展。</p><p> 因此Spark面世——将所有的专业系统整合到一起</p><a id="more"></a><h2 id="Apache-Spark"><a href="#Apache-Spark" class="headerlink" title="Apache Spark"></a>Apache Spark</h2><p>是一个通用目的数据处理引擎，为不同的需求设计，</p><ul><li>更快的批处理</li><li>应用需要交互式查询处理</li><li>处理流数据</li><li>系统需要迭代算法</li></ul><p>特征：</p><ul><li>是in-memory的计算引擎（充分利用内存）</li><li>用磁盘时比Hadoop快10倍，用内存时比Hadoop快100倍</li></ul><h4 id="Spark-结构"><a href="#Spark-结构" class="headerlink" title="Spark 结构"></a>Spark 结构</h4><p>Spark不提供任何类似HDFS的存储或者资源管理能力，它是一个以几乎实时的方式，处理大量数据的，统一的框架</p><p>三个主要的分层：</p><ol><li>生态层：基于核心层执行操作的库<ul><li>Spark SQL， Spark Streaming， BlinkDB， Spark ML， GraphX， Tachyon</li></ul></li><li>核心层：框架的通用层，它定义了所有的基础功能，其他功能和扩展都是基于这一层创建的<ul><li>Spark Core，Spark DataFrame API</li></ul></li><li>资源管理层：Spark以独立模式（单节点群集设置）管理自己的资源。 但是对于分布式集群模式，它可以与YARN之类的资源管理模块集成在一起。<ul><li>Standalone，YARN，Mesos</li></ul></li></ol><p>结构：</p><ul><li>Spark应用程序在集群上作为独立的进程集运行，由SparkContext对象（也称为驱动程序）协调。<ul><li>每个应用程序都有其自己的执行程序进程，这些进程在整个应用程序期间保持不变，并在多个线程中运行任务。</li><li>这具有将应用程序彼此<strong>隔离</strong>的好处——每个驱动程序调度自己的任务，并且来自不同应用程序的任务在不同的JVM中运行。</li><li>但是，这也意味着，如果不将数据写入外部存储系统，则无法在不同的Spark应用程序（SparkContext实例）之间共享数据。</li></ul></li><li>SparkContext负责将应用程序代码（JAR或Python文件）和任务发送给执行程序。</li><li>每个驱动程序都有一个Web UI，通常在端口4040上，该Web UI显示有关正在运行的任务，执行程序和存储使用情况的信息。</li></ul><h4 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h4><p>提供了Java、Scala、Python的high-level APIs</p><p>提供了优化引擎支持：产生执行图，结构化数据处理的高级工具</p><h3 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h3><p>处理：</p><ul><li>内存管理和容错</li><li><p>对集群上的任务jobs进行调度，分配，监控</p></li><li><p>与存储系统进行交互</p></li></ul><p>它也实现了弹性分布式数据库（RDDs）的关键概念。</p><ul><li>RDD是对象的不可变容错分布式集合，可以并行操作。</li><li>RDD可以包含任何类型的对象，并且可以通过加载外部数据集或从驱动程序分配集合来创建</li><li>RDD是分布在整个集群中的数据集的表示。</li></ul><h4 id="弹性分布式数据库-RESILIENT-DISTRIBUTED-DATABASES（RDDs）"><a href="#弹性分布式数据库-RESILIENT-DISTRIBUTED-DATABASES（RDDs）" class="headerlink" title="弹性分布式数据库 RESILIENT DISTRIBUTED DATABASES（RDDs）"></a>弹性分布式数据库 RESILIENT DISTRIBUTED DATABASES（RDDs）</h4><ul><li>RDDs可以被存储在内存或磁盘中，主要的性能来自于将数据存在内存中<ul><li>诸如MapReduce之类的当前框架提供了许多用于<u>访问集群的计算资源的接口</u>，但是缺乏<u>利用分布式内存的接口。</u></li></ul></li><li>Spark的优势：<ul><li>数据重用在许多迭代ML算法中很常见，例如K-means聚类。另一个示例是当用户对同一数据子集运行多个临时查询时。</li></ul></li><li>在Hadoop（和其他框架）中，在不同作业之间<u>重用数据的唯一方法</u>是将其写入外部存储系统（例如HDFS）。使用内存中的RDD，可以更快地处理数据。可以存储在分布式内存中的数据大小仅受群集大小限制。</li></ul><h4 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h4><ul><li>Transformations 转换：在RDD上执行并产生包含结果的新RDD的操作（例如，映射，过滤器，联接，联合等）</li><li>Actions 行动：在RDD上运行计算后返回值的操作（例如reduce，count，first等）。</li></ul><p>Spark上的转换操作是lazy的，并不会立即执行。只有当行动被调用时，转换才会执行。执行的结果将返回给驱动程序。该设计能提高Spark的运行效率</p><h4 id="Lazy-（Transformations）评估"><a href="#Lazy-（Transformations）评估" class="headerlink" title="Lazy （Transformations）评估"></a>Lazy （Transformations）评估</h4><p>转换是对数据的操纵。 它们从一个RDD转换到下一个。</p><p>比如：一个Action查询数据集中有多少数据，Spark在收到查询后，才会进行Transformations，再将结果返回给Action</p><h4 id="RDD用例"><a href="#RDD用例" class="headerlink" title="RDD用例"></a>RDD用例</h4><p>假设我们必须在大量的Web服务器访问日志中查找错误代码。</p><p>我们可以使用MapReduce，Storm或我们喜欢的任何框架来读取文件集，查找特定的错误代码，并将带有该代码的所有行放入存储设备（例如HDFS）</p><p>然后，当我们分析这些结果数据时，我们可能希望将错误与其他用户活动进行交叉引用cross-reference。 这将要求我们再次获取文件，处理并提供结果等。</p><p>对于传统方式需要重复对磁盘进行查询，而RDD是将数据存储在内存中，并提供了重新查询所用子集的功能。 </p><p>内存中数据存储非常适合许多迭代和交互式算法</p><h4 id="RDD容错"><a href="#RDD容错" class="headerlink" title="RDD容错"></a>RDD容错</h4><p>设计RDD的主要挑战是定义一个可提供有效容错能力的编程接口。</p><ul><li>故障是系统中的缺陷defect。</li><li>错误error是系统边界内观察到的行为与系统的指定行为之间的<strong>差异</strong></li><li>故障failure是系统当时<u>显示的行为</u>与<u>规范相反</u>的<strong>实例</strong></li></ul><p>现有解决方案提供基于<strong>细粒度更新</strong>的容错接口。</p><ul><li><p>使用这样的系统，获得容错的唯一方法，是<u>跨计算机复制数据</u>或<u>跨计算机记录更新</u>。</p></li><li><p>这些方法是数据密集型的——<strong>高带宽</strong>用于在群集网络上移动数据。</p></li></ul><p>RDD提供了基于粗粒度转换的接口（例如，映射，过滤器，联接）。 这些转换将相同的操作应用于许多数据项。</p><ul><li><p>这允许通过记录用于构建数据库的转换而不是实际数据本身来有效地应用容错。</p></li><li><p>如果RDD的分区丢失，则RDD具有有关如何从其他RDDS派生出来的足够信息，以便仅重新计算该分区。</p></li></ul><h4 id="RDD的限制"><a href="#RDD的限制" class="headerlink" title="RDD的限制"></a>RDD的限制</h4><p>不适合非迭代应用程序，因为Spark的主要性能提升是内存数据的迭代。</p><p>RDD也不太适合对共享状态进行异步细粒度更新的应用程序，例如Web应用程序的存储系统或增量Web爬虫。批量转换对于小的更新是浪费的。</p><h4 id="传统的流处理管道"><a href="#传统的流处理管道" class="headerlink" title="传统的流处理管道"></a>传统的流处理管道</h4><ol><li>从数据源接收流数据</li><li>在集群上并行处理流数据</li><li>将数据输出到下游的系统</li></ol><p>大多数传统的流处理器使用连续操作器（continuous operator）模型进行数据处理</p><ul><li>一组工作节点，每个工作节点运行一个或多个连续操作器</li><li>每个连续的操作器一次处理流数据一个记录，然后将记录转发给管道中的其他操作器。</li><li>有源操作器用于从采集系统接收数据，而下沉操作器则输出到下游系统。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcwbap19kxj30o80e4wii.jpg" alt="截屏2020-03-16下午6.05.24"></p><p>比如Apache Storm；这是一个非常优雅的解决方案，但是随着系统变得越来越大以及大数据分析的复杂性增加，使用此模型面临着越来越多的挑战。</p><h4 id="传统流数据处理系统的问题"><a href="#传统流数据处理系统的问题" class="headerlink" title="传统流数据处理系统的问题"></a>传统流数据处理系统的问题</h4><p><strong>故障和任务被卡主（straggling）：</strong></p><ul><li><p>随着规模扩大，集群节点故障或者无法预测的变慢（比如stragglers，掉队者）的可能性会增加</p></li><li><p>系统需要能自动从故障和卡住的任务（stragglers）中恢复，以实时提供结果</p></li><li>将<u>连续操作器</u>静态分配给工作节点，会使传统系统很难从故障和卡住的任务（stragglers）中快速恢复。</li></ul><p><strong>负载平衡：</strong></p><ul><li>Workers之间的处理负载分配不均，会导致连续操作器系统出现瓶颈。</li><li>这在大型集群和动态变化的工作负载中更可能发生。</li><li>系统需要能够根据工作负载动态调整资源分配。</li></ul><p><strong>流、批处理、交互式工作负载的统一：</strong></p><ul><li>在许多使用案例中，以交互方式查询流数据或将其与静态数据集（例如，预先计算的模型）结合起来很有吸引力。</li><li>在连续的操作器系统中，这很难做到，因为它们并非旨在动态地为临时查询引入新的运算器</li><li>这需要一个可以结合批处理，流式处理和交互式查询的引擎。</li></ul><p><strong>高级分析：</strong></p><ul><li><p>复杂的工作负载需要连续的学习和更新数据模型，甚至是用sql查询最新的流数据视图</p></li><li><p>使这些分析任务具有通用抽象（API），能让开发人员的工作更加轻松</p></li></ul><h4 id="离散流-Discretized-Streams-——-解决方案"><a href="#离散流-Discretized-Streams-——-解决方案" class="headerlink" title="离散流 Discretized Streams —— 解决方案"></a>离散流 Discretized Streams —— 解决方案</h4><p>为了解决这些问题，Spark Streaming组件使用称为离散化流的新架构，该架构直接利用了Spark引擎的库和容错能力。</p><ul><li>Spark Streaming接收器不会一次读取单个数据记录，而是将数据流离散化为亚秒级的微小批量（RDDs）。（即接收者并行接受数据并将其缓冲在Spark worker节点的内存中）。然后，Spark引擎运行简短的任务（数十毫秒）以处理批处理并将结果输出到其他系统。</li></ul><p>与连续操作器模型不同，Spark任务根据数据的位置和可用资源动态分配给工作人员。这是为了实现更好的负载平衡和更快的故障恢复。</p><ul><li>每个数据的batches都是一个RDD。这允许使用任何Spark代码或库来处理流数据。</li></ul><h4 id="DSP好处：动态负载平衡"><a href="#DSP好处：动态负载平衡" class="headerlink" title="DSP好处：动态负载平衡"></a>DSP好处：动态负载平衡</h4><p>将数据划分为多个微批，可以将计算能力以细粒度的方式分配给资源。</p><p>以字数统计为例：分区不均衡的流会导致某个节点过载，达到瓶颈；而将数据离散Discretized 后，可以根据节点的负载对任务进行分配和调度。</p><h4 id="DSP好处：从故障和卡住的任务中快速恢复"><a href="#DSP好处：从故障和卡住的任务中快速恢复" class="headerlink" title="DSP好处：从故障和卡住的任务中快速恢复"></a>DSP好处：从故障和卡住的任务中快速恢复</h4><p>传统流：</p><ul><li>万一发生节点故障，传统系统必须在另一个节点上重新启动发生故障的连续运算器，并重播数据流的某些部分以重新计算丢失的信息。（请注意，在重播后新节点赶上之前，管道无法继续进行。）</li></ul><p>Spark流（离散流）</p><ul><li><p>可以在集群中的所有其他节点上并行重新启动失败的任务，从而将所有重新计算均匀地分布在多个节点上，从而从故障中恢复。</p><p><u>计算已经离散化为可以在任何地方运行而不会影响正确性的任务。</u></p></li></ul><h4 id="DSP好处：流、批处理、交互的统一"><a href="#DSP好处：流、批处理、交互的统一" class="headerlink" title="DSP好处：流、批处理、交互的统一"></a>DSP好处：流、批处理、交互的统一</h4><p>Spark Streaming中的关键编程接口是DStream或分布式流。 每一批流数据都由RDD表示，因此DStream只是一系列RDD。</p><p>因此，我们可以使用任何Spark函数处理DStream。例如，我们可以将DStream与预先计算的静态数据集（已加载到另一个RDD中）结合在一起</p><p>数据批存储在workers的内存中，因此可以按需交互查询。<br>批处理，流和交互式工作负载的这种统一在Spark中非常简单，但是在没有<u>工作负载的通用接口</u>的系统中很难实现</p><h4 id="DSP好处：高级分析"><a href="#DSP好处：高级分析" class="headerlink" title="DSP好处：高级分析"></a>DSP好处：高级分析</h4><p>DStreams生成的RDD可以转换为DataFrames并使用SQL查询</p><p>例如，使用Spark的JDBC驱动程序，可以公开流的状态，并支持SQL语句进行查询。</p><p>然后，通过JDBC服务器，就能够以交互方式（比如SQL命令、GUI）查询持续更新的表。</p><h4 id="Spark流：性能"><a href="#Spark流：性能" class="headerlink" title="Spark流：性能"></a>Spark流：性能</h4><p>实际上，Spark Streaming具有批处理数据和利用Spark引擎的能力，可以使吞吐量与其他流系统相当或更高。</p><ul><li>Spark Streaming可以实现低至几百毫秒的延迟。</li></ul><p>开发人员有时会问微批处理是否会固有地增加过多的延迟。</p><ul><li>实际上，批处理延迟仅是端到端管道延迟的一小部分。</li></ul><ul><li>例如，许多应用程序在滑动窗口上计算结果，甚至在COS中，该窗口也仅定期更新（例如，每2秒滑动20秒的窗口）。</li></ul><ul><li>许多管道等待很短的时间来处理延迟或乱序的数据。</li></ul><ul><li>最后，任何自动触发算法都倾向于等待一段时间才能触发。</li></ul><p>同样，DStreams带来的吞吐量提高通常意味着您需要更少的计算机来处理相同的工作负载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;MapReduce的限制&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MapReduce编程对许多人来说都是有难度的&lt;/li&gt;
&lt;li&gt;性能通常会遇到瓶颈（因为批处理不适合所需的用例）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这导致MapReduce不适用于大型应用程序。因此出现了多种专业系统的发展。&lt;/p&gt;
&lt;p&gt; 因此Spark面世——将所有的专业系统整合到一起&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="https://liaoooyx.com/tags/Spark/"/>
    
      <category term="RDD" scheme="https://liaoooyx.com/tags/RDD/"/>
    
  </entry>
  
  <entry>
    <title>云计算/10 云中间件，配置管理，PaaS</title>
    <link href="https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/10%20%E4%BA%91%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%EF%BC%8CPaaS/"/>
    <id>https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/10%20%E4%BA%91%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%EF%BC%8CPaaS/</id>
    <published>2020-03-12T18:19:46.893Z</published>
    <updated>2020-03-20T00:39:38.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="10-云中间件，配置管理，PaaS"><a href="#10-云中间件，配置管理，PaaS" class="headerlink" title="10 云中间件，配置管理，PaaS"></a>10 云中间件，配置管理，PaaS</h2><h4 id="云计算的好处"><a href="#云计算的好处" class="headerlink" title="云计算的好处"></a>云计算的好处</h4><ul><li>弹性资源：自治的资源按需供应（通过实用的模型）</li><li><p>多重租赁：多个用户并发使用相同资源</p></li><li><p>工作负载整合：将利用不足的资源释放，把工作负载低的虚拟机整合到同一个物理机器上。</p></li></ul><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>位于网络中分布式计算系统每一侧的操作系统和应用程序之间的软件层：</p><ul><li>连接不同的软件组件</li><li>是在系统和分布式软件之间的软件层</li><li><p>隐藏了分布式系统的复杂性和多样性 heterogeneity</p></li><li><p>连接了低层次的OS通信（系统级别的通信实现）和编程语言抽象（通信的接口）的间隔</p></li><li><p>为分布式应用提供了常用的编程接口和基础设施</p></li><li>促进资源服务的使用</li><li>将应用与基础设施连接</li></ul><h4 id="Platform-as-a-Service-PaaS"><a href="#Platform-as-a-Service-PaaS" class="headerlink" title="Platform as a Service (PaaS)"></a>Platform as a Service (PaaS)</h4><p>定义：“向消费者提供的功能是将使用提供商提供的编程语言，库，服务和工具创建的，由消费者创建或获取的应用程序部署到云基础架构上。 使用者不管理或控制包括网络，服务器，操作系统或存储在内的底层云基础架构，但可以控制已部署的应用程序以及应用程序托管环境的配置设置。</p><p>简单的定义：在基本虚拟资源（即虚拟机，块存储）管理之外提供的任何服务。</p><p>是什么：是一种云中间件；提供<u>软件解决方案堆栈</u>即服务；可以聚合其他PaaS和IaaS供应商服务；通常由工具和/或库(APIs)组成</p><p>用处：通过抽象简化应用开发；通过简化管理促进应用部署</p><h4 id="PaaS例子"><a href="#PaaS例子" class="headerlink" title="PaaS例子"></a>PaaS例子</h4><ul><li>• Google App Engine</li><li>• Amazon Web Services<ul><li>– Amazon RDS (Relational Database Service) </li><li>– Amazon Elastic Transcoder</li></ul></li><li>• Hadoop Project<ul><li>– MapReduce</li><li>– Hbase: Bigtable-like capabilities on top of Hadoop and HDFS</li></ul></li></ul><h4 id="云服务的生命周期"><a href="#云服务的生命周期" class="headerlink" title="云服务的生命周期"></a>云服务的生命周期</h4><ol><li>construction：开发、组合、配置</li><li>deployment：选择供应商、部署、上下文化</li><li>operation：调度、优化、执行、重新上下文化</li></ol><h4 id="配置管理-Configuration-Management-CM"><a href="#配置管理-Configuration-Management-CM" class="headerlink" title="配置管理 Configuration Management (CM)"></a>配置管理 Configuration Management (CM)</h4><p>用于：在构造阶段后（但不是在部署和操作阶段），在大规模机器上（10k）配置应用和中间件</p><p>例子：puppet、chef</p><h4 id="Puppet"><a href="#Puppet" class="headerlink" title="Puppet"></a>Puppet</h4><p>提供基于图像的和模型驱动的方式；通过人类可读的DSL（Domain Specific Language）实现；资源是存储在“清单”中的配置单位；可以将资源编译到定义依赖项的目录中（作为有向非循环图）；目录已应用于系统以对其进行配置；在许多计时器步骤中，配置更改是不确定的（最终应用）</p><h4 id="Chef"><a href="#Chef" class="headerlink" title="Chef"></a>Chef</h4><p>是Puppet的一个受欢迎的分支；</p><p>主要区别：天生就是确定性的 Deterministic</p><p>强调启动一个新的服务（适合虚拟机和云）</p><p>按顺序应用配置，且用户可知</p><p>使用烹饪的类比：<br>•创建配方（安装步骤或脚本的预算）<br>•使用刀（用于管理的命令行工具）<br>•存储在服务器内的食谱中</p><h4 id="Chef的结构"><a href="#Chef的结构" class="headerlink" title="Chef的结构"></a>Chef的结构</h4><p>Client-Server架构</p><p>服务器推送配置变更</p><p>客户端在机器上实施配置变更</p><h4 id="配置管理在Cloud上的问题"><a href="#配置管理在Cloud上的问题" class="headerlink" title="配置管理在Cloud上的问题"></a>配置管理在Cloud上的问题</h4><ol><li>云环境天生就是动态的：CM工具并不是用于处理有弹性的资源集合（AWS Elastic Beanstalk 是Chef的云生命周期可感知版）；因为云的生命周期，导致云应用和普通应用不一样（Useful in Construction，What about: Deployment, Operation?）</li><li>遗留软件如何迁移到云：如何使遗留软件和他们的中间件适应云的动态特征（如何将云的dynamic nature提取走）</li><li>如何构建可内部交互的云应用</li></ol><h4 id="Contextualization-上下文化"><a href="#Contextualization-上下文化" class="headerlink" title="Contextualization 上下文化"></a>Contextualization 上下文化</h4><p>定义：上下文是在部署到特定环境期间自主配置应用程序的各个组件并支持软件堆栈的过程。</p><p>通过在整个生命周期内通过PaaS组件配置SaaS和PaaS，启用弹性云软件堆栈。<br>通过通用配置机制支持旧式中间件<br>通过recontextualization 实现IaaS提供程序的互操作性</p><p>上下文化机制的两个阶段：</p><ul><li>Deployment：从环境中（在PaaS层）采集动态生成的配置数据</li><li>Operation：由VM boot触发，使用上述数据的软件配置</li></ul><p>被OpenNebula和OpenStack采用，用于使软件使用Iaas供应商的环境，例如：</p><ul><li>配置基础网络（静态和动态）</li><li>配置虚拟机秘钥识别（SSH VPN）</li><li>连接基于网络的存储</li></ul><h4 id="Operation阶段的上下文化"><a href="#Operation阶段的上下文化" class="headerlink" title="Operation阶段的上下文化"></a>Operation阶段的上下文化</h4><ul><li>配置数据是如何传递到虚拟机的（见图）</li><li>在boot阶段安装ISO光盘镜像（ISO CD image）：上下文数据通过网络脚本传递到虚拟机内部的脚本上，由脚本创建软件专门的配置文件和域数据</li><li>配置文件和数据用于设置云环境中，软件依赖和中间件服务的上下文，</li></ul><h4 id="Recontextualization-重新上下文化"><a href="#Recontextualization-重新上下文化" class="headerlink" title="Recontextualization 重新上下文化"></a>Recontextualization 重新上下文化</h4><p>在Operation阶段（runtime）改变配置数据</p><blockquote><p>The recontextualizer is responsible for triggering the creation and association of new infrastructure class context data when applicable domains are migrated to the infrastructure.</p></blockquote><p>触发：虚拟机实时迁移Live Migration，比如本地环境变量更改，但无需重启reboot，因此需要触发机制，而不是有规律的执行</p><p>在重新上下文化的过程中，虚拟机将会持续运行，自动的，且更改对应用是透明的</p><h4 id="Contextualizer-结构"><a href="#Contextualizer-结构" class="headerlink" title="Contextualizer 结构"></a>Contextualizer 结构</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcsnmpoczxj31c00g2dlv.jpg" alt="截屏2020-03-13下午2.09.51"></p><blockquote><p>Figure 3 also includes the order in which components are called. From the figure it can be seen that the Contextualizer component is invoked by the VM Manger during application deployment (step 1) to create ISO images (steps 2, 3), create VM images (steps 4, 5) and/or manip- ulate VM images (steps 6, 7). After images have been created and/or manipulated, they are stored in a local data repository (step 8) for deployment by the VM Manager. During operation, if an event from the underlying hypervisor indicates that a VM has been stopped, started or migrated (step 9), alterations to the existing ISO images are made (steps 10, 11) and reinserted into the VM’s virtual device (step 12).</p></blockquote><p>从图中可以看出，在应用程序部署期间，VM管理器调用了Contextuizer组件（步骤1）以创建ISO映像（步骤2、3），创建VM映像（步骤4、5）和/或操作 -确定VM映像（步骤6、7）。 创建和/或操作映像后，它们将存储在本地数据存储库中（步骤8），以供VM Manager进行部署。 在操作过程中，如果来自底层管理程序的事件指示VM已停止，启动或迁移（步骤9），则对现有ISO映像进行更改（步骤10、11），然后将其重新插入VM的虚拟设备中（ 第12步）。</p><h4 id="Recontextualization-例子"><a href="#Recontextualization-例子" class="headerlink" title="Recontextualization 例子"></a>Recontextualization 例子</h4><p>由于先前的设置，分布式文件系统的操作性能可能会在实时迁移后降低</p><p>客户端数据与远程服务节点交互，而不是附近的节点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;10-云中间件，配置管理，PaaS&quot;&gt;&lt;a href=&quot;#10-云中间件，配置管理，PaaS&quot; class=&quot;headerlink&quot; title=&quot;10 云中间件，配置管理，PaaS&quot;&gt;&lt;/a&gt;10 云中间件，配置管理，PaaS&lt;/h2&gt;&lt;h4 id=&quot;云计算的好
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>云计算/19 Serverless Architectures</title>
    <link href="https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/19%20Serverless%20Architectures/"/>
    <id>https://liaoooyx.com/2020/03/%E4%BA%91%E8%AE%A1%E7%AE%97/19%20Serverless%20Architectures/</id>
    <published>2020-03-12T13:36:24.441Z</published>
    <updated>2020-03-12T14:29:36.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="19-Serverless-Architectures"><a href="#19-Serverless-Architectures" class="headerlink" title="19 Serverless Architectures"></a>19 Serverless Architectures</h2><h4 id="无服务计算"><a href="#无服务计算" class="headerlink" title="无服务计算"></a>无服务计算</h4><p>开发者不需要配置或者管理服务器或容器，如AWS Lambda，只需要将业务代码上传至平台即可。</p><p>在无服务计算的模型中，服务器的存在对开发者是隐藏的。</p><ul><li>无服务结构和功能即服务 Function-as-a-Service(FaaS) 平台的优点：简单、快速、灵活</li><li><strong>无服务</strong>指的是软件结构，<strong>功能即服务</strong>是其中的关键的机制，通过这种机制，开发者在该软件结构中实现业务逻辑</li></ul><h4 id="IaaS-PaaS-SaaS-FaaS的区别"><a href="#IaaS-PaaS-SaaS-FaaS的区别" class="headerlink" title="IaaS, PaaS, SaaS, FaaS的区别"></a>IaaS, PaaS, SaaS, FaaS的区别</h4><h4 id="无服务计算执行模型"><a href="#无服务计算执行模型" class="headerlink" title="无服务计算执行模型"></a>无服务计算执行模型</h4><p>如果该功能不存在与现有的服务器中，则平台从数据库中读取功能，并部署到服务器上，再返回功能的执行结果给用户</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>无需管理服务器，可连续扩展，动态分配资源，避免资源过度分配（管理资源分配，平衡资源分配），按使用付费</p><p>从生产角度From a productivity standpoint，可以不考虑代码存储和执行环境管理的细节</p><p>基于execution metrics，无服务计算十分划算priced，so there is a financial advantage as well.</p><h4 id="无服务功能-Serverless-Functions"><a href="#无服务功能-Serverless-Functions" class="headerlink" title="无服务功能 Serverless Functions"></a>无服务功能 Serverless Functions</h4><p>从 monoliths 到 microservices 到 functions</p><p><strong>微服务</strong>的特点：Smaller-grained services 粒度小的服务，专属、具体的功能</p><p><strong>微服务</strong>的结构：事件处理器 Event handler，无服务后端，数据处理</p><p><strong>无服务功能</strong>的特点：FaaS的指导原则，开发者无需关注被抽象化的服务器，按照功能的使用服务而不是服务器实例的大小，提供的服务是事件驱动的且能够立即扩展</p><h4 id="透明的应用部署"><a href="#透明的应用部署" class="headerlink" title="透明的应用部署"></a>透明的应用部署</h4><p>PaaS：用于基于用户需求和约束的服务发现</p><p><strong>无服务结构</strong>和<strong>微服务</strong>可以掩盖“运行过程中软件和数据的灵活组合/拆分和可交互性”</p><p><strong>容器</strong>或<strong>技术</strong>用于桥接云和边缘计算之间的间隔：Unikernels 提供解决“软件定义的基础架构”的基础功能</p><h4 id="无服务计算——其他好处"><a href="#无服务计算——其他好处" class="headerlink" title="无服务计算——其他好处"></a>无服务计算——其他好处</h4><p>简化部署和打包，消除系统管理的要求</p><p>敏捷开发，使开发者集中于代码，并快速发布deliver</p><p>扩展的成本更低：扩展（用户访问量）不需要开发者通过代码实现，管理者也不用更新服务器或添加新的服务器</p><p>更小的开发成本和经营成本 operational costs</p><p>更快发布软件 software release，减少到市场的时间 Decreased time to market</p><h4 id="无服务架构的解决方案和结构细节"><a href="#无服务架构的解决方案和结构细节" class="headerlink" title="无服务架构的解决方案和结构细节"></a>无服务架构的解决方案和结构细节</h4><ul><li>Amazon Lambda</li><li>Apache Openwhisk</li><li>IBM Openwhisk</li><li>Google cloud functions</li><li>Microsoft Azure functions Other: Iron.io, Fission</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;19-Serverless-Architectures&quot;&gt;&lt;a href=&quot;#19-Serverless-Architectures&quot; class=&quot;headerlink&quot; title=&quot;19 Serverless Architectures&quot;&gt;&lt;/a&gt;19 Se
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面向列的数据库</title>
    <link href="https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20NOSQL-%E8%B0%B7%E6%AD%8CBigTable/"/>
    <id>https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20NOSQL-%E8%B0%B7%E6%AD%8CBigTable/</id>
    <published>2020-03-11T00:00:00.000Z</published>
    <updated>2020-03-26T03:52:07.681Z</updated>
    
    <content type="html"><![CDATA[<p>大数据系统的规模对数据库空间的要求有很大挑战</p><p>传统的关系数据库管理系统（Relational Database Management System：<em>RDBMS</em>）无法扩展为适应真正的massive级别数据：ACID原则不适合大规模的数据，CAP定理中描述的问题</p><a id="more"></a><h4 id="CAP定理："><a href="#CAP定理：" class="headerlink" title="CAP定理："></a>CAP定理：</h4><ul><li>一致性：所有客户都能看到最新的数据，不管执行过什么操作（比如更新或删除）</li><li>可用性：即使某些节点发送错误，系统也需要继续客户的操作</li><li>分区容错：即使网络或消息发送错误，系统也需要继续执行可续操作（比如一个节点向另一个节点发送的消息，允许发送错误并被丢弃）</li></ul><h4 id="ACID-和-BASE"><a href="#ACID-和-BASE" class="headerlink" title="ACID 和 BASE"></a>ACID 和 BASE</h4><p>ACID：</p><ul><li>Atomic 原子性：事务的所有操作都成功，不然就回滚</li><li>Consistent 一致性：事务不能使数据库的最终状态出现不一致</li><li>Isolated 隔离性：事务使独立的，不能影响其他事务</li><li>Durable 容忍性：即使服务器重新启动等，已完成的事务也会保留。</li></ul><p>BASE</p><ul><li><strong>B</strong>asic <strong>A</strong>vailability 基础可用性：系统在CAP定理方面，保证系统的可用性</li><li><strong>S</strong>oft-state 软状态：系统的状态会随时间改变，即使没有输入（因为要确保最终一致性）</li><li><strong>E</strong>ventual consistency 最终一致性：只要数据库最终变得一致，在每个事务之后就不需要一致性。</li></ul><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><p>可以被分成4类：Key-value stores、Column-oriented databases、Document databases、Graph databases</p><h3 id="Google-BigTable-HBASE"><a href="#Google-BigTable-HBASE" class="headerlink" title="Google BigTable (HBASE)"></a>Google BigTable (HBASE)</h3><p>BigTable是第一个（也是影响力最大的）面向列的NoSQL数据库之一。于2006年发布。它旨在可靠地扩展到数千台计算机上的PB级数据。</p><p>在60多种Google产品中使用，包括Google Earth，Google Analytics（分析）和Youtube。</p><p>BigTable具有极大的影响力，它催生了一个非常受欢迎的开源克隆：HBase。</p><p>设计为与MapReduce BigTable兼容并互补，可为MapReduce提供基于键的快速查找</p><h4 id="关键特征"><a href="#关键特征" class="headerlink" title="关键特征"></a>关键特征</h4><ul><li>BigTable是一个简单的概念 —- 映射两个任意字符串值（行键和列键）以及时间戳，并将其放入关联的任意字节数组中：（行：字符串，列：字符串，时间：int64）-&gt;字符串</li><li>在NoSQL分类中，BigTable是面向列的数据库。<br>它是高度分布式的，没有可用的连接，并且假定“一次写入多次读取”。</li><li>数据模型是“稀疏，分布式，持久的多维排序图”<br>a sparse, distributed, persistent multi-dimensional sorted map”</li><li>实际上，这意味着您可以通过提供行ID，列名和时间戳来访问BigTable中的任何单元（用于版本控制–您保留同一单元的过去版本）。<br>提供这些参数，BigTable会很快将结果返回给您。</li></ul><h4 id="Tablets"><a href="#Tablets" class="headerlink" title="Tablets"></a>Tablets</h4><ul><li>单元的每个新版本都会增加时间戳。 这允许您设置策略，例如“仅保留最新的n个版本”或“仅保留自时间t开始存储的版本”。</li><li>数据按行排序，以行的Key按字典顺序排序，并且表的行范围是动态分区的。 每行范围称为一个Tablets。</li><li>Tablets是分配和负载平衡的单位——如果发生不平衡，则Tablets可以在服务器之间移动。<br>Tablets的大小大约在200MB</li></ul><p>例如 ：如果关键范围是{January，February，March}，并且从March开始有很多数据进入，则它将拆分为多个Tablets，并在服务器之间移动以平衡系统。</p><p>因此，少量row范围的读取是高效的，并且通常仅需要与少量机器通信。</p><h4 id="Tablet-管理"><a href="#Tablet-管理" class="headerlink" title="Tablet 管理"></a>Tablet 管理</h4><p>BigTable使用3层模型对tablet进行管理</p><ol><li>第一层包含存储在Chubby（用于访问控制的分布式锁定服务）中的文件，该文件包含根Tablet的位置。</li><li>根tablet包含系统中所有tablets的位置。 它经过特殊处理，并且与其他tablet不同，它永远不会被分割——确保层次结构永远不会超过3个级别。</li><li>根tablet中的每一行都在内存中使用大约1k的数据。 假设每块tablet有128MB的限制，则3级层次结构可以处理$2^{34}$（〜170亿）个tablets。</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5s2zivqsj30o60b2whu.jpg" alt="截屏2020-03-24下午10.36.12" style="zoom:50%;" /></p><h4 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h4><p>Head node：分配tablets到tablet服务器上</p><p>Tablet server：管理对tablets的读写操作；客户端直接与tablet服务器通信；tablet服务器将太大的tablets拆分</p><p>SSTable：Sorted String Tables 包含真实数据</p><h4 id="读写组织"><a href="#读写组织" class="headerlink" title="读写组织"></a>读写组织</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcvbq1kcy8j30sg0e8dhf.jpg" alt="截屏2020-03-15下午9.34.38"></p><p>内存中有一个表（memTable）用于存储发生的一系列的更新</p><p>一个写操作会将记录添加到memTable中，并且同时会写入日志（为了容错）</p><p>通过读取SSTable文件以及通过动态应用memTable的更新来提供读操作。 换句话说：“这里是价值所在，以及需要应用到该价值以获得真正价值的更新流”</p><h4 id="次要压缩-Minor-Compactions"><a href="#次要压缩-Minor-Compactions" class="headerlink" title="次要压缩 Minor Compactions"></a>次要压缩 Minor Compactions</h4><p>随着写操作执行，memTable的大小也会增大。当memTable的大小达到阈值，该memTable会被冻结，并创建一个新的memTable。被冻结的memTable被转化为SSTable并被写成文件。</p><p> 这部分操作被认为次要压缩，该压缩的两个目标：</p><ol><li>减少tablet服务器的内存使用量</li><li>减少数据恢复时，必须从提交日志中读取的数据量。</li></ol><p>发生压缩时，传入的读/写操作可以继续。</p><h4 id="主要压缩-Major-Compactions"><a href="#主要压缩-Major-Compactions" class="headerlink" title="主要压缩 Major Compactions"></a>主要压缩 Major Compactions</h4><p>每个次要压缩都会产生一个新的SSTable，如果该操作不断进行，读操作需要从大量的SSTables中合并更新。</p><p>为了防止这种情况，我们会在后台定期执行合并压缩。这样的压缩读取了几个SSTables和memTable的内容，并写出了一个新的SSTable。 完成后，可以丢弃之前的SSTables和memTable。</p><p><strong>将所有SSTables重写为一个SSTable的合并压缩称为主要压缩</strong>。 请记住，单个SSTable本身可能会拆分为多个文件。</p><h4 id="关键特征-1"><a href="#关键特征-1" class="headerlink" title="关键特征"></a>关键特征</h4><p>调整压缩格式</p><ul><li><p>客户端可以控制是否压缩地区组的SSTable，以及如果压缩，则使用哪种压缩格式。</p><p>用户指定的压缩格式将应用于每个SSTable块（大小可通过特定于位置组的调整参数来控制）。</p><p>分别压缩每个块时，会损失一些空间，但是我们的好处是，可以读取SSTable的一小部分而无需解压缩整个文件。</p></li></ul><p>布隆过滤器</p><ul><li><p>读取操作必须从组成tablet状态的所有SSTable中读取。 如果这些SSTable不在内存中，我们可能最终会进行许多磁盘访问。</p><p>BigTable可以使用Bloom Filters减少此类访问的次数。 布隆过滤器允许我们询问SSTable是否可能包含指定行/列/对的任何数据。</p><p>对于某些应用程序，将少量tablet服务器内存分配给<u>布隆过滤器</u>，能够大大减少读取操作所需的磁盘搜索次数。</p></li></ul><p>使SSTables不可变</p><ul><li><p>使用BigTable改善性能的另一种方法是使SSTables不可变。</p><p>这意味着SSTables不会直接写入，因为唯一可写入的数据结构是memTable，这使得并发控制相对简单。</p><p>结果，由于具有不可变性，仅在发生重大压缩时才创建SSTables。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大数据系统的规模对数据库空间的要求有很大挑战&lt;/p&gt;
&lt;p&gt;传统的关系数据库管理系统（Relational Database Management System：&lt;em&gt;RDBMS&lt;/em&gt;）无法扩展为适应真正的massive级别数据：ACID原则不适合大规模的数据，CAP定理中描述的问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Google BigTable" scheme="https://liaoooyx.com/tags/Google-BigTable/"/>
    
      <category term="HBase" scheme="https://liaoooyx.com/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>异构硬件</title>
    <link href="https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20%E5%BC%82%E6%9E%84%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20%E5%BC%82%E6%9E%84%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2020-03-11T00:00:00.000Z</published>
    <updated>2020-03-26T03:42:24.341Z</updated>
    
    <content type="html"><![CDATA[<p>Cyber-Physical Systems (CPS)，the Internet of Things (IoT)， and the Smart Anything Everywhere Initiative</p><p>从长远来看，随着大规模采用，物联网转型影响预计将显着增加：千万级数量的物品互联，非常大的经济价值</p><p>关键驱动因素：物联网收集的数据，复杂的应用程序开发平台，应用于事物的分析以及<strong>异构硬件体系结构 heterogeneous hardware architectures</strong>，能够促进新业务模型</p><a id="more"></a><h4 id="云计算-大数据"><a href="#云计算-大数据" class="headerlink" title="云计算+大数据"></a>云计算+大数据</h4><p>实时流、实时处理</p><p>数据可视化</p><p>实时结构化数据库、交互式分析、批量处理</p><p>结构化和非结构化数据</p><p>云基础设施</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Cyber-Physical Systems (CPS)，the Internet of Things (IoT)， and the Smart Anything Everywhere Initiative</p><p>从长远来看，随着大规模采用，物联网转型影响预计将显着增加：千万级数量的物品互联，非常大的经济价值</p><p>关键驱动因素：物联网收集的数据，复杂的应用程序开发平台，应用于事物的分析以及<strong>异构硬件体系结构 heterogeneous hardware architectures</strong>，能够促进新业务模型</p><h3 id="异构硬件体系结构-Heterogeneous-hardware-architectures"><a href="#异构硬件体系结构-Heterogeneous-hardware-architectures" class="headerlink" title="异构硬件体系结构 Heterogeneous hardware architectures"></a>异构硬件体系结构 Heterogeneous hardware architectures</h3><p>是运行产品和提供服务的一种高效方法；将不同的处理器类型组合到一个系统中，以此提高绝对性能，最小化能耗和成本。</p><p>引入新的平台：合并多核CPUs，多核GPUs，和许多附加设备作为一个单独解决方案。出现在从超级计算机到个人智能手机的各种环境中.</p><p>因为产品的种类不断增长，因此需要设计<strong>更灵活的软件抽象software abstractions</strong>，以及改进系统结构，以探索异构平台的好处</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>数据巨大且复杂，传统处理方法效率不足：</p><ul><li>Too large to fit reasonably in fast RAM 数据太大无法合理的放入fast RAM中</li><li>Random access intensive, making prefetching and caching ineffective 随机访问密集，使预取和缓存无效</li></ul><p>数据经常被存在多机集群中的二号存储节点中</p><ul><li>存储系统和网络性能成为 first-order concerns</li></ul><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>大数据系统带来新的需求：新的编程模型和工具</p><p>大数据系统需要实现：高性能和高效率</p><h4 id="关于异质性方面"><a href="#关于异质性方面" class="headerlink" title="关于异质性方面"></a>关于异质性方面</h4><p>异质性是并行结构中最深奥和最有挑战的特征</p><p>宏观方面：分布式计算机（云）的网络，由不同的节点结构（单核，多核）组成，通过可能的异质网络进行内部交互；即网络的异质性和，网络上的机器的异质性</p><p>微观方面：底层的内存结构（main、cache、disk storage、tertiary storage）和不同的accelerator结构（固定的、可编程的，比如GPUs；可配置的：FPGAs）</p><h3 id="电脑结构"><a href="#电脑结构" class="headerlink" title="电脑结构"></a>电脑结构</h3><p>需要进行分类：根据目的进行分类</p><h4 id="通用处理器-General-Purpose-Processors（GPP）"><a href="#通用处理器-General-Purpose-Processors（GPP）" class="headerlink" title="通用处理器 General Purpose Processors（GPP）"></a>通用处理器 <strong>General Purpose Processors</strong>（GPP）</h4><ul><li>通用微处理器（通用电脑）：比如PCs，workstations，Laptops，notepads，用于执行多种应用和任务</li><li>微控制器：嵌入式系统<ul><li>专门为嵌入式系统中指定任务而设计</li><li>有面向控制的外围设备</li><li>具有片上CPU，固定数量的RAM，ROM，I / O端口</li><li>低成本、低能耗、低性能、比微处理器更小</li><li>适合对成本、空间、能耗要求严格的应用</li></ul></li></ul><h4 id="应用专用处理器"><a href="#应用专用处理器" class="headerlink" title="应用专用处理器"></a>应用专用处理器</h4><p>通用处理器对不同的软件都能表现出较好的性能，但专用处理器在特定任务上的表现更好</p><p>应用专用处理器出现的目的：更高的性能，更低的消耗，更低的成本</p><p>比如：TVs、mobile phone（不是智能手机）、GPSs</p><p>被分为：</p><ol><li>Digital Signal Processor (DSPs) 数字信号处理器</li><li>Application Specific Instruction Set Processors (ASIPs) 应用专用命令集处理器</li><li>Application Specific Integrated Circuit (ASICs) 应用专用集成电路<ul><li>指定市场、更少编程、难以构建</li></ul></li></ol><h4 id="Accelerators-Coprocessors-加速器-协处理器"><a href="#Accelerators-Coprocessors-加速器-协处理器" class="headerlink" title="Accelerators - Coprocessors 加速器-协处理器"></a><strong>Accelerators - Coprocessors</strong> 加速器-协处理器</h4><p>加速器-协处理器对某些功能的处理性能比CPU更高效more efficiently ：更快、更低能耗，但更难编程，比如：</p><ol><li>Graphics Processing Unit (GPU)<ul><li>Single Instruction Multiple Thread (SIMT) model 单指令多线程模型 – CUDA code</li><li>高效：数据并行应用；吞吐量密集型应用——算法需要处理大量数据元素</li></ul></li><li>FPGA (Field Programmable Gate Array) 现场可编程门阵列<ul><li>是逻辑门阵列，可以进行硬件编程以完成用户指定的任务</li><li>软件的一部分可以直接由硬件实现</li><li>比软件更有效率，但比ASIC更贵</li></ul></li></ol><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>Intel CPU -&gt; DSP -&gt; MultiCore -&gt; ManyCore -&gt; GPU -&gt; FPGA -&gt; ASIC</p><p>灵活性、可编程、 ——&gt; 性能、特定领域、能源使用率高 power efficiency</p><h4 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h4><p>Host memory 主存：CPU的内存</p><p>Device memory 显存：GPU的内存</p><p><strong>处理流程：</strong></p><ol><li>从CPU中将输入数据拷贝到GPU中</li><li>加载GPU程序并执行，将数据缓存到芯片chip上提高性能</li><li>将执行结果从GPU内存中拷贝回CPU内存</li></ol><h4 id="GPU——数据处理"><a href="#GPU——数据处理" class="headerlink" title="GPU——数据处理"></a>GPU——数据处理</h4><p>擅长处理并行 data-parallel processing</p><ul><li>在多个数据元素上并行执行相同的计算——低控制流开销和高SP浮点运算强度 high SP floating point arithmetic intensity</li><li>每个内存访问有许多计算</li></ul><p>高浮点运算强度和许多数据元素意味着可以通过计算而不是大数据缓存来隐藏内存访问延迟</p><ul><li>需要避免带宽饱和</li></ul><h4 id="FPGA-现场可编程门阵列"><a href="#FPGA-现场可编程门阵列" class="headerlink" title="FPGA 现场可编程门阵列"></a>FPGA 现场可编程门阵列</h4><p>可配置逻辑块，内部通信网络，I/O信号</p><h4 id="FPGA——数据处理"><a href="#FPGA——数据处理" class="headerlink" title="FPGA——数据处理"></a>FPGA——数据处理</h4><ul><li>用于数据采集和原始数据预处理以进行事件过滤</li><li>需要掌握基于FPGA的硬件描述语言（HDL）的编程模型。<ul><li>– VHDL和Verilog是设计FPGA系统的传统方法</li><li>–描述执行计算的基础设计的基础硬件</li><li>–这与诸如C和C ++的编程语言形成对比，后者描述了在固定不变体系结构上执行的指令</li><li>–这使得FPGA既可以在其上实现的方面极为灵活，又在不充分了解其编程模型的情况下也很难设计。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cyber-Physical Systems (CPS)，the Internet of Things (IoT)， and the Smart Anything Everywhere Initiative&lt;/p&gt;
&lt;p&gt;从长远来看，随着大规模采用，物联网转型影响预计将显着增加：千万级数量的物品互联，非常大的经济价值&lt;/p&gt;
&lt;p&gt;关键驱动因素：物联网收集的数据，复杂的应用程序开发平台，应用于事物的分析以及&lt;strong&gt;异构硬件体系结构 heterogeneous hardware architectures&lt;/strong&gt;，能够促进新业务模型&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="异构硬件" scheme="https://liaoooyx.com/tags/%E5%BC%82%E6%9E%84%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="GPU" scheme="https://liaoooyx.com/tags/GPU/"/>
    
      <category term="FPGA" scheme="https://liaoooyx.com/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库、数据去重</title>
    <link href="https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%8E%BB%E9%87%8D%E5%92%8C%E4%BB%93%E5%BA%93/"/>
    <id>https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/13%20%E5%8E%BB%E9%87%8D%E5%92%8C%E4%BB%93%E5%BA%93/</id>
    <published>2020-03-11T00:00:00.000Z</published>
    <updated>2020-03-26T03:50:45.572Z</updated>
    
    <content type="html"><![CDATA[<p>数据去重是一个逐渐流行起来的方法</p><p>重复数据删除有许多用途，但其主要用途是减少系统所需存储空间的潜力。</p><p>去重可以是文件file级别，块block级别，字节byte级别</p><a id="more"></a><h4 id="数据仓库-data-warehouse"><a href="#数据仓库-data-warehouse" class="headerlink" title="数据仓库 data warehouse"></a>数据仓库 data warehouse</h4><p>假设一个大公司：有许多数据库database、许多站点sites，和不同的schemas。</p><p>求是：•支持决策<br>•在全公司范围内查看高质量信息的集成视图（来自不同的数据库）<br>•分离运营系统和信息系统</p><p>运营系统和信息系统的比较</p><div class="table-container"><table><thead><tr><th>特征</th><th>运营系统</th><th>信息系统</th></tr></thead><tbody><tr><td>主要目的</td><td>在当前基础上用于商业运营</td><td>帮助制定决策</td></tr><tr><td>数据类型</td><td>当前商业运营状况的展示</td><td>历史数据和预测数据</td></tr><tr><td>主要用户</td><td>柜员、销售、管理员</td><td>管理者、商业分析师、客户</td></tr><tr><td>使用范围</td><td>狭窄的、有计划的和简单的<u>更新和查找</u></td><td>宽泛的、复杂的<u>查询和分析</u></td></tr><tr><td>设计目标</td><td>性能：吞吐量、可用性</td><td>灵活访问和使用</td></tr><tr><td>大小</td><td>对一个和少数几个表的大量更新和查询</td><td>周期性的批量更新，对大量或所有行的查询</td></tr></tbody></table></div><p>数据仓库包括：元数据，原始数据-&gt;轻度总结数据-&gt;高度总结数据，数据库管理系统；其他还有：负载管理、查询管理、数据仓库管理</p><p>数据仓库的使用者：联机分析处理OLIP工具，报告、查询、应用开发、EIS工具，数据挖掘工具，和终端用户end-user访问工具</p><p>数据仓库的来源：<strong>运营数据源Operational data source</strong>，运营数据库Operational data store</p><h4 id="数据仓库的定义"><a href="#数据仓库的定义" class="headerlink" title="数据仓库的定义"></a>数据仓库的定义</h4><p>“数据仓库是面向主题的，集成的，随时间变化且非易失性的数据收集，以支持管理层的决策过程。”</p><p><strong>Subject-oriented</strong>：</p><ul><li>面向重要的主题，而不是交易transactions：比如销售、市场、金融、分销distribution；</li><li>简洁的视图，仅提供有用的数据以供决策</li></ul><p><strong>Integrated</strong>：</p><ul><li><p>来自于多个数据源的数据遵循一致的命名习惯Consistent naming conventions、格式、编码结构</p></li><li><p>对缺失数据，噪声数据，不一致数据进行清洗cleaning和预处理pre-processing</p></li></ul><p><strong>Time-varinat</strong>：</p><ul><li>只读，周期性刷新</li><li>提供历史historical值和可能的预测projected值</li></ul><p><strong>Non-volatile</strong>：</p><ul><li>在物理上分别存储</li><li>非在线更新</li><li>从不移除数据，因此没有并发问题</li></ul><h4 id="运营数据-Operational-data"><a href="#运营数据-Operational-data" class="headerlink" title="运营数据 Operational data"></a>运营数据 Operational data</h4><ul><li>transient 短暂的（not historical）</li><li>not normalised非标准化的（指的是数据库的范式）（可能为了性能而去规范化）</li><li>约束在一定范围内（非全面的 not comprehensive）</li><li>有时候质量不佳（出现不一致和错误）</li></ul><p><strong>经过提取/转换/加载 E(xtract)T(ransform)L(oad)后：</strong></p><ul><li>详细的Detailed（但还没被总结summarized）</li><li>历史的（周期性的periodic）</li><li>标准化（第三范式3rd  normal form或更高）</li><li>全面的：以公司为角度</li><li>时效的：数据足够支持目前的决策制定</li><li>质量受控的：数据精确且准确</li></ul><h4 id="删除重复数据-Data-Deduplication"><a href="#删除重复数据-Data-Deduplication" class="headerlink" title="删除重复数据 Data Deduplication"></a>删除重复数据 Data Deduplication</h4><p>数据去重是一个逐渐流行起来的方法</p><p>重复数据删除有许多用途，但其主要用途是减少系统所需存储空间的潜力。</p><p>去重可以是文件file级别，块block级别，字节byte级别</p><h4 id="文件级别去重"><a href="#文件级别去重" class="headerlink" title="文件级别去重"></a>文件级别去重</h4><p>对单文件去重，常被认为“单实例存储”，它的主要思想就是：不管有多少文件实例被使用，只保留一个文件备份</p><p>该技术被用于Amazon S3，并报告出能够减少存储和带宽的成本为1/10</p><h4 id="块级别去重"><a href="#块级别去重" class="headerlink" title="块级别去重"></a>块级别去重</h4><p>将文件拆分成块blocks（或chunks）：核心思想是，经过两个文件不同，但他们可能包括相同的元素（比如两个不同的ppt可能包含同一张图片）</p><h4 id="字节级别去重"><a href="#字节级别去重" class="headerlink" title="字节级别去重"></a>字节级别去重</h4><p>在许多方面，字节级去重是块级去重的一种特殊情况。它比较数据流中的每个单独字节，而不是块。</p><p>字节级别去重是通常是“内容感知”的——比如，卖方对数据流的组成有一定的了解，因此知道要处理的数据流的特定部分。</p><p>该方法通常是“后处理”的，即先存储所有的流，再进行处理</p><h4 id="去重处理"><a href="#去重处理" class="headerlink" title="去重处理"></a>去重处理</h4><p>我们需要一种方法来检查数据是否已经被存储在我们的系统中：对文件、块、字节进行哈希计算，然后在我们的去重数据库DDB中查询该哈希值。如果该值存在，则该数据存在，如果值不存在，则存储该数据和对应的哈希值。</p><h4 id="Source-based-和-Target-based"><a href="#Source-based-和-Target-based" class="headerlink" title="Source-based 和 Target-based"></a>Source-based 和 Target-based</h4><p><strong>Source-based</strong>：</p><ul><li>之间在文件系统（或靠近数据的地方）中进行去重</li><li>对用户和应用透明</li><li>可以由文件系统本身或主机的操作系统执行</li><li>通常一个文件系统会扫描新文件并和现存的文件比较哈希值</li><li>通常需要中心化的管理（文件系统和备份服务器要在一起）</li><li>需要更多的用户资源，而不是带宽</li></ul><p>Target-based</p><ul><li>发生在备份服务器（第二/归档archive数据库）</li><li>重复数据从创建数据的位置删除</li><li>不损耗数据源的资源</li><li>不需要中心化的管理</li><li>需要更多的带宽</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h4 id="去重的权衡"><a href="#去重的权衡" class="headerlink" title="去重的权衡"></a>去重的权衡</h4><p><strong>Granularity 粒度</strong>：影响存储的效率和性能（存储空间和处理效率的权衡）</p><p>将文件拆分得越小（比如chunck-block-byte），就能找到更多的重复数据，但同样的，去重的处理速度也就越慢</p><p>另一个考虑是是容错：只留一个去重数据的副本copy是否足够</p><p>多个副本的优缺点？容错；数据分散靠近用户的cluster中，有利于提高响应时间；占用存储空间，增加成本</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>Operational System —— 运营系统<br>ad hoc —— 常用来形容一些特殊的、不能用于其它方面的，为一个特定的问题、任务而专门设定的解决方案<br>throughput —— 吞吐量</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据去重是一个逐渐流行起来的方法&lt;/p&gt;
&lt;p&gt;重复数据删除有许多用途，但其主要用途是减少系统所需存储空间的潜力。&lt;/p&gt;
&lt;p&gt;去重可以是文件file级别，块block级别，字节byte级别&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据去重" scheme="https://liaoooyx.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D/"/>
    
      <category term="数据仓库" scheme="https://liaoooyx.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CAP定理</title>
    <link href="https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12_%20CAP%E5%AE%9A%E7%90%86/"/>
    <id>https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12_%20CAP%E5%AE%9A%E7%90%86/</id>
    <published>2020-03-11T00:00:00.000Z</published>
    <updated>2020-03-26T03:54:12.555Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="https://zh.wikipedia.org/wiki/理论计算机科学" target="_blank" rel="noopener">理论计算机科学</a>中，<strong>CAP定理</strong>（CAP theorem），又被称作<strong>布鲁尔定理</strong>（Brewer’s theorem），它指出对于一个<a href="https://zh.wikipedia.org/wiki/分布式计算" target="_blank" rel="noopener">分布式计算系统</a>来说，不可能同时满足以下三点：<a href="https: //zh.wikipedia.org/wiki/CAP定理#cite_note-Lynch-1">[1]</a><a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-2" target="_blank" rel="noopener">[2]</a></p><ul><li>一致性（<strong>C</strong>onsistency） （等同于所有节点访问同一份最新的数据副本）</li><li><a href="https://zh.wikipedia.org/wiki/可用性" target="_blank" rel="noopener">可用性</a>（<strong>A</strong>vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li><li><a href="https://zh.wikipedia.org/w/index.php?title=网络分区&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">分区容错性</a>（<strong>P</strong>artition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择<a href="https: //zh.wikipedia.org/wiki/CAP定理#cite_note-3">[3]</a>。）</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-4" target="_blank" rel="noopener">[4]</a>。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p></blockquote><a id="more"></a><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>客户端将值写入任何服务器并获得响应后，它期望从其读取的任何服务器取回该值（或更新鲜的值）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcv3kjxahwj319q0lygnv.jpg" alt="截屏2020-03-15下午4.52.25"></p><p>为了保证该特性，客户端在向其中一个服务器写入后，该服务器需要与其他服务器同步，在同步完成后，才会通知客户端已成功写入。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcv3kxx6tij318w0lqwh7.jpg" alt="截屏2020-03-15下午4.52.58"></p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><blockquote><p>系统中非故障节点收到的每个请求都必须导致响应</p><p>every request received by a non-failing node in the system must result in a response</p></blockquote><p>在可用的系统中，如果我们的客户端向服务器发送请求并且服务器没有崩溃，则服务器最终必须响应客户端。不允许服务器忽略客户端的请求。</p><h3 id="分区容错"><a href="#分区容错" class="headerlink" title="分区容错"></a>分区容错</h3><blockquote><p>网络将被允许任意丢失从一个节点发送到另一节点的许多消息</p><p>the network will be allowed to lose arbitrarily many messages sent from one node to another</p></blockquote><p>即一个节点向另外一个节点发送的消息丢失是可接受的，下图展示当所有消息都丢失的情况：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcv3sa21zej30yo08k752.jpg" alt="截屏2020-03-15下午4.59.59"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/理论计算机科学&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;理论计算机科学&lt;/a&gt;中，&lt;strong&gt;CAP定理&lt;/strong&gt;（CAP theorem），又被称作&lt;strong&gt;布鲁尔定理&lt;/strong&gt;（Brewer’s theorem），它指出对于一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/分布式计算&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分布式计算系统&lt;/a&gt;来说，不可能同时满足以下三点：&lt;a href=&quot;https: //zh.wikipedia.org/wiki/CAP定理#cite_note-Lynch-1&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/CAP定理#cite_note-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性（&lt;strong&gt;C&lt;/strong&gt;onsistency） （等同于所有节点访问同一份最新的数据副本）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/可用性&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可用性&lt;/a&gt;（&lt;strong&gt;A&lt;/strong&gt;vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=网络分区&amp;amp;action=edit&amp;amp;redlink=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分区容错性&lt;/a&gt;（&lt;strong&gt;P&lt;/strong&gt;artition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择&lt;a href=&quot;https: //zh.wikipedia.org/wiki/CAP定理#cite_note-3&quot;&gt;[3]&lt;/a&gt;。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项&lt;a href=&quot;https://zh.wikipedia.org/wiki/CAP定理#cite_note-4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[4]&lt;/a&gt;。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="CAP定理" scheme="https://liaoooyx.com/tags/CAP%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop和MapReduce的发展</title>
    <link href="https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/11%20Hadoop%E5%92%8CMapReduce%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <id>https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/11%20Hadoop%E5%92%8CMapReduce%E7%9A%84%E5%8F%91%E5%B1%95/</id>
    <published>2020-03-04T00:00:00.000Z</published>
    <updated>2020-03-26T03:41:00.840Z</updated>
    
    <content type="html"><![CDATA[<p>Hadoop 1 的局限、Hadoop 2：HDFS Federation、YARN</p><a id="more"></a><h3 id="Hadoop-1"><a href="#Hadoop-1" class="headerlink" title="Hadoop 1"></a>Hadoop 1</h3><h4 id="Hadoop1中的MapReduce"><a href="#Hadoop1中的MapReduce" class="headerlink" title="Hadoop1中的MapReduce"></a>Hadoop1中的MapReduce</h4><ol><li>客户端提交MapReduce任务到<u>工作追踪器 Job Tracker</u>上</li><li>工作追踪器询问<u>主节点 NameNode</u>：哪些<u>数据节点 Data Node</u>有文件块</li><li>工作追踪器然后将<u>任务追踪器 Task Tracker</u>和<u>执行Map计算的Java代码</u>提供给那些节点。计算任务将在拥有本地数据的节点执行</li><li>任务追踪器将启动Map任务，并监控进程。它将返回心跳和任务状态给工作追踪器</li><li>每一个Map任务完成后，该节点将临时存储结果（中间数据），当所有Map任务都完成后，数据将通过网络发送给执行Reduce任务的节点</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd17f7ua3oj30kq0gkdje.jpg" alt="截屏2020-03-20下午11.39.15" style="zoom:50%;" /></p><h4 id="Hadoop-1-的局限"><a href="#Hadoop-1-的局限" class="headerlink" title="Hadoop 1 的局限"></a>Hadoop 1 的局限</h4><p>集群资源管理和MapReduce是紧密耦合的</p><ul><li>Hadoop 1中的工作追踪器只在一个机器上运行<ol><li>可扩展性有限，但实际中可能需要许多数据节点</li><li>可用性只存在于单点，如果工作追踪器发生故障，那么所有工作 Jobs 都要重启</li></ol></li></ul><blockquote><p>雅虎估计该设计的上限是5000个节点和40000个并发任务</p></blockquote><p>在资源使用上同样存在问题</p><ul><li>Hadoop 1对map和reduce的插槽(slots)数量是提前定义好的，因此可能出现map插槽满了而reduce插槽还是空的情况（反之亦然）</li><li>文件的数量也十分有限。主节点在内存中持有元数据，因此每个集群通常限制为5千万-1亿个文件</li></ul><p>在Hadoop1上运行非MapReduce应用也存在限制</p><ul><li>MapReduce工作基于<u>批处理驱动的分析</u>，但是，人们通常希望在Hadoop集群中运行其他计算范例</li><li>为什么要运行非MapReduce应用？<ul><li>实时分析存在困难。 MapReduce是批处理驱动的； 当需要实时结果时，Apache Storm之类的引擎可以更好地工作。</li><li>消息传递方法在MapReduce中是不可能的（没有相互依赖性）。</li></ul></li></ul><p><strong>这些问题都在Hadoop2中得到解决</strong></p><h4 id="长尾现象"><a href="#长尾现象" class="headerlink" title="长尾现象"></a>长尾现象</h4><p>谷歌与2013年将其识别为长尾现象：<u>个别拖后腿的任务task stragglers</u>大大减慢了应用程序的完成速度（执行阈值比作业平均值高50％），由操作系统抖动 OS jitter，数据偏斜 data skew,，守护进程，能源等引起</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd18i1hjspj311y0e677y.jpg" alt="截屏2020-03-21上午12.16.14"></p><h3 id="Hadoop-2"><a href="#Hadoop-2" class="headerlink" title="Hadoop 2"></a>Hadoop 2</h3><p>Hadoop 2从受限的<u>面向批处理的模型</u>转变为更具交互性和专用性的处理模型</p><p>主要变化有：HDFS联盟，YARN，高度可用的NameNode，容器的概念</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd18nu9h66j30tg0cctcc.jpg" alt="截屏2020-03-21上午12.22.08"></p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是一个抽象概念，但本质上是一种资源分配。</p><p>容器授予应用程序使用特定主机上特定数量资源（cpu，内存，磁盘）的权限。</p><p>容器类似于虚拟机，但是在现有操作系统之上运行，而不是在<u>虚拟机管理程序Hypervisor</u>上运行。换句话说，容器能在应用级别对用户进行隔离（虚拟机是操作系统级别的隔离）。容器之间是相互独立的，但公用操作系统、bins和库</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd18ujrh6zj30lu0ditbg.jpg" alt="截屏2020-03-21上午12.28.35" style="zoom:50%;" /></p><h4 id="高可用性主节点"><a href="#高可用性主节点" class="headerlink" title="高可用性主节点"></a>高可用性主节点</h4><p>解决Hadoop1中主节点的单点问题：它提供在同一群集中运行两个冗余NameNode的选项，可以主动或被动配置，使备用节点<u>热待命 hot standby</u></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1955bwhfj30uq08owgr.jpg" alt="截屏2020-03-21上午12.38.46"></p><h4 id="HDFS水平可扩展性"><a href="#HDFS水平可扩展性" class="headerlink" title="HDFS水平可扩展性"></a>HDFS水平可扩展性</h4><p>由上图可以看出，即使通过备份让主节点获得高可用性，但2个单独的主节点并不能提供水平可扩展性</p><ul><li>垂直可扩展性：更多的RAM，更高效的内存使用，将部分命名空间放到内存中，主类归档（tar/zip）</li><li>水平可扩展性的好处：规模、隔离性、稳定性、可用性、灵活性、实现其他主节点或非HDFS 命名空间</li></ul><h4 id="解决方案：HDFS-Federation"><a href="#解决方案：HDFS-Federation" class="headerlink" title="解决方案：HDFS Federation"></a>解决方案：HDFS Federation</h4><p>解决方式是联合多个独立的主节点</p><ul><li>联合的主节点是独立的，不需要协调。</li><li>数据节点被所有主节点共用，作为块的存储。</li><li>每个数据节点向群集中的所有主节点注册。</li><li>DataNode发送心跳给所有主节点，并接受块报告和处理命令。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd19lu5mjej30jk0bstbq.jpg" alt="截屏2020-03-21上午12.54.48" style="zoom:50%;" /></p><p>主要概念：</p><ul><li><u>块池 Block Pool</u>是一个<u>命名空间 namespace</u>中的一系列块</li><li><p>数据节点存储集群中的所有块</p></li><li><p>块池是独立管理的。因此每个命名空间都可以生成块ID，而不需要与其他命名空间进行达成一致</p></li><li>一个主节点故障不会影响数据节点对其他主节点的服务</li><li>一个命名空间和它对应的块池统称为<u>命名空间卷 Namespace Volumes</u>，如果一个命名空间被删除，它对于的块池也会被删除</li></ul><h4 id="HDFS-Federation的好处"><a href="#HDFS-Federation的好处" class="headerlink" title="HDFS Federation的好处"></a>HDFS Federation的好处</h4><p>命名空间的可扩展性：HDFS群集存储（数据节点）可以水平扩展，但命名空间不能。 当使用大量文件部署时，可通过向群集添加更多主节点的而达成水平扩展的目的</p><p>性能：文件系统操作吞吐量不再局限于单个主节点的</p><p>隔离：单个主节点的在多用户环境中不提供隔离。 现在，我们可以将不同类别的应用程序放入不同的主节点中（例如，实验性应用程序减慢主节点的运行速度不会影响其余集群）</p><h4 id="Yet-Another-Resource-Negotiation-YARN"><a href="#Yet-Another-Resource-Negotiation-YARN" class="headerlink" title="Yet Another Resource Negotiation (YARN)"></a>Yet Another Resource Negotiation (YARN)</h4><p>YARN的基础思想是：将Hadoop资源管理和工作调度拆分为不同的进程（后台进程）</p><p>不同种类的应用程序都能被提交给YARN（比如MapReduce，Giraph等），应用程序可以是单个作业，也可以是作业的<u>有向无环图Directed Acyclic Graph（DAG）</u>。</p><p>这样可以并行运行更多作业，并且可扩展性得到显着提高</p><ul><li><u>资源管理器ResourceManager</u>代替<u>工作追踪器JobTracker</u>，负责在所有应用程序之间仲裁资源的使用权限。<ul><li>持续追踪：维护在集群上运行的所有程序，以及所有在线的节点管理器的可用资源</li><li>分配资源：决定下一个使用集群资源的程序（即下个一程序应该分配到哪个数据节点上）</li><li>监控<u>程序主节点</u></li></ul></li><li><p><u>节点管理器NodeManager</u>是一个基于机器的框架，负责管理容器、监视资源使用情况并向资源管理器报告。 集群中的每台计算机都是一个节点管理器和一个数据节点。 </p><ul><li>以容器的形式提供计算资源</li><li>管理容器内运行的进程</li><li>负责监视资源（容器）。 它没有固定数量的Map和Reduce插槽，但是可以动态创建和管理<u>资源容器</u>。 它就像Hadoop 1中JobTracker的通用版本。</li></ul></li><li><p><u>ApplicationMaster的任务是与资源管理器协商资源，并与各个节点管理器一起执行和监视任务。</p><ul><li>协调执行程序的内所有任务</li><li>请求合适的资源容器来执行任务</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1cz80dvaj30zk0hq118.jpg" alt="截屏2020-03-21上午2.51.28"></p><blockquote><p>ApplicationMaster负责单个应用程序的执行。它从资源调度程序（资源管理器）中请求容器，并在获得的容器上执行特定的程序（例如，Java类的主程序）。 Application Master知道程序逻辑，因此每个框架都需要自己编写ApplicationMaster。 MapReduce框架提供了自己的应用ApplicationMaster。</p><p>应用程序管理器ApplicationManager负责维护已提交的应用程序列表。在客户端提交应用程序后，应用程序管理器首先验证是否满足其ApplicationMaster的资源需求。如果有足够的资源，则将程序转发给调度器，否则将拒绝。还要确保没有其他具有相同应用程序ID的应用程序提交。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5f0alzhqj30ni0b2dgh.jpg" alt="image"></p><h4 id="提交应用到YARN中"><a href="#提交应用到YARN中" class="headerlink" title="提交应用到YARN中"></a>提交应用到YARN中</h4><ol><li>客户端将需要执行的程序发送给<u>资源管理器ResourceManager</u>（如MapReduce）</li><li>资源管理器，在容器内启动一个<u>程序管理器ApplicationMaster</u>，并将要执行的程序发送过去</li><li><u>程序管理器</u>与<u>资源管理器</u>协商资源。<ul><li>它负责应用程序的整个生命周期。</li><li>资源请求只是请求分配多个容器，表示为magabytes和CPU份额（当前）。</li></ul></li><li>然后，<u>ApplicationMaster</u>与<u>节点管理器</u>联系，以在容器中启动任务<ul><li>它监视这些任务的进度，重启失败的任务，推测性地运行速度较慢的任务，并计算应用程序计数器的总值。</li><li>它的整个生命周期用于与容器协商，来启动完成程序所需的所有任务</li></ul></li><li><u>资源管理器</u>不会监视程序中的任务——但它会检查<u>ApplicationMaster</u>的运行状况<ul><li>如果<u>ApplicationMaster</u>失败，则<u>资源管理器</u>可以在新容器中重新启动它。</li><li><u>资源管理器</u>负责<u>ApplicationMaster</u>，而<u>ApplicationMaster</u>负责<u>任务</u></li></ul></li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5fujv1klj317o0r6arg.jpg" alt="截屏2020-03-24下午3.31.42" style="zoom:50%;" /></p><h4 id="YARN可以运行任何分布式程序"><a href="#YARN可以运行任何分布式程序" class="headerlink" title="YARN可以运行任何分布式程序"></a>YARN可以运行任何分布式程序</h4><p>ResourceManager，NodeManager和Container不关心它们要运行的任务或应用程序的类型。只要实现了适当的ApplicationMaster，任何应用程序都可以运行。</p><p>好处：</p><ul><li>更高的集群利用率（一个框架不使用的资源可以被另一个框架使用）</li><li>更低的运营成本（仅需要管理和调整一种类型的集群）</li><li>数据移动减少（无需在YARN和其他系统之间移动数据）</li></ul><p>管理单个群集，还能够减少数据中心空间的使用，从而降低的运营成本，功耗，发热等。</p><h4 id="YARN的其他特征"><a href="#YARN的其他特征" class="headerlink" title="YARN的其他特征"></a>YARN的其他特征</h4><ul><li>如果作业足够小，则可以直接在ApplicationMaster的容器中运行MapReduce作业的所有任务。 这避免了从ResourceManager请求容器并要求NodeManager启动（据说很小）任务的开销。（见上图）</li><li>YARN提供简化的用户日志管理和访问。 与旧的Hadoop 1 MapReduce不同，日志不会保留在单个从节点上，而是移至中央存储（例如HDFS）。 后续可用于调试，性能分析等。</li><li>在重启资源管理器后恢复程序(YARN-128)——使资源管理器可以重建应用程序的状态，并仅重新运行未完成的任务。</li><li>高可用性的资源管理器体系结构（YARN-149）——发送故障后，支持资源管理器从一个实例到另一个实例（可能在另一台计算机上）。 它涉及领导者竞选，权限转移，客户端重定向。</li></ul><h4 id="Hadoop-2总结"><a href="#Hadoop-2总结" class="headerlink" title="Hadoop 2总结"></a>Hadoop 2总结</h4><p>HDFS2——高可用性和用于水平扩展的联合主节点</p><p>YARN——超越了Hadoop 1的批处理，并提高了效率</p><p>工具和程序的完整生态系统</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1dm0m0pfj30wy0be0wi.jpg" alt="截屏2020-03-21上午3.13.22"></p><h4 id="Hadoop不平衡集群"><a href="#Hadoop不平衡集群" class="headerlink" title="Hadoop不平衡集群"></a>Hadoop不平衡集群</h4><p>问题：</p><ul><li>将新服务器和机架添加到Hadoop群集可能会导致其变得不平衡。 现有数据保留在原处，新服务器处于空闲状态。</li><li>如果现有节点繁忙，则<u>工作追踪器JobTracker</u>可能不得不将Map任务分配给新服务器。</li><li>如果发生这种情况，新服务器将需要通过网络复制对应的数据块。 这导致更多的网络流量和较慢的作业完成时间。</li></ul><p>解决：为了解决不平衡的情况，Hadoop包含一个称为平衡器的实用程序。</p><ul><li>它检查节点之间的可用空间的差异，并尝试平衡到阈值。</li><li>当检测到具有大量磁盘空间的节点时，数据块将从空间较小的节点复制过去。 </li><li>平衡器是手动运行的，并在管理员关闭其终端时停止。 </li><li>平衡器的默认设置为1MB / s网络流量，可更改。</li></ul><p>理想情况下，平衡器应在所有群集上定期运行以进行良好管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hadoop 1 的局限、Hadoop 2：HDFS Federation、YARN&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop1" scheme="https://liaoooyx.com/tags/Hadoop1/"/>
    
      <category term="Hadoop2" scheme="https://liaoooyx.com/tags/Hadoop2/"/>
    
  </entry>
  
  <entry>
    <title>Bloom filters 布隆过滤器</title>
    <link href="https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20Bloom%20filters%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://liaoooyx.com/2020/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/12%20Bloom%20filters%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-03-02T00:00:00.000Z</published>
    <updated>2020-03-26T03:55:10.383Z</updated>
    
    <content type="html"><![CDATA[<p><strong>布隆过滤器</strong>（英語：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><a id="more"></a><p>will trigger: false positive —- possibly in the set</p><p>will no trigger: false negative —- definitely not in the set</p><h4 id="demo-amp-介绍"><a href="#demo-amp-介绍" class="headerlink" title="demo &amp; 介绍"></a>demo &amp; 介绍</h4><p><a href="https://llimllib.github.io/bloomfilter-tutorial/" target="_blank" rel="noopener">https://llimllib.github.io/bloomfilter-tutorial/</a></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>布隆过滤器</strong>（英語：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。<a href="https://zh.wikipedia.org/wiki/链表" target="_blank" rel="noopener">链表</a>、<a href="https://zh.wikipedia.org/wiki/树_(数据结构" target="_blank" rel="noopener">树</a>)、<a href="https://zh.wikipedia.org/wiki/散列表" target="_blank" rel="noopener">散列表</a>（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/db50673c67c6e72b7342ca1383def18cdead21b6" alt="{\displaystyle O(https://wikimedia.org/api/rest_v1/media/math/render/svg/db50673c67c6e72b7342ca1383def18cdead21b6),O(\log n),O(1)}">。</p><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个<a href="https://zh.wikipedia.org/wiki/散列函数" target="_blank" rel="noopener">散列函数</a>将这个元素映射成一个位<a href="https://zh.wikipedia.org/wiki/数组" target="_blank" rel="noopener">数组</a>中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ec39041121b14e8c2b1a986c9b04547b223e3c" alt="O(https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ec39041121b14e8c2b1a986c9b04547b223e3c)">。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p><p>布隆过滤器可以表示全集，其它任何数据结构都不能；</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" alt="k">和<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0a07d98bb302f3856cbabc47b2b9016692e3f7bc" alt="m">相同，使用同一组散列函数的两个布隆过滤器的交并<a href="https://zh.wikipedia.org/wiki/Wikipedia:列明来源" target="_blank" rel="noopener">[來源請求]</a>运算可以使用位操作进行。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率false positive随之增加。但是如果元素数量太少，则使用散列表足矣。</p><p>另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><p>在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p><p>optimal number of hash functions $k=\frac{m}{n}ln2,k=-\frac{lnp}{ln2}$</p><p>估计要添加的元素数量</p><p>bollm过滤器的大小</p><p>计算最佳的哈希函数数量</p><p>计算false positive的可能性</p><p>trade-off</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;布隆过滤器&lt;/strong&gt;（英語：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的&lt;a href=&quot;https://zh.wikipedia.org/wiki/二进制&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二进制&lt;/a&gt;向量和一系列随机&lt;a href=&quot;https://zh.wikipedia.org/wiki/映射&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;映射函数&lt;/a&gt;。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="布隆过滤器" scheme="https://liaoooyx.com/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据库和存储</title>
    <link href="https://liaoooyx.com/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/10%20DATABASES%20AND%20STORAGE/"/>
    <id>https://liaoooyx.com/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/10%20DATABASES%20AND%20STORAGE/</id>
    <published>2020-02-24T00:00:00.000Z</published>
    <updated>2020-03-26T03:40:26.247Z</updated>
    
    <content type="html"><![CDATA[<p>大数据系统需要存储大量的数据，并且需要花费大量的金钱对存储的数据进行获取和维护。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3phyt1uoj30tw0hgaf0.jpg" alt="截屏2020-03-23上午3.35.43"  /></p><a id="more"></a><h3 id="数据库的结构"><a href="#数据库的结构" class="headerlink" title="数据库的结构"></a>数据库的结构</h3><p>以下类型的数据可以被归类为：关系型数据库，或非关系型数据库（后4种）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3pmrg1u5j30r20fwn8e.jpg" alt="截屏2020-03-23上午3.40.17"></p><p><img src="../../../Library/Application Support/typora-user-images/截屏2020-03-23上午3.42.55.png" alt="截屏2020-03-23上午3.42.55"></p><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>关键特征：</p><ul><li><p>Edgar Codd’s 12 rules <a href="https://baike.baidu.com/item/%E7%A7%91%E5%BE%B7%E5%8D%81%E4%BA%8C%E5%AE%9A%E5%BE%8B/10138377?fr=aladdin" target="_blank" rel="noopener">科德十二定律</a></p></li><li><p>使用<u>表</u>储存<u>结构化数据</u></p></li><li><p>支持ACID事务的一致性</p><blockquote><p>Atomic 原子性：事务中的所有操作全部成功或者全部回滚</p><p>Consistent 一致性：事务不能让数据库处于不一致的状态</p><p>Isolated 隔离性：事务之间不能相互影响</p><p>Durable 耐用性：对完成的事务进行持久化，即使服务器重启</p></blockquote></li><li><p>通常使用SQL进行查询</p></li><li><p>通过主键和外键管理关系</p></li><li><p>使用SQL和关系来执行<u>关联joins</u></p><blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3pu209rij30xc0owjyl.jpg" alt="截屏2020-03-23上午3.47.23" style="zoom:50%;" /></p></blockquote></li></ul><h3 id="大数据系统中数据库的挑战"><a href="#大数据系统中数据库的挑战" class="headerlink" title="大数据系统中数据库的挑战"></a>大数据系统中数据库的挑战</h3><ul><li>大数据的规模，对数据库空间的要求是很大的挑战</li><li>传统的RDBMS无法扩展到真正”大数据“的级别</li><li>ACID原则不一定适用于大规模</li><li>CAP定理提出了一个问题</li></ul><h4 id="CAP定理："><a href="#CAP定理：" class="headerlink" title="CAP定理："></a>CAP定理：</h4><p>是Eric Brewer在1998年提出的一个假设，由Gilbert和Lynch在2002年证明。</p><p>它指出，分布式系统不可能同时确保<u>一致性</u>，<u>可用性</u>和<u>分区容错性</u>。</p><ul><li>一致性：所有客户都能看到最新的数据，不管执行过什么操作（比如更新或删除）</li><li>可用性：即使某些节点发送错误，系统也需要继续客户的操作</li><li>分区容错：即使网络或消息发送错误，系统也需要继续执行可续操作（比如一个节点向另一个节点发送的消息，允许发送错误并被丢弃）</li></ul><h4 id="ACID-和-BASE"><a href="#ACID-和-BASE" class="headerlink" title="ACID 和 BASE"></a>ACID 和 BASE</h4><p>ACID：</p><ul><li>Atomic 原子性：事务的所有操作都成功，不然就回滚</li><li>Consistent 一致性：事务不能使数据库的最终状态出现不一致</li><li>Isolated 隔离性：事务使独立的，不能影响其他事务</li><li>Durable 耐用性：即使服务器重新启动等，已完成的事务也会保留。</li></ul><p>BASE</p><ul><li><strong>B</strong>asic <strong>A</strong>vailability 基础可用性：系统在CAP定理方面，保证系统的可用性</li><li><strong>S</strong>oft-state 软状态：系统的状态会随时间改变，即使没有输入（因为要确保最终一致性）</li><li><strong>E</strong>ventual consistency 最终一致性：只要数据库最终变得一致，在每个事务之后就不需要一致性。</li></ul><h3 id="NoSQL-——-Not-only-SQL"><a href="#NoSQL-——-Not-only-SQL" class="headerlink" title="NoSQL —— Not only SQL"></a>NoSQL —— Not only SQL</h3><p><strong>严格的一致性</strong>会在大规模的系统中带来巨大的性能和能源开销。</p><p>妥协方案是<strong>最终一致性</strong>：给定足够长的时间不发送任何更改，可以期望所有更新都将通过系统进行传播，且所有副本都将最终保持一致。</p><p>NoSQL数据库比传统的数据库采用<u>更宽松的一致性模型</u>，它是非关系的数据库，没有固定的schema，也没有joins。NoSQL描述为克服RDBMS的可扩展性限制而开发的许多非关系数据库。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3qpwtjf1j310m0l2tsl.jpg" alt="截屏2020-03-23上午4.18.00" style="zoom:33%;" /></p><h4 id="NoSQL的好处"><a href="#NoSQL的好处" class="headerlink" title="NoSQL的好处"></a>NoSQL的好处</h4><ul><li>适合处理大量的数据</li><li>NoSQL数据库针对<u>检索</u>和<u>添加</u>操作进行了高度优化，并且通常除了记录存储之外几乎没有其他功能（尽管有时它们确实可以有）</li><li>当实时性能比一致性更重要时，可以采用NoSQL</li><li>例子：对大量文档进行索引、在高流量网站上提供页面、传递流媒体</li></ul><h4 id="NoSQL的种类"><a href="#NoSQL的种类" class="headerlink" title="NoSQL的种类"></a>NoSQL的种类</h4><p>键值对存储、面向列的数据库、文档型数据库、图数据库</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3qxs5kfej30r20fwgnj.jpg" alt="截屏2020-03-23上午3.40.17"></p><h4 id="类型1：键值对存储"><a href="#类型1：键值对存储" class="headerlink" title="类型1：键值对存储"></a>类型1：键值对存储</h4><ul><li>是最简单的NoSQL类型，且易于实现，比如MapReduce。</li><li>它允许数据以<u>无shcema</u>和<u>无固定数据模型</u>的方式存储。</li><li>Key可以用简单的值表示。</li><li>当它仅用于查询或对部分数据进行更新时，效率很低</li></ul><div class="table-container"><table><thead><tr><th>例子</th><th>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</th></tr></thead><tbody><tr><td>经典的应用</td><td>内容缓存（专注于向大量的数据进行扩展，为处理大量负载而设计），日志等</td></tr><tr><td>数据模型</td><td>一系列的键值对</td></tr><tr><td>优点</td><td>快速查询</td></tr><tr><td>缺点</td><td>存储的数据没有schema</td></tr><tr><td>适合</td><td>存储会话session信息、用户资料、偏好、购物车信息</td></tr><tr><td>不适合</td><td>查询信息、存储的数据之间有关系、同时操作多个Key</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3r8esu5ej310k0hy0zc.jpg" alt="截屏2020-03-23上午4.35.48" style="zoom:33%;" /></p><h4 id="面向列的数据库"><a href="#面向列的数据库" class="headerlink" title="面向列的数据库"></a>面向列的数据库</h4><p>数据库的常用查询需要对数据集进行聚合处理，以面向列的方式存储数据，能使需要对大规模数据进行聚合的查询更高效</p><p>面向列的数据库还可以处理非常大的数据，因为数据是按列组织的，并且可以轻松分区（称为分片）。在这种情况下，列会按列族（也称为组）进行组织，以将相关列保持在一起（如用于客户地址的列组等）</p><div class="table-container"><table><thead><tr><th>例子</th><th>Cassandra, HBase, Riak</th></tr></thead><tbody><tr><td>经典的应用</td><td>分布式文件系统</td></tr><tr><td>数据模型</td><td>列 -&gt; 族</td></tr><tr><td>优点</td><td>快速查询、分布式的数据存储</td></tr><tr><td>缺点</td><td>低级别的接口</td></tr><tr><td>适合</td><td>内容管理系统、博客平台、大量写入（日志聚合）、maintaining counters、expiring usage</td></tr><tr><td>不适合</td><td>早期开发、变化的查询模式</td></tr></tbody></table></div><h4 id="面向文档的数据库"><a href="#面向文档的数据库" class="headerlink" title="面向文档的数据库"></a>面向文档的数据库</h4><ul><li>面向文档的数据库类似于键值存储，不同之处在于，值指向标准格式/编码的文档（入XML，JSON等）</li><li>文档数据库将这些文档理解为字段的集合，除了通过键进行检索之外，还可以直接进行查询和更新。</li><li>文档数据库实质上是键值存储的下一个级别，允许与每个键与嵌套的值关联。 它们支持更有效的查询。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3sg7kp29j30ku0gymzg.jpg" alt="截屏2020-03-23上午5.17.51" style="zoom:25%;" /></p><div class="table-container"><table><thead><tr><th>例子</th><th>CouchDB, MongoDb</th></tr></thead><tbody><tr><td>经典的应用</td><td>网络应用</td></tr><tr><td>数据模型</td><td>列 -&gt; 族</td></tr><tr><td>优点</td><td>快速查询、分布式的数据存储</td></tr><tr><td>缺点</td><td>查询性能、没有标准的查询语法</td></tr><tr><td>适合</td><td>内容管理系统、博客平台、网络分析、实时分析、电商应用</td></tr><tr><td>不适合</td><td>跨多个业务的复杂事务、针对不同聚合结构的查询</td></tr></tbody></table></div><h4 id="图-树结构数据库"><a href="#图-树结构数据库" class="headerlink" title="图/树结构数据库"></a>图/树结构数据库</h4><p>图数据库使用灵活的图模型，代替行列式表和硬性结构（如SQL），它可以跨多台计算机进行扩展。目标是性能和灵活性。</p><p>图包括<u>节点</u>和<u>关系</u>两个元素，每个<u>节点</u>代表一个 实体（如人、地点等），每个<u>关系</u>代表两个节点之间的联系。Twitter是图数据库的例子之一</p><ul><li>图的存储：有些图数据库使用，专门为存储和管理图而设计的，自带存储方式，；其他的则使用<u>关系数据库</u>或<u>对象数据库</u></li><li>图的处理引擎：本地图处理（也称为“无索引邻接”）是处理图数据的最有效方法，因为连接的节点在数据库中彼此物理“指向”。非本机图处理使用其他方式来处理CRUD操作。</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3sqmtdb2j30ku0f40ze.jpg" alt="截屏2020-03-23上午5.27.55" style="zoom:50%;" /></p><p>性能：</p><ul><li>数据之间的连接（关系）数量比数据量增长得更快。</li><li>随着关系的数量和深度的增加，传统的数据库将变得混乱。 图数据库的性能可以更好地解决这一问题。</li></ul><p>灵活性：</p><ul><li>图的结构和方案可以随着解决方案/行业的变化而灵活变化。</li><li>无需对域进行详尽的建模。 可以在现有结构上进行添加，而不必担心当前的功能。</li></ul><div class="table-container"><table><thead><tr><th>例子</th><th>Neo4J, InfoGrid, Infinite Graph</th></tr></thead><tbody><tr><td>经典的应用</td><td>社交网络、推荐系统（专注于对数据结构建模 - 内部联系性）</td></tr><tr><td>数据模型</td><td>属性图 - 节点</td></tr><tr><td>优点</td><td>图算法：如最短路径、连通性、n度关系等</td></tr><tr><td>缺点</td><td>必须遍历整个图形才能获得确定的答案。不容易集群。</td></tr><tr><td>适合</td><td>关联数据的问题空间：社交网络、空间数据、货物和金钱的路由信息（物流）、推荐引擎</td></tr></tbody></table></div><h4 id="更多NoSQL的例子"><a href="#更多NoSQL的例子" class="headerlink" title="更多NoSQL的例子"></a>更多NoSQL的例子</h4><p>外部数据集成：</p><ul><li>许多公司需要集成来自业务合作伙伴的数据。 即使双方进行了大量的讨论和谈判，企业也几乎无法控制数据格式</li></ul><ul><li>同样，在许多情况下，由于业务需求等的变化，这些格式会非常频繁地更改。</li></ul><p>前端订单处理系统：</p><ul><li>每当最终用户从世界任何地方进行交易时，系统都需要不被中断的接受请求。</li><li>之后，协调系统通常会将其更新到后端系统，并更新最终用户的订单状态。</li></ul><p>企业内容管理服务：</p><ul><li>现在，内容管理已在公司的不同职能部门（例如HR或Sales）中使用。</li><li>挑战是，将使用不同元数据结构的部门，一起合并到公共内容管理服务中</li></ul><h4 id="NoSQL-VS-RDBMS"><a href="#NoSQL-VS-RDBMS" class="headerlink" title="NoSQL VS RDBMS"></a>NoSQL VS RDBMS</h4><p>NoSQL：</p><ul><li>存储应该能够处理非常高的负载，能够在存储上执行许多写操作</li><li>支持水平可扩展的存储</li><li>简单，因为使用非常简单的查询语言（无联接）</li></ul><p>RDBMS：</p><ul><li>存储应该是高负载的，但主要由读取操作组成</li><li>希望在复杂的数据结构中得到性能</li><li>需要强大的SQL查询语言</li></ul><p>NewSQL</p><ul><li>使用SQL查询（虽然不完全支持）</li><li>关系型</li><li>保持ACID事务的一致性</li><li>像NoSQL一样扩展</li></ul><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><blockquote><p>RDBMS —— Relational Database Management System —— 关系型数据库管理系统<br>column families —— 族</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大数据系统需要存储大量的数据，并且需要花费大量的金钱对存储的数据进行获取和维护。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gd3phyt1uoj30tw0hgaf0.jpg&quot; alt=&quot;截屏2020-03-23上午3.35.43&quot;  /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="非关系型数据库" scheme="https://liaoooyx.com/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="NoSQL" scheme="https://liaoooyx.com/tags/NoSQL/"/>
    
      <category term="ACID" scheme="https://liaoooyx.com/tags/ACID/"/>
    
      <category term="BASE" scheme="https://liaoooyx.com/tags/BASE/"/>
    
      <category term="CAP定理" scheme="https://liaoooyx.com/tags/CAP%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>云(1)</title>
    <link href="https://liaoooyx.com/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/08%20CLOUD%20%E2%80%93%20PART%201/"/>
    <id>https://liaoooyx.com/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/08%20CLOUD%20%E2%80%93%20PART%201/</id>
    <published>2020-02-19T00:00:00.000Z</published>
    <updated>2020-03-26T03:38:00.919Z</updated>
    
    <content type="html"><![CDATA[<p>实用计算：使<u>计算资源</u>像水电这样按表计量的服务一样按需使用；按需动态提供资源的能力</p><p>云计算：是一种模型，用于支持对可配置计算资源（例如，网络，服务器，存储，应用程序和服务）共享池的普遍，方便，按需的网络访问，这些资源可通过最少的管理工作或与服务提供商的交互，快速地进行配置和发布。（美国国家标准技术研究院（NIST））</p><a id="more"></a><h4 id="数据的类型"><a href="#数据的类型" class="headerlink" title="数据的类型"></a>数据的类型</h4><p>关系型数据（表、事务）、文本数据、半结构化数据（XML）、图类数据（社交网络）、流数据（只能被扫描一次）</p><h4 id="数据与生俱来的特点"><a href="#数据与生俱来的特点" class="headerlink" title="数据与生俱来的特点"></a>数据与生俱来的特点</h4><p>复杂、大量、半结构化</p><h4 id="大数据与云计算的关联"><a href="#大数据与云计算的关联" class="headerlink" title="大数据与云计算的关联"></a>大数据与云计算的关联</h4><ol><li>数据可视化</li><li>实时数据流、实时处理</li><li>实时的结构化数据库、交互式分析、批量处理</li><li>结构化和非结构化数据（HDFS、S3）</li><li>云基础设施</li><li>存储、网络、计算资源</li></ol><h4 id="例子：百事可乐和阿里巴巴"><a href="#例子：百事可乐和阿里巴巴" class="headerlink" title="例子：百事可乐和阿里巴巴"></a>例子：百事可乐和阿里巴巴</h4><p>百事可乐公司与阿里巴巴达成战略协议，以利用后者的数据来增强其客户体验并推动其在中国的发展。这是阿里巴巴达成的第二笔此类交易，允许公司利用其数据和见解为客户提供更好的服务。阿里巴巴是中国最大的电子商务平台。公司可以使用这些数据更好地了解消费者的偏好，并相应地修改其产品。 除了为外国企业提供进入中国市场的电子商务平台外，阿里巴巴现在还希望成为数据和见解提供。通过利用阿里巴巴客户数据产生的见解，百事可乐可以从事产品开发、创新和品牌建设，从而带动中国的增长。 据阿里巴巴称，此次合作“引领了中国食品饮料行业不断发展的数字化转型”（2017.05.16 Forbe）</p><h4 id="实用计算-Utility-Computing"><a href="#实用计算-Utility-Computing" class="headerlink" title="实用计算 Utility Computing"></a>实用计算 Utility Computing</h4><p>“到目前为止，计算机网络仍处于起步阶段，但是随着它们的成长和日趋成熟，我们可能会看到<u>计算机设施 computer utilities</u>的普及，像现在的电力和电话这类实用设施一样，它将为整个国家的家庭和办公室提供服务”（1969 – Leonard Kleinrock, ARPANET project）</p><p>什么是实用计算：使<u>计算资源</u>像水电这样按表计量的服务一样按需使用；按需动态提供资源的能力</p><p>为什么：成本（购买设备 VS 操作付费），可扩展性，弹性（按需扩展或收缩）</p><h4 id="云计算的定义"><a href="#云计算的定义" class="headerlink" title="云计算的定义"></a>云计算的定义</h4><p>个人设备可以通过网络获得各种各样的计算服务（不需要安装在本地）</p><p>云计算是一种模型，用于支持对可配置计算资源（例如，网络，服务器，存储，应用程序和服务）共享池的普遍，方便，按需的网络访问，这些资源可通过最少的管理工作或与服务提供商的交互，快速地进行配置和发布。（美国国家标准技术研究院（NIST））</p><p>主要特征： 1. 按需的自助服务 2. 广泛的网络访问 3. 资源池 4. 快速的弹性变化或扩展 5. 测量服务</p><p>三种服务模型：1. 软件 2. 平台 3. 基础设施</p><p>四种部署模型：1. 私有 2. 社区 3. 公开 4. 混合</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>成本和管理（经济的扩展方式，将资源管理外包）</li><li>减少部署时间（大部分工作由服务提供商完成）</li><li>可扩展性（按需使用，按需付费）</li><li>可靠性（大量的、冗余的、共享的资源）</li><li>可持续性（不需要自己购买设备）</li></ul><h4 id="虚拟化的基础设施"><a href="#虚拟化的基础设施" class="headerlink" title="虚拟化的基础设施"></a>虚拟化的基础设施</h4><p>整合服务器系统、降低成本、降低复杂性、简化管理、按使用付费</p><p>是一个新兴的计算范例，数据和服务位于大规模的数据中心，并且可以被任何联网设备访问</p><h4 id="云"><a href="#云" class="headerlink" title="云"></a>云</h4><p>当今互联网应用的历史根源：搜索、Email、社交网络、文件存储（Dropbox等）</p><p>Cloud infrastructure提供了一个框架，管理对应用程序的可扩展的、可靠的、按需的访问</p><p>对于终端的移动应用来说，云是不可见的</p><h4 id="云数据中心"><a href="#云数据中心" class="headerlink" title="云数据中心"></a>云数据中心</h4><p>10-100k的主机，通常紧密靠近以及紧密耦合。比如亚马逊的电商，YouTube、Apple、微软的内容服务器，Google的搜索引擎、数据挖掘</p><p>挑战：多应用，每个应用都要服务于大量的客户端；管理/负载平衡、处理、网络、数据管理（动态负载平衡）</p><h4 id="云结构的分层"><a href="#云结构的分层" class="headerlink" title="云结构的分层"></a>云结构的分层</h4><div class="table-container"><table><thead><tr><th>用户层、服务层、虚拟化层、物理层</th><th>用户级、用户级的中间件、核心中间件、系统级</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3eoih37ij312a0k87a2.jpg" alt="截屏2020-03-22下午9.21.28" style="zoom:33%;" /></td><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3enjxli1j31160nan5m.jpg" alt="截屏2020-03-22下午9.20.34" style="zoom: 33%;" /></td></tr></tbody></table></div><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>cloud infrastructure —— 云基础设施</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实用计算：使&lt;u&gt;计算资源&lt;/u&gt;像水电这样按表计量的服务一样按需使用；按需动态提供资源的能力&lt;/p&gt;
&lt;p&gt;云计算：是一种模型，用于支持对可配置计算资源（例如，网络，服务器，存储，应用程序和服务）共享池的普遍，方便，按需的网络访问，这些资源可通过最少的管理工作或与服务提供商的交互，快速地进行配置和发布。（美国国家标准技术研究院（NIST））&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="云计算" scheme="https://liaoooyx.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>云(2)</title>
    <link href="https://liaoooyx.com/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/09%20CLOUD%20PART%202/"/>
    <id>https://liaoooyx.com/2020/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/09%20CLOUD%20PART%202/</id>
    <published>2020-02-19T00:00:00.000Z</published>
    <updated>2020-03-26T03:38:44.926Z</updated>
    
    <content type="html"><![CDATA[<p>云数据中心——物理层（系统级）：存储、网络</p><p>虚拟机——虚拟化层（核心中间件）：Hypervisor、Infrastructure</p><p>编程模型 —— 结构层（用户级中间件）：MapReduce、Hadoop</p><a id="more"></a><h3 id="云计算的好处"><a href="#云计算的好处" class="headerlink" title="云计算的好处"></a>云计算的好处</h3><ol><li>用户似乎可以按需使用无限的计算资源，从而消除了云用户为资源调配而提前计划的需求</li><li>消除了云用户的前期投入，公司可以从小做起，并在将来需要时再增加硬件资源。</li><li>根据需要，在短期内购买计算资源，并在完成后释放它们，从而可以节约资源和成本（例如，按小时计算的处理器和按天存储的处理器，在服务使用的高峰期扩展服务器）。</li></ol><h3 id="云的三种服务模型"><a href="#云的三种服务模型" class="headerlink" title="云的三种服务模型"></a>云的三种服务模型</h3><p>服务可以在三层中的任何一层公开，较低的层对用户是透明的</p><ol><li>SaaS 软件即服务：是本地运行程序的代替方案，即远程运行程序。如Google Apps</li><li>PaaS 平台即服务：也是本地运行程序的代替方案。通过软件堆栈促进应用程序的部署。如微软Azure</li><li>IaaS 基础设施即服务：通过虚拟化，基础设施提供商可以拆分、分配和动态管理服务提供商，服务提供商将在这些系统上部署运行其服务的软件堆栈。 Amazon EC2</li></ol><div class="table-container"><table><thead><tr><th>服务模型</th><th>服务模型与典型软件结构</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3fespzsmj30gm0eedgi.jpg" alt="截屏2020-03-22下午9.46.47" style="zoom:33%;" /></td><td><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3gursrjoj30mq0k47ax.jpg" alt="截屏2020-03-22下午10.36.43" style="zoom:50%;" /></td></tr></tbody></table></div><h4 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h4><ul><li>通过互联网构建</li><li>任何为该服务付费的用户都可以访问</li><li>由服务提供商拥有</li><li>可通过订阅访问</li></ul><h4 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h4><ul><li>在单个组织拥有的Intranet域内构建</li><li>客户拥有和管理</li><li>访问仅限于拥有客户及其合作伙伴</li><li>可能影响云标准化，同时保留更大的自定义和组织控制权。</li></ul><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><ul><li>多个云协同工作，包括公共云和私有云</li><li>混合云可以由<u>联合的云提供商</u>交付，该供应商将其自身的资源与其他提供商的资源相结合</li></ul><h2 id="云数据中心——物理层（系统级）"><a href="#云数据中心——物理层（系统级）" class="headerlink" title="云数据中心——物理层（系统级）"></a>云数据中心——物理层（系统级）</h2><p>大规模：10万-100万的服务器，大约是足球场的11.5倍</p><p>小服务器集群：大约1000台服务器，通过 Ethernet switch 以太网交换机相连，放置在仓库或容器环境中</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>存储选项：</p><ul><li>使用服务器内部的磁盘，或通过无限带宽的网络附加存储（NAS）</li><li>WSCs 通常依赖于本地磁盘</li><li>Google文件系统（GFS）使用本地磁盘，并至少维护三个副本</li></ul><p>连接多个机架的交换机</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>包含：边界路由器，访问路由器、负载均衡器、一层交换机、二层交换机、架顶交换机、服务器机架</p><p>负载均衡器：应用层路由</p><ul><li>接收外部客户请求</li><li>在数据中心内分配工作负载</li><li>将结果返回给外部客户端（隐藏数据中心的内部细节）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3fssnn4hj30ya0m444x.jpg" alt="截屏2020-03-22下午10.00.01" style="zoom:50%;" /></p><h2 id="虚拟机——虚拟化层（核心中间件）"><a href="#虚拟机——虚拟化层（核心中间件）" class="headerlink" title="虚拟机——虚拟化层（核心中间件）"></a>虚拟机——虚拟化层（核心中间件）</h2><p>虚拟化层相当于底层硬件和虚拟机的中间件</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3gdgnmdpj31100hqq9d.jpg" alt="截屏2020-03-22下午10.20.05" style="zoom: 40%;" /></p><h4 id="虚拟化的定义"><a href="#虚拟化的定义" class="headerlink" title="虚拟化的定义"></a>虚拟化的定义</h4><ul><li><p>不同的虚拟机（VM）可以在同一台物理计算机上运行不同的操作系统（OS）和多个应用程序。</p></li><li><p>支持虚拟化的主要技术是虚拟机监控程序Hypervisor</p><ul><li>VMM通过仿真或硬件辅助虚拟化，以透明的方式对物理主机进行划分</li><li>提供了完整的硬件环境模拟</li></ul><blockquote><p>虚拟机：真实机器通过软件，提供操作环境，运行 Guest OS</p><p>Guest OS：运行在虚拟机环境中的，或直接运行在物理机器上的（不同于Host OS），操作系统</p></blockquote></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>更好的利用资源；最大化硬件利用，降低硬件成本；改进容错；扩容；能耗</p></li><li><p>自由选择操作系统（即测试环境）</p></li><li>整合服务器和基础架构</li><li>节省时间和金钱</li><li>使管理和保护桌面环境更加容易</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>GuestOS对硬件的要求更高（主机需要更多的内存，磁盘空间等）</li><li>可能需要培训才能操作</li></ul><h3 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h3><p>VMware、ESXi（原Elastic Sky X）、Xen、KVM</p><h4 id="VMware-ESX-Server-——-Type-1-Hypervisor（裸机）"><a href="#VMware-ESX-Server-——-Type-1-Hypervisor（裸机）" class="headerlink" title="VMware ESX Server —— Type-1 Hypervisor（裸机）"></a>VMware ESX Server —— Type-1 Hypervisor（裸机）</h4><ul><li>企业数据中心的商用VMM</li><li>支持<u>全虚拟化</u>和<u>混合虚拟化技术</u></li><li>基于x86和x86-64结构的Linux和Widows的变体</li><li>GuestOS最高支持：32个虚拟CPU和1TB内存</li><li>每个主机最高支持：160个CPU，2TB内存，512个虚拟机</li><li>其他商业版：VMware Workstation and Server 是 Type-2 Hypervisor（有HostOS）</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2g2esvvdj30l20d678f.jpg" alt="截屏2020-03-22上午1.23.51" style="zoom:50%;" /></p><h4 id="XEN-——-Type-1-Hypervisor（裸机）"><a href="#XEN-——-Type-1-Hypervisor（裸机）" class="headerlink" title="XEN —— Type-1 Hypervisor（裸机）"></a>XEN —— Type-1 Hypervisor（裸机）</h4><ul><li>例子：剑桥大学、Citrix System思杰系统</li><li>微核、</li><li>Domain 0（特权Guest）负责控制和I/O、其他Domain负责用户的程序</li><li>轻量（&lt;150k 代码行），高可扩展性，大于255个物理CPU</li><li>可以分配最高128个虚拟CPU和1TB内存给虚拟机</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2ftu1du4j30ya0d6tcl.jpg" alt="截屏2020-03-22上午1.15.39" style="zoom:50%;" /></p><h4 id="KVM-——-Type-2-Hypervisor（HostOS）"><a href="#KVM-——-Type-2-Hypervisor（HostOS）" class="headerlink" title="KVM —— Type 2 Hypervisor（HostOS）"></a>KVM —— Type 2 Hypervisor（HostOS）</h4><ul><li>由 Red Hat 支持</li><li>支持硬件辅助虚拟化、混合虚拟化</li><li>主要是X86和X86-64</li><li>移植到PowerPC和IA-64（Itanium）</li><li>通过kernel模块，将Linux内核转化为Hypervisor</li><li>通过QEMU进行设备模拟</li><li>支持多种GuestOS</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2gdbcx79j30iy0h8dpv.jpg" alt="截屏2020-03-22上午1.34.22" style="zoom:50%;" /></p><h3 id="云的结构"><a href="#云的结构" class="headerlink" title="云的结构"></a>云的结构</h3><ol><li>Hypervisor 虚拟机监控程序：创建、执行、管理同一台物理机上的多个虚拟机</li><li>虚拟基础设施管理者: 将虚拟机组织到分区组中</li><li>虚拟机群集：一组具有嵌入式软件的虚拟机，充当正在运行的应用程序的中间件</li><li>分布式应用程序：旨在在多台计算机上运行以执行特定任务的软件</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3gursrjoj30mq0k47ax.jpg" alt="截屏2020-03-22下午10.36.43" style="zoom:50%;" /></p><h4 id="云基础设施管理者-——-OpenNebula"><a href="#云基础设施管理者-——-OpenNebula" class="headerlink" title="云基础设施管理者 —— OpenNebula"></a>云基础设施管理者 —— OpenNebula</h4><p>代表终端用户，用于提供虚拟资源；具有庞大的用户群，和各种Linux发行版</p><p>功能：</p><ul><li>通过云插件支持多站点资源池</li><li>与Hypervisor无关</li><li>广泛采用云接口</li><li>简单的用户管理</li></ul><h4 id="云基础设施管理者-——-OpenStack"><a href="#云基础设施管理者-——-OpenStack" class="headerlink" title="云基础设施管理者 —— OpenStack"></a>云基础设施管理者 —— OpenStack</h4><p>用于生产出无处不在的开源云计算平台，无论规模大小，它都能满足公共云和私有云的需求，易于实现和可大规模扩展。（目标是称为云中的Linux）</p><p>功能：</p><ul><li>管理层增加了自动化和控制</li><li>有效分配资源</li><li>通过服务门户授权管理员和用户</li><li>开发人员能够通过API，能够使应用程序具有云感知能力</li><li>启用云联合</li></ul><h2 id="编程模型-——-结构层（用户级中间件）"><a href="#编程模型-——-结构层（用户级中间件）" class="headerlink" title="编程模型 —— 结构层（用户级中间件）"></a>编程模型 —— 结构层（用户级中间件）</h2><p>包括各种框架，允许对云中以及存在的服务和应用，进行编程和执行，包含一些分类：</p><ol><li>用于开发应用程序的新API：Microsoft Azure, Google App Engine</li><li>高性能计算：Message Passing Interface (MPI)</li><li>非通用目的编程模型：MapReduce、Aneka（用于在云上开发分布式应用的平台和框架）</li></ol><h4 id="MapReduce：可在大规模集群上扩展的数据处理模型"><a href="#MapReduce：可在大规模集群上扩展的数据处理模型" class="headerlink" title="MapReduce：可在大规模集群上扩展的数据处理模型"></a>MapReduce：可在大规模集群上扩展的数据处理模型</h4><ul><li>用于快速粗粒大数据集的编程模型</li><li>用于网络规模的搜索和云计算应用</li><li>用户编写map函数，生成键值对</li><li>用户编写的reduce函数，将键值对按照key合并</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3hllltgqj311y0e6ab7.jpg" alt="截屏2020-03-22下午11.02.22" style="zoom:50%;" /></p><h4 id="Hadoop：遵循MapReduce模型的分布式平台"><a href="#Hadoop：遵循MapReduce模型的分布式平台" class="headerlink" title="Hadoop：遵循MapReduce模型的分布式平台"></a>Hadoop：遵循MapReduce模型的分布式平台</h4><p>通过Hadoop，用户编写和执行程序，处理大规模的分布式数据</p><p>特点</p><ul><li>可扩展：扩展以存储和处理Web空间中的PB级数据</li><li>经济的：开源MapReduce最大限度地减少了任务生成和海量数据通信中的开销。</li><li>高效的：在大量的节点上以高度并行性处理数据</li><li>可轻松：自动维护数据的多个备份，以便于故障时重新部署计算任务</li></ul><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><blockquote><p>Hypervisor —— Virtual Machine Manager (VMM)  —— 虚拟机监控程序</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;云数据中心——物理层（系统级）：存储、网络&lt;/p&gt;
&lt;p&gt;虚拟机——虚拟化层（核心中间件）：Hypervisor、Infrastructure&lt;/p&gt;
&lt;p&gt;编程模型 —— 结构层（用户级中间件）：MapReduce、Hadoop&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://liaoooyx.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="云计算" scheme="https://liaoooyx.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Hypervisor" scheme="https://liaoooyx.com/tags/Hypervisor/"/>
    
      <category term="云计算的三种服务模型" scheme="https://liaoooyx.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>云计算/07 OpenNebula - A Cloud Virtual Infrastructure Manager</title>
    <link href="https://liaoooyx.com/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/07%20OpenNebula%20-%20A%20Cloud%20Virtual%20Infrastructure%20Manager/"/>
    <id>https://liaoooyx.com/2020/02/%E4%BA%91%E8%AE%A1%E7%AE%97/07%20OpenNebula%20-%20A%20Cloud%20Virtual%20Infrastructure%20Manager/</id>
    <published>2020-02-18T18:08:03.499Z</published>
    <updated>2020-02-20T10:20:51.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="07-OpenNebula-A-Cloud-Virtual-Infrastructure-Manager"><a href="#07-OpenNebula-A-Cloud-Virtual-Infrastructure-Manager" class="headerlink" title="07 OpenNebula - A Cloud Virtual Infrastructure Manager"></a>07 OpenNebula - A Cloud Virtual Infrastructure Manager</h2><h4 id="OpenNebula的主要特征"><a href="#OpenNebula的主要特征" class="headerlink" title="OpenNebula的主要特征"></a>OpenNebula的主要特征</h4><p>内部接口、调度（任务、负载）、虚拟化管理、镜像管理、网络管理、服务管理和语境化、安全、容错、可扩展性Scalability、安装、灵活且可扩展Extensibility</p><h4 id="OpenNebula结构——核心Core"><a href="#OpenNebula结构——核心Core" class="headerlink" title="OpenNebula结构——核心Core"></a>OpenNebula结构——核心Core</h4><p>请求管理：提供XML-RPC接口，用于管理和获取实体信息</p><h4 id="OpenNebula结构——工具层"><a href="#OpenNebula结构——工具层" class="headerlink" title="OpenNebula结构——工具层"></a>OpenNebula结构——工具层</h4><p>调度器</p><p>命令行接口</p><h4 id="OpenNebula结构——驱动层"><a href="#OpenNebula结构——驱动层" class="headerlink" title="OpenNebula结构——驱动层"></a>OpenNebula结构——驱动层</h4><p>传输Transfer驱动：负责镜像的管理，如克隆、删除、创建swap交换镜像</p><p>虚拟机驱动：</p><p>信息驱动：</p><h4 id="进程拆分"><a href="#进程拆分" class="headerlink" title="进程拆分"></a>进程拆分</h4><h4 id="构造私有云：存储"><a href="#构造私有云：存储" class="headerlink" title="构造私有云：存储"></a>构造私有云：存储</h4><h4 id="构造私有云：网络"><a href="#构造私有云：网络" class="headerlink" title="构造私有云：网络"></a>构造私有云：网络</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;07-OpenNebula-A-Cloud-Virtual-Infrastructure-Manager&quot;&gt;&lt;a href=&quot;#07-OpenNebula-A-Cloud-Virtual-Infrastructure-Manager&quot; class=&quot;headerl
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
